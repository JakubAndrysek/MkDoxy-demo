{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MkDoxy Demo","text":"<p>This is a demo of MkDoxy, a tool for generating Doxygen documentation from Markdown files.</p>"},{"location":"#look-at-jakubandrysek-mkdoxy-whole-project","title":"\ud83d\udc49 Look at JakubAndrysek / MkDoxy whole project. \ud83d\udc48","text":""},{"location":"#demo-of-mkdoxy","title":"Demo of MkDoxy","text":""},{"location":"#run-demo-locally","title":"Run demo locally","text":""},{"location":"#tools","title":"Tools","text":"<ul> <li>python 3.6 or newer -&gt; <code>sudo apt install python3</code></li> <li>Pip -&gt; <code>sudo apt install python3-pip</code></li> <li>Git -&gt; <code>sudo apt install git</code></li> <li>Doxygen -&gt; <code>sudo apt install doxygen</code></li> </ul>"},{"location":"#pip-packages","title":"PIP Packages","text":"<pre><code>pip3 install -r requirements.txt\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Serve MkDocs locally:</p> <pre><code>mkdocs serve\n</code></pre> <p>Build MkDocs:</p> <pre><code>mkdocs build\n</code></pre>"},{"location":"useage/","title":"How to use it","text":"<p>Look at JakubAndrysek / MkDoxy for more information.</p>"},{"location":"animal/","title":"Animal","text":"<p>This is the animal demo.</p> <p>Code from doxybook demo. </p>"},{"location":"api/","title":"API Demo","text":"<p>Look at folder to see how the API is generated.</p>"},{"location":"api/#show-function-definition-from-project-animals","title":"Show function definition from project animals","text":"<pre><code>::: doxy.animal.Function\nname: void some_global_function(example::Animal *animal)\n</code></pre>"},{"location":"api/#function-some_global_function","title":"function some_global_function","text":"<p>Some random global function that modifies Animal. <pre><code>void some_global_function (\nexample::Animal * animal\n) </code></pre></p> <p>See also: Animal </p> <p>Parameters:</p> <ul> <li><code>animal</code> The pointer to the animal instance </li> </ul>"},{"location":"api/#show-class-method-from-project-esp","title":"Show class method from project esp","text":"<pre><code>::: doxy.esp.Class.Method\nname: rb::MotorChangeBuilder\nmethod: brake (MotorId id, uint16_t brakingPower)\n</code></pre>"},{"location":"api/#function-brake","title":"function brake","text":"<p>Start braking. <pre><code>MotorChangeBuilder &amp; rb::MotorChangeBuilder::brake (\nMotorId id,\nuint16_t brakingPower\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> of the motor (e.g. rb:MotorId::M1) </li> <li><code>brakingPower</code> power of the braking, &lt;0, 32767&gt; </li> </ul>"},{"location":"api/#show-source-code-from-project-stm","title":"Show source code from project stm","text":"<pre><code>::: doxy.stm.Code\nfile: Motor.hpp\nstart: 8\nend: 20\n</code></pre> <p>Motor.hpp</p> <pre><code>inline const uint16_t motorLoopFreq = 100;\n\nclass Motor {\npublic:\nMotor() {\nm_lastEncTicks = 0;\nreset();\n}\n\nvoid reset() {\nm_velocityReg = Regulator(INT16_MAX, 150000, 300000, 20000);\nm_positionReg = Regulator(500, 1000, 0, 0);\nm_dither = 0;\n</code></pre>"},{"location":"api/#show-class-from-project-stm","title":"Show class from project stm","text":"<pre><code>::: doxy.esp.Class\nname: rb::MotorChangeBuilder\n</code></pre>"},{"location":"api/#class-rbmotorchangebuilder","title":"Class rb::MotorChangeBuilder","text":"<p>ClassList &gt; rb &gt; MotorChangeBuilder</p> <p>Helper class for building the motor change event. </p> <ul> <li><code>#include &lt;RBCXManager.h&gt;</code></li> </ul>"},{"location":"api/#public-functions","title":"Public Functions","text":"Type Name MotorChangeBuilder ()  MotorChangeBuilder (const MotorChangeBuilder &amp; o) = delete MotorChangeBuilder (MotorChangeBuilder &amp;&amp; o)  MotorChangeBuilder &amp; brake (MotorId id, uint16_t brakingPower) Start braking. MotorChangeBuilder &amp; drive (MotorId id, int32_t positionRelative, int16_t speedTicksPerSecond, Motor::callback_t callback=nullptr)  MotorChangeBuilder &amp; driveToValue (MotorId id, int32_t positionAbsolute, int16_t speedTicksPerSecond, Motor::callback_t callback=nullptr)  MotorChangeBuilder &amp; power (MotorId id, int16_t value) Set single motor power. MotorChangeBuilder &amp; pwmMaxPercent (MotorId id, int8_t percent) Limit motor index's power to percent. void set () Finish the changes and submit the events. MotorChangeBuilder &amp; speed (MotorId id, int16_t ticksPerSecond) Set single motor power. ~MotorChangeBuilder ()"},{"location":"api/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/#function-motorchangebuilder-13","title":"function MotorChangeBuilder [1/3]","text":"<pre><code>rb::MotorChangeBuilder::MotorChangeBuilder () </code></pre>"},{"location":"api/#function-motorchangebuilder-23","title":"function MotorChangeBuilder [2/3]","text":"<pre><code>rb::MotorChangeBuilder::MotorChangeBuilder (\nconst MotorChangeBuilder &amp; o\n) = delete\n</code></pre>"},{"location":"api/#function-motorchangebuilder-33","title":"function MotorChangeBuilder [3/3]","text":"<pre><code>rb::MotorChangeBuilder::MotorChangeBuilder (\nMotorChangeBuilder &amp;&amp; o\n) </code></pre>"},{"location":"api/#function-brake_1","title":"function brake","text":"<p>Start braking. <pre><code>MotorChangeBuilder &amp; rb::MotorChangeBuilder::brake (\nMotorId id,\nuint16_t brakingPower\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> of the motor (e.g. rb:MotorId::M1) </li> <li><code>brakingPower</code> power of the braking, &lt;0, 32767&gt; </li> </ul>"},{"location":"api/#function-drive","title":"function drive","text":"<pre><code>MotorChangeBuilder &amp; rb::MotorChangeBuilder::drive (\nMotorId id,\nint32_t positionRelative,\nint16_t speedTicksPerSecond,\nMotor::callback_t callback=nullptr\n) </code></pre>"},{"location":"api/#function-drivetovalue","title":"function driveToValue","text":"<pre><code>MotorChangeBuilder &amp; rb::MotorChangeBuilder::driveToValue (\nMotorId id,\nint32_t positionAbsolute,\nint16_t speedTicksPerSecond,\nMotor::callback_t callback=nullptr\n) </code></pre>"},{"location":"api/#function-power","title":"function power","text":"<p>Set single motor power. <pre><code>MotorChangeBuilder &amp; rb::MotorChangeBuilder::power (\nMotorId id,\nint16_t value\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> of the motor (e.g. rb:MotorId::M1) </li> <li><code>power</code> of the motor &lt;-32768; 32767&gt; </li> </ul>"},{"location":"api/#function-pwmmaxpercent","title":"function pwmMaxPercent","text":"<p>Limit motor index's power to percent. <pre><code>MotorChangeBuilder &amp; rb::MotorChangeBuilder::pwmMaxPercent (\nMotorId id,\nint8_t percent\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> of the motor (e.g. rb:MotorId::M1) </li> <li><code>percent</code> of the maximal power of the motor &lt;0 - 100&gt; </li> </ul>"},{"location":"api/#function-set","title":"function set","text":"<pre><code>void rb::MotorChangeBuilder::set () </code></pre>"},{"location":"api/#function-speed","title":"function speed","text":"<p>Set single motor power. <pre><code>MotorChangeBuilder &amp; rb::MotorChangeBuilder::speed (\nMotorId id,\nint16_t ticksPerSecond\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> of the motor (e.g. rb:MotorId::M1) </li> <li><code>speed</code> of the motor in encoder ticks &lt;-32768; 32767&gt; </li> </ul>"},{"location":"api/#function-motorchangebuilder","title":"function ~MotorChangeBuilder","text":"<pre><code>rb::MotorChangeBuilder::~MotorChangeBuilder () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXManager.h</code></p>"},{"location":"esp/","title":"ESP32 DEMO","text":"<p>Code is from RB3204-RBCX-library.</p> <p>It is main board for Robotka robot.</p> <p></p>"},{"location":"jaculus/","title":"Jaculus","text":"<p>Jaculus allows you to run JavaScript code on embedded platforms. Currently works on the ESP32 and ESP32-S3.</p> <p>Source code is available on GitHub. Author is Petr Kubica.</p>"},{"location":"stm/","title":"STM32 DEMO","text":"<p>Code is from RB3204-RBCX.</p> <p>It is main board for Robotka robot.</p> <p></p>"},{"location":"esp/annotated/","title":"Class List","text":"<p>Warning This is custom template. Look at documentation for more information.</p> <p>Template source: templates-custom/annotated.jinja2</p> <p>Add <code>template-dir: path/to/userDefined/templates</code> to your project configuration like in this example:</p> <pre><code>  - mkdoxy:\nprojects:\nesp:\nsrc-dirs: demo-projets/esp\nfull-doc: True\ntemplate-dir: path/to/userDefined/templates\ndoxy-cfg:\nFILE_PATTERNS: \"*.cpp *.h*\"\nEXAMPLE_PATH: examples\nRECURSIVE: True\n</code></pre> <p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class MyStack </li> <li>namespace rb </li> <li>class Angle </li> <li>class Battery Contains the battery state and can control the robot's power. </li> <li>class Buttons </li> <li>class Leds </li> <li>class Manager The main library class for working with the RBCX board. Call the install() method at the start of your program. </li> <li>class Motor </li> <li>class MotorChangeBuilder Helper class for building the motor change event. </li> <li>class Nvs </li> <li>class Piezo Helper class for controlling the piezo. </li> <li>class SmartServoBus </li> <li>class StupidServo </li> <li>class Timers </li> <li>class Ultrasound </li> <li>struct servo_info </li> <li>struct timer_t </li> </ul>"},{"location":"esp/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir demo-projets </li> <li>dir esp <ul> <li>file RBCX.h </li> <li>file RBCXAngle.cpp </li> <li>file RBCXAngle.h </li> <li>file RBCXBattery.cpp </li> <li>file RBCXBattery.h </li> <li>file RBCXButtons.cpp </li> <li>file RBCXButtons.h </li> <li>file RBCXLeds.cpp </li> <li>file RBCXLeds.h </li> <li>file RBCXManager.cpp </li> <li>file RBCXManager.h </li> <li>file RBCXMotor.cpp </li> <li>file RBCXMotor.h </li> <li>file RBCXNvs.cpp </li> <li>file RBCXNvs.h </li> <li>file RBCXPiezo.cpp </li> <li>file RBCXPiezo.h </li> <li>file RBCXPinout.h </li> <li>file RBCXSmartServo.cpp </li> <li>file RBCXSmartServo.h </li> <li>file RBCXStupidServo.cpp </li> <li>file RBCXStupidServo.h </li> <li>file RBCXTimers.cpp </li> <li>file RBCXTimers.h </li> <li>file RBCXUltrasound.cpp </li> <li>file RBCXUltrasound.h </li> <li>file RBCXUtil.h </li> <li>file RBCXVersion.h </li> <li>file main.cpp </li> <li>file test.cpp </li> </ul> </li> </ul>"},{"location":"esp/classMyStack/","title":"Class MyStack","text":"<p>template &lt;class T class T, int i&gt;</p> <p>ClassList &gt; MyStack</p> <p>More...</p>"},{"location":"esp/classMyStack/#public-functions","title":"Public Functions","text":"Type Name MyStack (void) Construct a new My Stack&lt;  T, i &gt;:: My Stack object. T &amp; pop (void) pop met void push (const T item)"},{"location":"esp/classMyStack/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>T</code> </li> <li><code>i</code> </li> </ul>"},{"location":"esp/classMyStack/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/classMyStack/#function-mystack","title":"function MyStack","text":"<p>Construct a new My Stack&lt;  T, i &gt;:: My Stack object. <pre><code>MyStack::MyStack (\nvoid\n) </code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> <li><code>i</code> </li> </ul>"},{"location":"esp/classMyStack/#function-pop","title":"function pop","text":"<p>pop met <pre><code>T &amp; MyStack::pop (\nvoid\n) </code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> myClass </li> <li><code>i</code> number </li> </ul> <p>Returns:</p> <p>T&amp; refer </p>"},{"location":"esp/classMyStack/#function-push","title":"function push","text":"<pre><code>void MyStack::push (\nconst T item\n) </code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> </li> <li><code>i</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>item</code> </li> </ul> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/test.cpp</code></p>"},{"location":"esp/namespacerb/","title":"Namespace rb","text":"<p>Namespace List &gt; rb</p>"},{"location":"esp/namespacerb/#classes","title":"Classes","text":"Type Name class Angle class Battery Contains the battery state and can control the robot's power. class Buttons class Leds class Manager The main library class for working with the RBCX board. Call the install() method at the start of your program. class Motor class MotorChangeBuilder Helper class for building the motor change event. class Nvs class Piezo Helper class for controlling the piezo. class SmartServoBus class StupidServo class Timers class Ultrasound"},{"location":"esp/namespacerb/#public-types","title":"Public Types","text":"Type Name enum uint32_t ButtonId Helper class for controlling the LEDs connected to the expander. enum LedId Helper class for controlling the LEDs connected to the expander. enum ManagerInstallFlags This enum contains flags for the Manager 's install() method. enum uint8_t MotorId"},{"location":"esp/namespacerb/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr int StupidServosCount   = = 4 constexpr int UltrasoundsCount   = = 4"},{"location":"esp/namespacerb/#public-functions","title":"Public Functions","text":"Type Name T clamp (T value, T min, T max)  void delay (std::chrono::duration&lt; uint32_t, std::milli &gt; delay)  void delayMs (int ms)  Angle operator\"\"_deg (long double d)  Angle operator\"\"_deg (unsigned long long int d)  Angle operator\"\"_rad (long double r)  Angle operator\"\"_rad (unsigned long long int r)  Angle operator* (Angle a, Angle::_T c)  Angle operator+ (Angle a, Angle b)  MotorId operator++ (MotorId &amp; x)  Angle operator- (Angle a, Angle b)  Angle operator/ (Angle a, Angle::_T c)  ManagerInstallFlags operator| (ManagerInstallFlags a, ManagerInstallFlags b)"},{"location":"esp/namespacerb/#public-static-functions","title":"Public Static Functions","text":"Type Name void dieTimers (TimerHandle_t timer)"},{"location":"esp/namespacerb/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"esp/namespacerb/#enum-buttonid","title":"enum ButtonId","text":"<pre><code>enum rb::ButtonId {\nOff = CoprocStat_ButtonsEnum_BOFF,\nOn = CoprocStat_ButtonsEnum_BON,\nB1 = CoprocStat_ButtonsEnum_B1,\nB2 = CoprocStat_ButtonsEnum_B2,\nB3 = CoprocStat_ButtonsEnum_B3,\nB4 = CoprocStat_ButtonsEnum_B4,\nUp = B1,\nDown = B2,\nLeft = B3,\nRight = B4\n};\n</code></pre>"},{"location":"esp/namespacerb/#enum-ledid","title":"enum LedId","text":"<pre><code>enum rb::LedId {\nL1 = CoprocReq_LedsEnum_L1,\nL2 = CoprocReq_LedsEnum_L2,\nL3 = CoprocReq_LedsEnum_L3,\nL4 = CoprocReq_LedsEnum_L4,\nGreen = L1,\nYellow = L2,\nRed = L3,\nBlue = L4,\nAll = L1 | L2 | L3 | L4\n};\n</code></pre>"},{"location":"esp/namespacerb/#enum-managerinstallflags","title":"enum ManagerInstallFlags","text":"<pre><code>enum rb::ManagerInstallFlags {\nMAN_NONE = 0,\nMAN_DISABLE_MOTOR_FAILSAFE = (1 &lt;&lt; 0)\n};\n</code></pre>"},{"location":"esp/namespacerb/#enum-motorid","title":"enum MotorId","text":"<pre><code>enum rb::MotorId {\nM1,\nM2,\nM3,\nM4,\nMAX\n};\n</code></pre>"},{"location":"esp/namespacerb/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"esp/namespacerb/#variable-stupidservoscount","title":"variable StupidServosCount","text":"<pre><code>constexpr int rb::StupidServosCount;\n</code></pre>"},{"location":"esp/namespacerb/#variable-ultrasoundscount","title":"variable UltrasoundsCount","text":"<pre><code>constexpr int rb::UltrasoundsCount;\n</code></pre>"},{"location":"esp/namespacerb/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/namespacerb/#function-clamp","title":"function clamp","text":"<pre><code>template&lt;typename T typename T&gt;\nT rb::clamp (\nT value,\nT min,\nT max\n) </code></pre>"},{"location":"esp/namespacerb/#function-delay","title":"function delay","text":"<pre><code>inline void rb::delay (\nstd::chrono::duration&lt; uint32_t, std::milli &gt; delay\n) </code></pre>"},{"location":"esp/namespacerb/#function-delayms","title":"function delayMs","text":"<pre><code>inline void rb::delayMs (\nint ms\n) </code></pre>"},{"location":"esp/namespacerb/#function-operator_deg","title":"function operator\"\"_deg","text":"<pre><code>Angle rb::operator\"\"_deg (\nlong double d\n) </code></pre>"},{"location":"esp/namespacerb/#function-operator_deg_1","title":"function operator\"\"_deg","text":"<pre><code>Angle rb::operator\"\"_deg (\nunsigned long long int d\n) </code></pre>"},{"location":"esp/namespacerb/#function-operator_rad","title":"function operator\"\"_rad","text":"<pre><code>Angle rb::operator\"\"_rad (\nlong double r\n) </code></pre>"},{"location":"esp/namespacerb/#function-operator_rad_1","title":"function operator\"\"_rad","text":"<pre><code>Angle rb::operator\"\"_rad (\nunsigned long long int r\n) </code></pre>"},{"location":"esp/namespacerb/#function-operator","title":"function operator*","text":"<pre><code>Angle rb::operator* (\nAngle a,\nAngle::_T c\n) </code></pre>"},{"location":"esp/namespacerb/#function-operator_1","title":"function operator+","text":"<pre><code>Angle rb::operator+ (\nAngle a,\nAngle b\n) </code></pre>"},{"location":"esp/namespacerb/#function-operator_2","title":"function operator++","text":"<pre><code>inline MotorId rb::operator++ (\nMotorId &amp; x\n) </code></pre>"},{"location":"esp/namespacerb/#function-operator-","title":"function operator-","text":"<pre><code>Angle rb::operator- (\nAngle a,\nAngle b\n) </code></pre>"},{"location":"esp/namespacerb/#function-operator_3","title":"function operator/","text":"<pre><code>Angle rb::operator/ (\nAngle a,\nAngle::_T c\n) </code></pre>"},{"location":"esp/namespacerb/#function-operator_4","title":"function operator|","text":"<pre><code>inline ManagerInstallFlags rb::operator| (\nManagerInstallFlags a,\nManagerInstallFlags b\n) </code></pre>"},{"location":"esp/namespacerb/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"esp/namespacerb/#function-dietimers","title":"function dieTimers","text":"<pre><code>static void rb::dieTimers (\nTimerHandle_t timer\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXAngle.cpp</code></p>"},{"location":"esp/classrb_1_1Angle/","title":"Class rb::Angle","text":"<p>ClassList &gt; rb &gt; Angle</p>"},{"location":"esp/classrb_1_1Angle/#public-types","title":"Public Types","text":"Type Name typedef float _T"},{"location":"esp/classrb_1_1Angle/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const Angle Pi   = = Angle::rad(Angle::_T(M_PI))"},{"location":"esp/classrb_1_1Angle/#public-functions","title":"Public Functions","text":"Type Name Angle ()  _T deg () const bool isNaN () const Angle &amp; operator*= (_T c)  Angle &amp; operator+= (Angle a)  Angle operator- () const Angle &amp; operator-= (Angle a)  Angle &amp; operator/= (_T c)  _T rad () const"},{"location":"esp/classrb_1_1Angle/#public-static-functions","title":"Public Static Functions","text":"Type Name Angle deg (_T d)  Angle nan ()  Angle rad (_T r)"},{"location":"esp/classrb_1_1Angle/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"esp/classrb_1_1Angle/#typedef-_t","title":"typedef _T","text":"<pre><code>typedef float rb::Angle::_T;\n</code></pre>"},{"location":"esp/classrb_1_1Angle/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"esp/classrb_1_1Angle/#variable-pi","title":"variable Pi","text":"<pre><code>const Angle rb::Angle::Pi;\n</code></pre>"},{"location":"esp/classrb_1_1Angle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/classrb_1_1Angle/#function-angle-12","title":"function Angle [1/2]","text":"<pre><code>inline rb::Angle::Angle () </code></pre>"},{"location":"esp/classrb_1_1Angle/#function-deg-12","title":"function deg [1/2]","text":"<pre><code>inline _T rb::Angle::deg () const\n</code></pre>"},{"location":"esp/classrb_1_1Angle/#function-isnan","title":"function isNaN","text":"<pre><code>inline bool rb::Angle::isNaN () const\n</code></pre>"},{"location":"esp/classrb_1_1Angle/#function-operator","title":"function operator*=","text":"<pre><code>inline Angle &amp; rb::Angle::operator*= (\n_T c\n) </code></pre>"},{"location":"esp/classrb_1_1Angle/#function-operator_1","title":"function operator+=","text":"<pre><code>inline Angle &amp; rb::Angle::operator+= (\nAngle a\n) </code></pre>"},{"location":"esp/classrb_1_1Angle/#function-operator-","title":"function operator-","text":"<pre><code>inline Angle rb::Angle::operator- () const\n</code></pre>"},{"location":"esp/classrb_1_1Angle/#function-operator-_1","title":"function operator-=","text":"<pre><code>inline Angle &amp; rb::Angle::operator-= (\nAngle a\n) </code></pre>"},{"location":"esp/classrb_1_1Angle/#function-operator_2","title":"function operator/=","text":"<pre><code>inline Angle &amp; rb::Angle::operator/= (\n_T c\n) </code></pre>"},{"location":"esp/classrb_1_1Angle/#function-rad-12","title":"function rad [1/2]","text":"<pre><code>inline _T rb::Angle::rad () const\n</code></pre>"},{"location":"esp/classrb_1_1Angle/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"esp/classrb_1_1Angle/#function-deg-22","title":"function deg [2/2]","text":"<pre><code>static inline Angle rb::Angle::deg (\n_T d\n) </code></pre>"},{"location":"esp/classrb_1_1Angle/#function-nan","title":"function nan","text":"<pre><code>static inline Angle rb::Angle::nan () </code></pre>"},{"location":"esp/classrb_1_1Angle/#function-rad-22","title":"function rad [2/2]","text":"<pre><code>static inline Angle rb::Angle::rad (\n_T r\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXAngle.h</code></p>"},{"location":"esp/classrb_1_1Battery/","title":"Class rb::Battery","text":"<p>ClassList &gt; rb &gt; Battery</p> <p>Contains the battery state and can control the robot's power. </p> <ul> <li><code>#include &lt;RBCXBattery.h&gt;</code></li> </ul>"},{"location":"esp/classrb_1_1Battery/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint32_t BATTERY_IN_THRESHOLD   = = 5000 constexpr uint32_t VOLTAGE_MAX   = = 4200 * 2Maximal battery voltage, in mV. constexpr uint32_t VOLTAGE_MIN   = = 3300 * 2Minimal battery voltage, in mV, at which the robot shuts down."},{"location":"esp/classrb_1_1Battery/#public-functions","title":"Public Functions","text":"Type Name uint32_t bMidVoltageMv () constreturns current temperature as measured by the STM32 coprocessor bool isPoweredByBattery () const uint32_t pct () constreturns current battery voltage void shutdown () shuts the robot's battery power int32_t temperatureC () const uint32_t voltageMv () constreturns battery Mid point voltage"},{"location":"esp/classrb_1_1Battery/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"esp/classrb_1_1Battery/#variable-battery_in_threshold","title":"variable BATTERY_IN_THRESHOLD","text":"<pre><code>constexpr uint32_t rb::Battery::BATTERY_IN_THRESHOLD;\n</code></pre>"},{"location":"esp/classrb_1_1Battery/#variable-voltage_max","title":"variable VOLTAGE_MAX","text":"<pre><code>constexpr uint32_t rb::Battery::VOLTAGE_MAX;\n</code></pre>"},{"location":"esp/classrb_1_1Battery/#variable-voltage_min","title":"variable VOLTAGE_MIN","text":"<pre><code>constexpr uint32_t rb::Battery::VOLTAGE_MIN;\n</code></pre>"},{"location":"esp/classrb_1_1Battery/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/classrb_1_1Battery/#function-bmidvoltagemv","title":"function bMidVoltageMv","text":"<pre><code>inline uint32_t rb::Battery::bMidVoltageMv () const\n</code></pre>"},{"location":"esp/classrb_1_1Battery/#function-ispoweredbybattery","title":"function isPoweredByBattery","text":"<pre><code>inline bool rb::Battery::isPoweredByBattery () const\n</code></pre>"},{"location":"esp/classrb_1_1Battery/#function-pct","title":"function pct","text":"<p>returns current battery voltage <pre><code>uint32_t rb::Battery::pct () const\n</code></pre></p> <p>returns current battery percentage </p>"},{"location":"esp/classrb_1_1Battery/#function-shutdown","title":"function shutdown","text":"<p>shuts the robot's battery power <pre><code>void rb::Battery::shutdown () </code></pre></p> <p>Returns true if the Robot's battery power branch is on </p>"},{"location":"esp/classrb_1_1Battery/#function-temperaturec","title":"function temperatureC","text":"<pre><code>inline int32_t rb::Battery::temperatureC () const\n</code></pre>"},{"location":"esp/classrb_1_1Battery/#function-voltagemv","title":"function voltageMv","text":"<pre><code>inline uint32_t rb::Battery::voltageMv () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXBattery.h</code></p>"},{"location":"esp/classrb_1_1Buttons/","title":"Class rb::Buttons","text":"<p>ClassList &gt; rb &gt; Buttons</p>"},{"location":"esp/classrb_1_1Buttons/#public-types","title":"Public Types","text":"Type Name typedef std::function&lt; bool(ButtonId, bool)&gt; callback_t"},{"location":"esp/classrb_1_1Buttons/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint32_t Count   = = 6"},{"location":"esp/classrb_1_1Buttons/#public-functions","title":"Public Functions","text":"Type Name bool byId (ButtonId id) const bool down () const bool left () const bool off () const bool on () const void onChange (callback_t callback)  bool right () const bool up () const"},{"location":"esp/classrb_1_1Buttons/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"esp/classrb_1_1Buttons/#typedef-callback_t","title":"typedef callback_t","text":"<pre><code>typedef std::function&lt;bool(ButtonId, bool)&gt; rb::Buttons::callback_t;\n</code></pre>"},{"location":"esp/classrb_1_1Buttons/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"esp/classrb_1_1Buttons/#variable-count","title":"variable Count","text":"<pre><code>constexpr uint32_t rb::Buttons::Count;\n</code></pre>"},{"location":"esp/classrb_1_1Buttons/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/classrb_1_1Buttons/#function-byid","title":"function byId","text":"<pre><code>inline bool rb::Buttons::byId (\nButtonId id\n) const\n</code></pre>"},{"location":"esp/classrb_1_1Buttons/#function-down","title":"function down","text":"<pre><code>inline bool rb::Buttons::down () const\n</code></pre>"},{"location":"esp/classrb_1_1Buttons/#function-left","title":"function left","text":"<pre><code>inline bool rb::Buttons::left () const\n</code></pre>"},{"location":"esp/classrb_1_1Buttons/#function-off","title":"function off","text":"<pre><code>inline bool rb::Buttons::off () const\n</code></pre>"},{"location":"esp/classrb_1_1Buttons/#function-on","title":"function on","text":"<pre><code>inline bool rb::Buttons::on () const\n</code></pre>"},{"location":"esp/classrb_1_1Buttons/#function-onchange","title":"function onChange","text":"<pre><code>void rb::Buttons::onChange (\ncallback_t callback\n) </code></pre>"},{"location":"esp/classrb_1_1Buttons/#function-right","title":"function right","text":"<pre><code>inline bool rb::Buttons::right () const\n</code></pre>"},{"location":"esp/classrb_1_1Buttons/#function-up","title":"function up","text":"<pre><code>inline bool rb::Buttons::up () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXButtons.h</code></p>"},{"location":"esp/classrb_1_1Leds/","title":"Class rb::Leds","text":"<p>ClassList &gt; rb &gt; Leds</p>"},{"location":"esp/classrb_1_1Leds/#public-functions","title":"Public Functions","text":"Type Name void blue (bool on=true) Set the blue LED state. void byId (LedId id, bool on=true) Set led styte by LedId. void green (bool on=true) Set the green LED state. void red (bool on=true) Set the red LED state. void yellow (bool on=true) Set the yellow LED state."},{"location":"esp/classrb_1_1Leds/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/classrb_1_1Leds/#function-blue","title":"function blue","text":"<pre><code>void rb::Leds::blue (\nbool on=true\n) </code></pre>"},{"location":"esp/classrb_1_1Leds/#function-byid","title":"function byId","text":"<pre><code>void rb::Leds::byId (\nLedId id,\nbool on=true\n) </code></pre>"},{"location":"esp/classrb_1_1Leds/#function-green","title":"function green","text":"<pre><code>void rb::Leds::green (\nbool on=true\n) </code></pre>"},{"location":"esp/classrb_1_1Leds/#function-red","title":"function red","text":"<pre><code>void rb::Leds::red (\nbool on=true\n) </code></pre>"},{"location":"esp/classrb_1_1Leds/#function-yellow","title":"function yellow","text":"<pre><code>void rb::Leds::yellow (\nbool on=true\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXLeds.h</code></p>"},{"location":"esp/classrb_1_1Manager/","title":"Class rb::Manager","text":"<p>ClassList &gt; rb &gt; Manager</p> <p>The main library class for working with the RBCX board. Call the install() method at the start of your program.</p> <ul> <li><code>#include &lt;RBCXManager.h&gt;</code></li> </ul>"},{"location":"esp/classrb_1_1Manager/#public-functions","title":"Public Functions","text":"Type Name Manager (Manager const &amp;) = delete Battery &amp; battery () Get the Battery interface. Buttons &amp; buttons ()  const CoprocStat_VersionStat &amp; coprocFwVersion () const void coprocFwVersionAssert (uint32_t minVersion, const char * name)  void install (ManagerInstallFlags flags=MAN_NONE, BaseType_t managerLoopStackSize=3072) Initialize the manager - must be called once at the start of the program. Leds &amp; leds () Get the Leds helper. void monitorTask (TaskHandle_t task)  Motor &amp; motor (MotorId id)  void operator= (Manager const &amp;) = delete Piezo &amp; piezo () Get the Piezo controller. void schedule (uint32_t period_ms, std::function&lt; bool()&gt; callback) Schedule callback to fire after period (in millisecond). void sendToCoproc (const CoprocReq &amp; msg)  MotorChangeBuilder setMotors () Get a motor instance. StupidServo &amp; stupidServo (uint8_t index)  Timers &amp; timers ()  Ultrasound &amp; ultrasound (uint8_t index) Initialize the UART servo bus for intelligent servos LX-16. TODO: smart servos not implemented!"},{"location":"esp/classrb_1_1Manager/#public-static-functions","title":"Public Static Functions","text":"Type Name Manager &amp; get () Get manager instance."},{"location":"esp/classrb_1_1Manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/classrb_1_1Manager/#function-manager-22","title":"function Manager [2/2]","text":"<pre><code>rb::Manager::Manager (\nManager const &amp;\n) = delete\n</code></pre>"},{"location":"esp/classrb_1_1Manager/#function-battery","title":"function battery","text":"<pre><code>inline Battery &amp; rb::Manager::battery () </code></pre>"},{"location":"esp/classrb_1_1Manager/#function-buttons","title":"function buttons","text":"<pre><code>inline Buttons &amp; rb::Manager::buttons () </code></pre>"},{"location":"esp/classrb_1_1Manager/#function-coprocfwversion","title":"function coprocFwVersion","text":"<pre><code>inline const CoprocStat_VersionStat &amp; rb::Manager::coprocFwVersion () const\n</code></pre>"},{"location":"esp/classrb_1_1Manager/#function-coprocfwversionassert","title":"function coprocFwVersionAssert","text":"<pre><code>void rb::Manager::coprocFwVersionAssert (\nuint32_t minVersion,\nconst char * name\n) </code></pre>"},{"location":"esp/classrb_1_1Manager/#function-install","title":"function install","text":"<p>Initialize the manager - must be called once at the start of the program. <pre><code>void rb::Manager::install (\nManagerInstallFlags flags=MAN_NONE,\nBaseType_t managerLoopStackSize=3072\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>flags</code> modify the manager's behavior or toggle some features. SeeManagerInstallFlags} enum. </li> </ul>"},{"location":"esp/classrb_1_1Manager/#function-leds","title":"function leds","text":"<pre><code>inline Leds &amp; rb::Manager::leds () </code></pre>"},{"location":"esp/classrb_1_1Manager/#function-monitortask","title":"function monitorTask","text":"<pre><code>void rb::Manager::monitorTask (\nTaskHandle_t task\n) </code></pre>"},{"location":"esp/classrb_1_1Manager/#function-motor","title":"function motor","text":"<pre><code>inline Motor &amp; rb::Manager::motor (\nMotorId id\n) </code></pre>"},{"location":"esp/classrb_1_1Manager/#function-operator","title":"function operator=","text":"<pre><code>void rb::Manager::operator= (\nManager const &amp;\n) = delete\n</code></pre>"},{"location":"esp/classrb_1_1Manager/#function-piezo","title":"function piezo","text":"<pre><code>inline Piezo &amp; rb::Manager::piezo () </code></pre>"},{"location":"esp/classrb_1_1Manager/#function-schedule","title":"function schedule","text":"<p>Schedule callback to fire after period (in millisecond). <pre><code>inline void rb::Manager::schedule (\nuint32_t period_ms,\nstd::function&lt; bool()&gt; callback\n) </code></pre></p> <p>Return true from the callback to schedule periodically, false to not (singleshot timer).</p> <p>Parameters:</p> <ul> <li><code>period_ms</code> is period in which will be the schedule callback fired </li> <li><code>callback</code> is a function which will be schedule with the set period. </li> </ul>"},{"location":"esp/classrb_1_1Manager/#function-sendtocoproc","title":"function sendToCoproc","text":"<pre><code>void rb::Manager::sendToCoproc (\nconst CoprocReq &amp; msg\n) </code></pre>"},{"location":"esp/classrb_1_1Manager/#function-setmotors","title":"function setMotors","text":"<p>Get a motor instance. <pre><code>MotorChangeBuilder rb::Manager::setMotors () </code></pre></p> <p>Create motor power change builder: MotorChangeBuilder. </p>"},{"location":"esp/classrb_1_1Manager/#function-stupidservo","title":"function stupidServo","text":"<pre><code>inline StupidServo &amp; rb::Manager::stupidServo (\nuint8_t index\n) </code></pre>"},{"location":"esp/classrb_1_1Manager/#function-timers","title":"function timers","text":"<pre><code>inline Timers &amp; rb::Manager::timers () </code></pre>"},{"location":"esp/classrb_1_1Manager/#function-ultrasound","title":"function ultrasound","text":"<p>Initialize the UART servo bus for intelligent servos LX-16. TODO: smart servos not implemented! <pre><code>inline Ultrasound &amp; rb::Manager::ultrasound (\nuint8_t index\n) </code></pre></p> <p>Returns:</p> <p>Instance of the class SmartServoBus which manage the intelligent servos.</p> <p>Get the SmartServoBus for working with intelligent servos LX-16.. </p> <p>Returns:</p> <p>Instance of the class SmartServoBus which manage the intelligent servos. </p>"},{"location":"esp/classrb_1_1Manager/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"esp/classrb_1_1Manager/#function-get","title":"function get","text":"<p>Get manager instance. <pre><code>static inline Manager &amp; rb::Manager::get () </code></pre></p> <p>Always returns the same instance and is thread-safe. Don't forget to call install() to initialize the manager at the start of your program, when you first get the instance. </p> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXManager.h</code></p>"},{"location":"esp/classrb_1_1Motor/","title":"Class rb::Motor","text":"<p>ClassList &gt; rb &gt; Motor</p>"},{"location":"esp/classrb_1_1Motor/#public-types","title":"Public Types","text":"Type Name typedef std::function&lt; void(Motor &amp;)&gt; callback_t"},{"location":"esp/classrb_1_1Motor/#public-functions","title":"Public Functions","text":"Type Name void brake (uint16_t brakingPower) Start braking. void drive (int32_t positionRelative, int16_t speedTicksPerSecond, callback_t callback=nullptr) Drive motor to set position (according relative value). void driveToValue (int32_t positionAbsolute, int16_t speedTicksPerSecond, callback_t callback=nullptr) Drive motor to set position (according absolute value). MotorId id () const int32_t position () const void power (int16_t value) Set motor power. void pwmMaxPercent (int8_t percent) Limit the maximum PWM value. If you call pwmMaxPercent(70) and then power(100), the motors will spin at 70% of maximum speed. This scales both the power and speed set through Motor . int8_t pwmMaxPercent () constGet current maximum PWM percent value. void requestInfo (callback_t cb)  void setConfig (const MotorConfig &amp; cfg) Set configuration, see MotorConfig &amp; STM32 firmware. void setCurrentPosition (int32_t pos=0) Set the encoder tick counter to some value. void speed (int16_t ticksPerSecond) Set motor speed."},{"location":"esp/classrb_1_1Motor/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"esp/classrb_1_1Motor/#typedef-callback_t","title":"typedef callback_t","text":"<pre><code>typedef std::function&lt;void(Motor&amp;)&gt; rb::Motor::callback_t;\n</code></pre>"},{"location":"esp/classrb_1_1Motor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/classrb_1_1Motor/#function-brake","title":"function brake","text":"<p>Start braking. <pre><code>void rb::Motor::brake (\nuint16_t brakingPower\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>brakingPower</code> braking power in &lt;0, 32767&gt; </li> </ul>"},{"location":"esp/classrb_1_1Motor/#function-drive","title":"function drive","text":"<pre><code>void rb::Motor::drive (\nint32_t positionRelative,\nint16_t speedTicksPerSecond,\ncallback_t callback=nullptr\n) </code></pre>"},{"location":"esp/classrb_1_1Motor/#function-drivetovalue","title":"function driveToValue","text":"<pre><code>void rb::Motor::driveToValue (\nint32_t positionAbsolute,\nint16_t speedTicksPerSecond,\ncallback_t callback=nullptr\n) </code></pre>"},{"location":"esp/classrb_1_1Motor/#function-id","title":"function id","text":"<pre><code>inline MotorId rb::Motor::id () const\n</code></pre>"},{"location":"esp/classrb_1_1Motor/#function-position","title":"function position","text":"<pre><code>inline int32_t rb::Motor::position () const\n</code></pre>"},{"location":"esp/classrb_1_1Motor/#function-power","title":"function power","text":"<p>Set motor power. <pre><code>void rb::Motor::power (\nint16_t value\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>power</code> of the motor &lt;-32768; 32767&gt; </li> </ul>"},{"location":"esp/classrb_1_1Motor/#function-pwmmaxpercent-12","title":"function pwmMaxPercent [1/2]","text":"<p>Limit the maximum PWM value. If you call pwmMaxPercent(70) and then power(100), the motors will spin at 70% of maximum speed. This scales both the power and speed set through Motor . <pre><code>void rb::Motor::pwmMaxPercent (\nint8_t percent\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>pct</code> of the max value &lt;0 - 100&gt; </li> </ul>"},{"location":"esp/classrb_1_1Motor/#function-pwmmaxpercent-22","title":"function pwmMaxPercent [2/2]","text":"<pre><code>inline int8_t rb::Motor::pwmMaxPercent () const\n</code></pre>"},{"location":"esp/classrb_1_1Motor/#function-requestinfo","title":"function requestInfo","text":"<pre><code>void rb::Motor::requestInfo (\ncallback_t cb\n) </code></pre>"},{"location":"esp/classrb_1_1Motor/#function-setconfig","title":"function setConfig","text":"<pre><code>void rb::Motor::setConfig (\nconst MotorConfig &amp; cfg\n) </code></pre>"},{"location":"esp/classrb_1_1Motor/#function-setcurrentposition","title":"function setCurrentPosition","text":"<pre><code>void rb::Motor::setCurrentPosition (\nint32_t pos=0\n) </code></pre>"},{"location":"esp/classrb_1_1Motor/#function-speed","title":"function speed","text":"<p>Set motor speed. <pre><code>void rb::Motor::speed (\nint16_t ticksPerSecond\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ticksPerSecond</code> speed of the motor &lt;-32768; 32767&gt; </li> </ul> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXMotor.h</code></p>"},{"location":"esp/classrb_1_1MotorChangeBuilder/","title":"Class rb::MotorChangeBuilder","text":"<p>ClassList &gt; rb &gt; MotorChangeBuilder</p> <p>Helper class for building the motor change event. </p> <ul> <li><code>#include &lt;RBCXManager.h&gt;</code></li> </ul>"},{"location":"esp/classrb_1_1MotorChangeBuilder/#public-functions","title":"Public Functions","text":"Type Name MotorChangeBuilder ()  MotorChangeBuilder (const MotorChangeBuilder &amp; o) = delete MotorChangeBuilder (MotorChangeBuilder &amp;&amp; o)  MotorChangeBuilder &amp; brake (MotorId id, uint16_t brakingPower) Start braking. MotorChangeBuilder &amp; drive (MotorId id, int32_t positionRelative, int16_t speedTicksPerSecond, Motor::callback_t callback=nullptr)  MotorChangeBuilder &amp; driveToValue (MotorId id, int32_t positionAbsolute, int16_t speedTicksPerSecond, Motor::callback_t callback=nullptr)  MotorChangeBuilder &amp; power (MotorId id, int16_t value) Set single motor power. MotorChangeBuilder &amp; pwmMaxPercent (MotorId id, int8_t percent) Limit motor index's power to percent. void set () Finish the changes and submit the events. MotorChangeBuilder &amp; speed (MotorId id, int16_t ticksPerSecond) Set single motor power. ~MotorChangeBuilder ()"},{"location":"esp/classrb_1_1MotorChangeBuilder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/classrb_1_1MotorChangeBuilder/#function-motorchangebuilder-13","title":"function MotorChangeBuilder [1/3]","text":"<pre><code>rb::MotorChangeBuilder::MotorChangeBuilder () </code></pre>"},{"location":"esp/classrb_1_1MotorChangeBuilder/#function-motorchangebuilder-23","title":"function MotorChangeBuilder [2/3]","text":"<pre><code>rb::MotorChangeBuilder::MotorChangeBuilder (\nconst MotorChangeBuilder &amp; o\n) = delete\n</code></pre>"},{"location":"esp/classrb_1_1MotorChangeBuilder/#function-motorchangebuilder-33","title":"function MotorChangeBuilder [3/3]","text":"<pre><code>rb::MotorChangeBuilder::MotorChangeBuilder (\nMotorChangeBuilder &amp;&amp; o\n) </code></pre>"},{"location":"esp/classrb_1_1MotorChangeBuilder/#function-brake","title":"function brake","text":"<p>Start braking. <pre><code>MotorChangeBuilder &amp; rb::MotorChangeBuilder::brake (\nMotorId id,\nuint16_t brakingPower\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> of the motor (e.g. rb:MotorId::M1) </li> <li><code>brakingPower</code> power of the braking, &lt;0, 32767&gt; </li> </ul>"},{"location":"esp/classrb_1_1MotorChangeBuilder/#function-drive","title":"function drive","text":"<pre><code>MotorChangeBuilder &amp; rb::MotorChangeBuilder::drive (\nMotorId id,\nint32_t positionRelative,\nint16_t speedTicksPerSecond,\nMotor::callback_t callback=nullptr\n) </code></pre>"},{"location":"esp/classrb_1_1MotorChangeBuilder/#function-drivetovalue","title":"function driveToValue","text":"<pre><code>MotorChangeBuilder &amp; rb::MotorChangeBuilder::driveToValue (\nMotorId id,\nint32_t positionAbsolute,\nint16_t speedTicksPerSecond,\nMotor::callback_t callback=nullptr\n) </code></pre>"},{"location":"esp/classrb_1_1MotorChangeBuilder/#function-power","title":"function power","text":"<p>Set single motor power. <pre><code>MotorChangeBuilder &amp; rb::MotorChangeBuilder::power (\nMotorId id,\nint16_t value\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> of the motor (e.g. rb:MotorId::M1) </li> <li><code>power</code> of the motor &lt;-32768; 32767&gt; </li> </ul>"},{"location":"esp/classrb_1_1MotorChangeBuilder/#function-pwmmaxpercent","title":"function pwmMaxPercent","text":"<p>Limit motor index's power to percent. <pre><code>MotorChangeBuilder &amp; rb::MotorChangeBuilder::pwmMaxPercent (\nMotorId id,\nint8_t percent\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> of the motor (e.g. rb:MotorId::M1) </li> <li><code>percent</code> of the maximal power of the motor &lt;0 - 100&gt; </li> </ul>"},{"location":"esp/classrb_1_1MotorChangeBuilder/#function-set","title":"function set","text":"<pre><code>void rb::MotorChangeBuilder::set () </code></pre>"},{"location":"esp/classrb_1_1MotorChangeBuilder/#function-speed","title":"function speed","text":"<p>Set single motor power. <pre><code>MotorChangeBuilder &amp; rb::MotorChangeBuilder::speed (\nMotorId id,\nint16_t ticksPerSecond\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> of the motor (e.g. rb:MotorId::M1) </li> <li><code>speed</code> of the motor in encoder ticks &lt;-32768; 32767&gt; </li> </ul>"},{"location":"esp/classrb_1_1MotorChangeBuilder/#function-motorchangebuilder","title":"function ~MotorChangeBuilder","text":"<pre><code>rb::MotorChangeBuilder::~MotorChangeBuilder () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXManager.h</code></p>"},{"location":"esp/classrb_1_1Nvs/","title":"Class rb::Nvs","text":"<p>ClassList &gt; rb &gt; Nvs</p>"},{"location":"esp/classrb_1_1Nvs/#public-functions","title":"Public Functions","text":"Type Name Nvs (const char * name_space, const char * partition=\"nvs\")  Nvs (const Nvs &amp;) = delete void commit ()  bool existsInt (const char * key)  bool existsString (const char * key)  int getInt (const char * key)  std::string getString (const char * key)  void writeInt (const char * key, int value)  void writeString (const char * key, const std::string &amp; value)  ~Nvs ()"},{"location":"esp/classrb_1_1Nvs/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/classrb_1_1Nvs/#function-nvs-12","title":"function Nvs [1/2]","text":"<pre><code>rb::Nvs::Nvs (\nconst char * name_space,\nconst char * partition=\"nvs\"\n) </code></pre>"},{"location":"esp/classrb_1_1Nvs/#function-nvs-22","title":"function Nvs [2/2]","text":"<pre><code>rb::Nvs::Nvs (\nconst Nvs &amp;\n) = delete\n</code></pre>"},{"location":"esp/classrb_1_1Nvs/#function-commit","title":"function commit","text":"<pre><code>void rb::Nvs::commit () </code></pre>"},{"location":"esp/classrb_1_1Nvs/#function-existsint","title":"function existsInt","text":"<pre><code>bool rb::Nvs::existsInt (\nconst char * key\n) </code></pre>"},{"location":"esp/classrb_1_1Nvs/#function-existsstring","title":"function existsString","text":"<pre><code>bool rb::Nvs::existsString (\nconst char * key\n) </code></pre>"},{"location":"esp/classrb_1_1Nvs/#function-getint","title":"function getInt","text":"<pre><code>int rb::Nvs::getInt (\nconst char * key\n) </code></pre>"},{"location":"esp/classrb_1_1Nvs/#function-getstring","title":"function getString","text":"<pre><code>std::string rb::Nvs::getString (\nconst char * key\n) </code></pre>"},{"location":"esp/classrb_1_1Nvs/#function-writeint","title":"function writeInt","text":"<pre><code>void rb::Nvs::writeInt (\nconst char * key,\nint value\n) </code></pre>"},{"location":"esp/classrb_1_1Nvs/#function-writestring","title":"function writeString","text":"<pre><code>void rb::Nvs::writeString (\nconst char * key,\nconst std::string &amp; value\n) </code></pre>"},{"location":"esp/classrb_1_1Nvs/#function-nvs","title":"function ~Nvs","text":"<pre><code>rb::Nvs::~Nvs () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXNvs.h</code></p>"},{"location":"esp/classrb_1_1Piezo/","title":"Class rb::Piezo","text":"<p>ClassList &gt; rb &gt; Piezo</p> <p>Helper class for controlling the piezo. </p> <ul> <li><code>#include &lt;RBCXPiezo.h&gt;</code></li> </ul>"},{"location":"esp/classrb_1_1Piezo/#public-functions","title":"Public Functions","text":"Type Name void setState (bool on)  void start ()  void stop ()"},{"location":"esp/classrb_1_1Piezo/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/classrb_1_1Piezo/#function-setstate","title":"function setState","text":"<pre><code>void rb::Piezo::setState (\nbool on\n) </code></pre>"},{"location":"esp/classrb_1_1Piezo/#function-start","title":"function start","text":"<pre><code>inline void rb::Piezo::start () </code></pre>"},{"location":"esp/classrb_1_1Piezo/#function-stop","title":"function stop","text":"<pre><code>inline void rb::Piezo::stop () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXPiezo.h</code></p>"},{"location":"esp/classrb_1_1SmartServoBus/","title":"Class rb::SmartServoBus","text":"<p>ClassList &gt; rb &gt; SmartServoBus</p>"},{"location":"esp/classrb_1_1SmartServoBus/#public-functions","title":"Public Functions","text":"Type Name SmartServoBus ()  uint8_t getId (uint8_t destId=254)  void limit (uint8_t id, Angle bottom, Angle top)  Angle pos (uint8_t id)  Angle posOffline (uint8_t id)  void set (uint8_t id, Angle ang, float speed=180.f, float speed_raise=0.0015f)  void setAutoStop (uint8_t id, bool enable=true)  void setId (uint8_t newId, uint8_t destId=254)  ~SmartServoBus ()"},{"location":"esp/classrb_1_1SmartServoBus/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/classrb_1_1SmartServoBus/#function-smartservobus-12","title":"function SmartServoBus [1/2]","text":"<pre><code>rb::SmartServoBus::SmartServoBus () </code></pre>"},{"location":"esp/classrb_1_1SmartServoBus/#function-getid","title":"function getId","text":"<pre><code>uint8_t rb::SmartServoBus::getId (\nuint8_t destId=254\n) </code></pre>"},{"location":"esp/classrb_1_1SmartServoBus/#function-limit","title":"function limit","text":"<pre><code>void rb::SmartServoBus::limit (\nuint8_t id,\nAngle bottom,\nAngle top\n) </code></pre>"},{"location":"esp/classrb_1_1SmartServoBus/#function-pos","title":"function pos","text":"<pre><code>Angle rb::SmartServoBus::pos (\nuint8_t id\n) </code></pre>"},{"location":"esp/classrb_1_1SmartServoBus/#function-posoffline","title":"function posOffline","text":"<pre><code>Angle rb::SmartServoBus::posOffline (\nuint8_t id\n) </code></pre>"},{"location":"esp/classrb_1_1SmartServoBus/#function-set","title":"function set","text":"<pre><code>void rb::SmartServoBus::set (\nuint8_t id,\nAngle ang,\nfloat speed=180.f,\nfloat speed_raise=0.0015f\n) </code></pre>"},{"location":"esp/classrb_1_1SmartServoBus/#function-setautostop","title":"function setAutoStop","text":"<pre><code>void rb::SmartServoBus::setAutoStop (\nuint8_t id,\nbool enable=true\n) </code></pre>"},{"location":"esp/classrb_1_1SmartServoBus/#function-setid","title":"function setId","text":"<pre><code>void rb::SmartServoBus::setId (\nuint8_t newId,\nuint8_t destId=254\n) </code></pre>"},{"location":"esp/classrb_1_1SmartServoBus/#function-smartservobus","title":"function ~SmartServoBus","text":"<pre><code>inline rb::SmartServoBus::~SmartServoBus () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXSmartServo.h</code></p>"},{"location":"esp/classrb_1_1StupidServo/","title":"Class rb::StupidServo","text":"<p>ClassList &gt; rb &gt; StupidServo</p>"},{"location":"esp/classrb_1_1StupidServo/#public-functions","title":"Public Functions","text":"Type Name void disable ()  uint8_t id () constset servo posiotion, range is &lt;0;1&gt;. Some servos might accept a bit more float position () const void setPosition (float positionFraction) Returns last set position (can be NaN if disabled)"},{"location":"esp/classrb_1_1StupidServo/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/classrb_1_1StupidServo/#function-disable","title":"function disable","text":"<pre><code>void rb::StupidServo::disable () </code></pre>"},{"location":"esp/classrb_1_1StupidServo/#function-id","title":"function id","text":"<pre><code>inline uint8_t rb::StupidServo::id () const\n</code></pre>"},{"location":"esp/classrb_1_1StupidServo/#function-position","title":"function position","text":"<pre><code>inline float rb::StupidServo::position () const\n</code></pre>"},{"location":"esp/classrb_1_1StupidServo/#function-setposition","title":"function setPosition","text":"<pre><code>void rb::StupidServo::setPosition (\nfloat positionFraction\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXStupidServo.h</code></p>"},{"location":"esp/classrb_1_1Timers/","title":"Class rb::Timers","text":"<p>ClassList &gt; rb &gt; Timers</p>"},{"location":"esp/classrb_1_1Timers/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint16_t INVALID_ID   = = 0"},{"location":"esp/classrb_1_1Timers/#public-functions","title":"Public Functions","text":"Type Name bool cancel (uint16_t id)  bool isOnTimerTask () const bool reset (uint16_t id, uint32_t period_ms)  uint16_t schedule (uint32_t period_ms, std::function&lt; bool()&gt; callback) Schedule callback to fire after period (in millisecond). bool stop (uint16_t id)"},{"location":"esp/classrb_1_1Timers/#public-static-functions","title":"Public Static Functions","text":"Type Name void deleteFreeRtOsTimerTask () If you don't plan to use FreeRTOS SW timers, call this to free up 2KB of heap. Timers &amp; get ()"},{"location":"esp/classrb_1_1Timers/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"esp/classrb_1_1Timers/#variable-invalid_id","title":"variable INVALID_ID","text":"<pre><code>constexpr uint16_t rb::Timers::INVALID_ID;\n</code></pre>"},{"location":"esp/classrb_1_1Timers/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/classrb_1_1Timers/#function-cancel","title":"function cancel","text":"<pre><code>bool rb::Timers::cancel (\nuint16_t id\n) </code></pre>"},{"location":"esp/classrb_1_1Timers/#function-isontimertask","title":"function isOnTimerTask","text":"<pre><code>bool rb::Timers::isOnTimerTask () const\n</code></pre>"},{"location":"esp/classrb_1_1Timers/#function-reset","title":"function reset","text":"<pre><code>bool rb::Timers::reset (\nuint16_t id,\nuint32_t period_ms\n) </code></pre>"},{"location":"esp/classrb_1_1Timers/#function-schedule","title":"function schedule","text":"<p>Schedule callback to fire after period (in millisecond). <pre><code>uint16_t rb::Timers::schedule (\nuint32_t period_ms,\nstd::function&lt; bool()&gt; callback\n) </code></pre></p> <p>Return true from the callback to schedule periodically, false to not (singleshot timer).</p> <p>Parameters:</p> <ul> <li><code>period_ms</code> is period in which will be the schedule callback fired </li> <li><code>callback</code> is a function which will be schedule with the set period. </li> </ul> <p>Returns:</p> <p>timer ID that you can use to cancel the timer. </p>"},{"location":"esp/classrb_1_1Timers/#function-stop","title":"function stop","text":"<pre><code>bool rb::Timers::stop (\nuint16_t id\n) </code></pre>"},{"location":"esp/classrb_1_1Timers/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"esp/classrb_1_1Timers/#function-deletefreertostimertask","title":"function deleteFreeRtOsTimerTask","text":"<pre><code>static void rb::Timers::deleteFreeRtOsTimerTask () </code></pre>"},{"location":"esp/classrb_1_1Timers/#function-get","title":"function get","text":"<pre><code>static Timers &amp; rb::Timers::get () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXTimers.h</code></p>"},{"location":"esp/classrb_1_1Ultrasound/","title":"Class rb::Ultrasound","text":"<p>ClassList &gt; rb &gt; Ultrasound</p>"},{"location":"esp/classrb_1_1Ultrasound/#public-types","title":"Public Types","text":"Type Name typedef std::function&lt; bool(uint32_t)&gt; callback_t"},{"location":"esp/classrb_1_1Ultrasound/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float defaultSpeedOfSound   = = 347.13f&lt; Default is speed at 25C, 50%, 101 kPa"},{"location":"esp/classrb_1_1Ultrasound/#public-functions","title":"Public Functions","text":"Type Name float getSpeedOfSound () const bool isLastMeasurementValid () const uint32_t lastDistanceMm () const uint32_t lastDurationUs () const uint32_t measure ()  void measureAsync (callback_t callback=nullptr)  void setSpeedOfSound (float speedOfSoundInMetersPerSecond=defaultSpeedOfSound)"},{"location":"esp/classrb_1_1Ultrasound/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"esp/classrb_1_1Ultrasound/#typedef-callback_t","title":"typedef callback_t","text":"<pre><code>typedef std::function&lt;bool(uint32_t)&gt; rb::Ultrasound::callback_t;\n</code></pre>"},{"location":"esp/classrb_1_1Ultrasound/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"esp/classrb_1_1Ultrasound/#variable-defaultspeedofsound","title":"variable defaultSpeedOfSound","text":"<pre><code>constexpr float rb::Ultrasound::defaultSpeedOfSound;\n</code></pre>"},{"location":"esp/classrb_1_1Ultrasound/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/classrb_1_1Ultrasound/#function-getspeedofsound","title":"function getSpeedOfSound","text":"<pre><code>inline float rb::Ultrasound::getSpeedOfSound () const\n</code></pre>"},{"location":"esp/classrb_1_1Ultrasound/#function-islastmeasurementvalid","title":"function isLastMeasurementValid","text":"<pre><code>inline bool rb::Ultrasound::isLastMeasurementValid () const\n</code></pre>"},{"location":"esp/classrb_1_1Ultrasound/#function-lastdistancemm","title":"function lastDistanceMm","text":"<pre><code>inline uint32_t rb::Ultrasound::lastDistanceMm () const\n</code></pre>"},{"location":"esp/classrb_1_1Ultrasound/#function-lastdurationus","title":"function lastDurationUs","text":"<pre><code>inline uint32_t rb::Ultrasound::lastDurationUs () const\n</code></pre>"},{"location":"esp/classrb_1_1Ultrasound/#function-measure","title":"function measure","text":"<pre><code>uint32_t rb::Ultrasound::measure () </code></pre>"},{"location":"esp/classrb_1_1Ultrasound/#function-measureasync","title":"function measureAsync","text":"<pre><code>void rb::Ultrasound::measureAsync (\ncallback_t callback=nullptr\n) </code></pre>"},{"location":"esp/classrb_1_1Ultrasound/#function-setspeedofsound","title":"function setSpeedOfSound","text":"<pre><code>void rb::Ultrasound::setSpeedOfSound (\nfloat speedOfSoundInMetersPerSecond=defaultSpeedOfSound\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXUltrasound.h</code></p>"},{"location":"esp/structrb_1_1SmartServoBus_1_1servo__info/","title":"Struct rb::SmartServoBus::servo_info","text":"<p>ClassList &gt; servo_info</p>"},{"location":"esp/structrb_1_1SmartServoBus_1_1servo__info/#public-attributes","title":"Public Attributes","text":"Type Name bool auto_stop uint8_t auto_stop_counter uint16_t current float speed_coef float speed_raise float speed_target uint16_t target"},{"location":"esp/structrb_1_1SmartServoBus_1_1servo__info/#public-functions","title":"Public Functions","text":"Type Name bool hasValidCurrent () const servo_info ()"},{"location":"esp/structrb_1_1SmartServoBus_1_1servo__info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"esp/structrb_1_1SmartServoBus_1_1servo__info/#variable-auto_stop","title":"variable auto_stop","text":"<pre><code>bool rb::SmartServoBus::servo_info::auto_stop;\n</code></pre>"},{"location":"esp/structrb_1_1SmartServoBus_1_1servo__info/#variable-auto_stop_counter","title":"variable auto_stop_counter","text":"<pre><code>uint8_t rb::SmartServoBus::servo_info::auto_stop_counter;\n</code></pre>"},{"location":"esp/structrb_1_1SmartServoBus_1_1servo__info/#variable-current","title":"variable current","text":"<pre><code>uint16_t rb::SmartServoBus::servo_info::current;\n</code></pre>"},{"location":"esp/structrb_1_1SmartServoBus_1_1servo__info/#variable-speed_coef","title":"variable speed_coef","text":"<pre><code>float rb::SmartServoBus::servo_info::speed_coef;\n</code></pre>"},{"location":"esp/structrb_1_1SmartServoBus_1_1servo__info/#variable-speed_raise","title":"variable speed_raise","text":"<pre><code>float rb::SmartServoBus::servo_info::speed_raise;\n</code></pre>"},{"location":"esp/structrb_1_1SmartServoBus_1_1servo__info/#variable-speed_target","title":"variable speed_target","text":"<pre><code>float rb::SmartServoBus::servo_info::speed_target;\n</code></pre>"},{"location":"esp/structrb_1_1SmartServoBus_1_1servo__info/#variable-target","title":"variable target","text":"<pre><code>uint16_t rb::SmartServoBus::servo_info::target;\n</code></pre>"},{"location":"esp/structrb_1_1SmartServoBus_1_1servo__info/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/structrb_1_1SmartServoBus_1_1servo__info/#function-hasvalidcurrent","title":"function hasValidCurrent","text":"<pre><code>inline bool servo_info::hasValidCurrent () const\n</code></pre>"},{"location":"esp/structrb_1_1SmartServoBus_1_1servo__info/#function-servo_info","title":"function servo_info","text":"<pre><code>inline servo_info::servo_info () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXSmartServo.h</code></p>"},{"location":"esp/structrb_1_1Timers_1_1timer__t/","title":"Struct rb::Timers::timer_t","text":"<p>ClassList &gt; timer_t</p>"},{"location":"esp/structrb_1_1Timers_1_1timer__t/#public-attributes","title":"Public Attributes","text":"Type Name std::function&lt; bool()&gt; callback esp_timer_handle_t handle uint16_t id"},{"location":"esp/structrb_1_1Timers_1_1timer__t/#public-functions","title":"Public Functions","text":"Type Name void swap (timer_t &amp; o)"},{"location":"esp/structrb_1_1Timers_1_1timer__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"esp/structrb_1_1Timers_1_1timer__t/#variable-callback","title":"variable callback","text":"<pre><code>std::function&lt;bool()&gt; rb::Timers::timer_t::callback;\n</code></pre>"},{"location":"esp/structrb_1_1Timers_1_1timer__t/#variable-handle","title":"variable handle","text":"<pre><code>esp_timer_handle_t rb::Timers::timer_t::handle;\n</code></pre>"},{"location":"esp/structrb_1_1Timers_1_1timer__t/#variable-id","title":"variable id","text":"<pre><code>uint16_t rb::Timers::timer_t::id;\n</code></pre>"},{"location":"esp/structrb_1_1Timers_1_1timer__t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/structrb_1_1Timers_1_1timer__t/#function-swap","title":"function swap","text":"<pre><code>inline void timer_t::swap (\ntimer_t &amp; o\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXTimers.h</code></p>"},{"location":"esp/dir_9ba036507fddba3d714985d68e6a47f2/","title":"Dir demo-projets","text":"<p>FileList &gt; demo-projets</p>"},{"location":"esp/dir_9ba036507fddba3d714985d68e6a47f2/#directories","title":"Directories","text":"Type Name dir esp <p>The documentation for this class was generated from the following file <code>demo-projets/</code></p>"},{"location":"esp/dir_9e58d4d56519a220c76623521536407c/","title":"Dir demo-projets/esp","text":"<p>FileList &gt; demo-projets &gt; esp</p>"},{"location":"esp/dir_9e58d4d56519a220c76623521536407c/#files","title":"Files","text":"Type Name file RBCX.h file RBCXAngle.cpp file RBCXAngle.h file RBCXBattery.cpp file RBCXBattery.h file RBCXButtons.cpp file RBCXButtons.h file RBCXLeds.cpp file RBCXLeds.h file RBCXManager.cpp file RBCXManager.h file RBCXMotor.cpp file RBCXMotor.h file RBCXNvs.cpp file RBCXNvs.h file RBCXPiezo.cpp file RBCXPiezo.h file RBCXPinout.h file RBCXSmartServo.cpp file RBCXSmartServo.h file RBCXStupidServo.cpp file RBCXStupidServo.h file RBCXTimers.cpp file RBCXTimers.h file RBCXUltrasound.cpp file RBCXUltrasound.h file RBCXUtil.h file RBCXVersion.h file main.cpp file test.cpp <p>The documentation for this class was generated from the following file <code>demo-projets/esp/</code></p>"},{"location":"esp/RBCX_8h/","title":"File RBCX.h","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCX.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"RBCXManager.h\"</code></li> <li><code>#include \"RBCXPinout.h\"</code></li> <li><code>#include \"RBCXVersion.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCX.h</code></p>"},{"location":"esp/RBCX_8h_source/","title":"File RBCX.h","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCX.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"RBCXManager.h\"\n#include \"RBCXPinout.h\"\n#include \"RBCXVersion.h\"\n</code></pre>"},{"location":"esp/RBCXAngle_8cpp/","title":"File RBCXAngle.cpp","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXAngle.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"RBCXAngle.h\"</code></li> </ul>"},{"location":"esp/RBCXAngle_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace rb <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXAngle.cpp</code></p>"},{"location":"esp/RBCXAngle_8cpp_source/","title":"File RBCXAngle.cpp","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXAngle.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"RBCXAngle.h\"\n\nnamespace rb {\n\nconst Angle Angle::Pi = Angle::rad(Angle::_T(M_PI));\n\nAngle operator+(Angle a, Angle b) {\na += b;\nreturn a;\n}\n\nAngle operator-(Angle a, Angle b) {\na -= b;\nreturn a;\n}\n\nAngle operator*(Angle a, Angle::_T c) {\na *= c;\nreturn a;\n}\n\nAngle operator/(Angle a, Angle::_T c) {\na /= c;\nreturn a;\n}\n\nAngle operator\"\" _deg(long double d) { return Angle::deg(Angle::_T(d)); }\n\nAngle operator\"\" _rad(long double r) { return Angle::rad(Angle::_T(r)); }\n\nAngle operator\"\" _deg(unsigned long long int d) { return Angle::deg(d); }\n\nAngle operator\"\" _rad(unsigned long long int r) { return Angle::rad(r); }\n\n}; // namespace rb\n</code></pre>"},{"location":"esp/RBCXAngle_8h/","title":"File RBCXAngle.h","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXAngle.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;cmath&gt;</code></li> </ul>"},{"location":"esp/RBCXAngle_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXAngle_8h/#classes","title":"Classes","text":"Type Name class Angle"},{"location":"esp/RBCXAngle_8h/#macros","title":"Macros","text":"Type Name define M_PI  3.14159265358979323846"},{"location":"esp/RBCXAngle_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"esp/RBCXAngle_8h/#define-m_pi","title":"define M_PI","text":"<pre><code>#define M_PI 3.14159265358979323846\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXAngle.h</code></p>"},{"location":"esp/RBCXAngle_8h_source/","title":"File RBCXAngle.h","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXAngle.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;cmath&gt;\n\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n\nnamespace rb {\n\nclass Angle {\npublic:\ntypedef float _T;\nstatic const Angle Pi;\n\nAngle()\n: _rads(0) {}\n\nstatic Angle rad(_T r) { return Angle(r); }\nstatic Angle deg(_T d) { return Angle(d * _T(M_PI / 180)); }\nstatic Angle nan() { return Angle(nanf(\"\")); }\n\nbool isNaN() const { return std::isnan(_rads); }\n\nAngle&amp; operator+=(Angle a) {\n_rads += a._rads;\nreturn *this;\n}\nAngle&amp; operator-=(Angle a) {\n_rads -= a._rads;\nreturn *this;\n}\nAngle operator-() const { return Angle(-_rads); }\nAngle&amp; operator*=(_T c) {\n_rads *= c;\nreturn *this;\n}\nAngle&amp; operator/=(_T c) {\n_rads /= c;\nreturn *this;\n}\n\n_T deg() const { return _rads * _T(180.0 / M_PI); }\n_T rad() const { return _rads; }\n\nprivate:\n_T _rads;\nAngle(_T r)\n: _rads(r) {}\n};\n\nAngle operator+(Angle a, Angle b);\nAngle operator-(Angle a, Angle b);\nAngle operator*(Angle a, Angle::_T c);\nAngle operator/(Angle a, Angle::_T c);\nAngle operator\"\" _deg(long double d);\nAngle operator\"\" _rad(long double r);\nAngle operator\"\" _deg(unsigned long long int d);\nAngle operator\"\" _rad(unsigned long long int r);\n\n}; // namespace rb\n</code></pre>"},{"location":"esp/RBCXBattery_8cpp/","title":"File RBCXBattery.cpp","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXBattery.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;esp_log.h&gt;</code></li> <li><code>#include \"RBCXBattery.h\"</code></li> <li><code>#include \"RBCXManager.h\"</code></li> </ul>"},{"location":"esp/RBCXBattery_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXBattery_8cpp/#macros","title":"Macros","text":"Type Name define TAG  \"RBCXBattery\""},{"location":"esp/RBCXBattery_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"esp/RBCXBattery_8cpp/#define-tag","title":"define TAG","text":"<pre><code>#define TAG \"RBCXBattery\"\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXBattery.cpp</code></p>"},{"location":"esp/RBCXBattery_8cpp_source/","title":"File RBCXBattery.cpp","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXBattery.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;esp_log.h&gt;\n\n#include \"RBCXBattery.h\"\n#include \"RBCXManager.h\"\n\n#define TAG \"RBCXBattery\"\n\nnamespace rb {\n\nBattery::Battery() {}\n\nBattery::~Battery() {}\n\nvoid Battery::shutdown() { ESP_LOGW(TAG, \"Shutting down.\");\n\nManager::get().sendToCoproc(CoprocReq {\n.which_payload = CoprocReq_shutdownPower_tag,\n});\n}\n\nuint32_t Battery::pct() const {\nconst auto mv = voltageMv();\nif (mv &lt;= VOLTAGE_MIN) {\nreturn 0;\n} else if (mv &gt;= VOLTAGE_MAX) {\nreturn 100;\n} else {\nreturn (float(mv - VOLTAGE_MIN) / (VOLTAGE_MAX - VOLTAGE_MIN)) * 100.f;\n}\n}\n\n};\n</code></pre>"},{"location":"esp/RBCXBattery_8h/","title":"File RBCXBattery.h","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXBattery.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"esp/RBCXBattery_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXBattery_8h/#classes","title":"Classes","text":"Type Name class Battery Contains the battery state and can control the robot's power. <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXBattery.h</code></p>"},{"location":"esp/RBCXBattery_8h_source/","title":"File RBCXBattery.h","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXBattery.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"rbcx.pb.h\"\n\nnamespace rb {\n\nclass Manager;\n\nclass Battery {\nfriend class Manager;\n\npublic:\nstatic constexpr uint32_t VOLTAGE_MIN = 3300\n* 2; static constexpr uint32_t VOLTAGE_MAX\n= 4200 * 2; static constexpr uint32_t BATTERY_IN_THRESHOLD = 5000;\n\nuint32_t pct() const; uint32_t voltageMv() const { return m_state.vccMv; }\n\nuint32_t bMidVoltageMv() const { return m_state.battMidMv; }\n\nint32_t temperatureC() const { return m_state.temperatureC; }\n\nvoid shutdown(); bool isPoweredByBattery() const {\nreturn voltageMv() &gt; BATTERY_IN_THRESHOLD;\n}\n\nprivate:\nBattery();\nBattery(const Battery&amp;) = delete;\n~Battery();\n\nvoid setState(const CoprocStat_PowerAdcStat&amp; msg) { m_state = msg; }\n\nCoprocStat_PowerAdcStat m_state;\n};\n\n};\n</code></pre>"},{"location":"esp/RBCXButtons_8cpp/","title":"File RBCXButtons.cpp","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXButtons.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"RBCXButtons.h\"</code></li> </ul>"},{"location":"esp/RBCXButtons_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace rb <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXButtons.cpp</code></p>"},{"location":"esp/RBCXButtons_8cpp_source/","title":"File RBCXButtons.cpp","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXButtons.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"RBCXButtons.h\"\n\nnamespace rb {\n\nButtons::Buttons()\n: m_buttonsSet {} {}\n\nButtons::~Buttons() {}\n\nvoid Buttons::setState(const CoprocStat_ButtonsStat&amp; msg) {\nconst uint32_t diff = m_buttonsSet ^ (ButtonId)msg.buttonsPressed;\nif (diff == 0)\nreturn;\n\nm_buttonsSet = (ButtonId)msg.buttonsPressed;\n\nstd::lock_guard&lt;std::recursive_mutex&gt; l(m_mutex);\nfor (uint32_t i = 0; i &lt; Count; ++i) {\nif ((diff &amp; (1 &lt;&lt; i)) == 0)\ncontinue;\n\nfor (size_t x = 0; x &lt; m_callbacks.size();) {\nconst auto id = ButtonId(1 &lt;&lt; i);\nif (!m_callbacks[x](id, byId(id))) {\nm_callbacks.erase(m_callbacks.begin() + x);\n} else {\n++x;\n}\n}\n}\n}\n\nvoid Buttons::onChange(callback_t callback) {\nstd::lock_guard&lt;std::recursive_mutex&gt; l(m_mutex);\nm_callbacks.emplace_back(std::move(callback));\n}\n};\n</code></pre>"},{"location":"esp/RBCXButtons_8h/","title":"File RBCXButtons.h","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXButtons.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"RBCXUtil.h\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"esp/RBCXButtons_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXButtons_8h/#classes","title":"Classes","text":"Type Name class Buttons <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXButtons.h</code></p>"},{"location":"esp/RBCXButtons_8h_source/","title":"File RBCXButtons.h","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXButtons.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;functional&gt;\n#include &lt;mutex&gt;\n#include &lt;vector&gt;\n\n#include \"RBCXUtil.h\"\n\n#include \"rbcx.pb.h\"\n\n// Arduino defines B1...\n#ifdef B1\n#undef B1\n#endif\n\nnamespace rb {\n\nenum ButtonId : uint32_t {\nOff = CoprocStat_ButtonsEnum_BOFF,\nOn = CoprocStat_ButtonsEnum_BON,\n\nB1 = CoprocStat_ButtonsEnum_B1,\nB2 = CoprocStat_ButtonsEnum_B2,\nB3 = CoprocStat_ButtonsEnum_B3,\nB4 = CoprocStat_ButtonsEnum_B4,\n\nUp = B1,\nDown = B2,\nLeft = B3,\nRight = B4,\n};\n\nRBCX_ENUM_IMPL_MASK_OPERATORS(ButtonId)\n\nclass Buttons {\nfriend class Manager;\n\npublic:\ntypedef std::function&lt;bool(ButtonId, bool)&gt; callback_t;\n\nstatic constexpr uint32_t Count = 6;\n\ninline bool byId(ButtonId id) const { return (m_buttonsSet &amp; id) != 0; };\ninline bool up() const { return byId(ButtonId::Up); }\ninline bool down() const { return byId(ButtonId::Down); }\ninline bool left() const { return byId(ButtonId::Left); }\ninline bool right() const { return byId(ButtonId::Right); }\ninline bool on() const { return byId(ButtonId::On); }\ninline bool off() const { return byId(ButtonId::Off); }\n\nvoid onChange(callback_t callback);\n\nprivate:\nButtons();\nButtons(const Buttons&amp;) = delete;\n~Buttons();\n\nvoid setState(const CoprocStat_ButtonsStat&amp; msg);\n\nstd::vector&lt;callback_t&gt; m_callbacks;\nstd::recursive_mutex m_mutex;\nButtonId m_buttonsSet;\n};\n};\n</code></pre>"},{"location":"esp/RBCXLeds_8cpp/","title":"File RBCXLeds.cpp","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXLeds.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"RBCXLeds.h\"</code></li> <li><code>#include \"RBCXManager.h\"</code></li> </ul>"},{"location":"esp/RBCXLeds_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace rb <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXLeds.cpp</code></p>"},{"location":"esp/RBCXLeds_8cpp_source/","title":"File RBCXLeds.cpp","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXLeds.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"RBCXLeds.h\"\n#include \"RBCXManager.h\"\n\nnamespace rb {\n\nLeds::Leds()\n: m_ledsOn {} {}\n\nLeds::~Leds() {}\n\nvoid Leds::red(bool on) { byId(LedId::Red, on); }\n\nvoid Leds::yellow(bool on) { byId(LedId::Yellow, on); }\n\nvoid Leds::green(bool on) { byId(LedId::Green, on); }\n\nvoid Leds::blue(bool on) { byId(LedId::Blue, on); }\n\nvoid Leds::byId(LedId id, bool on) {\nstd::lock_guard&lt;std::mutex&gt; l(m_mutex);\nauto newState = m_ledsOn;\nif (on) {\nnewState |= id;\n} else {\nnewState &amp;= ~id;\n}\n\nif (newState == m_ledsOn)\nreturn;\nm_ledsOn = newState;\n\nconst CoprocReq req = {\n.which_payload = CoprocReq_setLeds_tag,\n.payload = {\n.setLeds = {\n.ledsOn = (CoprocReq_LedsEnum)newState,\n}\n},\n};\n\nManager::get().sendToCoproc(req);\n}\n};\n</code></pre>"},{"location":"esp/RBCXLeds_8h/","title":"File RBCXLeds.h","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXLeds.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include \"RBCXUtil.h\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"esp/RBCXLeds_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXLeds_8h/#classes","title":"Classes","text":"Type Name class Leds <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXLeds.h</code></p>"},{"location":"esp/RBCXLeds_8h_source/","title":"File RBCXLeds.h","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXLeds.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;mutex&gt;\n\n#include \"RBCXUtil.h\"\n\n#include \"rbcx.pb.h\"\n\nnamespace rb {\n\nenum LedId {\nL1 = CoprocReq_LedsEnum_L1,\nL2 = CoprocReq_LedsEnum_L2,\nL3 = CoprocReq_LedsEnum_L3,\nL4 = CoprocReq_LedsEnum_L4,\n\nGreen = L1,\nYellow = L2,\nRed = L3,\nBlue = L4,\n\nAll = L1 | L2 | L3 | L4,\n};\n\nRBCX_ENUM_IMPL_MASK_OPERATORS(LedId)\n\nclass Leds {\nfriend class Manager;\n\npublic:\nvoid red(bool on = true); void yellow(bool on = true); void green(bool on = true); void blue(bool on = true); void byId(LedId id, bool on = true); private:\nLeds();\nLeds(const Leds&amp;) = delete;\n~Leds();\n\nLedId m_ledsOn;\nstd::mutex m_mutex;\n};\n\n};\n</code></pre>"},{"location":"esp/RBCXManager_8cpp/","title":"File RBCXManager.cpp","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXManager.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;driver/i2c.h&gt;</code></li> <li><code>#include &lt;driver/uart.h&gt;</code></li> <li><code>#include &lt;esp_log.h&gt;</code></li> <li><code>#include &lt;freertos/FreeRTOS.h&gt;</code></li> <li><code>#include &lt;freertos/task.h&gt;</code></li> <li><code>#include \"RBCXBattery.h\"</code></li> <li><code>#include \"RBCXManager.h\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"esp/RBCXManager_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXManager_8cpp/#macros","title":"Macros","text":"Type Name define MAX_COPROC_IDLE_MS  75 define MOTORS_FAILSAFE_PERIOD_MS  300 define TAG  \"RBCXManager\""},{"location":"esp/RBCXManager_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"esp/RBCXManager_8cpp/#define-max_coproc_idle_ms","title":"define MAX_COPROC_IDLE_MS","text":"<pre><code>#define MAX_COPROC_IDLE_MS 75\n</code></pre>"},{"location":"esp/RBCXManager_8cpp/#define-motors_failsafe_period_ms","title":"define MOTORS_FAILSAFE_PERIOD_MS","text":"<pre><code>#define MOTORS_FAILSAFE_PERIOD_MS 300\n</code></pre>"},{"location":"esp/RBCXManager_8cpp/#define-tag","title":"define TAG","text":"<pre><code>#define TAG \"RBCXManager\"\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXManager.cpp</code></p>"},{"location":"esp/RBCXManager_8cpp_source/","title":"File RBCXManager.cpp","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXManager.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;driver/i2c.h&gt;\n#include &lt;driver/uart.h&gt;\n#include &lt;esp_log.h&gt;\n#include &lt;freertos/FreeRTOS.h&gt;\n#include &lt;freertos/task.h&gt;\n\n#include \"RBCXBattery.h\"\n#include \"RBCXManager.h\"\n\n#include \"rbcx.pb.h\"\n\n#define TAG \"RBCXManager\"\n\n#define MOTORS_FAILSAFE_PERIOD_MS 300\n#define MAX_COPROC_IDLE_MS 75\n\nnamespace rb {\n\nManager::Manager()\n: m_keepaliveTask(nullptr)\n, m_coprocFwVersion(CoprocStat_VersionStat_init_zero) {}\n\nManager::~Manager() {}\n\nvoid Manager::install(\nManagerInstallFlags flags, BaseType_t managerLoopStackSize) {\nif (m_keepaliveTask != nullptr) {\nESP_LOGE(TAG,\n\"The manager has already been installed, please make sure to \"\n\"only call install() once!\");\nabort();\n}\n\nfor (int i = 0; i &lt; UltrasoundsCount; ++i) {\nm_ultrasounds[i].init(i);\n}\n\nfor (int i = 0; i &lt; StupidServosCount; ++i) {\nm_stupidServos[i].setId(i);\n}\n\nfor (MotorId id = MotorId::M1; id &lt; MotorId::MAX; ++id) {\nm_motors[size_t(id)].setId(id);\n}\n\nm_motors_last_set = 0;\nif (!(flags &amp; MAN_DISABLE_MOTOR_FAILSAFE)) {\nschedule(MOTORS_FAILSAFE_PERIOD_MS,\nstd::bind(&amp;Manager::motorsFailSafe, this));\n}\n\nconst uart_config_t uart_config = {\n.baud_rate = 921600,\n.data_bits = UART_DATA_8_BITS,\n.parity = UART_PARITY_DISABLE,\n.stop_bits = UART_STOP_BITS_1,\n.flow_ctrl = UART_HW_FLOWCTRL_DISABLE,\n};\nESP_ERROR_CHECK(uart_param_config(UART_NUM_2, &amp;uart_config));\nESP_ERROR_CHECK(uart_set_pin(UART_NUM_2, GPIO_NUM_2, GPIO_NUM_0,\nUART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));\nESP_ERROR_CHECK(uart_driver_install(UART_NUM_2, 1024, 0, 0, NULL, 0));\n\nm_coprocSemaphore = xSemaphoreCreateBinary();\n\n// The esp_timer (-&gt; rb::Timers) task runs pinned on core 0, which gets stalled\n// for ~700 ms(?!) when connecting to a WiFi network, so it can't be used\n// for this watchdog.\nxTaskCreate(&amp;Manager::keepaliveRoutine, \"rbmanager_keepalive\", 1536, this,\n10, &amp;m_keepaliveTask);\nmonitorTask(m_keepaliveTask);\n\nTaskHandle_t task;\nxTaskCreate(&amp;Manager::consumerRoutineTrampoline, \"rbmanager_loop\",\nmanagerLoopStackSize, this, 5, &amp;task);\nmonitorTask(task);\n\nsendToCoproc(CoprocReq { .which_payload = CoprocReq_versionReq_tag });\nsendToCoproc(CoprocReq { .which_payload = CoprocReq_getButtons_tag });\n\nif (xSemaphoreTake(m_coprocSemaphore, pdMS_TO_TICKS(300)) != pdTRUE) {\nESP_LOGE(TAG,\n\"failed to acquire FW version from STM32, message not received in \"\n\"300ms.\\n\");\n}\n\n#ifdef RB_DEBUG_MONITOR_TASKS\nschedule(10000, [&amp;]() { return printTasksDebugInfo(); });\n#endif\n}\n\n/*rb::SmartServoBus&amp; Manager::initSmartServoBus(uint8_t servo_count) {\n    m_servos.install(servo_count);\n    return m_servos;\n}*/\n\nvoid Manager::consumerRoutineTrampoline(void* cookie) {\n((Manager*)cookie)-&gt;consumerRoutine();\n}\n\nvoid Manager::consumerRoutine() {\nCoprocLinkParser&lt;CoprocStat, &amp;CoprocStat_msg&gt; parser(m_codec);\n\nwhile (true) {\nuint8_t byte;\nif (uart_read_bytes(UART_NUM_2, &amp;byte, 1, portMAX_DELAY) != 1) {\nESP_LOGE(TAG, \"Invalid uart read\\n\");\ncontinue;\n}\n\nif (!parser.add(byte))\ncontinue;\n\nconst auto&amp; msg = parser.lastMessage();\nswitch (msg.which_payload) {\ncase CoprocStat_buttonsStat_tag:\nm_buttons.setState(msg.payload.buttonsStat);\nbreak;\ncase CoprocStat_ultrasoundStat_tag: {\nconst auto&amp; p = msg.payload.ultrasoundStat;\nif (p.utsIndex &gt;= 0 &amp;&amp; p.utsIndex &lt; UltrasoundsCount)\nm_ultrasounds[p.utsIndex].onMeasuringDone(p);\nbreak;\n}\ncase CoprocStat_powerAdcStat_tag:\nm_battery.setState(msg.payload.powerAdcStat);\nbreak;\ncase CoprocStat_versionStat_tag:\nm_coprocFwVersion = msg.payload.versionStat;\nxSemaphoreGive(m_coprocSemaphore);\nbreak;\ncase CoprocStat_motorStat_tag: {\nconst auto&amp; p = msg.payload.motorStat;\nif (p.motorIndex &lt; (uint32_t)MotorId::MAX) {\nm_motors[p.motorIndex].onMotorStat(p);\n}\nbreak;\n}\n\ncase CoprocStat_ledsStat_tag:\ncase CoprocStat_stupidServoStat_tag:\n// Ignore\nbreak;\ndefault:\nprintf(\"Received message of unknown type from stm32: %d\\n\",\nmsg.which_payload);\nbreak;\n}\n}\n}\n\nvoid Manager::keepaliveRoutine(void* cookie) {\nauto&amp; man = *((Manager*)cookie);\n\nwhile (true) {\nif (xTaskNotifyWait(0, 0, NULL, pdMS_TO_TICKS(MAX_COPROC_IDLE_MS))\n== pdFALSE) {\nman.sendToCoproc(CoprocReq {\n.which_payload = CoprocReq_keepalive_tag,\n});\n}\n}\n}\n\nvoid Manager::sendToCoproc(const CoprocReq&amp; msg) {\nm_codecTxMutex.lock();\nconst auto len = m_codec.encodeWithHeader(\n&amp;CoprocReq_msg, &amp;msg, m_txBuf, sizeof(m_txBuf));\nif (len &gt; 0) {\nuart_write_bytes(UART_NUM_2, (const char*)m_txBuf, len);\n}\nm_codecTxMutex.unlock();\n\nxTaskNotify(m_keepaliveTask, 0, eNoAction);\n}\n\nvoid Manager::coprocFwVersionAssert(uint32_t minVersion, const char* name) {\n// Ignore zero version number and pass. Might be the cmd was not received yet,\n// but better than to crash in that case.\nif (m_coprocFwVersion.number == 0)\nreturn;\n\nif (minVersion &gt; m_coprocFwVersion.number) {\nprintf(\"\\n\\nERROR: Please update your STM32 FW, '%s' requires version \"\n\"0x%06x and you have 0x%06x!\\n\\n\",\nname, minVersion, m_coprocFwVersion.number);\nabort();\n}\n}\n\nvoid Manager::resetMotorsFailSafe() { m_motors_last_set = xTaskGetTickCount(); }\n\nbool Manager::motorsFailSafe() {\nif (m_motors_last_set != 0) {\nconst auto now = xTaskGetTickCount();\nif (now - m_motors_last_set\n&gt; pdMS_TO_TICKS(MOTORS_FAILSAFE_PERIOD_MS)) {\nESP_LOGE(TAG, \"Motor failsafe triggered, stopping all motors!\");\nfor (auto&amp; m : m_motors) {\nm.power(0);\n}\nm_motors_last_set = 0;\n}\n}\nreturn true;\n}\n\nMotorChangeBuilder Manager::setMotors() { return MotorChangeBuilder(); }\n\nvoid Manager::monitorTask(TaskHandle_t task) {\n#ifdef RB_DEBUG_MONITOR_TASKS\nm_tasks_mutex.lock();\nm_tasks.push_back(task);\nm_tasks_mutex.unlock();\n#endif\n}\n\n#ifdef RB_DEBUG_MONITOR_TASKS\nbool Manager::printTasksDebugInfo() {\nstd::lock_guard&lt;std::mutex&gt; lock(m_tasks_mutex);\n\nprintf(\"%16s %5s %5s\\n\", \"Name\", \"prio\", \"stack\");\nprintf(\"==========================================\\n\");\nfor (auto task : m_tasks) {\nauto stackMark = uxTaskGetStackHighWaterMark(task);\nauto prio = uxTaskPriorityGet(task);\nprintf(\"%16s %5d %5d\\n\", pcTaskGetTaskName(task), (int)prio,\n(int)stackMark);\n}\nreturn true;\n}\n#endif\n\nMotorChangeBuilder::MotorChangeBuilder() {}\n\nMotorChangeBuilder::MotorChangeBuilder(MotorChangeBuilder&amp;&amp; o)\n: m_calls(std::move(o.m_calls)) {}\n\nMotorChangeBuilder::~MotorChangeBuilder() {}\n\nMotorChangeBuilder&amp; MotorChangeBuilder::power(MotorId id, int16_t value) {\nm_calls.emplace_back(\nstd::move([=]() { Manager::get().motor(id).power(value); }));\nreturn *this;\n}\n\nMotorChangeBuilder&amp; MotorChangeBuilder::speed(\nMotorId id, int16_t ticksPerSecond) {\nm_calls.emplace_back(\nstd::move([=]() { Manager::get().motor(id).speed(ticksPerSecond); }));\nreturn *this;\n}\n\nMotorChangeBuilder&amp; MotorChangeBuilder::pwmMaxPercent(\nMotorId id, int8_t percent) {\nm_calls.emplace_back(\nstd::move([=]() { Manager::get().motor(id).pwmMaxPercent(percent); }));\nreturn *this;\n}\n\nMotorChangeBuilder&amp; MotorChangeBuilder::brake(\nMotorId id, uint16_t brakingPower) {\nm_calls.emplace_back(\nstd::move([=]() { Manager::get().motor(id).brake(brakingPower); }));\nreturn *this;\n}\n\nMotorChangeBuilder&amp; MotorChangeBuilder::drive(MotorId id,\nint32_t positionRelative, int16_t speedTicksPerSecond,\nMotor::callback_t callback) {\n\nm_calls.emplace_back(std::move([=]() {\nManager::get().motor(id).drive(\npositionRelative, speedTicksPerSecond, std::move(callback));\n}));\nreturn *this;\n}\n\nMotorChangeBuilder&amp; MotorChangeBuilder::driveToValue(MotorId id,\nint32_t positionAbsolute, int16_t speedTicksPerSecond,\nMotor::callback_t callback) {\nm_calls.emplace_back(std::move([=]() {\nManager::get().motor(id).driveToValue(\npositionAbsolute, speedTicksPerSecond, std::move(callback));\n}));\nreturn *this;\n}\n\nvoid MotorChangeBuilder::set() {\nfor (const auto&amp; c : m_calls) {\nc();\n}\nm_calls.clear();\n}\n};\n</code></pre>"},{"location":"esp/RBCXManager_8h/","title":"File RBCXManager.h","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXManager.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;freertos/FreeRTOS.h&gt;</code></li> <li><code>#include &lt;freertos/queue.h&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;list&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"RBCXBattery.h\"</code></li> <li><code>#include \"RBCXButtons.h\"</code></li> <li><code>#include \"RBCXLeds.h\"</code></li> <li><code>#include \"RBCXMotor.h\"</code></li> <li><code>#include \"RBCXPiezo.h\"</code></li> <li><code>#include \"RBCXSmartServo.h\"</code></li> <li><code>#include \"RBCXStupidServo.h\"</code></li> <li><code>#include \"RBCXTimers.h\"</code></li> <li><code>#include \"RBCXUltrasound.h\"</code></li> <li><code>#include \"coproc_link_parser.h\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"esp/RBCXManager_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXManager_8h/#classes","title":"Classes","text":"Type Name class Manager The main library class for working with the RBCX board. Call the install() method at the start of your program. class MotorChangeBuilder Helper class for building the motor change event. <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXManager.h</code></p>"},{"location":"esp/RBCXManager_8h_source/","title":"File RBCXManager.h","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXManager.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;freertos/FreeRTOS.h&gt;\n#include &lt;freertos/queue.h&gt;\n#include &lt;functional&gt;\n#include &lt;list&gt;\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n#include &lt;vector&gt;\n\n#include \"RBCXBattery.h\"\n#include \"RBCXButtons.h\"\n#include \"RBCXLeds.h\"\n#include \"RBCXMotor.h\"\n#include \"RBCXPiezo.h\"\n#include \"RBCXSmartServo.h\"\n#include \"RBCXStupidServo.h\"\n#include \"RBCXTimers.h\"\n#include \"RBCXUltrasound.h\"\n\n#include \"coproc_link_parser.h\"\n#include \"rbcx.pb.h\"\n\nnamespace rb {\n\nclass MotorChangeBuilder;\n\nenum ManagerInstallFlags {\nMAN_NONE = 0,\nMAN_DISABLE_MOTOR_FAILSAFE = (1 &lt;&lt; 0),\n};\n\ninline ManagerInstallFlags operator|(\nManagerInstallFlags a, ManagerInstallFlags b) {\nreturn static_cast&lt;ManagerInstallFlags&gt;(\nstatic_cast&lt;int&gt;(a) | static_cast&lt;int&gt;(b));\n}\n\n// Periodically print info about all RBCX tasks to the console\n//#define RB_DEBUG_MONITOR_TASKS 1\n\nclass Manager {\nfriend class MotorChangeBuilder;\nfriend class Encoder;\nfriend class PcntInterruptHandler;\nfriend class Motor;\n\npublic:\nManager(Manager const&amp;) = delete;\nvoid operator=(Manager const&amp;) = delete;\n\nstatic Manager&amp; get() {\nstatic Manager instance;\nreturn instance;\n}\n\nvoid install(ManagerInstallFlags flags = MAN_NONE,\nBaseType_t managerLoopStackSize = 3072);\n\n//SmartServoBus&amp; initSmartServoBus(uint8_t servo_count);\n\n//SmartServoBus&amp; servoBus() { return m_servos; };\n\nUltrasound&amp; ultrasound(uint8_t index) { return m_ultrasounds[index]; }\n\nStupidServo&amp; stupidServo(uint8_t index) { return m_stupidServos[index]; }\n\nPiezo&amp; piezo() { return m_piezo; } Battery&amp; battery() {\nreturn m_battery;\n} Leds&amp; leds() { return m_leds; } Buttons&amp; buttons() { return m_buttons; }\n\nMotor&amp; motor(MotorId id) {\nreturn m_motors[static_cast&lt;int&gt;(id)];\n}; MotorChangeBuilder\nsetMotors(); void schedule(uint32_t period_ms, std::function&lt;bool()&gt; callback) {\ntimers().schedule(period_ms, callback);\n}\n\ninline Timers&amp; timers() { return rb::Timers::get(); }\n\n// internal api to monitor RBCX tasks\nvoid monitorTask(TaskHandle_t task);\n\nvoid sendToCoproc(const CoprocReq&amp; msg);\n\nconst CoprocStat_VersionStat&amp; coprocFwVersion() const {\nreturn m_coprocFwVersion;\n}\n\nvoid coprocFwVersionAssert(uint32_t minVersion, const char* name);\n\nprivate:\nManager();\n~Manager();\n\nstatic void consumerRoutineTrampoline(void* cookie);\nvoid consumerRoutine();\n\nstatic void keepaliveRoutine(void* cookie);\n\nvoid resetMotorsFailSafe();\nbool motorsFailSafe();\n\n#ifdef RB_DEBUG_MONITOR_TASKS\nbool printTasksDebugInfo();\n\nstd::vector&lt;TaskHandle_t&gt; m_tasks;\nstd::mutex m_tasks_mutex;\n#endif\n\nTaskHandle_t m_keepaliveTask;\n\nCoprocCodec m_codec;\nuint8_t m_txBuf[CoprocCodec::MaxFrameSize];\nstd::mutex m_codecTxMutex;\n\nuint16_t m_coprocWatchdogTimer;\n\nCoprocStat_VersionStat m_coprocFwVersion;\nSemaphoreHandle_t m_coprocSemaphore;\n\nTickType_t m_motors_last_set;\nMotor m_motors[size_t(MotorId::MAX)];\n\nrb::Piezo m_piezo;\nrb::Leds m_leds;\nrb::Buttons m_buttons;\nrb::Battery m_battery;\n//rb::SmartServoBus m_servos;\nrb::Ultrasound m_ultrasounds[UltrasoundsCount];\nrb::StupidServo m_stupidServos[StupidServosCount];\n};\n\nclass MotorChangeBuilder {\npublic:\nMotorChangeBuilder();\nMotorChangeBuilder(const MotorChangeBuilder&amp; o) = delete;\nMotorChangeBuilder(MotorChangeBuilder&amp;&amp; o);\n~MotorChangeBuilder();\n\nMotorChangeBuilder&amp; power(MotorId id, int16_t value);\n\nMotorChangeBuilder&amp; speed(MotorId id, int16_t ticksPerSecond);\n\nMotorChangeBuilder&amp; brake(MotorId id, uint16_t brakingPower);\n\nMotorChangeBuilder&amp; pwmMaxPercent(MotorId id, int8_t percent);\n\nMotorChangeBuilder&amp; drive(MotorId id, int32_t positionRelative,\nint16_t speedTicksPerSecond, Motor::callback_t callback = nullptr);\n\nMotorChangeBuilder&amp; driveToValue(MotorId id, int32_t positionAbsolute,\nint16_t speedTicksPerSecond, Motor::callback_t callback = nullptr);\n\nvoid set();\n\nprivate:\nstd::vector&lt;std::function&lt;void()&gt;&gt; m_calls;\n};\n\n} // namespace rb\n</code></pre>"},{"location":"esp/RBCXMotor_8cpp/","title":"File RBCXMotor.cpp","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXMotor.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"RBCXMotor.h\"</code></li> <li><code>#include \"RBCXManager.h\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"esp/RBCXMotor_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXMotor_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint32_t minVersionPositional   = = 0x010100"},{"location":"esp/RBCXMotor_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"esp/RBCXMotor_8cpp/#variable-minversionpositional","title":"variable minVersionPositional","text":"<pre><code>constexpr uint32_t minVersionPositional;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXMotor.cpp</code></p>"},{"location":"esp/RBCXMotor_8cpp_source/","title":"File RBCXMotor.cpp","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXMotor.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"RBCXMotor.h\"\n#include \"RBCXManager.h\"\n\n#include \"rbcx.pb.h\"\n\nstatic constexpr uint32_t minVersionPositional = 0x010100;\n\nnamespace rb {\n\nMotor::Motor() {\nm_power = 0;\nm_speed = 0;\nm_position = 0;\nm_mode = MotorMode_POWER;\nm_lastReq = CoprocReq_MotorReq_init_zero;\nm_pwm_max_percent = 100;\n}\n\nvoid Motor::requestInfo(callback_t cb) {\nManager::get().coprocFwVersionAssert(\nminVersionPositional, \"positional motor control (drive)\");\n\nstd::lock_guard&lt;std::mutex&gt; l(m_mutex);\n\nif (m_infoCbs.empty()) {\nManager::get().sendToCoproc(CoprocReq {\n.which_payload = CoprocReq_motorReq_tag,\n.payload = {\n.motorReq = CoprocReq_MotorReq {\n.motorIndex = (uint32_t)m_id,\n.which_motorCmd = CoprocReq_MotorReq_getState_tag,\n},\n},\n});\n}\n\nif (cb) {\nm_infoCbs.emplace_back(std::move(cb));\n}\n}\n\nvoid Motor::power(int16_t value) {\nsendMotorReq(CoprocReq_MotorReq {\n.motorIndex = (uint32_t)m_id,\n.which_motorCmd = CoprocReq_MotorReq_setPower_tag,\n.motorCmd = {\n.setPower = scale(value),\n},\n});\n}\n\nvoid Motor::speed(int16_t ticksPerSecond) {\nsendMotorReq(CoprocReq_MotorReq {\n.motorIndex = (uint32_t)m_id,\n.which_motorCmd = CoprocReq_MotorReq_setVelocity_tag,\n.motorCmd = {\n.setVelocity = scale(ticksPerSecond),\n},\n});\n}\n\nvoid Motor::brake(uint16_t value) {\nsendMotorReq(CoprocReq_MotorReq {\n.motorIndex = (uint32_t)m_id,\n.which_motorCmd = CoprocReq_MotorReq_setBrake_tag,\n.motorCmd = {\n.setBrake = value,\n},\n});\n}\n\nvoid Motor::pwmMaxPercent(int8_t percent) {\nm_pwm_max_percent = std::min(int8_t(100), std::max(int8_t(0), percent));\n}\n\nvoid Motor::driveToValue(int32_t positionAbsolute, int16_t speedTicksPerSecond,\ncallback_t callback) {\nManager::get().coprocFwVersionAssert(\nminVersionPositional, \"positional motor control (drive)\");\n\nsendPositionReq(false,\nCoprocReq_MotorReq_SetPosition {\n.targetPosition = positionAbsolute,\n.runningVelocity = scale(speedTicksPerSecond),\n},\nstd::move(callback));\n}\n\nvoid Motor::drive(int32_t positionRelative, int16_t speedTicksPerSecond,\ncallback_t callback) {\nManager::get().coprocFwVersionAssert(\nminVersionPositional, \"positional motor control (drive)\");\nsendPositionReq(true,\nCoprocReq_MotorReq_SetPosition {\n.targetPosition = positionRelative,\n.runningVelocity = scale(speedTicksPerSecond),\n},\nstd::move(callback));\n}\n\nvoid Motor::setConfig(const MotorConfig&amp; conf) {\nManager::get().coprocFwVersionAssert(\nminVersionPositional, \"positional motor control (drive)\");\n\nconst CoprocReq coprocReq = {\n.which_payload = CoprocReq_motorReq_tag,\n.payload = {\n.motorReq = CoprocReq_MotorReq {\n.motorIndex = (uint32_t)m_id,\n.which_motorCmd = CoprocReq_MotorReq_setConfig_tag,\n.motorCmd = {\n.setConfig = conf,\n},\n},\n},\n};\n\nManager::get().sendToCoproc(coprocReq);\n}\n\nvoid Motor::setCurrentPosition(int32_t pos) {\nManager::get().coprocFwVersionAssert(\nminVersionPositional, \"positional motor control (drive)\");\n\nstd::lock_guard&lt;std::mutex&gt; l(m_mutex);\n\nm_position = pos;\n\nconst CoprocReq coprocReq = {\n.which_payload = CoprocReq_motorReq_tag,\n.payload = {\n.motorReq = CoprocReq_MotorReq {\n.motorIndex = (uint32_t)m_id,\n.which_motorCmd = CoprocReq_MotorReq_homePosition_tag,\n.motorCmd = {\n.homePosition = pos,\n},\n},\n},\n};\n\nManager::get().sendToCoproc(coprocReq);\n}\n\nint16_t Motor::scale(int16_t val) {\nreturn int32_t(val) * m_pwm_max_percent / 100;\n}\n\nvoid Motor::sendPositionReq(bool additive,\nconst CoprocReq_MotorReq_SetPosition&amp; req, callback_t&amp;&amp; callback) {\n\n{\nstd::lock_guard&lt;std::mutex&gt; l(m_mutex);\n\nManager::get().resetMotorsFailSafe();\nmemset(&amp;m_lastReq, 0, sizeof(CoprocReq_MotorReq));\n\nm_mode = MotorMode_POSITION;\nm_speed = req.runningVelocity;\nm_positionCb = callback;\n\nconst pb_size_t tag = additive ? CoprocReq_MotorReq_addPosition_tag\n: CoprocReq_MotorReq_setPosition_tag;\nconst CoprocReq coprocReq = {\n.which_payload = CoprocReq_motorReq_tag,\n.payload = {\n.motorReq = CoprocReq_MotorReq {\n.motorIndex = (uint32_t)m_id,\n.which_motorCmd = tag,\n.motorCmd = {\n.setPosition = req,\n},\n},\n},\n};\nManager::get().sendToCoproc(coprocReq);\n}\n}\n\nvoid Motor::sendMotorReq(const CoprocReq_MotorReq&amp; req) {\n{\nstd::lock_guard&lt;std::mutex&gt; l(m_mutex);\n\nManager::get().resetMotorsFailSafe();\n\nif (memcmp(&amp;m_lastReq, &amp;req, sizeof(CoprocReq_MotorReq)) == 0)\nreturn;\nmemcpy(&amp;m_lastReq, &amp;req, sizeof(CoprocReq_MotorReq));\n\nswitch (req.which_motorCmd) {\ncase CoprocReq_MotorReq_setPower_tag:\nm_mode = MotorMode_POWER;\nbreak;\ncase CoprocReq_MotorReq_setBrake_tag:\nm_mode = MotorMode_BRAKE;\nbreak;\ncase CoprocReq_MotorReq_setVelocity_tag:\nm_mode = MotorMode_VELOCITY;\nbreak;\ndefault:\nabort();\n}\n\nif (m_mode != MotorMode_POSITION &amp;&amp; m_positionCb) {\nm_positionCb = nullptr;\n}\n\nconst CoprocReq coprocReq = {\n.which_payload = CoprocReq_motorReq_tag,\n.payload = {\n.motorReq = req,\n},\n};\nManager::get().sendToCoproc(coprocReq);\n}\n}\n\nvoid Motor::onMotorStat(const CoprocStat_MotorStat&amp; msg) {\ncallback_t positionCb;\nstd::vector&lt;callback_t&gt; infoCbs;\n\n{\nstd::lock_guard&lt;std::mutex&gt; l(m_mutex);\nif (m_mode == MotorMode_POSITION &amp;&amp; msg.mode == MotorMode_POSITION_IDLE\n&amp;&amp; m_positionCb) {\nm_positionCb.swap(positionCb);\n}\n\nif (!m_infoCbs.empty()) {\nm_infoCbs.swap(infoCbs);\n}\n\nm_mode = msg.mode;\nm_position = msg.position;\nm_power = msg.power;\nm_speed = msg.velocity;\n}\n\nif (positionCb) {\npositionCb(*this);\n}\n\nfor (const auto&amp; cb : infoCbs) {\ncb(*this);\n}\n}\n\n}; // namespace rb\n</code></pre>"},{"location":"esp/RBCXMotor_8h/","title":"File RBCXMotor.h","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXMotor.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"RBCXPinout.h\"</code></li> <li><code>#include \"RBCXUtil.h\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"esp/RBCXMotor_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXMotor_8h/#classes","title":"Classes","text":"Type Name class Motor <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXMotor.h</code></p>"},{"location":"esp/RBCXMotor_8h_source/","title":"File RBCXMotor.h","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXMotor.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n#include &lt;vector&gt;\n\n#include \"RBCXPinout.h\"\n#include \"RBCXUtil.h\"\n\n#include \"rbcx.pb.h\"\n\nnamespace rb {\n\nclass Manager;\nclass MotorChangeBuilder;\n\nclass Motor {\nfriend class Manager;\nfriend class MotorChangeBuilder;\n\npublic:\ntypedef std::function&lt;void(Motor&amp;)&gt; callback_t;\n\nMotorId id() const { return m_id; }\n\nint32_t position() const { return m_position; }\n\nvoid requestInfo(callback_t cb);\n\nvoid power(int16_t value);\n\nvoid speed(int16_t ticksPerSecond);\n\nvoid brake(uint16_t brakingPower);\n\nvoid pwmMaxPercent(int8_t percent);\n\nint8_t pwmMaxPercent() const { return m_pwm_max_percent; }\n\nvoid driveToValue(int32_t positionAbsolute, int16_t speedTicksPerSecond,\ncallback_t callback = nullptr);\n\nvoid drive(int32_t positionRelative, int16_t speedTicksPerSecond,\ncallback_t callback = nullptr);\n\nvoid setCurrentPosition(int32_t pos = 0);\n\nvoid setConfig(const MotorConfig&amp; cfg);\n\nprivate:\nMotor();\nMotor(const Motor&amp;) = delete;\n\nvoid setId(MotorId id) { m_id = id; }\n\nvoid sendPositionReq(bool additive,\nconst CoprocReq_MotorReq_SetPosition&amp; req, callback_t&amp;&amp; callback);\nvoid sendMotorReq(const CoprocReq_MotorReq&amp; req);\nvoid onMotorStat(const CoprocStat_MotorStat&amp; msg);\n\nint16_t scale(int16_t val);\n\ncallback_t m_positionCb;\nstd::vector&lt;callback_t&gt; m_infoCbs;\nCoprocReq_MotorReq m_lastReq;\nstd::mutex m_mutex;\n\nMotorId m_id;\nMotorMode m_mode;\nint32_t m_position;\nint16_t m_power;\nint16_t m_speed;\n\nint8_t m_pwm_max_percent;\n};\n\n} // namespace rb\n</code></pre>"},{"location":"esp/RBCXNvs_8cpp/","title":"File RBCXNvs.cpp","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXNvs.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"RBCXNvs.h\"</code></li> </ul>"},{"location":"esp/RBCXNvs_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace rb <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXNvs.cpp</code></p>"},{"location":"esp/RBCXNvs_8cpp_source/","title":"File RBCXNvs.cpp","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXNvs.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;vector&gt;\n\n#include \"RBCXNvs.h\"\n\nnamespace rb {\n\nNvs::Nvs(const char* name, const char* partiton)\n: m_dirty(false) {\nESP_ERROR_CHECK(initFlash());\nESP_ERROR_CHECK(\nnvs_open_from_partition(partiton, name, NVS_READWRITE, &amp;m_handle));\n}\n\nNvs::~Nvs() {\nif (m_dirty)\ncommit();\nnvs_close(m_handle);\n}\n\nesp_err_t Nvs::initFlash() {\nesp_err_t err = nvs_flash_init();\nif (err == ESP_ERR_NVS_NO_FREE_PAGES\n|| err == ESP_ERR_NVS_NEW_VERSION_FOUND) {\n// NVS partition was truncated and needs to be erased\n// Retry nvs_flash_init\nESP_ERROR_CHECK(nvs_flash_erase());\nerr = nvs_flash_init();\n}\nreturn err;\n}\n\nbool Nvs::existsInt(const char* key) {\nint value;\nreturn nvs_get_i32(m_handle, key, &amp;value) == ESP_OK;\n}\n\nint Nvs::getInt(const char* key) {\nint value;\nESP_ERROR_CHECK(nvs_get_i32(m_handle, key, &amp;value));\nreturn value;\n}\n\nvoid Nvs::writeInt(const char* key, int value) {\nESP_ERROR_CHECK(nvs_set_i32(m_handle, key, value));\nm_dirty = true;\n}\n\nbool Nvs::existsString(const char* key) {\nsize_t len;\nreturn nvs_get_str(m_handle, key, NULL, &amp;len) == ESP_OK;\n}\n\nstd::string Nvs::getString(const char* key) {\nsize_t len;\nESP_ERROR_CHECK(nvs_get_str(m_handle, key, NULL, &amp;len));\n\nstd::vector&lt;char&gt; res(len, ' ');\nESP_ERROR_CHECK(nvs_get_str(m_handle, key, res.data(), &amp;len));\nreturn std::string(res.data());\n}\n\nvoid Nvs::writeString(const char* key, const std::string&amp; value) {\nESP_ERROR_CHECK(nvs_set_str(m_handle, key, value.c_str()));\nm_dirty = true;\n}\n\nvoid Nvs::commit() {\nnvs_commit(m_handle);\nm_dirty = false;\n}\n\n} // namespace rb\n</code></pre>"},{"location":"esp/RBCXNvs_8h/","title":"File RBCXNvs.h","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXNvs.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;esp_system.h&gt;</code></li> <li><code>#include &lt;nvs.h&gt;</code></li> <li><code>#include &lt;nvs_flash.h&gt;</code></li> </ul>"},{"location":"esp/RBCXNvs_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXNvs_8h/#classes","title":"Classes","text":"Type Name class Nvs <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXNvs.h</code></p>"},{"location":"esp/RBCXNvs_8h_source/","title":"File RBCXNvs.h","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXNvs.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;string&gt;\n\n#include &lt;esp_system.h&gt;\n#include &lt;nvs.h&gt;\n#include &lt;nvs_flash.h&gt;\n\nnamespace rb {\n\nclass Nvs {\npublic:\nNvs(const char* name_space, const char* partition = \"nvs\");\n~Nvs();\nNvs(const Nvs&amp;) = delete;\n\nbool existsInt(const char* key);\nint getInt(const char* key);\nvoid writeInt(const char* key, int value);\n\nbool existsString(const char* key);\nstd::string getString(const char* key);\nvoid writeString(const char* key, const std::string&amp; value);\n\nvoid commit();\n\nprivate:\nesp_err_t initFlash();\n\nnvs_handle m_handle;\nbool m_dirty;\n};\n\n} // namespace rb\n</code></pre>"},{"location":"esp/RBCXPiezo_8cpp/","title":"File RBCXPiezo.cpp","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXPiezo.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;driver/gpio.h&gt;</code></li> <li><code>#include &lt;driver/ledc.h&gt;</code></li> <li><code>#include &lt;esp_log.h&gt;</code></li> <li><code>#include \"RBCXManager.h\"</code></li> <li><code>#include \"RBCXPiezo.h\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"esp/RBCXPiezo_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace rb <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXPiezo.cpp</code></p>"},{"location":"esp/RBCXPiezo_8cpp_source/","title":"File RBCXPiezo.cpp","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXPiezo.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;driver/gpio.h&gt;\n#include &lt;driver/ledc.h&gt;\n#include &lt;esp_log.h&gt;\n\n#include \"RBCXManager.h\"\n#include \"RBCXPiezo.h\"\n\n#include \"rbcx.pb.h\"\n\nnamespace rb {\n\nPiezo::Piezo()\n: m_on(false) {}\n\nPiezo::~Piezo() {}\n\nvoid Piezo::setState(bool on) {\nif (m_on == on)\nreturn;\nm_on = on;\n\nManager::get().sendToCoproc(\nCoprocReq { .which_payload = CoprocReq_buzzerReq_tag,\n.payload = { .buzzerReq = {\n.on = on,\n} } });\n}\n\n};\n</code></pre>"},{"location":"esp/RBCXPiezo_8h/","title":"File RBCXPiezo.h","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXPiezo.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> </ul>"},{"location":"esp/RBCXPiezo_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXPiezo_8h/#classes","title":"Classes","text":"Type Name class Piezo Helper class for controlling the piezo. <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXPiezo.h</code></p>"},{"location":"esp/RBCXPiezo_8h_source/","title":"File RBCXPiezo.h","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXPiezo.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;atomic&gt;\n\nnamespace rb {\n\nclass Piezo {\nfriend class Manager;\n\npublic:\nvoid start() { setState(true); }\nvoid stop() { setState(false); }\n\nvoid setState(bool on);\n\nprivate:\nPiezo();\nPiezo(const Piezo&amp;) = delete;\n~Piezo();\n\nbool m_on;\n};\n};\n</code></pre>"},{"location":"esp/RBCXPinout_8h/","title":"File RBCXPinout.h","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXPinout.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;driver/adc.h&gt;</code></li> <li><code>#include &lt;driver/gpio.h&gt;</code></li> </ul>"},{"location":"esp/RBCXPinout_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rb <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXPinout.h</code></p>"},{"location":"esp/RBCXPinout_8h_source/","title":"File RBCXPinout.h","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXPinout.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;driver/adc.h&gt;\n#include &lt;driver/gpio.h&gt;\n\nnamespace rb {\n\nenum class MotorId : uint8_t {\nM1,\nM2,\nM3,\nM4,\n\nMAX,\n};\n\ninline MotorId operator++(MotorId&amp; x) {\nreturn x = MotorId(static_cast&lt;uint8_t&gt;(x) + 1);\n}\n\nstatic constexpr int UltrasoundsCount = 4;\nstatic constexpr int StupidServosCount = 4;\n\n} // namespace rb\n</code></pre>"},{"location":"esp/RBCXSmartServo_8cpp/","title":"File RBCXSmartServo.cpp","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXSmartServo.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;esp_log.h&gt;</code></li> <li><code>#include &lt;freertos/FreeRTOS.h&gt;</code></li> <li><code>#include &lt;freertos/task.h&gt;</code></li> <li><code>#include &lt;math.h&gt;</code></li> <li><code>#include \"RBCXManager.h\"</code></li> <li><code>#include \"RBCXSmartServo.h\"</code></li> </ul>"},{"location":"esp/RBCXSmartServo_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXSmartServo_8cpp/#macros","title":"Macros","text":"Type Name define MS_TO_TICKS (ms)     ((portTICK_PERIOD_MS &lt;= ms) ? (ms / portTICK_PERIOD_MS) : 1) define TAG  \"RBCXSmartServoBus\""},{"location":"esp/RBCXSmartServo_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"esp/RBCXSmartServo_8cpp/#define-ms_to_ticks","title":"define MS_TO_TICKS","text":"<pre><code>#define MS_TO_TICKS (\nms\n) ((portTICK_PERIOD_MS &lt;= ms) ? (ms / portTICK_PERIOD_MS) : 1)\n</code></pre>"},{"location":"esp/RBCXSmartServo_8cpp/#define-tag","title":"define TAG","text":"<pre><code>#define TAG \"RBCXSmartServoBus\"\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXSmartServo.cpp</code></p>"},{"location":"esp/RBCXSmartServo_8cpp_source/","title":"File RBCXSmartServo.cpp","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXSmartServo.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;chrono&gt;\n#include &lt;esp_log.h&gt;\n#include &lt;freertos/FreeRTOS.h&gt;\n#include &lt;freertos/task.h&gt;\n#include &lt;math.h&gt;\n\n#include \"RBCXManager.h\"\n#include \"RBCXSmartServo.h\"\n\n#define TAG \"RBCXSmartServoBus\"\n#define MS_TO_TICKS(ms)                                                        \\\n    ((portTICK_PERIOD_MS &lt;= ms) ? (ms / portTICK_PERIOD_MS) : 1)\n\nnamespace rb {\n\nSmartServoBus::SmartServoBus() {}\n\nvoid SmartServoBus::install(uint8_t servo_count) {\nif (!m_servos.empty() || servo_count == 0)\nreturn;\n\nm_servos.resize(servo_count);\n\nTaskHandle_t task;\nxTaskCreate(&amp;SmartServoBus::regulatorRoutineTrampoline, \"rbservo_reg\", 1536,\nthis, 2, &amp;task);\nManager::get().monitorTask(task);\n\nAngle val;\nfor (uint8_t i = 0; i &lt; servo_count; ++i) {\nfor (int x = 0; x &lt; 3; ++x) {\nval = pos(i);\nif (!val.isNaN()) {\nbreak;\n} else {\nESP_LOGW(\nTAG, \"failed to read servo %d pos, attempt %d\", i, x + 1);\n}\n}\n\nif (val.isNaN()) {\nESP_LOGE(TAG,\n\"failed to read position from servo %d, it will not work!\", i);\ncontinue;\n}\n\nconst uint16_t deg_val = 100 * val.deg();\n\nm_mutex.lock();\nm_servos[i].current = deg_val;\nm_servos[i].target = deg_val;\nm_mutex.unlock();\n}\n}\n\nvoid SmartServoBus::setId(uint8_t newId, uint8_t destId) {\n// TODO\n}\n\nuint8_t SmartServoBus::getId(uint8_t destId) {\n// TODO\nreturn 0;\n}\n\nvoid SmartServoBus::set(uint8_t id, Angle ang, float speed, float speed_raise) {\nspeed = std::max(1.f, std::min(240.f, speed)) / 10.f;\nconst uint16_t angle\n= std::max(0.f, std::min(360.f, (float)ang.deg())) * 100;\n\nstd::lock_guard&lt;std::mutex&gt; lock(m_mutex);\n\nauto&amp; si = m_servos[id];\nif (!si.hasValidCurrent()) {\nconst auto cur = pos(id);\nif (cur.isNaN()) {\nESP_LOGE(TAG, \"failed to get servo %d position, can't move it!\",\nint(id));\nreturn;\n}\nconst uint16_t deg_val = 100 * cur.deg();\nsi.current = deg_val;\nsi.target = deg_val;\n}\n\nif (si.current == angle)\nreturn;\n\nif ((si.current &gt; si.target) != (si.current &gt; angle)) {\nsi.speed_coef = 0.f;\n}\n\nsi.target = angle;\nsi.speed_target = speed;\nsi.speed_raise = speed_raise;\n}\n\nAngle SmartServoBus::pos(uint8_t id) {\n// TODO\nreturn Angle::deg(0);\n}\n\nAngle SmartServoBus::posOffline(uint8_t id) {\nstd::lock_guard&lt;std::mutex&gt; lock(m_mutex);\nauto&amp; s = m_servos[id];\nif (s.current == 0xFFFF)\nreturn Angle::nan();\nreturn Angle::deg(Angle::_T(s.current) / 100.f);\n}\n\nvoid SmartServoBus::limit(uint8_t id, Angle bottom, Angle top) {\n// TODO\n}\n\nvoid SmartServoBus::setAutoStop(uint8_t id, bool enable) {\nm_mutex.lock();\nm_servos[id].auto_stop = enable;\nm_mutex.unlock();\n}\n\nvoid SmartServoBus::regulatorRoutineTrampoline(void* cookie) {\n((SmartServoBus*)cookie)-&gt;regulatorRoutine();\n}\n\nvoid SmartServoBus::regulatorRoutine() {\nconst size_t servos_cnt = m_servos.size();\n\nconstexpr uint32_t msPerServo = 30;\nconstexpr auto ticksPerServo = MS_TO_TICKS(msPerServo);\nconst uint32_t msPerIter = servos_cnt * msPerServo;\nconst auto ticksPerIter = MS_TO_TICKS(msPerIter);\n\n// TODO\nauto queue = xQueueCreate(1, 4 /*sizeof(struct rx_response)*/);\nwhile (true) {\nconst auto tm_iter_start = xTaskGetTickCount();\nfor (size_t i = 0; i &lt; servos_cnt; ++i) {\nconst auto tm_servo_start = xTaskGetTickCount();\nregulateServo(queue, i, msPerIter);\nconst auto diff = xTaskGetTickCount() - tm_servo_start;\nif (diff &lt; ticksPerServo) {\nvTaskDelay(ticksPerServo - diff);\n}\n}\n\nconst auto diff = xTaskGetTickCount() - tm_iter_start;\nif (diff &lt; ticksPerIter) {\nvTaskDelay(ticksPerIter - diff);\n}\n}\n}\n\nbool SmartServoBus::regulateServo(\nQueueHandle_t responseQueue, size_t id, uint32_t timeSliceMs) {\nfloat move_pos_deg;\nauto&amp; s = m_servos[id];\n\n{\nstd::lock_guard&lt;std::mutex&gt; lock(m_mutex);\n\nif (s.auto_stop) {\n// TODO\n/*lw::Packet pos_req(id, lw::Command::SERVO_POS_READ);\n            send(pos_req, responseQueue, true);\n            xQueueReceive(responseQueue, &amp;resp, portMAX_DELAY);\n            if (resp.size == 0x08) {\n                const float val = (float)((resp.data[6] &lt;&lt; 8) | resp.data[5]);\n                const int val_int = (val / 1000.f) * 24000.f;\n                const int diff = val_int - int(s.current);\n                if (abs(diff) &gt; 300) {\n                    if (++s.auto_stop_counter &gt; 5) {\n                        s.target = val_int + (diff &gt; 0 ? -200 : 200);\n                        s.auto_stop_counter = 0;\n                    }\n                } else if (s.auto_stop_counter != 0) {\n                    s.auto_stop_counter = 0;\n                }\n            }*/\n}\n\nif (s.current == s.target) {\nreturn false;\n}\n\nfloat speed = s.speed_target;\nif (s.speed_coef &lt; 1.f) {\ns.speed_coef\n= std::min(1.f, s.speed_coef + (s.speed_raise * timeSliceMs));\nspeed *= (s.speed_coef * s.speed_coef);\n}\n\nint32_t dist = abs(int32_t(s.target) - int32_t(s.current));\ndist = std::max(1, std::min(dist, int32_t(speed * timeSliceMs)));\nif (dist &gt; 0) {\nif (s.target &lt; s.current) {\ns.current -= dist;\n} else {\ns.current += dist;\n}\n}\n\nif (dist &lt;= 0 || s.current == s.target) {\ns.current = s.target;\ns.speed_coef = 0.f;\n}\nmove_pos_deg = float(s.current) / 100.f;\n}\n\n// TODO\n/*const auto pkt = lw::Servo::move(id, Angle::deg(move_pos_deg),\n        std::chrono::milliseconds(timeSliceMs - 5));\n    send(pkt, responseQueue, false, true);\n\n    if (xQueueReceive(responseQueue, &amp;resp, 500 / portTICK_PERIOD_MS)\n        != pdTRUE) {\n        ESP_LOGE(TAG, \"Response to move packet not received!\");\n    }*/\nreturn true;\n}\n\n}; // namespace rb\n</code></pre>"},{"location":"esp/RBCXSmartServo_8h/","title":"File RBCXSmartServo.h","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXSmartServo.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;FreeRTOS.h&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"RBCXAngle.h\"</code></li> <li><code>#include \"RBCXUtil.h\"</code></li> </ul>"},{"location":"esp/RBCXSmartServo_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXSmartServo_8h/#classes","title":"Classes","text":"Type Name class SmartServoBus <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXSmartServo.h</code></p>"},{"location":"esp/RBCXSmartServo_8h_source/","title":"File RBCXSmartServo.h","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXSmartServo.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;FreeRTOS.h&gt;\n#include &lt;mutex&gt;\n#include &lt;vector&gt;\n\n#include \"RBCXAngle.h\"\n#include \"RBCXUtil.h\"\n\nnamespace rb {\n\nclass Manager;\nclass Encoder;\n\nclass SmartServoBus {\nfriend class Manager;\n\npublic:\nSmartServoBus();\n~SmartServoBus() {}\n\nvoid set(uint8_t id, Angle ang, float speed = 180.f,\nfloat speed_raise = 0.0015f);\nvoid limit(uint8_t id, Angle bottom, Angle top);\n\nAngle pos(uint8_t id);\nAngle posOffline(uint8_t id);\n\nvoid setAutoStop(uint8_t id, bool enable = true);\n\nvoid setId(uint8_t newId, uint8_t destId = 254);\nuint8_t getId(uint8_t destId = 254);\n\nprivate:\nSmartServoBus(const SmartServoBus&amp;) = delete;\n\nvoid install(uint8_t servo_count);\n\nstatic void regulatorRoutineTrampoline(void* cookie);\nvoid regulatorRoutine();\nbool regulateServo(\nQueueHandle_t responseQueue, size_t id, uint32_t timeSliceMs);\n\nstruct servo_info {\nservo_info() {\ncurrent = 0xFFFF;\ntarget = 0xFFFF;\nspeed_coef = 0.f;\nspeed_target = 0.f;\nspeed_raise = 0.f;\nauto_stop = false;\nauto_stop_counter = 0;\n}\n\nbool hasValidCurrent() const { return current != 0xFFFF; }\n\nfloat speed_coef;\nfloat speed_target;\nfloat speed_raise;\nuint16_t current;\nuint16_t target;\nbool auto_stop;\nuint8_t auto_stop_counter;\n};\n\nstd::vector&lt;servo_info&gt; m_servos;\nstd::mutex m_mutex;\n};\n\n};\n</code></pre>"},{"location":"esp/RBCXStupidServo_8cpp/","title":"File RBCXStupidServo.cpp","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXStupidServo.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"RBCXStupidServo.h\"</code></li> <li><code>#include \"RBCXManager.h\"</code></li> </ul>"},{"location":"esp/RBCXStupidServo_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace rb <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXStupidServo.cpp</code></p>"},{"location":"esp/RBCXStupidServo_8cpp_source/","title":"File RBCXStupidServo.cpp","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXStupidServo.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"RBCXStupidServo.h\"\n#include \"RBCXManager.h\"\n\nnamespace rb {\n\nStupidServo::StupidServo()\n: m_lastPosition(NAN) {}\n\nvoid StupidServo::setPosition(float posFraction) { sendServoMsg(posFraction); }\n\nvoid StupidServo::disable() { sendServoMsg(NAN); }\n\nvoid StupidServo::sendServoMsg(float position) {\nstd::lock_guard&lt;std::mutex&gt; l(m_mutex);\nif (m_lastPosition == position)\nreturn;\nm_lastPosition = position;\n\nconst pb_size_t tag = std::isnan(position)\n? CoprocReq_SetStupidServo_disable_tag\n: CoprocReq_SetStupidServo_setPosition_tag;\n\nManager::get().sendToCoproc(CoprocReq {\n.which_payload = CoprocReq_setStupidServo_tag,\n.payload = {\n.setStupidServo = {\n.servoIndex = m_id,\n.which_servoCmd = tag,\n.servoCmd = {\n.setPosition = position,\n},\n},\n},\n});\n}\n};\n</code></pre>"},{"location":"esp/RBCXStupidServo_8h/","title":"File RBCXStupidServo.h","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXStupidServo.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"esp/RBCXStupidServo_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXStupidServo_8h/#classes","title":"Classes","text":"Type Name class StupidServo <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXStupidServo.h</code></p>"},{"location":"esp/RBCXStupidServo_8h_source/","title":"File RBCXStupidServo.h","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXStupidServo.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;mutex&gt;\n#include &lt;stdint.h&gt;\n\n#include \"rbcx.pb.h\"\n\nnamespace rb {\n\nclass Manager;\n\nclass StupidServo {\nfriend class Manager;\n\npublic:\nuint8_t id() const { return m_id; }\n\nvoid setPosition(float positionFraction);\n\nfloat position() const { return m_lastPosition; }\n\nvoid disable();\n\nprivate:\nStupidServo();\n~StupidServo() {}\nStupidServo(const StupidServo&amp;) = delete;\n\nvoid setId(uint8_t id) { m_id = id; }\n\nvoid sendServoMsg(float position);\n\nstd::mutex m_mutex;\nfloat m_lastPosition;\nuint8_t m_id;\n};\n\n};\n</code></pre>"},{"location":"esp/RBCXTimers_8cpp/","title":"File RBCXTimers.cpp","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXTimers.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;freertos/FreeRTOS.h&gt;</code></li> <li><code>#include &lt;freertos/timers.h&gt;</code></li> <li><code>#include \"RBCXManager.h\"</code></li> <li><code>#include \"RBCXTimers.h\"</code></li> </ul>"},{"location":"esp/RBCXTimers_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace rb <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXTimers.cpp</code></p>"},{"location":"esp/RBCXTimers_8cpp_source/","title":"File RBCXTimers.cpp","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXTimers.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;freertos/FreeRTOS.h&gt;\n#include &lt;freertos/timers.h&gt;\n\n#include \"RBCXManager.h\"\n#include \"RBCXTimers.h\"\n\nnamespace rb {\n\nstatic void dieTimers(TimerHandle_t timer) {\nvPortFree(timer);\nvTaskDelete(NULL); // lol\n}\n\nvoid Timers::deleteFreeRtOsTimerTask() {\nxTimerStart(\nxTimerCreate(\"sike!\", 1, pdFALSE, NULL, dieTimers), portMAX_DELAY);\n}\n\nTimers&amp; Timers::get() {\nstatic Timers instance;\nreturn instance;\n}\n\nTimers::Timers()\n: m_id_counter(1) {}\n\nTimers::~Timers() {}\n\nvoid Timers::timerCallback(void* idVoid) {\nauto&amp; self = Timers::get();\nconst auto id = (uint16_t)(uintptr_t)idVoid;\n\nstd::lock_guard&lt;std::recursive_mutex&gt; l(self.m_mutex);\nfor (const auto&amp; tm : self.m_timers) {\nif (tm.id != id)\ncontinue;\nif (!tm.callback()) {\nself.cancel(id);\n}\nbreak;\n}\n}\n\nuint16_t Timers::schedule(uint32_t period_ms, std::function&lt;bool()&gt; callback) {\nstd::lock_guard&lt;std::recursive_mutex&gt; l(m_mutex);\n\nconst auto id = getFreeIdLocked();\n\nconst esp_timer_create_args_t timer_args = {\n.callback = timerCallback,\n.arg = (void*)(uintptr_t)id,\n.dispatch_method = ESP_TIMER_TASK,\n.name = \"rb_timer\",\n};\n\nesp_timer_handle_t timer = nullptr;\nesp_timer_create(&amp;timer_args, &amp;timer);\n\nm_timers.emplace_back(std::move(timer_t {\n.callback = callback,\n.handle = timer,\n.id = id,\n}));\n\nesp_timer_start_periodic(timer, uint64_t(period_ms) * 1000);\n\nreturn id;\n}\n\nbool Timers::reset(uint16_t id, uint32_t period_ms) {\nstd::lock_guard&lt;std::recursive_mutex&gt; l(m_mutex);\n\nfor (auto&amp; t : m_timers) {\nif (t.id != id)\ncontinue;\n\nesp_timer_stop(t.handle);\nesp_timer_start_periodic(t.handle, uint64_t(period_ms) * 1000);\nreturn true;\n}\nreturn false;\n}\n\nbool Timers::cancel(uint16_t id) {\nstd::lock_guard&lt;std::recursive_mutex&gt; l(m_mutex);\n\nconst auto size = m_timers.size();\nfor (size_t i = 0; i &lt; size; ++i) {\nif (m_timers[i].id == id) {\ncancelByIdxLocked(i);\nreturn true;\n}\n}\nreturn false;\n}\n\nbool Timers::stop(uint16_t id) {\nstd::lock_guard&lt;std::recursive_mutex&gt; l(m_mutex);\n\nfor (auto&amp; t : m_timers) {\nif (t.id != id)\ncontinue;\nesp_timer_stop(t.handle);\nreturn true;\n}\nreturn false;\n}\n\nvoid Timers::cancelByIdxLocked(size_t idx) {\nauto&amp; t = m_timers[idx];\nesp_timer_stop(t.handle);\nesp_timer_delete(t.handle);\n\nconst auto size = m_timers.size();\nif (idx + 1 &lt; size) {\nm_timers[idx].swap(m_timers[size - 1]);\n}\nm_timers.pop_back();\n}\n\nuint16_t Timers::getFreeIdLocked() {\nuint16_t id = m_id_counter;\nwhile (1) {\nif (id == INVALID_ID) {\n++id;\ncontinue;\n}\n\nbool found = false;\nfor (const auto&amp; t : m_timers) {\nif (t.id == id) {\nfound = true;\n++id;\nbreak;\n}\n}\n\nif (!found) {\nm_id_counter = id + 1;\nreturn id;\n}\n}\n}\n\nbool Timers::isOnTimerTask() const {\nreturn strcmp(pcTaskGetTaskName(NULL), \"esp_timer\") == 0;\n}\n};\n</code></pre>"},{"location":"esp/RBCXTimers_8h/","title":"File RBCXTimers.h","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXTimers.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;esp_timer.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"esp/RBCXTimers_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXTimers_8h/#classes","title":"Classes","text":"Type Name class Timers <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXTimers.h</code></p>"},{"location":"esp/RBCXTimers_8h_source/","title":"File RBCXTimers.h","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXTimers.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;esp_timer.h&gt;\n\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n#include &lt;vector&gt;\n\nnamespace rb {\n\nclass Manager;\nclass Timers;\n\nclass Timers {\npublic:\nstatic constexpr uint16_t INVALID_ID = 0;\n\nstatic void deleteFreeRtOsTimerTask();\n\nstatic Timers&amp; get();\n\nuint16_t schedule(uint32_t period_ms, std::function&lt;bool()&gt; callback);\n\nbool reset(uint16_t id, uint32_t period_ms);\nbool cancel(uint16_t id);\nbool stop(uint16_t id);\n\n// returns true if the calling code is running in the timer task.\nbool isOnTimerTask() const;\n\nprivate:\nstruct timer_t {\nstd::function&lt;bool()&gt; callback;\nesp_timer_handle_t handle;\nuint16_t id;\n\nvoid swap(timer_t&amp; o) {\ncallback.swap(o.callback);\nstd::swap(handle, o.handle);\nstd::swap(id, o.id);\n}\n};\n\nstatic void timerCallback(void* handleVoid);\n\nTimers();\n~Timers();\n\nvoid cancelByIdxLocked(size_t idx);\nuint16_t getFreeIdLocked();\n\nstd::vector&lt;timer_t&gt; m_timers;\nstd::recursive_mutex m_mutex;\nuint16_t m_id_counter;\n};\n\n};\n</code></pre>"},{"location":"esp/RBCXUltrasound_8cpp/","title":"File RBCXUltrasound.cpp","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXUltrasound.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;esp_log.h&gt;</code></li> <li><code>#include \"RBCXManager.h\"</code></li> <li><code>#include \"RBCXUltrasound.h\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"esp/RBCXUltrasound_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXUltrasound_8cpp/#macros","title":"Macros","text":"Type Name define TAG  \"RBCXUltrasound\""},{"location":"esp/RBCXUltrasound_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"esp/RBCXUltrasound_8cpp/#define-tag","title":"define TAG","text":"<pre><code>#define TAG \"RBCXUltrasound\"\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXUltrasound.cpp</code></p>"},{"location":"esp/RBCXUltrasound_8cpp_source/","title":"File RBCXUltrasound.cpp","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXUltrasound.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;esp_log.h&gt;\n\n#include \"RBCXManager.h\"\n#include \"RBCXUltrasound.h\"\n#include \"rbcx.pb.h\"\n\n#define TAG \"RBCXUltrasound\"\n\nnamespace rb {\n\nUltrasound::Ultrasound()\n: m_index(0)\n, m_lastUs(0)\n, m_lastDistanceMm(0)\n, m_speedOfSound(defaultSpeedOfSound / 100.f)\n, m_measuring(false)\n, m_timeoutTimer(0) {}\n\nUltrasound::~Ultrasound() {}\n\nvoid Ultrasound::init(uint8_t index) {\nm_index = index;\n\nm_timeoutTimer = Timers::get().schedule(0xFFFFFFFF, [this]() -&gt; bool {\nESP_LOGE(TAG, \"Ultrasound %d response timeout!\\n\", m_index);\nonMeasuringDone(CoprocStat_UltrasoundStat { 0 });\nreturn true; // return true to prevent cancel, was stopped in onMeasuringDone\n});\n\nTimers::get().stop(m_timeoutTimer);\n}\n\nvoid Ultrasound::setSpeedOfSound(float speedOfSoundInMetersPerSecond) {\nm_mutex.lock();\nm_speedOfSound = speedOfSoundInMetersPerSecond / 100.f;\nrecalculateLastDistanceLocked();\nm_mutex.unlock();\n}\n\nvoid Ultrasound::measureAsync(callback_t callback) {\nstd::lock_guard&lt;std::recursive_mutex&gt; ul(m_mutex);\n\nif (!m_measuring) {\nm_measuring = true;\nManager::get().sendToCoproc(CoprocReq {\n.which_payload = CoprocReq_ultrasoundReq_tag,\n.payload = {\n.ultrasoundReq = {\n.utsIndex = m_index,\n.which_utsCmd = CoprocReq_UltrasoundReq_singlePing_tag,\n},\n},\n});\nTimers::get().reset(m_timeoutTimer, 250);\n}\n\nif (callback)\nm_callbacks.emplace_back(std::move(callback));\n}\n\nuint32_t Ultrasound::measure() {\nif (Timers::get().isOnTimerTask()) {\nESP_LOGE(TAG,\n\"you can't call measure() from the ESP timer task, as it is a \"\n\"blocking function. Use measureAsync.\\n\");\nabort();\n}\nstd::unique_lock&lt;std::recursive_mutex&gt; ul(m_mutex);\nmeasureAsync();\nm_measuringDone.wait(ul);\nreturn m_lastDistanceMm;\n}\n\nvoid Ultrasound::onMeasuringDone(const CoprocStat_UltrasoundStat&amp; result) {\nuint32_t distance;\n\n{\nstd::lock_guard&lt;std::recursive_mutex&gt; ul(m_mutex);\n\nm_lastUs = result.roundtripMicrosecs;\nrecalculateLastDistanceLocked();\ndistance = m_lastDistanceMm;\nm_measuring = false;\nTimers::get().stop(m_timeoutTimer);\nm_measuringDone.notify_all();\n\nfor (auto itr = m_callbacks.begin(); itr != m_callbacks.end();) {\nif (!(*itr)(distance)) {\nitr = m_callbacks.erase(itr);\n} else {\n++itr;\n}\n}\n\nif (!m_callbacks.empty()) {\nmeasureAsync();\n}\n}\n}\n\nvoid Ultrasound::recalculateLastDistanceLocked() {\nif (m_lastUs == 0) {\nm_lastDistanceMm = 0;\nreturn;\n}\n\nm_lastDistanceMm = uint32_t(m_speedOfSound * (float(m_lastUs) / 10.f)) / 2;\n}\n\n};\n</code></pre>"},{"location":"esp/RBCXUltrasound_8h/","title":"File RBCXUltrasound.h","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXUltrasound.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;condition_variable&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"RBCXTimers.h\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"esp/RBCXUltrasound_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXUltrasound_8h/#classes","title":"Classes","text":"Type Name class Ultrasound <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXUltrasound.h</code></p>"},{"location":"esp/RBCXUltrasound_8h_source/","title":"File RBCXUltrasound.h","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXUltrasound.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;condition_variable&gt;\n#include &lt;functional&gt;\n#include &lt;mutex&gt;\n#include &lt;stdint.h&gt;\n#include &lt;vector&gt;\n\n#include \"RBCXTimers.h\"\n\n#include \"rbcx.pb.h\"\n\nnamespace rb {\n\nclass Manager;\n\nclass Ultrasound {\nfriend class Manager;\n\npublic:\nstatic constexpr float defaultSpeedOfSound = 347.13f;\n\ntypedef std::function&lt;bool(uint32_t)&gt; callback_t;\n\nuint32_t lastDistanceMm() const { return m_lastDistanceMm; }\nuint32_t lastDurationUs() const { return m_lastUs; }\nbool isLastMeasurementValid() const { return m_lastUs != 0; }\n\nvoid setSpeedOfSound(\nfloat speedOfSoundInMetersPerSecond = defaultSpeedOfSound);\nfloat getSpeedOfSound() const { return m_speedOfSound; }\n\nvoid measureAsync(callback_t callback = nullptr);\nuint32_t measure();\n\nprivate:\nUltrasound();\nUltrasound(const Ultrasound&amp;) = delete;\n~Ultrasound();\n\nvoid init(uint8_t index);\n\nvoid recalculateLastDistanceLocked();\nvoid onMeasuringDone(const CoprocStat_UltrasoundStat&amp; result);\n\nuint8_t m_index;\n\nuint32_t m_lastUs;\nuint32_t m_lastDistanceMm;\nfloat m_speedOfSound;\nbool m_measuring;\nstd::vector&lt;callback_t&gt; m_callbacks;\nstd::recursive_mutex m_mutex;\nstd::condition_variable_any m_measuringDone;\nuint16_t m_timeoutTimer;\n};\n\n};\n</code></pre>"},{"location":"esp/RBCXUtil_8h/","title":"File RBCXUtil.h","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXUtil.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;freertos/FreeRTOS.h&gt;</code></li> <li><code>#include &lt;freertos/task.h&gt;</code></li> <li><code>#include &lt;ratio&gt;</code></li> </ul>"},{"location":"esp/RBCXUtil_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rb"},{"location":"esp/RBCXUtil_8h/#macros","title":"Macros","text":"Type Name define RBCX_ENUM_IMPL_MASK_OPERATORS (T)"},{"location":"esp/RBCXUtil_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"esp/RBCXUtil_8h/#define-rbcx_enum_impl_mask_operators","title":"define RBCX_ENUM_IMPL_MASK_OPERATORS","text":"<pre><code>#define RBCX_ENUM_IMPL_MASK_OPERATORS (\nT\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXUtil.h</code></p>"},{"location":"esp/RBCXUtil_8h_source/","title":"File RBCXUtil.h","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXUtil.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;freertos/FreeRTOS.h&gt;\n#include &lt;freertos/task.h&gt;\n#include &lt;ratio&gt;\n\nnamespace rb {\n\ntemplate &lt;typename T&gt; T clamp(T value, T min, T max) {\nif (value &lt; min) {\nreturn min;\n} else if (value &gt; max) {\nreturn max;\n}\nreturn value;\n}\n\ninline void delayMs(int ms) { vTaskDelay(ms / portTICK_PERIOD_MS); }\n\ninline void delay(std::chrono::duration&lt;uint32_t, std::milli&gt; delay) {\nvTaskDelay(delay.count() / portTICK_PERIOD_MS);\n}\n\n#define RBCX_ENUM_IMPL_MASK_OPERATORS(T)                                       \\\n    inline T operator|(T a, T b) {                                             \\\n        return static_cast&lt;T&gt;(static_cast&lt;int&gt;(a) | static_cast&lt;int&gt;(b));      \\\n    }                                                                          \\\n                                                                               \\\n    inline T operator&amp;(T a, T b) {                                             \\\n        return static_cast&lt;T&gt;(static_cast&lt;int&gt;(a) &amp; static_cast&lt;int&gt;(b));      \\\n    }                                                                          \\\n                                                                               \\\n    inline T operator^(T a, T b) {                                             \\\n        return static_cast&lt;T&gt;(static_cast&lt;int&gt;(a) ^ static_cast&lt;int&gt;(b));      \\\n    }                                                                          \\\n                                                                               \\\n    inline T operator|=(T&amp; a, T b) {                                           \\\n        return static_cast&lt;T&gt;(                                                 \\\n            reinterpret_cast&lt;int&amp;&gt;(a) |= static_cast&lt;int&gt;(b));                 \\\n    }                                                                          \\\n                                                                               \\\n    inline T operator&amp;=(T&amp; a, T b) {                                           \\\n        return static_cast&lt;T&gt;(                                                 \\\n            reinterpret_cast&lt;int&amp;&gt;(a) &amp;= static_cast&lt;int&gt;(b));                 \\\n    }                                                                          \\\n                                                                               \\\n    inline T operator^=(T&amp; a, T b) {                                           \\\n        return static_cast&lt;T&gt;(                                                 \\\n            reinterpret_cast&lt;int&amp;&gt;(a) ^= static_cast&lt;int&gt;(b));                 \\\n    }                                                                          \\\n                                                                               \\\n    inline T operator~(T a) { return static_cast&lt;T&gt;(~static_cast&lt;int&gt;(a)); }   \\\n                                                                               \\\n    inline T operator&lt;&lt;=(T&amp; a, int b) {                                        \\\n        return static_cast&lt;T&gt;(                                                 \\\n            reinterpret_cast&lt;int&amp;&gt;(a) &lt;&lt;= static_cast&lt;int&gt;(b));                \\\n    }                                                                          \\\n                                                                               \\\n    inline T operator&gt;&gt;=(T&amp; a, int b) {                                        \\\n        return static_cast&lt;T&gt;(                                                 \\\n            reinterpret_cast&lt;int&amp;&gt;(a) &gt;&gt;= static_cast&lt;int&gt;(b));                \\\n    }                                                                          \\\n                                                                               \\\n    inline T operator&lt;&lt;(T a, int b) {                                          \\\n        return static_cast&lt;T&gt;(static_cast&lt;int&gt;(a) &lt;&lt; static_cast&lt;int&gt;(b));     \\\n    }                                                                          \\\n                                                                               \\\n    inline T operator&gt;&gt;(T a, int b) {                                          \\\n        return static_cast&lt;T&gt;(static_cast&lt;int&gt;(a) &gt;&gt; static_cast&lt;int&gt;(b));     \\\n    }                                                                          \\\n                                                                               \\\n    T operator+=(T&amp; a, T b) = delete;                                          \\\n    T operator-=(T&amp; a, T b) = delete;                                          \\\n    T operator++(T a) = delete;                                                \\\n    T operator--(T a) = delete;\n\n} // namespace rb\n</code></pre>"},{"location":"esp/RBCXVersion_8h/","title":"File RBCXVersion.h","text":"<p>FileList &gt; demo-projets &gt; esp &gt; RBCXVersion.h</p> <p>Go to the source code of this file.</p>"},{"location":"esp/RBCXVersion_8h/#macros","title":"Macros","text":"Type Name define RB3204 define RB3204_MAJOR  0 define RB3204_MINOR  0 define RB3204_PATCH  2 define RB3204_RBCX define RBCX"},{"location":"esp/RBCXVersion_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"esp/RBCXVersion_8h/#define-rb3204","title":"define RB3204","text":"<pre><code>#define RB3204 \n</code></pre>"},{"location":"esp/RBCXVersion_8h/#define-rb3204_major","title":"define RB3204_MAJOR","text":"<pre><code>#define RB3204_MAJOR 0\n</code></pre>"},{"location":"esp/RBCXVersion_8h/#define-rb3204_minor","title":"define RB3204_MINOR","text":"<pre><code>#define RB3204_MINOR 0\n</code></pre>"},{"location":"esp/RBCXVersion_8h/#define-rb3204_patch","title":"define RB3204_PATCH","text":"<pre><code>#define RB3204_PATCH 2\n</code></pre>"},{"location":"esp/RBCXVersion_8h/#define-rb3204_rbcx","title":"define RB3204_RBCX","text":"<pre><code>#define RB3204_RBCX \n</code></pre>"},{"location":"esp/RBCXVersion_8h/#define-rbcx","title":"define RBCX","text":"<pre><code>#define RBCX \n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/RBCXVersion.h</code></p>"},{"location":"esp/RBCXVersion_8h_source/","title":"File RBCXVersion.h","text":"<p>File List &gt; demo-projets &gt; esp &gt; RBCXVersion.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#define RB3204\n#define RB3204_RBCX\n#define RBCX\n\n#define RB3204_MAJOR 0\n#define RB3204_MINOR 0\n#define RB3204_PATCH 2\n</code></pre>"},{"location":"esp/main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; demo-projets &gt; esp &gt; main.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include \"RBCX.h\"</code></li> </ul>"},{"location":"esp/main_8cpp/#public-functions","title":"Public Functions","text":"Type Name void loop ()  void setup ()  int testFnc (float a, char b) My test function Some description. Next line."},{"location":"esp/main_8cpp/#macros","title":"Macros","text":"Type Name define MY_MACRO  (A | B)"},{"location":"esp/main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/main_8cpp/#function-loop","title":"function loop","text":"<pre><code>void loop () </code></pre>"},{"location":"esp/main_8cpp/#function-setup","title":"function setup","text":"<pre><code>void setup () </code></pre>"},{"location":"esp/main_8cpp/#function-testfnc","title":"function testFnc","text":"<p>My test function Some description. Next line. <pre><code>int testFnc (\nfloat a,\nchar b\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>a</code> float number </li> <li><code>b</code> character [0-255] </li> </ul>"},{"location":"esp/main_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"esp/main_8cpp/#define-my_macro","title":"define MY_MACRO","text":"<pre><code>#define MY_MACRO (A | B)\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/main.cpp</code></p>"},{"location":"esp/main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; demo-projets &gt; esp &gt; main.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;iostream&gt;\n\n#include &lt;Arduino.h&gt;\n\n#include \"RBCX.h\"\n\n#define MY_MACRO (A | B)\n\nint testFnc(float a, char b) {\nreturn a;\n}\n\nvoid setup() {\nprintf(\"RB3204-RBCX\\n\");\ndelay(500);\n\nprintf(\"Init manager\\n\");\nauto&amp; man = rb::Manager::get();\nman.install();\n\nwhile (true) {\nmicros(); // update overflow\nman.setMotors()\n.power(rb::MotorId::M1, 20)\n.power(rb::MotorId::M2, 20)\n.set();\nprintf(\"lmotor power: %d rmotor power: %d\\n\", 20, 20);\ndelay(1000);\n\nrb::Manager::get()\n.setMotors()\n.power(rb::MotorId::M1, 0)\n.power(rb::MotorId::M2, 0)\n.set();\nprintf(\"lmotor power: %d rmotor power: %d\\n\", 0, 0);\ndelay(5000);\n}\n}\n\nvoid loop() {}\n</code></pre>"},{"location":"esp/test_8cpp/","title":"File test.cpp","text":"<p>FileList &gt; demo-projets &gt; esp &gt; test.cpp</p> <p>Go to the source code of this file.</p>"},{"location":"esp/test_8cpp/#classes","title":"Classes","text":"Type Name class MyStack &lt;class T, i&gt;"},{"location":"esp/test_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main ()"},{"location":"esp/test_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"esp/test_8cpp/#function-main","title":"function main","text":"<pre><code>int main () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/esp/test.cpp</code></p>"},{"location":"esp/test_8cpp_source/","title":"File test.cpp","text":"<p>File List &gt; demo-projets &gt; esp &gt; test.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>template&lt;class T, int i&gt; class MyStack\n{\nT*  pStack;\nT StackBuffer[i];\nstatic const int cItems = i * sizeof(T);\npublic:\nMyStack( void );\nvoid push( const T item );\nT&amp; pop( void );\n};\n\n\ntemplate&lt; class T, int i &gt; MyStack&lt; T, i &gt;::MyStack( void )\n{\n};\n\ntemplate&lt; class T, int i &gt; void MyStack&lt; T, i &gt;::push( const T item )\n{\n};\n\ntemplate&lt; class T, int i &gt; T&amp; MyStack&lt; T, i &gt;::pop( void )\n{\n};\n\nint main()\n{\n}\n</code></pre>"},{"location":"esp/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace rb </li> </ul>"},{"location":"esp/classes/","title":"Class Index","text":""},{"location":"esp/classes/#a","title":"a","text":"<ul> <li>Angle (rb)</li> </ul>"},{"location":"esp/classes/#b","title":"b","text":"<ul> <li>Battery (rb)</li> <li>Buttons (rb)</li> </ul>"},{"location":"esp/classes/#l","title":"l","text":"<ul> <li>Leds (rb)</li> </ul>"},{"location":"esp/classes/#m","title":"m","text":"<ul> <li>MyStack</li> <li>Manager (rb)</li> <li>Motor (rb)</li> <li>MotorChangeBuilder (rb)</li> </ul>"},{"location":"esp/classes/#n","title":"n","text":"<ul> <li>Nvs (rb)</li> </ul>"},{"location":"esp/classes/#p","title":"p","text":"<ul> <li>Piezo (rb)</li> </ul>"},{"location":"esp/classes/#s","title":"s","text":"<ul> <li>SmartServoBus (rb)</li> <li>StupidServo (rb)</li> <li>servo_info</li> </ul>"},{"location":"esp/classes/#t","title":"t","text":"<ul> <li>Timers (rb)</li> <li>timer_t</li> </ul>"},{"location":"esp/classes/#u","title":"u","text":"<ul> <li>Ultrasound (rb)</li> </ul>"},{"location":"esp/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class MyStack </li> <li>class rb::Angle </li> <li>class rb::Battery Contains the battery state and can control the robot's power. </li> <li>class rb::Buttons </li> <li>class rb::Leds </li> <li>class rb::Manager The main library class for working with the RBCX board. Call the install() method at the start of your program.</li> <li>class rb::Motor </li> <li>class rb::MotorChangeBuilder Helper class for building the motor change event. </li> <li>class rb::Nvs </li> <li>class rb::Piezo Helper class for controlling the piezo. </li> <li>class rb::SmartServoBus </li> <li>class rb::StupidServo </li> <li>class rb::Timers </li> <li>class rb::Ultrasound </li> <li>struct rb::SmartServoBus::servo_info </li> <li>struct rb::Timers::timer_t </li> </ul>"},{"location":"esp/modules/","title":"Modules","text":"<p>Here is a list of all modules:</p>"},{"location":"esp/pages/","title":"Class List","text":"<p>Warning This is custom template. Look at documentation for more information.</p> <p>Template source: templates-custom/annotated.jinja2</p> <p>Add <code>template-dir: path/to/userDefined/templates</code> to your project configuration like in this example:</p> <pre><code>  - mkdoxy:\nprojects:\nesp:\nsrc-dirs: demo-projets/esp\nfull-doc: True\ntemplate-dir: path/to/userDefined/templates\ndoxy-cfg:\nFILE_PATTERNS: \"*.cpp *.h*\"\nEXAMPLE_PATH: examples\nRECURSIVE: True\n</code></pre> <p>Here are the classes, structs, unions and interfaces with brief descriptions:</p>"},{"location":"esp/class_members/","title":"Class Members","text":""},{"location":"esp/class_members/#a","title":"a","text":"<ul> <li>Angle (rb::Angle)</li> <li>auto_stop (rb::SmartServoBus::servo_info)</li> <li>auto_stop_counter (rb::SmartServoBus::servo_info)</li> </ul>"},{"location":"esp/class_members/#b","title":"b","text":"<ul> <li>BATTERY_IN_THRESHOLD (rb::Battery)</li> <li>Battery (rb::Battery)</li> <li>bMidVoltageMv (rb::Battery)</li> <li>Buttons (rb::Buttons)</li> <li>byId (rb::Buttons, rb::Leds)</li> <li>blue (rb::Leds)</li> <li>battery (rb::Manager)</li> <li>buttons (rb::Manager)</li> <li>brake (rb::Motor, rb::MotorChangeBuilder)</li> </ul>"},{"location":"esp/class_members/#c","title":"c","text":"<ul> <li>cItems (MyStack)</li> <li>Count (rb::Buttons)</li> <li>callback_t (rb::Buttons, rb::Motor, rb::Ultrasound)</li> <li>consumerRoutine (rb::Manager)</li> <li>consumerRoutineTrampoline (rb::Manager)</li> <li>coprocFwVersion (rb::Manager)</li> <li>coprocFwVersionAssert (rb::Manager)</li> <li>commit (rb::Nvs)</li> <li>cancel (rb::Timers)</li> <li>cancelByIdxLocked (rb::Timers)</li> <li>current (rb::SmartServoBus::servo_info)</li> <li>callback (rb::Timers::timer_t)</li> </ul>"},{"location":"esp/class_members/#d","title":"d","text":"<ul> <li>deg (rb::Angle)</li> <li>down (rb::Buttons)</li> <li>drive (rb::Motor, rb::MotorChangeBuilder)</li> <li>driveToValue (rb::Motor, rb::MotorChangeBuilder)</li> <li>disable (rb::StupidServo)</li> <li>deleteFreeRtOsTimerTask (rb::Timers)</li> <li>defaultSpeedOfSound (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_members/#e","title":"e","text":"<ul> <li>existsInt (rb::Nvs)</li> <li>existsString (rb::Nvs)</li> </ul>"},{"location":"esp/class_members/#g","title":"g","text":"<ul> <li>green (rb::Leds)</li> <li>get (rb::Manager, rb::Timers)</li> <li>getInt (rb::Nvs)</li> <li>getString (rb::Nvs)</li> <li>getId (rb::SmartServoBus)</li> <li>getFreeIdLocked (rb::Timers)</li> <li>getSpeedOfSound (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_members/#h","title":"h","text":"<ul> <li>hasValidCurrent (rb::SmartServoBus::servo_info)</li> <li>handle (rb::Timers::timer_t)</li> </ul>"},{"location":"esp/class_members/#i","title":"i","text":"<ul> <li>isNaN (rb::Angle)</li> <li>isPoweredByBattery (rb::Battery)</li> <li>install (rb::Manager, rb::SmartServoBus)</li> <li>id (rb::Motor, rb::StupidServo, rb::Timers::timer_t)</li> <li>initFlash (rb::Nvs)</li> <li>INVALID_ID (rb::Timers)</li> <li>isOnTimerTask (rb::Timers)</li> <li>init (rb::Ultrasound)</li> <li>isLastMeasurementValid (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_members/#k","title":"k","text":"<ul> <li>keepaliveRoutine (rb::Manager)</li> </ul>"},{"location":"esp/class_members/#l","title":"l","text":"<ul> <li>left (rb::Buttons)</li> <li>Leds (rb::Leds)</li> <li>leds (rb::Manager)</li> <li>limit (rb::SmartServoBus)</li> <li>lastDistanceMm (rb::Ultrasound)</li> <li>lastDurationUs (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_members/#m","title":"m","text":"<ul> <li>MyStack (MyStack)</li> <li>m_state (rb::Battery)</li> <li>m_buttonsSet (rb::Buttons)</li> <li>m_callbacks (rb::Buttons, rb::Ultrasound)</li> <li>m_mutex (rb::Buttons, rb::Leds, rb::Motor, rb::SmartServoBus, rb::StupidServo, rb::Timers, rb::Ultrasound)</li> <li>m_ledsOn (rb::Leds)</li> <li>Manager (rb::Manager)</li> <li>m_battery (rb::Manager)</li> <li>m_buttons (rb::Manager)</li> <li>m_codec (rb::Manager)</li> <li>m_codecTxMutex (rb::Manager)</li> <li>m_coprocFwVersion (rb::Manager)</li> <li>m_coprocSemaphore (rb::Manager)</li> <li>m_coprocWatchdogTimer (rb::Manager)</li> <li>m_keepaliveTask (rb::Manager)</li> <li>m_leds (rb::Manager)</li> <li>m_motors (rb::Manager)</li> <li>m_motors_last_set (rb::Manager)</li> <li>m_piezo (rb::Manager)</li> <li>m_stupidServos (rb::Manager)</li> <li>m_txBuf (rb::Manager)</li> <li>m_ultrasounds (rb::Manager)</li> <li>monitorTask (rb::Manager)</li> <li>motor (rb::Manager)</li> <li>motorsFailSafe (rb::Manager)</li> <li>Motor (rb::Motor)</li> <li>m_id (rb::Motor, rb::StupidServo)</li> <li>m_infoCbs (rb::Motor)</li> <li>m_lastReq (rb::Motor)</li> <li>m_mode (rb::Motor)</li> <li>m_position (rb::Motor)</li> <li>m_positionCb (rb::Motor)</li> <li>m_power (rb::Motor)</li> <li>m_pwm_max_percent (rb::Motor)</li> <li>m_speed (rb::Motor)</li> <li>MotorChangeBuilder (rb::MotorChangeBuilder)</li> <li>m_calls (rb::MotorChangeBuilder)</li> <li>m_dirty (rb::Nvs)</li> <li>m_handle (rb::Nvs)</li> <li>m_on (rb::Piezo)</li> <li>m_servos (rb::SmartServoBus)</li> <li>m_lastPosition (rb::StupidServo)</li> <li>m_id_counter (rb::Timers)</li> <li>m_timers (rb::Timers)</li> <li>m_index (rb::Ultrasound)</li> <li>m_lastDistanceMm (rb::Ultrasound)</li> <li>m_lastUs (rb::Ultrasound)</li> <li>m_measuring (rb::Ultrasound)</li> <li>m_measuringDone (rb::Ultrasound)</li> <li>m_speedOfSound (rb::Ultrasound)</li> <li>m_timeoutTimer (rb::Ultrasound)</li> <li>measure (rb::Ultrasound)</li> <li>measureAsync (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_members/#n","title":"n","text":"<ul> <li>nan (rb::Angle)</li> <li>Nvs (rb::Nvs)</li> </ul>"},{"location":"esp/class_members/#o","title":"o","text":"<ul> <li>operator*= (rb::Angle)</li> <li>operator+= (rb::Angle)</li> <li>operator- (rb::Angle)</li> <li>operator-= (rb::Angle)</li> <li>operator/= (rb::Angle)</li> <li>off (rb::Buttons)</li> <li>on (rb::Buttons)</li> <li>onChange (rb::Buttons)</li> <li>operator= (rb::Manager)</li> <li>onMotorStat (rb::Motor)</li> <li>onMeasuringDone (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_members/#p","title":"p","text":"<ul> <li>pStack (MyStack)</li> <li>pop (MyStack)</li> <li>push (MyStack)</li> <li>Pi (rb::Angle)</li> <li>pct (rb::Battery)</li> <li>piezo (rb::Manager)</li> <li>position (rb::Motor, rb::StupidServo)</li> <li>power (rb::Motor, rb::MotorChangeBuilder)</li> <li>pwmMaxPercent (rb::Motor, rb::MotorChangeBuilder)</li> <li>Piezo (rb::Piezo)</li> <li>pos (rb::SmartServoBus)</li> <li>posOffline (rb::SmartServoBus)</li> </ul>"},{"location":"esp/class_members/#r","title":"r","text":"<ul> <li>rad (rb::Angle)</li> <li>right (rb::Buttons)</li> <li>red (rb::Leds)</li> <li>resetMotorsFailSafe (rb::Manager)</li> <li>requestInfo (rb::Motor)</li> <li>regulateServo (rb::SmartServoBus)</li> <li>regulatorRoutine (rb::SmartServoBus)</li> <li>regulatorRoutineTrampoline (rb::SmartServoBus)</li> <li>reset (rb::Timers)</li> <li>recalculateLastDistanceLocked (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_members/#s","title":"s","text":"<ul> <li>StackBuffer (MyStack)</li> <li>setState (rb::Battery, rb::Buttons, rb::Piezo)</li> <li>shutdown (rb::Battery)</li> <li>schedule (rb::Manager, rb::Timers)</li> <li>sendToCoproc (rb::Manager)</li> <li>setMotors (rb::Manager)</li> <li>stupidServo (rb::Manager)</li> <li>scale (rb::Motor)</li> <li>sendMotorReq (rb::Motor)</li> <li>sendPositionReq (rb::Motor)</li> <li>setConfig (rb::Motor)</li> <li>setCurrentPosition (rb::Motor)</li> <li>setId (rb::Motor, rb::SmartServoBus, rb::StupidServo)</li> <li>speed (rb::Motor, rb::MotorChangeBuilder)</li> <li>set (rb::MotorChangeBuilder, rb::SmartServoBus)</li> <li>start (rb::Piezo)</li> <li>stop (rb::Piezo, rb::Timers)</li> <li>SmartServoBus (rb::SmartServoBus)</li> <li>setAutoStop (rb::SmartServoBus)</li> <li>StupidServo (rb::StupidServo)</li> <li>sendServoMsg (rb::StupidServo)</li> <li>setPosition (rb::StupidServo)</li> <li>setSpeedOfSound (rb::Ultrasound)</li> <li>servo_info (rb::SmartServoBus::servo_info)</li> <li>speed_coef (rb::SmartServoBus::servo_info)</li> <li>speed_raise (rb::SmartServoBus::servo_info)</li> <li>speed_target (rb::SmartServoBus::servo_info)</li> <li>swap (rb::Timers::timer_t)</li> </ul>"},{"location":"esp/class_members/#t","title":"t","text":"<ul> <li>temperatureC (rb::Battery)</li> <li>timers (rb::Manager)</li> <li>Timers (rb::Timers)</li> <li>timerCallback (rb::Timers)</li> <li>target (rb::SmartServoBus::servo_info)</li> </ul>"},{"location":"esp/class_members/#u","title":"u","text":"<ul> <li>up (rb::Buttons)</li> <li>ultrasound (rb::Manager)</li> <li>Ultrasound (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_members/#v","title":"v","text":"<ul> <li>VOLTAGE_MAX (rb::Battery)</li> <li>VOLTAGE_MIN (rb::Battery)</li> <li>voltageMv (rb::Battery)</li> </ul>"},{"location":"esp/class_members/#w","title":"w","text":"<ul> <li>writeInt (rb::Nvs)</li> <li>writeString (rb::Nvs)</li> </ul>"},{"location":"esp/class_members/#y","title":"y","text":"<ul> <li>yellow (rb::Leds)</li> </ul>"},{"location":"esp/class_members/#_1","title":"~","text":"<ul> <li>~Battery (rb::Battery)</li> <li>~Buttons (rb::Buttons)</li> <li>~Leds (rb::Leds)</li> <li>~Manager (rb::Manager)</li> <li>~MotorChangeBuilder (rb::MotorChangeBuilder)</li> <li>~Nvs (rb::Nvs)</li> <li>~Piezo (rb::Piezo)</li> <li>~SmartServoBus (rb::SmartServoBus)</li> <li>~StupidServo (rb::StupidServo)</li> <li>~Timers (rb::Timers)</li> <li>~Ultrasound (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_members/#_","title":"_","text":"<ul> <li>_T (rb::Angle)</li> <li>_rads (rb::Angle)</li> </ul>"},{"location":"esp/class_member_functions/","title":"Class Member Functions","text":""},{"location":"esp/class_member_functions/#a","title":"a","text":"<ul> <li>Angle (rb::Angle)</li> </ul>"},{"location":"esp/class_member_functions/#b","title":"b","text":"<ul> <li>Battery (rb::Battery)</li> <li>bMidVoltageMv (rb::Battery)</li> <li>Buttons (rb::Buttons)</li> <li>byId (rb::Buttons, rb::Leds)</li> <li>blue (rb::Leds)</li> <li>battery (rb::Manager)</li> <li>buttons (rb::Manager)</li> <li>brake (rb::Motor, rb::MotorChangeBuilder)</li> </ul>"},{"location":"esp/class_member_functions/#c","title":"c","text":"<ul> <li>consumerRoutine (rb::Manager)</li> <li>consumerRoutineTrampoline (rb::Manager)</li> <li>coprocFwVersion (rb::Manager)</li> <li>coprocFwVersionAssert (rb::Manager)</li> <li>commit (rb::Nvs)</li> <li>cancel (rb::Timers)</li> <li>cancelByIdxLocked (rb::Timers)</li> </ul>"},{"location":"esp/class_member_functions/#d","title":"d","text":"<ul> <li>deg (rb::Angle)</li> <li>down (rb::Buttons)</li> <li>drive (rb::Motor, rb::MotorChangeBuilder)</li> <li>driveToValue (rb::Motor, rb::MotorChangeBuilder)</li> <li>disable (rb::StupidServo)</li> <li>deleteFreeRtOsTimerTask (rb::Timers)</li> </ul>"},{"location":"esp/class_member_functions/#e","title":"e","text":"<ul> <li>existsInt (rb::Nvs)</li> <li>existsString (rb::Nvs)</li> </ul>"},{"location":"esp/class_member_functions/#g","title":"g","text":"<ul> <li>green (rb::Leds)</li> <li>get (rb::Manager, rb::Timers)</li> <li>getInt (rb::Nvs)</li> <li>getString (rb::Nvs)</li> <li>getId (rb::SmartServoBus)</li> <li>getFreeIdLocked (rb::Timers)</li> <li>getSpeedOfSound (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_member_functions/#h","title":"h","text":"<ul> <li>hasValidCurrent (rb::SmartServoBus::servo_info)</li> </ul>"},{"location":"esp/class_member_functions/#i","title":"i","text":"<ul> <li>isNaN (rb::Angle)</li> <li>isPoweredByBattery (rb::Battery)</li> <li>install (rb::Manager, rb::SmartServoBus)</li> <li>id (rb::Motor, rb::StupidServo)</li> <li>initFlash (rb::Nvs)</li> <li>isOnTimerTask (rb::Timers)</li> <li>init (rb::Ultrasound)</li> <li>isLastMeasurementValid (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_member_functions/#k","title":"k","text":"<ul> <li>keepaliveRoutine (rb::Manager)</li> </ul>"},{"location":"esp/class_member_functions/#l","title":"l","text":"<ul> <li>left (rb::Buttons)</li> <li>Leds (rb::Leds)</li> <li>leds (rb::Manager)</li> <li>limit (rb::SmartServoBus)</li> <li>lastDistanceMm (rb::Ultrasound)</li> <li>lastDurationUs (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_member_functions/#m","title":"m","text":"<ul> <li>MyStack (MyStack)</li> <li>Manager (rb::Manager)</li> <li>monitorTask (rb::Manager)</li> <li>motor (rb::Manager)</li> <li>motorsFailSafe (rb::Manager)</li> <li>Motor (rb::Motor)</li> <li>MotorChangeBuilder (rb::MotorChangeBuilder)</li> <li>measure (rb::Ultrasound)</li> <li>measureAsync (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_member_functions/#n","title":"n","text":"<ul> <li>nan (rb::Angle)</li> <li>Nvs (rb::Nvs)</li> </ul>"},{"location":"esp/class_member_functions/#o","title":"o","text":"<ul> <li>operator*= (rb::Angle)</li> <li>operator+= (rb::Angle)</li> <li>operator- (rb::Angle)</li> <li>operator-= (rb::Angle)</li> <li>operator/= (rb::Angle)</li> <li>off (rb::Buttons)</li> <li>on (rb::Buttons)</li> <li>onChange (rb::Buttons)</li> <li>operator= (rb::Manager)</li> <li>onMotorStat (rb::Motor)</li> <li>onMeasuringDone (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_member_functions/#p","title":"p","text":"<ul> <li>pop (MyStack)</li> <li>push (MyStack)</li> <li>pct (rb::Battery)</li> <li>piezo (rb::Manager)</li> <li>position (rb::Motor, rb::StupidServo)</li> <li>power (rb::Motor, rb::MotorChangeBuilder)</li> <li>pwmMaxPercent (rb::Motor, rb::MotorChangeBuilder)</li> <li>Piezo (rb::Piezo)</li> <li>pos (rb::SmartServoBus)</li> <li>posOffline (rb::SmartServoBus)</li> </ul>"},{"location":"esp/class_member_functions/#r","title":"r","text":"<ul> <li>rad (rb::Angle)</li> <li>right (rb::Buttons)</li> <li>red (rb::Leds)</li> <li>resetMotorsFailSafe (rb::Manager)</li> <li>requestInfo (rb::Motor)</li> <li>regulateServo (rb::SmartServoBus)</li> <li>regulatorRoutine (rb::SmartServoBus)</li> <li>regulatorRoutineTrampoline (rb::SmartServoBus)</li> <li>reset (rb::Timers)</li> <li>recalculateLastDistanceLocked (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_member_functions/#s","title":"s","text":"<ul> <li>setState (rb::Battery, rb::Buttons, rb::Piezo)</li> <li>shutdown (rb::Battery)</li> <li>schedule (rb::Manager, rb::Timers)</li> <li>sendToCoproc (rb::Manager)</li> <li>setMotors (rb::Manager)</li> <li>stupidServo (rb::Manager)</li> <li>scale (rb::Motor)</li> <li>sendMotorReq (rb::Motor)</li> <li>sendPositionReq (rb::Motor)</li> <li>setConfig (rb::Motor)</li> <li>setCurrentPosition (rb::Motor)</li> <li>setId (rb::Motor, rb::SmartServoBus, rb::StupidServo)</li> <li>speed (rb::Motor, rb::MotorChangeBuilder)</li> <li>set (rb::MotorChangeBuilder, rb::SmartServoBus)</li> <li>start (rb::Piezo)</li> <li>stop (rb::Piezo, rb::Timers)</li> <li>SmartServoBus (rb::SmartServoBus)</li> <li>setAutoStop (rb::SmartServoBus)</li> <li>StupidServo (rb::StupidServo)</li> <li>sendServoMsg (rb::StupidServo)</li> <li>setPosition (rb::StupidServo)</li> <li>setSpeedOfSound (rb::Ultrasound)</li> <li>servo_info (rb::SmartServoBus::servo_info)</li> <li>swap (rb::Timers::timer_t)</li> </ul>"},{"location":"esp/class_member_functions/#t","title":"t","text":"<ul> <li>temperatureC (rb::Battery)</li> <li>timers (rb::Manager)</li> <li>Timers (rb::Timers)</li> <li>timerCallback (rb::Timers)</li> </ul>"},{"location":"esp/class_member_functions/#u","title":"u","text":"<ul> <li>up (rb::Buttons)</li> <li>ultrasound (rb::Manager)</li> <li>Ultrasound (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_member_functions/#v","title":"v","text":"<ul> <li>voltageMv (rb::Battery)</li> </ul>"},{"location":"esp/class_member_functions/#w","title":"w","text":"<ul> <li>writeInt (rb::Nvs)</li> <li>writeString (rb::Nvs)</li> </ul>"},{"location":"esp/class_member_functions/#y","title":"y","text":"<ul> <li>yellow (rb::Leds)</li> </ul>"},{"location":"esp/class_member_functions/#_1","title":"~","text":"<ul> <li>~Battery (rb::Battery)</li> <li>~Buttons (rb::Buttons)</li> <li>~Leds (rb::Leds)</li> <li>~Manager (rb::Manager)</li> <li>~MotorChangeBuilder (rb::MotorChangeBuilder)</li> <li>~Nvs (rb::Nvs)</li> <li>~Piezo (rb::Piezo)</li> <li>~SmartServoBus (rb::SmartServoBus)</li> <li>~StupidServo (rb::StupidServo)</li> <li>~Timers (rb::Timers)</li> <li>~Ultrasound (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_member_variables/","title":"Class Member Variables","text":""},{"location":"esp/class_member_variables/#a","title":"a","text":"<ul> <li>auto_stop (rb::SmartServoBus::servo_info)</li> <li>auto_stop_counter (rb::SmartServoBus::servo_info)</li> </ul>"},{"location":"esp/class_member_variables/#b","title":"b","text":"<ul> <li>BATTERY_IN_THRESHOLD (rb::Battery)</li> </ul>"},{"location":"esp/class_member_variables/#c","title":"c","text":"<ul> <li>cItems (MyStack)</li> <li>Count (rb::Buttons)</li> <li>current (rb::SmartServoBus::servo_info)</li> <li>callback (rb::Timers::timer_t)</li> </ul>"},{"location":"esp/class_member_variables/#d","title":"d","text":"<ul> <li>defaultSpeedOfSound (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_member_variables/#h","title":"h","text":"<ul> <li>handle (rb::Timers::timer_t)</li> </ul>"},{"location":"esp/class_member_variables/#i","title":"i","text":"<ul> <li>INVALID_ID (rb::Timers)</li> <li>id (rb::Timers::timer_t)</li> </ul>"},{"location":"esp/class_member_variables/#m","title":"m","text":"<ul> <li>m_state (rb::Battery)</li> <li>m_buttonsSet (rb::Buttons)</li> <li>m_callbacks (rb::Buttons, rb::Ultrasound)</li> <li>m_mutex (rb::Buttons, rb::Leds, rb::Motor, rb::SmartServoBus, rb::StupidServo, rb::Timers, rb::Ultrasound)</li> <li>m_ledsOn (rb::Leds)</li> <li>m_battery (rb::Manager)</li> <li>m_buttons (rb::Manager)</li> <li>m_codec (rb::Manager)</li> <li>m_codecTxMutex (rb::Manager)</li> <li>m_coprocFwVersion (rb::Manager)</li> <li>m_coprocSemaphore (rb::Manager)</li> <li>m_coprocWatchdogTimer (rb::Manager)</li> <li>m_keepaliveTask (rb::Manager)</li> <li>m_leds (rb::Manager)</li> <li>m_motors (rb::Manager)</li> <li>m_motors_last_set (rb::Manager)</li> <li>m_piezo (rb::Manager)</li> <li>m_stupidServos (rb::Manager)</li> <li>m_txBuf (rb::Manager)</li> <li>m_ultrasounds (rb::Manager)</li> <li>m_id (rb::Motor, rb::StupidServo)</li> <li>m_infoCbs (rb::Motor)</li> <li>m_lastReq (rb::Motor)</li> <li>m_mode (rb::Motor)</li> <li>m_position (rb::Motor)</li> <li>m_positionCb (rb::Motor)</li> <li>m_power (rb::Motor)</li> <li>m_pwm_max_percent (rb::Motor)</li> <li>m_speed (rb::Motor)</li> <li>m_calls (rb::MotorChangeBuilder)</li> <li>m_dirty (rb::Nvs)</li> <li>m_handle (rb::Nvs)</li> <li>m_on (rb::Piezo)</li> <li>m_servos (rb::SmartServoBus)</li> <li>m_lastPosition (rb::StupidServo)</li> <li>m_id_counter (rb::Timers)</li> <li>m_timers (rb::Timers)</li> <li>m_index (rb::Ultrasound)</li> <li>m_lastDistanceMm (rb::Ultrasound)</li> <li>m_lastUs (rb::Ultrasound)</li> <li>m_measuring (rb::Ultrasound)</li> <li>m_measuringDone (rb::Ultrasound)</li> <li>m_speedOfSound (rb::Ultrasound)</li> <li>m_timeoutTimer (rb::Ultrasound)</li> </ul>"},{"location":"esp/class_member_variables/#p","title":"p","text":"<ul> <li>pStack (MyStack)</li> <li>Pi (rb::Angle)</li> </ul>"},{"location":"esp/class_member_variables/#s","title":"s","text":"<ul> <li>StackBuffer (MyStack)</li> <li>speed_coef (rb::SmartServoBus::servo_info)</li> <li>speed_raise (rb::SmartServoBus::servo_info)</li> <li>speed_target (rb::SmartServoBus::servo_info)</li> </ul>"},{"location":"esp/class_member_variables/#t","title":"t","text":"<ul> <li>target (rb::SmartServoBus::servo_info)</li> </ul>"},{"location":"esp/class_member_variables/#v","title":"v","text":"<ul> <li>VOLTAGE_MAX (rb::Battery)</li> <li>VOLTAGE_MIN (rb::Battery)</li> </ul>"},{"location":"esp/class_member_variables/#_","title":"_","text":"<ul> <li>_rads (rb::Angle)</li> </ul>"},{"location":"esp/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"esp/class_member_typedefs/#c","title":"c","text":"<ul> <li>callback_t (rb::Buttons, rb::Motor, rb::Ultrasound)</li> </ul>"},{"location":"esp/class_member_typedefs/#_","title":"_","text":"<ul> <li>_T (rb::Angle)</li> </ul>"},{"location":"esp/class_member_enums/","title":"Class Member Enums","text":""},{"location":"esp/namespace_members/","title":"Namespace Members","text":""},{"location":"esp/namespace_members/#b","title":"b","text":"<ul> <li>ButtonId (rb)</li> </ul>"},{"location":"esp/namespace_members/#c","title":"c","text":"<ul> <li>clamp (rb)</li> </ul>"},{"location":"esp/namespace_members/#d","title":"d","text":"<ul> <li>delay (rb)</li> <li>delayMs (rb)</li> <li>dieTimers (rb)</li> </ul>"},{"location":"esp/namespace_members/#l","title":"l","text":"<ul> <li>LedId (rb)</li> </ul>"},{"location":"esp/namespace_members/#m","title":"m","text":"<ul> <li>ManagerInstallFlags (rb)</li> <li>MotorId (rb)</li> </ul>"},{"location":"esp/namespace_members/#o","title":"o","text":"<ul> <li>operator\"\"_deg (rb)</li> <li>operator\"\"_rad (rb)</li> <li>operator* (rb)</li> <li>operator+ (rb)</li> <li>operator++ (rb)</li> <li>operator- (rb)</li> <li>operator/ (rb)</li> <li>operator| (rb)</li> </ul>"},{"location":"esp/namespace_members/#s","title":"s","text":"<ul> <li>StupidServosCount (rb)</li> </ul>"},{"location":"esp/namespace_members/#u","title":"u","text":"<ul> <li>UltrasoundsCount (rb)</li> </ul>"},{"location":"esp/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"esp/namespace_member_functions/#c","title":"c","text":"<ul> <li>clamp (rb)</li> </ul>"},{"location":"esp/namespace_member_functions/#d","title":"d","text":"<ul> <li>delay (rb)</li> <li>delayMs (rb)</li> <li>dieTimers (rb)</li> </ul>"},{"location":"esp/namespace_member_functions/#o","title":"o","text":"<ul> <li>operator\"\"_deg (rb)</li> <li>operator\"\"_rad (rb)</li> <li>operator* (rb)</li> <li>operator+ (rb)</li> <li>operator++ (rb)</li> <li>operator- (rb)</li> <li>operator/ (rb)</li> <li>operator| (rb)</li> </ul>"},{"location":"esp/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"esp/namespace_member_variables/#s","title":"s","text":"<ul> <li>StupidServosCount (rb)</li> </ul>"},{"location":"esp/namespace_member_variables/#u","title":"u","text":"<ul> <li>UltrasoundsCount (rb)</li> </ul>"},{"location":"esp/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"esp/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"esp/namespace_member_enums/#b","title":"b","text":"<ul> <li>ButtonId (rb)</li> </ul>"},{"location":"esp/namespace_member_enums/#l","title":"l","text":"<ul> <li>LedId (rb)</li> </ul>"},{"location":"esp/namespace_member_enums/#m","title":"m","text":"<ul> <li>ManagerInstallFlags (rb)</li> <li>MotorId (rb)</li> </ul>"},{"location":"esp/functions/","title":"Functions","text":""},{"location":"esp/functions/#l","title":"l","text":"<ul> <li>loop (main.cpp)</li> </ul>"},{"location":"esp/functions/#m","title":"m","text":"<ul> <li>main (test.cpp)</li> </ul>"},{"location":"esp/functions/#s","title":"s","text":"<ul> <li>setup (main.cpp)</li> </ul>"},{"location":"esp/functions/#t","title":"t","text":"<ul> <li>testFnc (main.cpp)</li> </ul>"},{"location":"esp/macros/","title":"Macros","text":""},{"location":"esp/macros/#m","title":"m","text":"<ul> <li>M_PI (RBCXAngle.h)</li> <li>MAX_COPROC_IDLE_MS (RBCXManager.cpp)</li> <li>MOTORS_FAILSAFE_PERIOD_MS (RBCXManager.cpp)</li> <li>MS_TO_TICKS (RBCXSmartServo.cpp)</li> <li>MY_MACRO (main.cpp)</li> </ul>"},{"location":"esp/macros/#r","title":"r","text":"<ul> <li>RBCX_ENUM_IMPL_MASK_OPERATORS (RBCXUtil.h)</li> <li>RB3204 (RBCXVersion.h)</li> <li>RB3204_MAJOR (RBCXVersion.h)</li> <li>RB3204_MINOR (RBCXVersion.h)</li> <li>RB3204_PATCH (RBCXVersion.h)</li> <li>RB3204_RBCX (RBCXVersion.h)</li> <li>RBCX (RBCXVersion.h)</li> </ul>"},{"location":"esp/macros/#t","title":"t","text":"<ul> <li>TAG (RBCXBattery.cpp, RBCXManager.cpp, RBCXSmartServo.cpp, RBCXUltrasound.cpp)</li> </ul>"},{"location":"esp/variables/","title":"Variables","text":""},{"location":"esp/variables/#m","title":"m","text":"<ul> <li>minVersionPositional (RBCXMotor.cpp)</li> </ul>"},{"location":"esp/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List<ul> <li>class MyStack</li> <li>namespace rb</li> <li>class rb::Angle</li> <li>class rb::Battery</li> <li>class rb::Buttons</li> <li>class rb::Leds</li> <li>class rb::Manager</li> <li>class rb::Motor</li> <li>class rb::MotorChangeBuilder</li> <li>class rb::Nvs</li> <li>class rb::Piezo</li> <li>class rb::SmartServoBus</li> <li>class rb::StupidServo</li> <li>class rb::Timers</li> <li>class rb::Ultrasound</li> <li>struct rb::SmartServoBus::servo_info</li> <li>struct rb::Timers::timer_t</li> </ul> </li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files<ul> <li>demo-projets</li> <li>demo-projets/esp<ul> <li>RBCX.h</li> <li>RBCX.h source</li> <li>RBCXAngle.cpp</li> <li>RBCXAngle.cpp source</li> <li>RBCXAngle.h</li> <li>RBCXAngle.h source</li> <li>RBCXBattery.cpp</li> <li>RBCXBattery.cpp source</li> <li>RBCXBattery.h</li> <li>RBCXBattery.h source</li> <li>RBCXButtons.cpp</li> <li>RBCXButtons.cpp source</li> <li>RBCXButtons.h</li> <li>RBCXButtons.h source</li> <li>RBCXLeds.cpp</li> <li>RBCXLeds.cpp source</li> <li>RBCXLeds.h</li> <li>RBCXLeds.h source</li> <li>RBCXManager.cpp</li> <li>RBCXManager.cpp source</li> <li>RBCXManager.h</li> <li>RBCXManager.h source</li> <li>RBCXMotor.cpp</li> <li>RBCXMotor.cpp source</li> <li>RBCXMotor.h</li> <li>RBCXMotor.h source</li> <li>RBCXNvs.cpp</li> <li>RBCXNvs.cpp source</li> <li>RBCXNvs.h</li> <li>RBCXNvs.h source</li> <li>RBCXPiezo.cpp</li> <li>RBCXPiezo.cpp source</li> <li>RBCXPiezo.h</li> <li>RBCXPiezo.h source</li> <li>RBCXPinout.h</li> <li>RBCXPinout.h source</li> <li>RBCXSmartServo.cpp</li> <li>RBCXSmartServo.cpp source</li> <li>RBCXSmartServo.h</li> <li>RBCXSmartServo.h source</li> <li>RBCXStupidServo.cpp</li> <li>RBCXStupidServo.cpp source</li> <li>RBCXStupidServo.h</li> <li>RBCXStupidServo.h source</li> <li>RBCXTimers.cpp</li> <li>RBCXTimers.cpp source</li> <li>RBCXTimers.h</li> <li>RBCXTimers.h source</li> <li>RBCXUltrasound.cpp</li> <li>RBCXUltrasound.cpp source</li> <li>RBCXUltrasound.h</li> <li>RBCXUltrasound.h source</li> <li>RBCXUtil.h</li> <li>RBCXUtil.h source</li> <li>RBCXVersion.h</li> <li>RBCXVersion.h source</li> <li>main.cpp</li> <li>main.cpp source</li> <li>test.cpp</li> <li>test.cpp source</li> </ul> </li> </ul> </li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"animal/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace example </li> <li>class Animal Base class for all animals from which Bird derives. <ul> <li>struct Result Some random inner class of Animal . </li> </ul> </li> <li>interface AnimalInterface </li> <li>class Bird </li> <li>class CustomException </li> <li>class NumericException </li> <li>class SpecialBird </li> <li>namespace inner_namespace <ul> <li>class Vector </li> </ul> </li> <li>namespace std </li> </ul>"},{"location":"animal/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir demo-projets </li> <li>dir animal <ul> <li>file animal.h </li> <li>file animal_interface.h </li> <li>file bird.h </li> <li>file config.h This is a config file. </li> <li>dir utils </li> <li>file exception.h </li> <li>file example.h </li> <li>file special_bird.h </li> </ul> </li> </ul>"},{"location":"animal/namespaceexample/","title":"Namespace example","text":"<p>Namespace List &gt; example</p>"},{"location":"animal/namespaceexample/#namespaces","title":"Namespaces","text":"Type Name namespace inner_namespace"},{"location":"animal/namespaceexample/#classes","title":"Classes","text":"Type Name class Animal Base class for all animals from which Bird derives. interface AnimalInterface class Bird class CustomException class NumericException class SpecialBird"},{"location":"animal/namespaceexample/#public-types","title":"Public Types","text":"Type Name typedef std::function&lt; void *(Animal *)&gt; Callback Animal callback function definition. enum CallbackType Different types of an Animal callback events."},{"location":"animal/namespaceexample/#public-functions","title":"Public Functions","text":"Type Name void some_namespace_function (Animal * animal) Some random namespace function that modifies Animal ."},{"location":"animal/namespaceexample/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"animal/namespaceexample/#typedef-callback","title":"typedef Callback","text":"<pre><code>typedef std::function&lt;void*(Animal*)&gt; example::Callback;\n</code></pre>"},{"location":"animal/namespaceexample/#enum-callbacktype","title":"enum CallbackType","text":"<pre><code>enum example::CallbackType {\nNONE = 0,\nEAT,\nSLEEP,\nATTACK\n};\n</code></pre>"},{"location":"animal/namespaceexample/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"animal/namespaceexample/#function-some_namespace_function","title":"function some_namespace_function","text":"<p>Some random namespace function that modifies Animal . <pre><code>void example::some_namespace_function (\nAnimal * animal\n) </code></pre></p> <p>See also: Animal </p> <p>Parameters:</p> <ul> <li><code>animal</code> The pointer to the animal instance </li> </ul> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/animal.h</code></p>"},{"location":"animal/classexample_1_1Animal/","title":"Class example::Animal","text":"<p>ClassList &gt; example &gt; Animal</p> <p>Base class for all animals from which Bird derives.More...</p> <ul> <li><code>#include &lt;animal.h&gt;</code></li> </ul> <p>Inherits the following classes: example::AnimalInterface</p> <p>Inherited by the following classes: example::Bird</p>"},{"location":"animal/classexample_1_1Animal/#classes","title":"Classes","text":"Type Name struct Result Some random inner class of Animal ."},{"location":"animal/classexample_1_1Animal/#public-types","title":"Public Types","text":"Type Name typedef std::pair&lt; Animal *, Animal * &gt; Parents enum Type The 6 classes of animal kingdom."},{"location":"animal/classexample_1_1Animal/#public-functions","title":"Public Functions","text":"Type Name Animal (Type type, const std::string &amp; name, Animal * mother=nullptr, Animal * father=nullptr) The main constructor. Animal (const Animal &amp; other) = delete Animal (Animal &amp;&amp; animal) noexcept const std::string &amp; get_name () constGet the name of the animal. virtual int get_num_of_eyes () override constReturns the number of eyes. virtual int get_num_of_limbs () override constReturns the number of limbs. Parents get_parents () const virtual bool has_tail () override constReturns true if the animal has a tail. virtual void make_sound () = 0 virtual void move ()  operator bool () constReturns true if this is an valid animal. Animal &amp; operator= (const Animal &amp; other) = deleteDeleted copy operator. Animal &amp; operator= (Animal &amp;&amp; other) noexceptMove operator. void some_inline_member_function (Animal * animal) Lorem Ipsum. void swap (Animal &amp; other) noexcept virtual ~Animal () = default"},{"location":"animal/classexample_1_1Animal/#public-functions-inherited-from-exampleanimalinterface","title":"Public Functions inherited from example::AnimalInterface","text":"<p>See example::AnimalInterface</p> Type Name virtual int get_num_of_eyes () const = 0Returns the number of eyes. virtual int get_num_of_limbs () const = 0Returns the number of limbs. virtual bool has_tail () const = 0Returns true if the animal has a tail."},{"location":"animal/classexample_1_1Animal/#public-static-functions","title":"Public Static Functions","text":"Type Name Animal * find_child_by_name (Animal * parent)  Animal * find_parent_by_name (Animal * child)"},{"location":"animal/classexample_1_1Animal/#protected-attributes","title":"Protected Attributes","text":"Type Name Animal * father The pointer to the father. Animal * mother The pointer to the mother. std::string name"},{"location":"animal/classexample_1_1Animal/#detailed-description","title":"Detailed Description","text":"<p>Lorem Ipsum Donor. Some Random link with bold and italics And the following is a <code>typewritter</code> font.</p> <p>Example code:</p> <p>Animal animal = Animal(\"Hello World\", nullptr, nullptr); std::cout &lt;&lt; animal.get_name() &lt;&lt; std::endl;</p> <p>See also: Bird </p> <p>Bug</p> <p>Some random bug </p> <p>Note:</p> <p>Some random note </p> <p>Warning:</p> <p>Some random warning </p> <p>Test</p> <p>Some random test description </p> <p>Todo</p> <p>Some random todo </p> <p>Template parameters:</p> <ul> <li><code>T</code> Some random template paramater description which actually does not exist in the code! </li> </ul> <p>Precondition:</p> <p>First initialize the system. </p> <p>Date:</p> <p>2017-2018 </p> <p>Author:</p> <p>Matus Novak </p> <p>Author:</p> <p>Hello World </p>"},{"location":"animal/classexample_1_1Animal/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"animal/classexample_1_1Animal/#typedef-parents","title":"typedef Parents","text":"<pre><code>typedef std::pair&lt;Animal*, Animal*&gt; example::Animal::Parents;\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#enum-type","title":"enum Type","text":"<p>The 6 classes of animal kingdom. <pre><code>enum example::Animal::Type {\nNONE = 0,\nINSECT = 1,\nAMPHIBIAN = 2,\nBIRD = 3,\nFISH = 4,\nREPTILE = 5,\nMAMMAL = 6\n};\n</code></pre></p> <p>Lorem Ipsum Donor. </p>"},{"location":"animal/classexample_1_1Animal/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"animal/classexample_1_1Animal/#function-animal-13","title":"function Animal [1/3]","text":"<p>The main constructor. <pre><code>example::Animal::Animal (\nType type,\nconst std::string &amp; name,\nAnimal * mother=nullptr,\nAnimal * father=nullptr\n) </code></pre></p> <p>Use this constructor to allocate a new instance of Animal </p> <p>Parameters:</p> <ul> <li><code>type</code> The type of the animal that matches Animal::Type </li> <li><code>name</code> Any name to associate the animal with </li> </ul> <p>Exception:</p> <ul> <li>CustomException If either only mother or father is assigned </li> </ul>"},{"location":"animal/classexample_1_1Animal/#function-animal-23","title":"function Animal [2/3]","text":"<pre><code>example::Animal::Animal (\nconst Animal &amp; other\n) = delete\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#function-animal-33","title":"function Animal [3/3]","text":"<pre><code>example::Animal::Animal (\nAnimal &amp;&amp; animal\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#function-get_name","title":"function get_name","text":"<p>Get the name of the animal. <pre><code>inline const std::string &amp; example::Animal::get_name () const\n</code></pre></p> <p>Returns:</p> <p>A constant reference to the name </p>"},{"location":"animal/classexample_1_1Animal/#function-get_num_of_eyes","title":"function get_num_of_eyes","text":"<p>Returns the number of eyes. <pre><code>virtual int example::Animal::get_num_of_eyes () override const\n</code></pre></p> <p>See also: get_num_of_limbs, get_num_of_eyes </p> <p>Implements example::AnimalInterface::get_num_of_eyes</p>"},{"location":"animal/classexample_1_1Animal/#function-get_num_of_limbs","title":"function get_num_of_limbs","text":"<p>Returns the number of limbs. <pre><code>virtual int example::Animal::get_num_of_limbs () override const\n</code></pre></p> <p>See also: get_num_of_eyes, get_num_of_limbs </p> <p>Implements example::AnimalInterface::get_num_of_limbs</p>"},{"location":"animal/classexample_1_1Animal/#function-get_parents","title":"function get_parents","text":"<pre><code>inline Parents example::Animal::get_parents () const\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#function-has_tail","title":"function has_tail","text":"<p>Returns true if the animal has a tail. <pre><code>virtual bool example::Animal::has_tail () override const\n</code></pre></p> <p>See also: get_num_of_limbs, get_num_of_eyes </p> <p>Return value:</p> <ul> <li><code>true</code> Does have a tail </li> <li><code>false</code> Does not have a tail </li> </ul> <p>Implements example::AnimalInterface::has_tail</p>"},{"location":"animal/classexample_1_1Animal/#function-make_sound","title":"function make_sound","text":"<pre><code>virtual void example::Animal::make_sound () = 0\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#function-move","title":"function move","text":"<pre><code>virtual void example::Animal::move () </code></pre>"},{"location":"animal/classexample_1_1Animal/#function-operator-bool","title":"function operator bool","text":"<p>Returns true if this is an valid animal. <pre><code>example::Animal::operator bool () const\n</code></pre></p> <p>Lorem Ipsum returns true </p>"},{"location":"animal/classexample_1_1Animal/#function-operator","title":"function operator=","text":"<pre><code>Animal &amp; example::Animal::operator= (\nconst Animal &amp; other\n) = delete\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#function-operator_1","title":"function operator=","text":"<pre><code>Animal &amp; example::Animal::operator= (\nAnimal &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#function-some_inline_member_function","title":"function some_inline_member_function","text":"<p>Lorem Ipsum. <pre><code>inline void example::Animal::some_inline_member_function (\nAnimal * animal\n) </code></pre></p> <p>See also: Animal </p> <p>Parameters:</p> <ul> <li><code>animal</code> The pointer to the animal instance</li> </ul> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>"},{"location":"animal/classexample_1_1Animal/#implementation","title":"Implementation:","text":""},{"location":"animal/classexample_1_1Animal/#function-swap","title":"function swap","text":"<pre><code>void example::Animal::swap (\nAnimal &amp; other\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#function-animal","title":"function ~Animal","text":"<pre><code>virtual example::Animal::~Animal () = default\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"animal/classexample_1_1Animal/#function-find_child_by_name","title":"function find_child_by_name","text":"<pre><code>static Animal * example::Animal::find_child_by_name (\nAnimal * parent\n) </code></pre>"},{"location":"animal/classexample_1_1Animal/#function-find_parent_by_name","title":"function find_parent_by_name","text":"<pre><code>static Animal * example::Animal::find_parent_by_name (\nAnimal * child\n) </code></pre>"},{"location":"animal/classexample_1_1Animal/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"animal/classexample_1_1Animal/#variable-father","title":"variable father","text":"<p>The pointer to the father. <pre><code>Animal* example::Animal::father;\n</code></pre></p> <p>Can be null! </p>"},{"location":"animal/classexample_1_1Animal/#variable-mother","title":"variable mother","text":"<p>The pointer to the mother. <pre><code>Animal* example::Animal::mother;\n</code></pre></p> <p>Can be null! </p>"},{"location":"animal/classexample_1_1Animal/#variable-name","title":"variable name","text":"<pre><code>std::string example::Animal::name;\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#friends-documentation","title":"Friends Documentation","text":""},{"location":"animal/classexample_1_1Animal/#friend-some_global_function","title":"friend some_global_function","text":"<p>Some random global function that modifies Animal . <pre><code>void example::Animal::some_global_function (\nAnimal * animal\n) </code></pre></p> <p>See also: Animal </p> <p>Parameters:</p> <ul> <li><code>animal</code> The pointer to the animal instance </li> </ul> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/animal.h</code></p>"},{"location":"animal/structexample_1_1Animal_1_1Result/","title":"Struct example::Animal::Result","text":"<p>ClassList &gt; example &gt; Animal &gt; Result</p> <p>Some random inner class of Animal .</p> <ul> <li><code>#include &lt;animal.h&gt;</code></li> </ul>"},{"location":"animal/structexample_1_1Animal_1_1Result/#public-attributes","title":"Public Attributes","text":"Type Name const Animal * father   = = nullptr const Animal * mother   = = nullptr const std::string name const Type type   = = Type::NONE"},{"location":"animal/structexample_1_1Animal_1_1Result/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"animal/structexample_1_1Animal_1_1Result/#variable-father","title":"variable father","text":"<pre><code>const Animal* example::Animal::Result::father;\n</code></pre>"},{"location":"animal/structexample_1_1Animal_1_1Result/#variable-mother","title":"variable mother","text":"<pre><code>const Animal* example::Animal::Result::mother;\n</code></pre>"},{"location":"animal/structexample_1_1Animal_1_1Result/#variable-name","title":"variable name","text":"<pre><code>const std::string example::Animal::Result::name;\n</code></pre>"},{"location":"animal/structexample_1_1Animal_1_1Result/#variable-type","title":"variable type","text":"<pre><code>const Type example::Animal::Result::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/animal.h</code></p>"},{"location":"animal/classexample_1_1AnimalInterface/","title":"Interface example::AnimalInterface","text":"<p>ClassList &gt; example &gt; AnimalInterface</p> <p>Inherited by the following classes: example::Animal</p>"},{"location":"animal/classexample_1_1AnimalInterface/#public-functions","title":"Public Functions","text":"Type Name virtual int get_num_of_eyes () const = 0Returns the number of eyes. virtual int get_num_of_limbs () const = 0Returns the number of limbs. virtual bool has_tail () const = 0Returns true if the animal has a tail."},{"location":"animal/classexample_1_1AnimalInterface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"animal/classexample_1_1AnimalInterface/#function-get_num_of_eyes","title":"function get_num_of_eyes","text":"<p>Returns the number of eyes. <pre><code>virtual int example::AnimalInterface::get_num_of_eyes () const = 0\n</code></pre></p> <p>See also: get_num_of_limbs </p>"},{"location":"animal/classexample_1_1AnimalInterface/#function-get_num_of_limbs","title":"function get_num_of_limbs","text":"<p>Returns the number of limbs. <pre><code>virtual int example::AnimalInterface::get_num_of_limbs () const = 0\n</code></pre></p> <p>See also: get_num_of_eyes </p>"},{"location":"animal/classexample_1_1AnimalInterface/#function-has_tail","title":"function has_tail","text":"<p>Returns true if the animal has a tail. <pre><code>virtual bool example::AnimalInterface::has_tail () const = 0\n</code></pre></p> <p>See also: get_num_of_limbs </p> <p>Return value:</p> <ul> <li><code>true</code> Does have a tail </li> <li><code>false</code> Does not have a tail </li> </ul> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/animal_interface.h</code></p>"},{"location":"animal/classexample_1_1Bird/","title":"Class example::Bird","text":"<p>ClassList &gt; example &gt; Bird</p> <p>Inherits the following classes: example::Animal</p> <p>Inherited by the following classes: example::SpecialBird</p>"},{"location":"animal/classexample_1_1Bird/#public-types-inherited-from-exampleanimal","title":"Public Types inherited from example::Animal","text":"<p>See example::Animal</p> Type Name typedef std::pair&lt; Animal *, Animal * &gt; Parents enum Type The 6 classes of animal kingdom."},{"location":"animal/classexample_1_1Bird/#public-functions","title":"Public Functions","text":"Type Name Bird (const std::string &amp; name, Bird * mother=nullptr, Bird * father=nullptr)  Bird (const Bird &amp; other) = delete Bird (Bird &amp;&amp; Bird) noexcept virtual void make_sound () override virtual void move () override Bird &amp; operator= (const Bird &amp; other) = deleteDeleted copy operator. Bird &amp; operator= (Bird &amp;&amp; other) noexceptMove operator. void swap (Bird &amp; other) noexcept ~Bird () = default"},{"location":"animal/classexample_1_1Bird/#public-functions-inherited-from-exampleanimal","title":"Public Functions inherited from example::Animal","text":"<p>See example::Animal</p> Type Name Animal (Type type, const std::string &amp; name, Animal * mother=nullptr, Animal * father=nullptr) The main constructor. Animal (const Animal &amp; other) = delete Animal (Animal &amp;&amp; animal) noexcept const std::string &amp; get_name () constGet the name of the animal. virtual int get_num_of_eyes () override constReturns the number of eyes. virtual int get_num_of_limbs () override constReturns the number of limbs. Parents get_parents () const virtual bool has_tail () override constReturns true if the animal has a tail. virtual void make_sound () = 0 virtual void move ()  operator bool () constReturns true if this is an valid animal. Animal &amp; operator= (const Animal &amp; other) = deleteDeleted copy operator. Animal &amp; operator= (Animal &amp;&amp; other) noexceptMove operator. void some_inline_member_function (Animal * animal) Lorem Ipsum. void swap (Animal &amp; other) noexcept virtual ~Animal () = default"},{"location":"animal/classexample_1_1Bird/#public-functions-inherited-from-exampleanimalinterface","title":"Public Functions inherited from example::AnimalInterface","text":"<p>See example::AnimalInterface</p> Type Name virtual int get_num_of_eyes () const = 0Returns the number of eyes. virtual int get_num_of_limbs () const = 0Returns the number of limbs. virtual bool has_tail () const = 0Returns true if the animal has a tail."},{"location":"animal/classexample_1_1Bird/#public-static-functions-inherited-from-exampleanimal","title":"Public Static Functions inherited from example::Animal","text":"<p>See example::Animal</p> Type Name Animal * find_child_by_name (Animal * parent)  Animal * find_parent_by_name (Animal * child)"},{"location":"animal/classexample_1_1Bird/#protected-attributes-inherited-from-exampleanimal","title":"Protected Attributes inherited from example::Animal","text":"<p>See example::Animal</p> Type Name Animal * father The pointer to the father. Animal * mother The pointer to the mother. std::string name"},{"location":"animal/classexample_1_1Bird/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"animal/classexample_1_1Bird/#function-bird-13","title":"function Bird [1/3]","text":"<pre><code>example::Bird::Bird (\nconst std::string &amp; name,\nBird * mother=nullptr,\nBird * father=nullptr\n) </code></pre>"},{"location":"animal/classexample_1_1Bird/#function-bird-23","title":"function Bird [2/3]","text":"<pre><code>example::Bird::Bird (\nconst Bird &amp; other\n) = delete\n</code></pre>"},{"location":"animal/classexample_1_1Bird/#function-bird-33","title":"function Bird [3/3]","text":"<pre><code>example::Bird::Bird (\nBird &amp;&amp; Bird\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1Bird/#function-make_sound","title":"function make_sound","text":"<pre><code>virtual void example::Bird::make_sound () override\n</code></pre> <p>Implements example::Animal::make_sound</p>"},{"location":"animal/classexample_1_1Bird/#function-move","title":"function move","text":"<pre><code>virtual void example::Bird::move () override\n</code></pre> <p>Implements example::Animal::move</p>"},{"location":"animal/classexample_1_1Bird/#function-operator","title":"function operator=","text":"<pre><code>Bird &amp; example::Bird::operator= (\nconst Bird &amp; other\n) = delete\n</code></pre>"},{"location":"animal/classexample_1_1Bird/#function-operator_1","title":"function operator=","text":"<pre><code>Bird &amp; example::Bird::operator= (\nBird &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1Bird/#function-swap","title":"function swap","text":"<pre><code>void example::Bird::swap (\nBird &amp; other\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1Bird/#function-bird","title":"function ~Bird","text":"<pre><code>example::Bird::~Bird () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/bird.h</code></p>"},{"location":"animal/classexample_1_1CustomException/","title":"Class example::CustomException","text":"<p>ClassList &gt; example &gt; CustomException</p> <p>Inherits the following classes: std::exception</p>"},{"location":"animal/classexample_1_1CustomException/#public-functions","title":"Public Functions","text":"Type Name CustomException (const std::string &amp; msg)  virtual const char * what () const"},{"location":"animal/classexample_1_1CustomException/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"animal/classexample_1_1CustomException/#function-customexception","title":"function CustomException","text":"<pre><code>inline example::CustomException::CustomException (\nconst std::string &amp; msg\n) </code></pre>"},{"location":"animal/classexample_1_1CustomException/#function-what","title":"function what","text":"<pre><code>inline virtual const char * example::CustomException::what () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/utils/exception.h</code></p>"},{"location":"animal/classexample_1_1NumericException/","title":"Class example::NumericException","text":"<p>ClassList &gt; example &gt; NumericException</p> <p>Inherits the following classes: std::exception</p>"},{"location":"animal/classexample_1_1NumericException/#public-functions","title":"Public Functions","text":"Type Name NumericException (const std::string &amp; msg)  virtual const char * what () const"},{"location":"animal/classexample_1_1NumericException/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"animal/classexample_1_1NumericException/#function-numericexception","title":"function NumericException","text":"<pre><code>inline example::NumericException::NumericException (\nconst std::string &amp; msg\n) </code></pre>"},{"location":"animal/classexample_1_1NumericException/#function-what","title":"function what","text":"<pre><code>inline virtual const char * example::NumericException::what () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/utils/exception.h</code></p>"},{"location":"animal/classexample_1_1SpecialBird/","title":"Class example::SpecialBird","text":"<p>ClassList &gt; example &gt; SpecialBird</p> <p>Inherits the following classes: example::Bird</p>"},{"location":"animal/classexample_1_1SpecialBird/#public-types-inherited-from-exampleanimal","title":"Public Types inherited from example::Animal","text":"<p>See example::Animal</p> Type Name typedef std::pair&lt; Animal *, Animal * &gt; Parents enum Type The 6 classes of animal kingdom."},{"location":"animal/classexample_1_1SpecialBird/#public-functions","title":"Public Functions","text":"Type Name SpecialBird (const std::string &amp; name, SpecialBird * mother=nullptr, SpecialBird * father=nullptr)  SpecialBird (const SpecialBird &amp; other) = delete SpecialBird (SpecialBird &amp;&amp; SpecialBird) noexcept void do_something_special ()  SpecialBird &amp; operator= (const SpecialBird &amp; other) = delete SpecialBird &amp; operator= (SpecialBird &amp;&amp; other) noexcept void swap (SpecialBird &amp; other) noexcept ~SpecialBird () = default"},{"location":"animal/classexample_1_1SpecialBird/#public-functions-inherited-from-examplebird","title":"Public Functions inherited from example::Bird","text":"<p>See example::Bird</p> Type Name Bird (const std::string &amp; name, Bird * mother=nullptr, Bird * father=nullptr)  Bird (const Bird &amp; other) = delete Bird (Bird &amp;&amp; Bird) noexcept virtual void make_sound () override virtual void move () override Bird &amp; operator= (const Bird &amp; other) = deleteDeleted copy operator. Bird &amp; operator= (Bird &amp;&amp; other) noexceptMove operator. void swap (Bird &amp; other) noexcept ~Bird () = default"},{"location":"animal/classexample_1_1SpecialBird/#public-functions-inherited-from-exampleanimal","title":"Public Functions inherited from example::Animal","text":"<p>See example::Animal</p> Type Name Animal (Type type, const std::string &amp; name, Animal * mother=nullptr, Animal * father=nullptr) The main constructor. Animal (const Animal &amp; other) = delete Animal (Animal &amp;&amp; animal) noexcept const std::string &amp; get_name () constGet the name of the animal. virtual int get_num_of_eyes () override constReturns the number of eyes. virtual int get_num_of_limbs () override constReturns the number of limbs. Parents get_parents () const virtual bool has_tail () override constReturns true if the animal has a tail. virtual void make_sound () = 0 virtual void move ()  operator bool () constReturns true if this is an valid animal. Animal &amp; operator= (const Animal &amp; other) = deleteDeleted copy operator. Animal &amp; operator= (Animal &amp;&amp; other) noexceptMove operator. void some_inline_member_function (Animal * animal) Lorem Ipsum. void swap (Animal &amp; other) noexcept virtual ~Animal () = default"},{"location":"animal/classexample_1_1SpecialBird/#public-functions-inherited-from-exampleanimalinterface","title":"Public Functions inherited from example::AnimalInterface","text":"<p>See example::AnimalInterface</p> Type Name virtual int get_num_of_eyes () const = 0Returns the number of eyes. virtual int get_num_of_limbs () const = 0Returns the number of limbs. virtual bool has_tail () const = 0Returns true if the animal has a tail."},{"location":"animal/classexample_1_1SpecialBird/#public-static-functions-inherited-from-exampleanimal","title":"Public Static Functions inherited from example::Animal","text":"<p>See example::Animal</p> Type Name Animal * find_child_by_name (Animal * parent)  Animal * find_parent_by_name (Animal * child)"},{"location":"animal/classexample_1_1SpecialBird/#protected-attributes-inherited-from-exampleanimal","title":"Protected Attributes inherited from example::Animal","text":"<p>See example::Animal</p> Type Name Animal * father The pointer to the father. Animal * mother The pointer to the mother. std::string name"},{"location":"animal/classexample_1_1SpecialBird/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"animal/classexample_1_1SpecialBird/#function-specialbird-13","title":"function SpecialBird [1/3]","text":"<pre><code>example::SpecialBird::SpecialBird (\nconst std::string &amp; name,\nSpecialBird * mother=nullptr,\nSpecialBird * father=nullptr\n) </code></pre>"},{"location":"animal/classexample_1_1SpecialBird/#function-specialbird-23","title":"function SpecialBird [2/3]","text":"<pre><code>example::SpecialBird::SpecialBird (\nconst SpecialBird &amp; other\n) = delete\n</code></pre>"},{"location":"animal/classexample_1_1SpecialBird/#function-specialbird-33","title":"function SpecialBird [3/3]","text":"<pre><code>example::SpecialBird::SpecialBird (\nSpecialBird &amp;&amp; SpecialBird\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1SpecialBird/#function-do_something_special","title":"function do_something_special","text":"<pre><code>void example::SpecialBird::do_something_special () </code></pre>"},{"location":"animal/classexample_1_1SpecialBird/#function-operator","title":"function operator=","text":"<pre><code>SpecialBird &amp; example::SpecialBird::operator= (\nconst SpecialBird &amp; other\n) = delete\n</code></pre>"},{"location":"animal/classexample_1_1SpecialBird/#function-operator_1","title":"function operator=","text":"<pre><code>SpecialBird &amp; example::SpecialBird::operator= (\nSpecialBird &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1SpecialBird/#function-swap","title":"function swap","text":"<pre><code>void example::SpecialBird::swap (\nSpecialBird &amp; other\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1SpecialBird/#function-specialbird","title":"function ~SpecialBird","text":"<pre><code>example::SpecialBird::~SpecialBird () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/special_bird.h</code></p>"},{"location":"animal/namespaceexample_1_1inner__namespace/","title":"Namespace example::inner_namespace","text":"<p>Namespace List &gt; example &gt; inner_namespace</p>"},{"location":"animal/namespaceexample_1_1inner__namespace/#classes","title":"Classes","text":"Type Name class Vector <p>The documentation for this class was generated from the following file <code>demo-projets/animal/animal.h</code></p>"},{"location":"animal/classexample_1_1inner__namespace_1_1Vector/","title":"Class example::inner_namespace::Vector","text":"<p>ClassList &gt; example &gt; inner_namespace &gt; Vector</p> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/animal.h</code></p>"},{"location":"animal/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"animal/group__organism/","title":"Group organism","text":"<p>Modules &gt; organism</p> <p>This is a brief description to the organism group. More...</p>"},{"location":"animal/group__organism/#modules","title":"Modules","text":"Type Name module An animal group example This is a brief description to the animals group."},{"location":"animal/group__organism/#detailed-description","title":"Detailed Description","text":"<p>Some detailed description here </p>"},{"location":"animal/group__animals/","title":"Group animals","text":"<p>Modules &gt; animals</p> <p>This is a brief description to the animals group. More...</p>"},{"location":"animal/group__animals/#files","title":"Files","text":"Type Name file config.h This is a config file."},{"location":"animal/group__animals/#classes","title":"Classes","text":"Type Name class example::Animal Base class for all animals from which Bird derives. interface example::AnimalInterface class example::Bird class example::CustomException class example::NumericException class example::SpecialBird"},{"location":"animal/group__animals/#public-types","title":"Public Types","text":"Type Name enum example::Animal::Type The 6 classes of animal kingdom."},{"location":"animal/group__animals/#public-functions","title":"Public Functions","text":"Type Name void some_global_function (example::Animal * animal) Some random global function that modifies Animal. void example::some_namespace_function (Animal * animal) Some random namespace function that modifies Animal ."},{"location":"animal/group__animals/#macros","title":"Macros","text":"Type Name define CONFIG_HELLO  (123) define CONFIG_WORLD  (\"abx\") define PI  3.14159265358979323846 define PRINT_PRETTY (MSG, ...) printf(MSG, __VA_ARGS__)"},{"location":"animal/group__animals/#detailed-description","title":"Detailed Description","text":"<p>Some inner namespace.</p> <p>Some random brief description.</p> <p>Some detailed description here </p>"},{"location":"animal/group__animals/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"animal/group__animals/#enum-type","title":"enum Type","text":"<p>The 6 classes of animal kingdom. <pre><code>enum example::Animal::Type {\nNONE = 0,\nINSECT = 1,\nAMPHIBIAN = 2,\nBIRD = 3,\nFISH = 4,\nREPTILE = 5,\nMAMMAL = 6\n};\n</code></pre></p> <p>Lorem Ipsum Donor. </p>"},{"location":"animal/group__animals/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"animal/group__animals/#function-some_global_function","title":"function some_global_function","text":"<p>Some random global function that modifies Animal. <pre><code>void some_global_function (\nexample::Animal * animal\n) </code></pre></p> <p>See also: Animal </p> <p>Parameters:</p> <ul> <li><code>animal</code> The pointer to the animal instance </li> </ul>"},{"location":"animal/group__animals/#function-some_namespace_function","title":"function some_namespace_function","text":"<p>Some random namespace function that modifies Animal . <pre><code>void example::some_namespace_function (\nAnimal * animal\n) </code></pre></p> <p>See also: Animal </p> <p>Parameters:</p> <ul> <li><code>animal</code> The pointer to the animal instance </li> </ul>"},{"location":"animal/group__animals/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"animal/group__animals/#define-config_hello","title":"define CONFIG_HELLO","text":"<pre><code>#define CONFIG_HELLO (123)\n</code></pre>"},{"location":"animal/group__animals/#define-config_world","title":"define CONFIG_WORLD","text":"<pre><code>#define CONFIG_WORLD (\"abx\")\n</code></pre>"},{"location":"animal/group__animals/#define-pi","title":"define PI","text":"<pre><code>#define PI 3.14159265358979323846\n</code></pre>"},{"location":"animal/group__animals/#define-print_pretty","title":"define PRINT_PRETTY","text":"<pre><code>#define PRINT_PRETTY (\nMSG,\n...\n) printf(MSG, __VA_ARGS__)\n</code></pre>"},{"location":"animal/config_8h/","title":"File config.h","text":"<p>FileList &gt; animal &gt; config.h</p> <p>Go to the source code of this file.</p> <p>This is a config file. More...</p>"},{"location":"animal/config_8h/#macros","title":"Macros","text":"Type Name define CONFIG_HELLO  (123) define CONFIG_WORLD  (\"abx\") define PI  3.14159265358979323846 define PRINT_PRETTY (MSG, ...) printf(MSG, __VA_ARGS__)"},{"location":"animal/config_8h/#detailed-description","title":"Detailed Description","text":"<p>This is a detailed description </p>"},{"location":"animal/config_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"animal/config_8h/#define-config_hello","title":"define CONFIG_HELLO","text":"<pre><code>#define CONFIG_HELLO (123)\n</code></pre>"},{"location":"animal/config_8h/#define-config_world","title":"define CONFIG_WORLD","text":"<pre><code>#define CONFIG_WORLD (\"abx\")\n</code></pre>"},{"location":"animal/config_8h/#define-pi","title":"define PI","text":"<pre><code>#define PI 3.14159265358979323846\n</code></pre>"},{"location":"animal/config_8h/#define-print_pretty","title":"define PRINT_PRETTY","text":"<pre><code>#define PRINT_PRETTY (\nMSG,\n...\n) printf(MSG, __VA_ARGS__)\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/config.h</code></p>"},{"location":"animal/classexample_1_1Animal/","title":"Class example::Animal","text":"<p>ClassList &gt; example &gt; Animal</p> <p>Base class for all animals from which Bird derives.More...</p> <ul> <li><code>#include &lt;animal.h&gt;</code></li> </ul> <p>Inherits the following classes: example::AnimalInterface</p> <p>Inherited by the following classes: example::Bird</p>"},{"location":"animal/classexample_1_1Animal/#classes","title":"Classes","text":"Type Name struct Result Some random inner class of Animal ."},{"location":"animal/classexample_1_1Animal/#public-types","title":"Public Types","text":"Type Name typedef std::pair&lt; Animal *, Animal * &gt; Parents enum Type The 6 classes of animal kingdom."},{"location":"animal/classexample_1_1Animal/#public-functions","title":"Public Functions","text":"Type Name Animal (Type type, const std::string &amp; name, Animal * mother=nullptr, Animal * father=nullptr) The main constructor. Animal (const Animal &amp; other) = delete Animal (Animal &amp;&amp; animal) noexcept const std::string &amp; get_name () constGet the name of the animal. virtual int get_num_of_eyes () override constReturns the number of eyes. virtual int get_num_of_limbs () override constReturns the number of limbs. Parents get_parents () const virtual bool has_tail () override constReturns true if the animal has a tail. virtual void make_sound () = 0 virtual void move ()  operator bool () constReturns true if this is an valid animal. Animal &amp; operator= (const Animal &amp; other) = deleteDeleted copy operator. Animal &amp; operator= (Animal &amp;&amp; other) noexceptMove operator. void some_inline_member_function (Animal * animal) Lorem Ipsum. void swap (Animal &amp; other) noexcept virtual ~Animal () = default"},{"location":"animal/classexample_1_1Animal/#public-functions-inherited-from-exampleanimalinterface","title":"Public Functions inherited from example::AnimalInterface","text":"<p>See example::AnimalInterface</p> Type Name virtual int get_num_of_eyes () const = 0Returns the number of eyes. virtual int get_num_of_limbs () const = 0Returns the number of limbs. virtual bool has_tail () const = 0Returns true if the animal has a tail."},{"location":"animal/classexample_1_1Animal/#public-static-functions","title":"Public Static Functions","text":"Type Name Animal * find_child_by_name (Animal * parent)  Animal * find_parent_by_name (Animal * child)"},{"location":"animal/classexample_1_1Animal/#protected-attributes","title":"Protected Attributes","text":"Type Name Animal * father The pointer to the father. Animal * mother The pointer to the mother. std::string name"},{"location":"animal/classexample_1_1Animal/#detailed-description","title":"Detailed Description","text":"<p>Lorem Ipsum Donor. Some Random link with bold and italics And the following is a <code>typewritter</code> font.</p> <p>Example code:</p> <p>Animal animal = Animal(\"Hello World\", nullptr, nullptr); std::cout &lt;&lt; animal.get_name() &lt;&lt; std::endl;</p> <p>See also: Bird </p> <p>Bug</p> <p>Some random bug </p> <p>Note:</p> <p>Some random note </p> <p>Warning:</p> <p>Some random warning </p> <p>Test</p> <p>Some random test description </p> <p>Todo</p> <p>Some random todo </p> <p>Template parameters:</p> <ul> <li><code>T</code> Some random template paramater description which actually does not exist in the code! </li> </ul> <p>Precondition:</p> <p>First initialize the system. </p> <p>Date:</p> <p>2017-2018 </p> <p>Author:</p> <p>Matus Novak </p> <p>Author:</p> <p>Hello World </p>"},{"location":"animal/classexample_1_1Animal/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"animal/classexample_1_1Animal/#typedef-parents","title":"typedef Parents","text":"<pre><code>typedef std::pair&lt;Animal*, Animal*&gt; example::Animal::Parents;\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#enum-type","title":"enum Type","text":"<p>The 6 classes of animal kingdom. <pre><code>enum example::Animal::Type {\nNONE = 0,\nINSECT = 1,\nAMPHIBIAN = 2,\nBIRD = 3,\nFISH = 4,\nREPTILE = 5,\nMAMMAL = 6\n};\n</code></pre></p> <p>Lorem Ipsum Donor. </p>"},{"location":"animal/classexample_1_1Animal/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"animal/classexample_1_1Animal/#function-animal-13","title":"function Animal [1/3]","text":"<p>The main constructor. <pre><code>example::Animal::Animal (\nType type,\nconst std::string &amp; name,\nAnimal * mother=nullptr,\nAnimal * father=nullptr\n) </code></pre></p> <p>Use this constructor to allocate a new instance of Animal </p> <p>Parameters:</p> <ul> <li><code>type</code> The type of the animal that matches Animal::Type </li> <li><code>name</code> Any name to associate the animal with </li> </ul> <p>Exception:</p> <ul> <li>CustomException If either only mother or father is assigned </li> </ul>"},{"location":"animal/classexample_1_1Animal/#function-animal-23","title":"function Animal [2/3]","text":"<pre><code>example::Animal::Animal (\nconst Animal &amp; other\n) = delete\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#function-animal-33","title":"function Animal [3/3]","text":"<pre><code>example::Animal::Animal (\nAnimal &amp;&amp; animal\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#function-get_name","title":"function get_name","text":"<p>Get the name of the animal. <pre><code>inline const std::string &amp; example::Animal::get_name () const\n</code></pre></p> <p>Returns:</p> <p>A constant reference to the name </p>"},{"location":"animal/classexample_1_1Animal/#function-get_num_of_eyes","title":"function get_num_of_eyes","text":"<p>Returns the number of eyes. <pre><code>virtual int example::Animal::get_num_of_eyes () override const\n</code></pre></p> <p>See also: get_num_of_limbs, get_num_of_eyes </p> <p>Implements example::AnimalInterface::get_num_of_eyes</p>"},{"location":"animal/classexample_1_1Animal/#function-get_num_of_limbs","title":"function get_num_of_limbs","text":"<p>Returns the number of limbs. <pre><code>virtual int example::Animal::get_num_of_limbs () override const\n</code></pre></p> <p>See also: get_num_of_eyes, get_num_of_limbs </p> <p>Implements example::AnimalInterface::get_num_of_limbs</p>"},{"location":"animal/classexample_1_1Animal/#function-get_parents","title":"function get_parents","text":"<pre><code>inline Parents example::Animal::get_parents () const\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#function-has_tail","title":"function has_tail","text":"<p>Returns true if the animal has a tail. <pre><code>virtual bool example::Animal::has_tail () override const\n</code></pre></p> <p>See also: get_num_of_limbs, get_num_of_eyes </p> <p>Return value:</p> <ul> <li><code>true</code> Does have a tail </li> <li><code>false</code> Does not have a tail </li> </ul> <p>Implements example::AnimalInterface::has_tail</p>"},{"location":"animal/classexample_1_1Animal/#function-make_sound","title":"function make_sound","text":"<pre><code>virtual void example::Animal::make_sound () = 0\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#function-move","title":"function move","text":"<pre><code>virtual void example::Animal::move () </code></pre>"},{"location":"animal/classexample_1_1Animal/#function-operator-bool","title":"function operator bool","text":"<p>Returns true if this is an valid animal. <pre><code>example::Animal::operator bool () const\n</code></pre></p> <p>Lorem Ipsum returns true </p>"},{"location":"animal/classexample_1_1Animal/#function-operator","title":"function operator=","text":"<pre><code>Animal &amp; example::Animal::operator= (\nconst Animal &amp; other\n) = delete\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#function-operator_1","title":"function operator=","text":"<pre><code>Animal &amp; example::Animal::operator= (\nAnimal &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#function-some_inline_member_function","title":"function some_inline_member_function","text":"<p>Lorem Ipsum. <pre><code>inline void example::Animal::some_inline_member_function (\nAnimal * animal\n) </code></pre></p> <p>See also: Animal </p> <p>Parameters:</p> <ul> <li><code>animal</code> The pointer to the animal instance</li> </ul> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>"},{"location":"animal/classexample_1_1Animal/#implementation","title":"Implementation:","text":""},{"location":"animal/classexample_1_1Animal/#function-swap","title":"function swap","text":"<pre><code>void example::Animal::swap (\nAnimal &amp; other\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#function-animal","title":"function ~Animal","text":"<pre><code>virtual example::Animal::~Animal () = default\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"animal/classexample_1_1Animal/#function-find_child_by_name","title":"function find_child_by_name","text":"<pre><code>static Animal * example::Animal::find_child_by_name (\nAnimal * parent\n) </code></pre>"},{"location":"animal/classexample_1_1Animal/#function-find_parent_by_name","title":"function find_parent_by_name","text":"<pre><code>static Animal * example::Animal::find_parent_by_name (\nAnimal * child\n) </code></pre>"},{"location":"animal/classexample_1_1Animal/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"animal/classexample_1_1Animal/#variable-father","title":"variable father","text":"<p>The pointer to the father. <pre><code>Animal* example::Animal::father;\n</code></pre></p> <p>Can be null! </p>"},{"location":"animal/classexample_1_1Animal/#variable-mother","title":"variable mother","text":"<p>The pointer to the mother. <pre><code>Animal* example::Animal::mother;\n</code></pre></p> <p>Can be null! </p>"},{"location":"animal/classexample_1_1Animal/#variable-name","title":"variable name","text":"<pre><code>std::string example::Animal::name;\n</code></pre>"},{"location":"animal/classexample_1_1Animal/#friends-documentation","title":"Friends Documentation","text":""},{"location":"animal/classexample_1_1Animal/#friend-some_global_function","title":"friend some_global_function","text":"<p>Some random global function that modifies Animal . <pre><code>void example::Animal::some_global_function (\nAnimal * animal\n) </code></pre></p> <p>See also: Animal </p> <p>Parameters:</p> <ul> <li><code>animal</code> The pointer to the animal instance </li> </ul> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/animal.h</code></p>"},{"location":"animal/structexample_1_1Animal_1_1Result/","title":"Struct example::Animal::Result","text":"<p>ClassList &gt; example &gt; Animal &gt; Result</p> <p>Some random inner class of Animal .</p> <ul> <li><code>#include &lt;animal.h&gt;</code></li> </ul>"},{"location":"animal/structexample_1_1Animal_1_1Result/#public-attributes","title":"Public Attributes","text":"Type Name const Animal * father   = = nullptr const Animal * mother   = = nullptr const std::string name const Type type   = = Type::NONE"},{"location":"animal/structexample_1_1Animal_1_1Result/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"animal/structexample_1_1Animal_1_1Result/#variable-father","title":"variable father","text":"<pre><code>const Animal* example::Animal::Result::father;\n</code></pre>"},{"location":"animal/structexample_1_1Animal_1_1Result/#variable-mother","title":"variable mother","text":"<pre><code>const Animal* example::Animal::Result::mother;\n</code></pre>"},{"location":"animal/structexample_1_1Animal_1_1Result/#variable-name","title":"variable name","text":"<pre><code>const std::string example::Animal::Result::name;\n</code></pre>"},{"location":"animal/structexample_1_1Animal_1_1Result/#variable-type","title":"variable type","text":"<pre><code>const Type example::Animal::Result::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/animal.h</code></p>"},{"location":"animal/classexample_1_1AnimalInterface/","title":"Interface example::AnimalInterface","text":"<p>ClassList &gt; example &gt; AnimalInterface</p> <p>Inherited by the following classes: example::Animal</p>"},{"location":"animal/classexample_1_1AnimalInterface/#public-functions","title":"Public Functions","text":"Type Name virtual int get_num_of_eyes () const = 0Returns the number of eyes. virtual int get_num_of_limbs () const = 0Returns the number of limbs. virtual bool has_tail () const = 0Returns true if the animal has a tail."},{"location":"animal/classexample_1_1AnimalInterface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"animal/classexample_1_1AnimalInterface/#function-get_num_of_eyes","title":"function get_num_of_eyes","text":"<p>Returns the number of eyes. <pre><code>virtual int example::AnimalInterface::get_num_of_eyes () const = 0\n</code></pre></p> <p>See also: get_num_of_limbs </p>"},{"location":"animal/classexample_1_1AnimalInterface/#function-get_num_of_limbs","title":"function get_num_of_limbs","text":"<p>Returns the number of limbs. <pre><code>virtual int example::AnimalInterface::get_num_of_limbs () const = 0\n</code></pre></p> <p>See also: get_num_of_eyes </p>"},{"location":"animal/classexample_1_1AnimalInterface/#function-has_tail","title":"function has_tail","text":"<p>Returns true if the animal has a tail. <pre><code>virtual bool example::AnimalInterface::has_tail () const = 0\n</code></pre></p> <p>See also: get_num_of_limbs </p> <p>Return value:</p> <ul> <li><code>true</code> Does have a tail </li> <li><code>false</code> Does not have a tail </li> </ul> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/animal_interface.h</code></p>"},{"location":"animal/classexample_1_1Bird/","title":"Class example::Bird","text":"<p>ClassList &gt; example &gt; Bird</p> <p>Inherits the following classes: example::Animal</p> <p>Inherited by the following classes: example::SpecialBird</p>"},{"location":"animal/classexample_1_1Bird/#public-types-inherited-from-exampleanimal","title":"Public Types inherited from example::Animal","text":"<p>See example::Animal</p> Type Name typedef std::pair&lt; Animal *, Animal * &gt; Parents enum Type The 6 classes of animal kingdom."},{"location":"animal/classexample_1_1Bird/#public-functions","title":"Public Functions","text":"Type Name Bird (const std::string &amp; name, Bird * mother=nullptr, Bird * father=nullptr)  Bird (const Bird &amp; other) = delete Bird (Bird &amp;&amp; Bird) noexcept virtual void make_sound () override virtual void move () override Bird &amp; operator= (const Bird &amp; other) = deleteDeleted copy operator. Bird &amp; operator= (Bird &amp;&amp; other) noexceptMove operator. void swap (Bird &amp; other) noexcept ~Bird () = default"},{"location":"animal/classexample_1_1Bird/#public-functions-inherited-from-exampleanimal","title":"Public Functions inherited from example::Animal","text":"<p>See example::Animal</p> Type Name Animal (Type type, const std::string &amp; name, Animal * mother=nullptr, Animal * father=nullptr) The main constructor. Animal (const Animal &amp; other) = delete Animal (Animal &amp;&amp; animal) noexcept const std::string &amp; get_name () constGet the name of the animal. virtual int get_num_of_eyes () override constReturns the number of eyes. virtual int get_num_of_limbs () override constReturns the number of limbs. Parents get_parents () const virtual bool has_tail () override constReturns true if the animal has a tail. virtual void make_sound () = 0 virtual void move ()  operator bool () constReturns true if this is an valid animal. Animal &amp; operator= (const Animal &amp; other) = deleteDeleted copy operator. Animal &amp; operator= (Animal &amp;&amp; other) noexceptMove operator. void some_inline_member_function (Animal * animal) Lorem Ipsum. void swap (Animal &amp; other) noexcept virtual ~Animal () = default"},{"location":"animal/classexample_1_1Bird/#public-functions-inherited-from-exampleanimalinterface","title":"Public Functions inherited from example::AnimalInterface","text":"<p>See example::AnimalInterface</p> Type Name virtual int get_num_of_eyes () const = 0Returns the number of eyes. virtual int get_num_of_limbs () const = 0Returns the number of limbs. virtual bool has_tail () const = 0Returns true if the animal has a tail."},{"location":"animal/classexample_1_1Bird/#public-static-functions-inherited-from-exampleanimal","title":"Public Static Functions inherited from example::Animal","text":"<p>See example::Animal</p> Type Name Animal * find_child_by_name (Animal * parent)  Animal * find_parent_by_name (Animal * child)"},{"location":"animal/classexample_1_1Bird/#protected-attributes-inherited-from-exampleanimal","title":"Protected Attributes inherited from example::Animal","text":"<p>See example::Animal</p> Type Name Animal * father The pointer to the father. Animal * mother The pointer to the mother. std::string name"},{"location":"animal/classexample_1_1Bird/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"animal/classexample_1_1Bird/#function-bird-13","title":"function Bird [1/3]","text":"<pre><code>example::Bird::Bird (\nconst std::string &amp; name,\nBird * mother=nullptr,\nBird * father=nullptr\n) </code></pre>"},{"location":"animal/classexample_1_1Bird/#function-bird-23","title":"function Bird [2/3]","text":"<pre><code>example::Bird::Bird (\nconst Bird &amp; other\n) = delete\n</code></pre>"},{"location":"animal/classexample_1_1Bird/#function-bird-33","title":"function Bird [3/3]","text":"<pre><code>example::Bird::Bird (\nBird &amp;&amp; Bird\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1Bird/#function-make_sound","title":"function make_sound","text":"<pre><code>virtual void example::Bird::make_sound () override\n</code></pre> <p>Implements example::Animal::make_sound</p>"},{"location":"animal/classexample_1_1Bird/#function-move","title":"function move","text":"<pre><code>virtual void example::Bird::move () override\n</code></pre> <p>Implements example::Animal::move</p>"},{"location":"animal/classexample_1_1Bird/#function-operator","title":"function operator=","text":"<pre><code>Bird &amp; example::Bird::operator= (\nconst Bird &amp; other\n) = delete\n</code></pre>"},{"location":"animal/classexample_1_1Bird/#function-operator_1","title":"function operator=","text":"<pre><code>Bird &amp; example::Bird::operator= (\nBird &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1Bird/#function-swap","title":"function swap","text":"<pre><code>void example::Bird::swap (\nBird &amp; other\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1Bird/#function-bird","title":"function ~Bird","text":"<pre><code>example::Bird::~Bird () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/bird.h</code></p>"},{"location":"animal/classexample_1_1CustomException/","title":"Class example::CustomException","text":"<p>ClassList &gt; example &gt; CustomException</p> <p>Inherits the following classes: std::exception</p>"},{"location":"animal/classexample_1_1CustomException/#public-functions","title":"Public Functions","text":"Type Name CustomException (const std::string &amp; msg)  virtual const char * what () const"},{"location":"animal/classexample_1_1CustomException/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"animal/classexample_1_1CustomException/#function-customexception","title":"function CustomException","text":"<pre><code>inline example::CustomException::CustomException (\nconst std::string &amp; msg\n) </code></pre>"},{"location":"animal/classexample_1_1CustomException/#function-what","title":"function what","text":"<pre><code>inline virtual const char * example::CustomException::what () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/utils/exception.h</code></p>"},{"location":"animal/classexample_1_1NumericException/","title":"Class example::NumericException","text":"<p>ClassList &gt; example &gt; NumericException</p> <p>Inherits the following classes: std::exception</p>"},{"location":"animal/classexample_1_1NumericException/#public-functions","title":"Public Functions","text":"Type Name NumericException (const std::string &amp; msg)  virtual const char * what () const"},{"location":"animal/classexample_1_1NumericException/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"animal/classexample_1_1NumericException/#function-numericexception","title":"function NumericException","text":"<pre><code>inline example::NumericException::NumericException (\nconst std::string &amp; msg\n) </code></pre>"},{"location":"animal/classexample_1_1NumericException/#function-what","title":"function what","text":"<pre><code>inline virtual const char * example::NumericException::what () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/utils/exception.h</code></p>"},{"location":"animal/classexample_1_1SpecialBird/","title":"Class example::SpecialBird","text":"<p>ClassList &gt; example &gt; SpecialBird</p> <p>Inherits the following classes: example::Bird</p>"},{"location":"animal/classexample_1_1SpecialBird/#public-types-inherited-from-exampleanimal","title":"Public Types inherited from example::Animal","text":"<p>See example::Animal</p> Type Name typedef std::pair&lt; Animal *, Animal * &gt; Parents enum Type The 6 classes of animal kingdom."},{"location":"animal/classexample_1_1SpecialBird/#public-functions","title":"Public Functions","text":"Type Name SpecialBird (const std::string &amp; name, SpecialBird * mother=nullptr, SpecialBird * father=nullptr)  SpecialBird (const SpecialBird &amp; other) = delete SpecialBird (SpecialBird &amp;&amp; SpecialBird) noexcept void do_something_special ()  SpecialBird &amp; operator= (const SpecialBird &amp; other) = delete SpecialBird &amp; operator= (SpecialBird &amp;&amp; other) noexcept void swap (SpecialBird &amp; other) noexcept ~SpecialBird () = default"},{"location":"animal/classexample_1_1SpecialBird/#public-functions-inherited-from-examplebird","title":"Public Functions inherited from example::Bird","text":"<p>See example::Bird</p> Type Name Bird (const std::string &amp; name, Bird * mother=nullptr, Bird * father=nullptr)  Bird (const Bird &amp; other) = delete Bird (Bird &amp;&amp; Bird) noexcept virtual void make_sound () override virtual void move () override Bird &amp; operator= (const Bird &amp; other) = deleteDeleted copy operator. Bird &amp; operator= (Bird &amp;&amp; other) noexceptMove operator. void swap (Bird &amp; other) noexcept ~Bird () = default"},{"location":"animal/classexample_1_1SpecialBird/#public-functions-inherited-from-exampleanimal","title":"Public Functions inherited from example::Animal","text":"<p>See example::Animal</p> Type Name Animal (Type type, const std::string &amp; name, Animal * mother=nullptr, Animal * father=nullptr) The main constructor. Animal (const Animal &amp; other) = delete Animal (Animal &amp;&amp; animal) noexcept const std::string &amp; get_name () constGet the name of the animal. virtual int get_num_of_eyes () override constReturns the number of eyes. virtual int get_num_of_limbs () override constReturns the number of limbs. Parents get_parents () const virtual bool has_tail () override constReturns true if the animal has a tail. virtual void make_sound () = 0 virtual void move ()  operator bool () constReturns true if this is an valid animal. Animal &amp; operator= (const Animal &amp; other) = deleteDeleted copy operator. Animal &amp; operator= (Animal &amp;&amp; other) noexceptMove operator. void some_inline_member_function (Animal * animal) Lorem Ipsum. void swap (Animal &amp; other) noexcept virtual ~Animal () = default"},{"location":"animal/classexample_1_1SpecialBird/#public-functions-inherited-from-exampleanimalinterface","title":"Public Functions inherited from example::AnimalInterface","text":"<p>See example::AnimalInterface</p> Type Name virtual int get_num_of_eyes () const = 0Returns the number of eyes. virtual int get_num_of_limbs () const = 0Returns the number of limbs. virtual bool has_tail () const = 0Returns true if the animal has a tail."},{"location":"animal/classexample_1_1SpecialBird/#public-static-functions-inherited-from-exampleanimal","title":"Public Static Functions inherited from example::Animal","text":"<p>See example::Animal</p> Type Name Animal * find_child_by_name (Animal * parent)  Animal * find_parent_by_name (Animal * child)"},{"location":"animal/classexample_1_1SpecialBird/#protected-attributes-inherited-from-exampleanimal","title":"Protected Attributes inherited from example::Animal","text":"<p>See example::Animal</p> Type Name Animal * father The pointer to the father. Animal * mother The pointer to the mother. std::string name"},{"location":"animal/classexample_1_1SpecialBird/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"animal/classexample_1_1SpecialBird/#function-specialbird-13","title":"function SpecialBird [1/3]","text":"<pre><code>example::SpecialBird::SpecialBird (\nconst std::string &amp; name,\nSpecialBird * mother=nullptr,\nSpecialBird * father=nullptr\n) </code></pre>"},{"location":"animal/classexample_1_1SpecialBird/#function-specialbird-23","title":"function SpecialBird [2/3]","text":"<pre><code>example::SpecialBird::SpecialBird (\nconst SpecialBird &amp; other\n) = delete\n</code></pre>"},{"location":"animal/classexample_1_1SpecialBird/#function-specialbird-33","title":"function SpecialBird [3/3]","text":"<pre><code>example::SpecialBird::SpecialBird (\nSpecialBird &amp;&amp; SpecialBird\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1SpecialBird/#function-do_something_special","title":"function do_something_special","text":"<pre><code>void example::SpecialBird::do_something_special () </code></pre>"},{"location":"animal/classexample_1_1SpecialBird/#function-operator","title":"function operator=","text":"<pre><code>SpecialBird &amp; example::SpecialBird::operator= (\nconst SpecialBird &amp; other\n) = delete\n</code></pre>"},{"location":"animal/classexample_1_1SpecialBird/#function-operator_1","title":"function operator=","text":"<pre><code>SpecialBird &amp; example::SpecialBird::operator= (\nSpecialBird &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1SpecialBird/#function-swap","title":"function swap","text":"<pre><code>void example::SpecialBird::swap (\nSpecialBird &amp; other\n) noexcept\n</code></pre>"},{"location":"animal/classexample_1_1SpecialBird/#function-specialbird","title":"function ~SpecialBird","text":"<pre><code>example::SpecialBird::~SpecialBird () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/special_bird.h</code></p>"},{"location":"animal/dir_9ba036507fddba3d714985d68e6a47f2/","title":"Dir demo-projets","text":"<p>FileList &gt; demo-projets</p>"},{"location":"animal/dir_9ba036507fddba3d714985d68e6a47f2/#directories","title":"Directories","text":"Type Name dir animal <p>The documentation for this class was generated from the following file <code>demo-projets/</code></p>"},{"location":"animal/dir_22eaa7c0bb807e057b5df3cac2aac6fd/","title":"Dir demo-projets/animal","text":"<p>FileList &gt; animal</p>"},{"location":"animal/dir_22eaa7c0bb807e057b5df3cac2aac6fd/#files","title":"Files","text":"Type Name file animal.h file animal_interface.h file bird.h file config.h This is a config file. file example.h file special_bird.h"},{"location":"animal/dir_22eaa7c0bb807e057b5df3cac2aac6fd/#directories","title":"Directories","text":"Type Name dir utils <p>The documentation for this class was generated from the following file <code>demo-projets/animal/</code></p>"},{"location":"animal/animal_8h/","title":"File animal.h","text":"<p>FileList &gt; animal &gt; animal.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include \"animal_interface.h\"</code></li> </ul>"},{"location":"animal/animal_8h/#namespaces","title":"Namespaces","text":"Type Name namespace example namespace inner_namespace"},{"location":"animal/animal_8h/#classes","title":"Classes","text":"Type Name class Animal Base class for all animals from which Bird derives. struct Result Some random inner class of Animal . class Vector"},{"location":"animal/animal_8h/#public-functions","title":"Public Functions","text":"Type Name void some_global_function (example::Animal * animal) Some random global function that modifies Animal."},{"location":"animal/animal_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"animal/animal_8h/#function-some_global_function","title":"function some_global_function","text":"<p>Some random global function that modifies Animal. <pre><code>void some_global_function (\nexample::Animal * animal\n) </code></pre></p> <p>See also: Animal </p> <p>Parameters:</p> <ul> <li><code>animal</code> The pointer to the animal instance </li> </ul> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/animal.h</code></p>"},{"location":"animal/animal_8h_source/","title":"File animal.h","text":"<p>File List &gt; animal &gt; animal.h</p> <p>Go to the documentation of this file. </p> <pre><code>#ifndef EXAMPLE_ANIMAL_H\n#define EXAMPLE_ANIMAL_H\n\n#include &lt;functional&gt;\n#include \"animal_interface.h\"\n\nnamespace example {\nnamespace inner_namespace {\nclass Vector {\nint x, y, z;\n};\n}\nclass Animal: public AnimalInterface {\npublic:\nenum Type {\nNONE = 0,\nINSECT = 1,\nAMPHIBIAN = 2,\nBIRD = 3,\nFISH = 4,\nREPTILE = 5,\nMAMMAL = 6\n};\n\ntypedef std::pair&lt;Animal*, Animal*&gt; Parents;\nstruct Result {\nconst Type type = Type::NONE;\nconst std::string name;\nconst Animal* mother = nullptr;\nconst Animal* father = nullptr;\n};\n\nstatic Animal* find_parent_by_name(Animal* child);\nstatic Animal* find_child_by_name(Animal* parent);\n\nAnimal(Type type, const std::string&amp; name, Animal* mother = nullptr, Animal* father = nullptr);\nAnimal(const Animal&amp; other) = delete;\nAnimal(Animal&amp;&amp; animal) noexcept;\nvirtual ~Animal() = default;\n\noperator bool() const;\n\nvoid swap(Animal&amp; other) noexcept;\n\nint get_num_of_limbs() const override;\n\nint get_num_of_eyes() const override;\n\nbool has_tail() const override;\n\nvirtual void move();\nvirtual void make_sound() = 0;\n\ninline Parents get_parents() const {\nreturn Parents(mother, father);\n}\n\ninline const std::string&amp; get_name() const {\nreturn name;\n}\ninline void some_inline_member_function(Animal* animal) {\ndo_more_things();\n\ncheck_best();\n}\n\nAnimal&amp; operator = (const Animal&amp; other) = delete;\nAnimal&amp; operator = (Animal&amp;&amp; other) noexcept;\n\nfriend void some_global_function(Animal* animal);\n\nprotected:\nAnimal* mother;\nAnimal* father;\nstd::string name;\n};\n\nvoid some_namespace_function(Animal* animal);\ntypedef std::function&lt;void*(Animal*)&gt; Callback;\nenum class CallbackType {\nNONE = 0,\nEAT,\nSLEEP,\nATTACK\n};\n}\n\nextern void some_global_function(example::Animal* animal);\n\n#endif\n</code></pre>"},{"location":"animal/animal__interface_8h/","title":"File animal_interface.h","text":"<p>FileList &gt; animal &gt; animal_interface.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"animal/animal__interface_8h/#namespaces","title":"Namespaces","text":"Type Name namespace example"},{"location":"animal/animal__interface_8h/#classes","title":"Classes","text":"Type Name interface AnimalInterface <p>The documentation for this class was generated from the following file <code>demo-projets/animal/animal_interface.h</code></p>"},{"location":"animal/animal__interface_8h_source/","title":"File animal_interface.h","text":"<p>File List &gt; animal &gt; animal_interface.h</p> <p>Go to the documentation of this file. </p> <pre><code>#ifndef EXAMPLE_ANIMAL_INTERFACE_H\n#define EXAMPLE_ANIMAL_INTERFACE_H\n\n#include &lt;string&gt;\n\nnamespace example {\nclass AnimalInterface {\npublic:\nvirtual int get_num_of_limbs() const = 0;\n\nvirtual int get_num_of_eyes() const = 0;\n\nvirtual bool has_tail() const = 0;\n};\n}\n\n#endif\n</code></pre>"},{"location":"animal/bird_8h/","title":"File bird.h","text":"<p>FileList &gt; animal &gt; bird.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"animal.h\"</code></li> </ul>"},{"location":"animal/bird_8h/#namespaces","title":"Namespaces","text":"Type Name namespace example"},{"location":"animal/bird_8h/#classes","title":"Classes","text":"Type Name class Bird <p>The documentation for this class was generated from the following file <code>demo-projets/animal/bird.h</code></p>"},{"location":"animal/bird_8h_source/","title":"File bird.h","text":"<p>File List &gt; animal &gt; bird.h</p> <p>Go to the documentation of this file. </p> <pre><code>#ifndef EXAMPLE_BIRD_H\n#define EXAMPLE_BIRD_H\n\n#include \"animal.h\"\n\nnamespace example {\nclass Bird: public Animal {\npublic:\nBird(const std::string&amp; name, Bird* mother = nullptr, Bird* father = nullptr);\nBird(const Bird&amp; other) = delete;\nBird(Bird&amp;&amp; Bird) noexcept;\n~Bird() = default;\n\nvoid swap(Bird&amp; other) noexcept;\n\nvoid move() override;\nvoid make_sound() override;\nBird&amp; operator = (const Bird&amp; other) = delete;\nBird&amp; operator = (Bird&amp;&amp; other) noexcept;\n};\n}\n\n#endif\n</code></pre>"},{"location":"animal/config_8h/","title":"File config.h","text":"<p>FileList &gt; animal &gt; config.h</p> <p>Go to the source code of this file.</p> <p>This is a config file. More...</p>"},{"location":"animal/config_8h/#macros","title":"Macros","text":"Type Name define CONFIG_HELLO  (123) define CONFIG_WORLD  (\"abx\") define PI  3.14159265358979323846 define PRINT_PRETTY (MSG, ...) printf(MSG, __VA_ARGS__)"},{"location":"animal/config_8h/#detailed-description","title":"Detailed Description","text":"<p>This is a detailed description </p>"},{"location":"animal/config_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"animal/config_8h/#define-config_hello","title":"define CONFIG_HELLO","text":"<pre><code>#define CONFIG_HELLO (123)\n</code></pre>"},{"location":"animal/config_8h/#define-config_world","title":"define CONFIG_WORLD","text":"<pre><code>#define CONFIG_WORLD (\"abx\")\n</code></pre>"},{"location":"animal/config_8h/#define-pi","title":"define PI","text":"<pre><code>#define PI 3.14159265358979323846\n</code></pre>"},{"location":"animal/config_8h/#define-print_pretty","title":"define PRINT_PRETTY","text":"<pre><code>#define PRINT_PRETTY (\nMSG,\n...\n) printf(MSG, __VA_ARGS__)\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/config.h</code></p>"},{"location":"animal/config_8h_source/","title":"File config.h","text":"<p>File List &gt; animal &gt; config.h</p> <p>Go to the documentation of this file. </p> <pre><code>#ifndef EXAMPLE_CONFIG_H\n#define EXAMPLE_CONFIG_H\n#define CONFIG_HELLO (123)\n#define CONFIG_WORLD (\"abx\")\n#define PI 3.14159265358979323846\n#define PRINT_PRETTY(MSG, ...) printf(MSG, __VA_ARGS__)\n\n#endif\n</code></pre>"},{"location":"animal/dir_9be598fa7bb93d6d3213f48e316de8fe/","title":"Dir demo-projets/animal/utils","text":"<p>FileList &gt; animal &gt; utils</p>"},{"location":"animal/dir_9be598fa7bb93d6d3213f48e316de8fe/#files","title":"Files","text":"Type Name file exception.h <p>The documentation for this class was generated from the following file <code>demo-projets/animal/utils/</code></p>"},{"location":"animal/exception_8h/","title":"File exception.h","text":"<p>FileList &gt; animal &gt; utils &gt; exception.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;exception&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"animal/exception_8h/#namespaces","title":"Namespaces","text":"Type Name namespace example"},{"location":"animal/exception_8h/#classes","title":"Classes","text":"Type Name class CustomException class NumericException <p>The documentation for this class was generated from the following file <code>demo-projets/animal/utils/exception.h</code></p>"},{"location":"animal/exception_8h_source/","title":"File exception.h","text":"<p>File List &gt; animal &gt; utils &gt; exception.h</p> <p>Go to the documentation of this file. </p> <pre><code>#ifndef EXAMPLE_EXCEPTION_H\n#define EXAMPLE_EXCEPTION_H\n\n#include &lt;exception&gt;\n#include &lt;string&gt;\n\nnamespace example {\nclass CustomException : public std::exception {\npublic:\nCustomException(const std::string&amp; msg):std::exception(),msg(msg){\n\n}\n\nvirtual const char* what() const throw() {\nreturn msg.c_str();\n}\n\nprivate:\nstd::string msg;\n};\n\nclass NumericException : public std::exception {\npublic:\nNumericException(const std::string&amp; msg):std::exception(),msg(msg){\n\n}\n\nvirtual const char* what() const throw() {\nreturn msg.c_str();\n}\n\nprivate:\nstd::string msg;\n};\n}\n\n#endif\n</code></pre>"},{"location":"animal/example_8h/","title":"File example.h","text":"<p>FileList &gt; animal &gt; example.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"animal.h\"</code></li> <li><code>#include \"bird.h\"</code></li> <li><code>#include \"utils/exception.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>demo-projets/animal/example.h</code></p>"},{"location":"animal/example_8h_source/","title":"File example.h","text":"<p>File List &gt; animal &gt; example.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n *\n * \\section intro_sec Introduction\n *\n * This is the introduction.\n *\n * \\section install_sec Installation\n *\n * \\subsection step1 Step 1: Opening the box\n *\n * etc...\n */\n\n#include \"animal.h\"\n#include \"bird.h\"\n#include \"utils/exception.h\"\n</code></pre>"},{"location":"animal/special__bird_8h/","title":"File special_bird.h","text":"<p>FileList &gt; animal &gt; special_bird.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"bird.h\"</code></li> </ul>"},{"location":"animal/special__bird_8h/#namespaces","title":"Namespaces","text":"Type Name namespace example"},{"location":"animal/special__bird_8h/#classes","title":"Classes","text":"Type Name class SpecialBird <p>The documentation for this class was generated from the following file <code>demo-projets/animal/special_bird.h</code></p>"},{"location":"animal/special__bird_8h_source/","title":"File special_bird.h","text":"<p>File List &gt; animal &gt; special_bird.h</p> <p>Go to the documentation of this file. </p> <pre><code>#ifndef EXAMPLE_SPECIAL_BIRD_H\n#define EXAMPLE_SPECIAL_BIRD_H\n\n#include \"bird.h\"\n\nnamespace example {\nclass SpecialBird: public Bird {\npublic:\nSpecialBird(const std::string&amp; name, SpecialBird* mother = nullptr, SpecialBird* father = nullptr);\nSpecialBird(const SpecialBird&amp; other) = delete;\nSpecialBird(SpecialBird&amp;&amp; SpecialBird) noexcept;\n~SpecialBird() = default;\n\nvoid swap(SpecialBird&amp; other) noexcept;\nvoid do_something_special();\n\nSpecialBird&amp; operator = (const SpecialBird&amp; other) = delete;\nSpecialBird&amp; operator = (SpecialBird&amp;&amp; other) noexcept;\n};\n}\n\n#endif\n</code></pre>"},{"location":"animal/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace example </li> <li>namespace inner_namespace </li> <li>namespace std </li> </ul>"},{"location":"animal/classes/","title":"Class Index","text":""},{"location":"animal/classes/#a","title":"a","text":"<ul> <li>Animal (example)</li> <li>AnimalInterface (example)</li> </ul>"},{"location":"animal/classes/#b","title":"b","text":"<ul> <li>Bird (example)</li> </ul>"},{"location":"animal/classes/#c","title":"c","text":"<ul> <li>CustomException (example)</li> </ul>"},{"location":"animal/classes/#n","title":"n","text":"<ul> <li>NumericException (example)</li> </ul>"},{"location":"animal/classes/#r","title":"r","text":"<ul> <li>Result (example::Animal)</li> </ul>"},{"location":"animal/classes/#s","title":"s","text":"<ul> <li>SpecialBird (example)</li> </ul>"},{"location":"animal/classes/#v","title":"v","text":"<ul> <li>Vector (example::inner_namespace)</li> </ul>"},{"location":"animal/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>interface example::AnimalInterface </li> <li>class example::Animal Base class for all animals from which Bird derives. <ul> <li>class example::Bird </li> <li>class example::SpecialBird </li> </ul> </li> <li>class example::inner_namespace::Vector </li> <li>struct example::Animal::Result Some random inner class of Animal .</li> <li>class std::exception </li> <li>class example::CustomException </li> <li>class example::NumericException </li> </ul>"},{"location":"animal/modules/","title":"Modules","text":"<p>Here is a list of all modules:</p> <ul> <li>Some organism example This is a brief description to the organism group. </li> <li>An animal group example This is a brief description to the animals group. </li> </ul>"},{"location":"animal/bug/","title":"Bug List","text":""},{"location":"animal/bug/#class-exampleanimal","title":"Class example::Animal","text":"<p>Some random bug </p>"},{"location":"animal/test/","title":"Test List","text":""},{"location":"animal/test/#class-exampleanimal","title":"Class example::Animal","text":"<p>Some random test description </p>"},{"location":"animal/todo/","title":"Todo List","text":""},{"location":"animal/todo/#class-exampleanimal","title":"Class example::Animal","text":"<p>Some random todo </p>"},{"location":"animal/pages/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p>"},{"location":"animal/class_members/","title":"Class Members","text":""},{"location":"animal/class_members/#a","title":"a","text":"<ul> <li>Animal (example::Animal)</li> </ul>"},{"location":"animal/class_members/#b","title":"b","text":"<ul> <li>Bird (example::Bird)</li> </ul>"},{"location":"animal/class_members/#c","title":"c","text":"<ul> <li>CustomException (example::CustomException)</li> </ul>"},{"location":"animal/class_members/#d","title":"d","text":"<ul> <li>do_something_special (example::SpecialBird)</li> </ul>"},{"location":"animal/class_members/#f","title":"f","text":"<ul> <li>father (example::Animal::Result, example::Animal)</li> <li>find_child_by_name (example::Animal)</li> <li>find_parent_by_name (example::Animal)</li> </ul>"},{"location":"animal/class_members/#g","title":"g","text":"<ul> <li>get_name (example::Animal)</li> <li>get_num_of_eyes (example::Animal, example::AnimalInterface)</li> <li>get_num_of_limbs (example::Animal, example::AnimalInterface)</li> <li>get_parents (example::Animal)</li> </ul>"},{"location":"animal/class_members/#h","title":"h","text":"<ul> <li>has_tail (example::Animal, example::AnimalInterface)</li> </ul>"},{"location":"animal/class_members/#m","title":"m","text":"<ul> <li>mother (example::Animal::Result, example::Animal)</li> <li>make_sound (example::Animal, example::Bird)</li> <li>move (example::Animal, example::Bird)</li> <li>msg (example::CustomException, example::NumericException)</li> </ul>"},{"location":"animal/class_members/#n","title":"n","text":"<ul> <li>name (example::Animal::Result, example::Animal)</li> <li>NumericException (example::NumericException)</li> </ul>"},{"location":"animal/class_members/#o","title":"o","text":"<ul> <li>operator bool (example::Animal)</li> <li>operator= (example::Animal, example::Bird, example::SpecialBird)</li> </ul>"},{"location":"animal/class_members/#p","title":"p","text":"<ul> <li>Parents (example::Animal)</li> </ul>"},{"location":"animal/class_members/#s","title":"s","text":"<ul> <li>some_inline_member_function (example::Animal)</li> <li>swap (example::Animal, example::Bird, example::SpecialBird)</li> <li>SpecialBird (example::SpecialBird)</li> </ul>"},{"location":"animal/class_members/#t","title":"t","text":"<ul> <li>Type (example::Animal)</li> <li>type (example::Animal::Result)</li> </ul>"},{"location":"animal/class_members/#w","title":"w","text":"<ul> <li>what (example::CustomException, example::NumericException)</li> </ul>"},{"location":"animal/class_members/#x","title":"x","text":"<ul> <li>x (example::inner_namespace::Vector)</li> </ul>"},{"location":"animal/class_members/#y","title":"y","text":"<ul> <li>y (example::inner_namespace::Vector)</li> </ul>"},{"location":"animal/class_members/#z","title":"z","text":"<ul> <li>z (example::inner_namespace::Vector)</li> </ul>"},{"location":"animal/class_members/#_1","title":"~","text":"<ul> <li>~Animal (example::Animal)</li> <li>~Bird (example::Bird)</li> <li>~SpecialBird (example::SpecialBird)</li> </ul>"},{"location":"animal/class_member_functions/","title":"Class Member Functions","text":""},{"location":"animal/class_member_functions/#a","title":"a","text":"<ul> <li>Animal (example::Animal)</li> </ul>"},{"location":"animal/class_member_functions/#b","title":"b","text":"<ul> <li>Bird (example::Bird)</li> </ul>"},{"location":"animal/class_member_functions/#c","title":"c","text":"<ul> <li>CustomException (example::CustomException)</li> </ul>"},{"location":"animal/class_member_functions/#d","title":"d","text":"<ul> <li>do_something_special (example::SpecialBird)</li> </ul>"},{"location":"animal/class_member_functions/#f","title":"f","text":"<ul> <li>find_child_by_name (example::Animal)</li> <li>find_parent_by_name (example::Animal)</li> </ul>"},{"location":"animal/class_member_functions/#g","title":"g","text":"<ul> <li>get_name (example::Animal)</li> <li>get_num_of_eyes (example::Animal, example::AnimalInterface)</li> <li>get_num_of_limbs (example::Animal, example::AnimalInterface)</li> <li>get_parents (example::Animal)</li> </ul>"},{"location":"animal/class_member_functions/#h","title":"h","text":"<ul> <li>has_tail (example::Animal, example::AnimalInterface)</li> </ul>"},{"location":"animal/class_member_functions/#m","title":"m","text":"<ul> <li>make_sound (example::Animal, example::Bird)</li> <li>move (example::Animal, example::Bird)</li> </ul>"},{"location":"animal/class_member_functions/#n","title":"n","text":"<ul> <li>NumericException (example::NumericException)</li> </ul>"},{"location":"animal/class_member_functions/#o","title":"o","text":"<ul> <li>operator bool (example::Animal)</li> <li>operator= (example::Animal, example::Bird, example::SpecialBird)</li> </ul>"},{"location":"animal/class_member_functions/#s","title":"s","text":"<ul> <li>some_inline_member_function (example::Animal)</li> <li>swap (example::Animal, example::Bird, example::SpecialBird)</li> <li>SpecialBird (example::SpecialBird)</li> </ul>"},{"location":"animal/class_member_functions/#w","title":"w","text":"<ul> <li>what (example::CustomException, example::NumericException)</li> </ul>"},{"location":"animal/class_member_functions/#_1","title":"~","text":"<ul> <li>~Animal (example::Animal)</li> <li>~Bird (example::Bird)</li> <li>~SpecialBird (example::SpecialBird)</li> </ul>"},{"location":"animal/class_member_variables/","title":"Class Member Variables","text":""},{"location":"animal/class_member_variables/#f","title":"f","text":"<ul> <li>father (example::Animal::Result, example::Animal)</li> </ul>"},{"location":"animal/class_member_variables/#m","title":"m","text":"<ul> <li>mother (example::Animal::Result, example::Animal)</li> <li>msg (example::CustomException, example::NumericException)</li> </ul>"},{"location":"animal/class_member_variables/#n","title":"n","text":"<ul> <li>name (example::Animal::Result, example::Animal)</li> </ul>"},{"location":"animal/class_member_variables/#t","title":"t","text":"<ul> <li>type (example::Animal::Result)</li> </ul>"},{"location":"animal/class_member_variables/#x","title":"x","text":"<ul> <li>x (example::inner_namespace::Vector)</li> </ul>"},{"location":"animal/class_member_variables/#y","title":"y","text":"<ul> <li>y (example::inner_namespace::Vector)</li> </ul>"},{"location":"animal/class_member_variables/#z","title":"z","text":"<ul> <li>z (example::inner_namespace::Vector)</li> </ul>"},{"location":"animal/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"animal/class_member_typedefs/#p","title":"p","text":"<ul> <li>Parents (example::Animal)</li> </ul>"},{"location":"animal/class_member_enums/","title":"Class Member Enums","text":""},{"location":"animal/class_member_enums/#t","title":"t","text":"<ul> <li>Type (example::Animal)</li> </ul>"},{"location":"animal/namespace_members/","title":"Namespace Members","text":""},{"location":"animal/namespace_members/#c","title":"c","text":"<ul> <li>Callback (example)</li> <li>CallbackType (example)</li> </ul>"},{"location":"animal/namespace_members/#s","title":"s","text":"<ul> <li>some_namespace_function (example)</li> </ul>"},{"location":"animal/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"animal/namespace_member_functions/#s","title":"s","text":"<ul> <li>some_namespace_function (example)</li> </ul>"},{"location":"animal/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"animal/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"animal/namespace_member_typedefs/#c","title":"c","text":"<ul> <li>Callback (example)</li> </ul>"},{"location":"animal/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"animal/namespace_member_enums/#c","title":"c","text":"<ul> <li>CallbackType (example)</li> </ul>"},{"location":"animal/functions/","title":"Functions","text":""},{"location":"animal/functions/#s","title":"s","text":"<ul> <li>some_global_function (animal.h)</li> </ul>"},{"location":"animal/macros/","title":"Macros","text":""},{"location":"animal/macros/#c","title":"c","text":"<ul> <li>CONFIG_HELLO (config.h)</li> <li>CONFIG_WORLD (config.h)</li> </ul>"},{"location":"animal/macros/#p","title":"p","text":"<ul> <li>PI (config.h)</li> <li>PRINT_PRETTY (config.h)</li> </ul>"},{"location":"animal/variables/","title":"Variables","text":""},{"location":"animal/links/","title":"Links","text":"<ul> <li>Related Pages<ul> <li>Bug List</li> <li>Test List</li> <li>Todo List</li> </ul> </li> <li>Modules<ul> <li>Some organism example</li> <li>An animal group example</li> </ul> </li> <li>Class List<ul> <li>namespace example</li> <li>class example::Animal<ul> <li>struct example::Animal::Result</li> </ul> </li> <li>interface example::AnimalInterface</li> <li>class example::Bird</li> <li>class example::CustomException</li> <li>class example::NumericException</li> <li>class example::SpecialBird</li> <li>namespace example::inner_namespace<ul> <li>class example::inner_namespace::Vector</li> </ul> </li> <li>namespace std</li> </ul> </li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files<ul> <li>demo-projets</li> <li>demo-projets/animal<ul> <li>animal.h</li> <li>animal.h source</li> <li>animal_interface.h</li> <li>animal_interface.h source</li> <li>bird.h</li> <li>bird.h source</li> <li>config.h</li> <li>config.h source</li> <li>demo-projets/animal/utils</li> <li>exception.h</li> <li>exception.h source</li> <li>example.h</li> <li>example.h source</li> <li>special_bird.h</li> <li>special_bird.h source</li> </ul> </li> </ul> </li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"stm/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class BasePriorityRaiser </li> <li>class ByteFifo </li> <li>struct CalibrationData </li> <li>class Esp32Manager </li> <li>struct FontDef </li> <li>struct MPU6050_t </li> <li>class MessageBufferWrapper </li> <li>class Motor </li> <li>struct MpuMotion32 </li> <li>struct MpuMotion6 </li> <li>struct MpuVector </li> <li>struct MpuVector32 </li> <li>class MutexWrapper </li> <li>struct OLED_VERTEX </li> <li>struct OLED_t </li> <li>class QueueWrapper </li> <li>struct Regulator </li> <li>class StreamBufferWrapper </li> <li>class TaskWrapper </li> <li>class TickTimer </li> <li>class XorShift Fast deterministic PRNG - https://en.wikipedia.org/wiki/Xorshift . </li> <li>struct __debug_descriptors </li> <li>struct cdc_config </li> <li>struct mpu_t </li> </ul>"},{"location":"stm/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>file Readme.md </li> <li>dir demo-projets </li> <li>dir stm32 <ul> <li>dir include </li> <li>file Bsp.hpp </li> <li>file ButtonController.hpp </li> <li>file BuzzerController.hpp </li> <li>file CdcUartTunnel.hpp </li> <li>file ControlLink.hpp </li> <li>file DebugLink.hpp </li> <li>file Dispatcher.hpp </li> <li>file Esp32Manager.hpp </li> <li>file FreeRTOSConfig.h </li> <li>file I2cController.hpp </li> <li>file Motor.hpp </li> <li>file MotorController.hpp </li> <li>file Mpu6050.hpp </li> <li>file MpuController.hpp </li> <li>file OledController.hpp </li> <li>file OledController_fonts.hpp </li> <li>file Power.hpp </li> <li>file StupidServoController.hpp </li> <li>file UltrasoundController.hpp </li> <li>file UsbCdcLink.h </li> <li>dir utils <ul> <li>file BasePriorityRaiser.hpp </li> <li>file ByteFifo.hpp </li> <li>file Debug.hpp </li> <li>file Flash.hpp </li> <li>file HalDma.hpp </li> <li>file MessageBufferWrapper.hpp </li> <li>file MutexWrapper.hpp </li> <li>file QueueWrapper.hpp </li> <li>file Regulator.hpp </li> <li>file StreamBufferWrapper.hpp </li> <li>file TaskWrapper.hpp </li> <li>file TickTimer.hpp </li> <li>file XorShift.hpp </li> </ul> </li> <li>dir src </li> <li>file Bsp.cpp </li> <li>file ButtonController.cpp </li> <li>file CdcUartTunnel.cpp </li> <li>file ControlLink.cpp </li> <li>file DebugLink.cpp </li> <li>file Dispatcher.cpp </li> <li>file Esp32Manager.cpp </li> <li>file FreeRTOSCallbacks.cpp </li> <li>file I2cController.cpp </li> <li>file MotorController.cpp </li> <li>file MpuController.cpp </li> <li>file OledController.cpp </li> <li>file OledController_fonts.cpp </li> <li>file Power.cpp </li> <li>file StupidServoController.cpp </li> <li>file UltrasoundController.cpp </li> <li>file UsbCdcDescriptors.c </li> <li>file UsbCdcLink.cpp </li> <li>dir utils <ul> <li>file Debug.cpp </li> </ul> </li> <li>file main.cpp </li> </ul> </li> </ul>"},{"location":"stm/classBasePriorityRaiser/","title":"Class BasePriorityRaiser","text":"<p>template &lt;uint32_t TargetIrqPriority&gt;</p> <p>ClassList &gt; BasePriorityRaiser</p>"},{"location":"stm/classBasePriorityRaiser/#public-functions","title":"Public Functions","text":"Type Name BasePriorityRaiser ()  void lock ()  void unlock ()  ~BasePriorityRaiser ()"},{"location":"stm/classBasePriorityRaiser/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/classBasePriorityRaiser/#function-basepriorityraiser-12","title":"function BasePriorityRaiser [1/2]","text":"<pre><code>inline BasePriorityRaiser::BasePriorityRaiser () </code></pre>"},{"location":"stm/classBasePriorityRaiser/#function-lock","title":"function lock","text":"<pre><code>inline void BasePriorityRaiser::lock () </code></pre>"},{"location":"stm/classBasePriorityRaiser/#function-unlock","title":"function unlock","text":"<pre><code>inline void BasePriorityRaiser::unlock () </code></pre>"},{"location":"stm/classBasePriorityRaiser/#function-basepriorityraiser","title":"function ~BasePriorityRaiser","text":"<pre><code>inline BasePriorityRaiser::~BasePriorityRaiser () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/BasePriorityRaiser.hpp</code></p>"},{"location":"stm/classByteFifo/","title":"Class ByteFifo","text":"<p>template &lt;int Size&gt;</p> <p>ClassList &gt; ByteFifo</p> <p>More...</p> <ul> <li><code>#include &lt;ByteFifo.hpp&gt;</code></li> </ul>"},{"location":"stm/classByteFifo/#public-functions","title":"Public Functions","text":"Type Name ByteFifo ()  size_t available () constReadable bytes. void clear () Clears the buffer by setting m_tail = m_head;. uint8_t * data () constPointer to the beginning. bool hasData () constTrue if some data is ready for reading. void notifyRead (size_t len) Move the read index (tail), indicating len bytes have been read out. void notifyWritten (size_t len) Move the write index (head), indicating len bytes have been written. void peekSpan (uint8_t * data, size_t len) Read len bytes into buffer starting at data. uint8_t pop () Reads one byte, must be available. void push (uint8_t b) Writes one byte. std::pair&lt; uint8_t *, size_t &gt; readableSpan () const void setHead (int newHead) Override the write index aka. head. constexpr size_t size () constTotal capacity. void writeSpan (uint8_t * data, size_t len) Write len bytes into buffer starting at data. std::pair&lt; uint8_t *, size_t &gt; writeableSpan () const"},{"location":"stm/classByteFifo/#detailed-description","title":"Detailed Description","text":"<p>A DMA-ready byte ring buffer with contiguous I/O API Allows direct read/write access using: readableSpan() -&gt; read-out -&gt; notifyRead() writeableSpan() -&gt; write-in -&gt; notifyWritten() </p>"},{"location":"stm/classByteFifo/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/classByteFifo/#function-bytefifo","title":"function ByteFifo","text":"<pre><code>inline ByteFifo::ByteFifo () </code></pre>"},{"location":"stm/classByteFifo/#function-available","title":"function available","text":"<pre><code>inline size_t ByteFifo::available () const\n</code></pre>"},{"location":"stm/classByteFifo/#function-clear","title":"function clear","text":"<pre><code>inline void ByteFifo::clear () </code></pre>"},{"location":"stm/classByteFifo/#function-data","title":"function data","text":"<pre><code>inline uint8_t * ByteFifo::data () const\n</code></pre>"},{"location":"stm/classByteFifo/#function-hasdata","title":"function hasData","text":"<pre><code>inline bool ByteFifo::hasData () const\n</code></pre>"},{"location":"stm/classByteFifo/#function-notifyread","title":"function notifyRead","text":"<pre><code>inline void ByteFifo::notifyRead (\nsize_t len\n) </code></pre>"},{"location":"stm/classByteFifo/#function-notifywritten","title":"function notifyWritten","text":"<pre><code>inline void ByteFifo::notifyWritten (\nsize_t len\n) </code></pre>"},{"location":"stm/classByteFifo/#function-peekspan","title":"function peekSpan","text":"<pre><code>inline void ByteFifo::peekSpan (\nuint8_t * data,\nsize_t len\n) </code></pre>"},{"location":"stm/classByteFifo/#function-pop","title":"function pop","text":"<pre><code>inline uint8_t ByteFifo::pop () </code></pre>"},{"location":"stm/classByteFifo/#function-push","title":"function push","text":"<pre><code>inline void ByteFifo::push (\nuint8_t b\n) </code></pre>"},{"location":"stm/classByteFifo/#function-readablespan","title":"function readableSpan","text":"<pre><code>inline std::pair&lt; uint8_t *, size_t &gt; ByteFifo::readableSpan () const\n</code></pre> <p>Gets a contiguous range of bytes ready for reading. Doesn't represent all readable bytes if wrapped over the end. Zero size_t means FIFO is empty. </p>"},{"location":"stm/classByteFifo/#function-sethead","title":"function setHead","text":"<pre><code>inline void ByteFifo::setHead (\nint newHead\n) </code></pre>"},{"location":"stm/classByteFifo/#function-size","title":"function size","text":"<pre><code>inline constexpr size_t ByteFifo::size () const\n</code></pre>"},{"location":"stm/classByteFifo/#function-writespan","title":"function writeSpan","text":"<pre><code>inline void ByteFifo::writeSpan (\nuint8_t * data,\nsize_t len\n) </code></pre>"},{"location":"stm/classByteFifo/#function-writeablespan","title":"function writeableSpan","text":"<pre><code>inline std::pair&lt; uint8_t *, size_t &gt; ByteFifo::writeableSpan () const\n</code></pre> <p>Gets a contiguous range of bytes ready for writing. Doesn't represent all writeable bytes if wrapped over the end. Zero size_t means FIFO is full. </p> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/ByteFifo.hpp</code></p>"},{"location":"stm/structCalibrationData/","title":"Struct CalibrationData","text":"<p>ClassList &gt; CalibrationData</p>"},{"location":"stm/structCalibrationData/#public-attributes","title":"Public Attributes","text":"Type Name float batteryCoef float batteryMidCoef uint16_t internalVrefMv uint32_t magic uint16_t tempTypicalAtC uint16_t tempTypicalMv"},{"location":"stm/structCalibrationData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/structCalibrationData/#variable-batterycoef","title":"variable batteryCoef","text":"<pre><code>float CalibrationData::batteryCoef;\n</code></pre>"},{"location":"stm/structCalibrationData/#variable-batterymidcoef","title":"variable batteryMidCoef","text":"<pre><code>float CalibrationData::batteryMidCoef;\n</code></pre>"},{"location":"stm/structCalibrationData/#variable-internalvrefmv","title":"variable internalVrefMv","text":"<pre><code>uint16_t CalibrationData::internalVrefMv;\n</code></pre>"},{"location":"stm/structCalibrationData/#variable-magic","title":"variable magic","text":"<pre><code>uint32_t CalibrationData::magic;\n</code></pre>"},{"location":"stm/structCalibrationData/#variable-temptypicalatc","title":"variable tempTypicalAtC","text":"<pre><code>uint16_t CalibrationData::tempTypicalAtC;\n</code></pre>"},{"location":"stm/structCalibrationData/#variable-temptypicalmv","title":"variable tempTypicalMv","text":"<pre><code>uint16_t CalibrationData::tempTypicalMv;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/Power.cpp</code></p>"},{"location":"stm/classEsp32Manager/","title":"Class Esp32Manager","text":"<p>ClassList &gt; Esp32Manager</p>"},{"location":"stm/classEsp32Manager/#public-functions","title":"Public Functions","text":"Type Name Esp32Manager ()  void init ()  bool isInBootloader () const void onEnRisingInIrq ()  void onSerialBreakInIrq (bool dtr, bool rst)  void poll ()  void queueReset (bool bootloader=false)  void resetWatchdog ()  void setWatchdogInhibit (bool inhibit)  ~Esp32Manager ()"},{"location":"stm/classEsp32Manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/classEsp32Manager/#function-esp32manager-22","title":"function Esp32Manager [2/2]","text":"<pre><code>Esp32Manager::Esp32Manager () </code></pre>"},{"location":"stm/classEsp32Manager/#function-init","title":"function init","text":"<pre><code>void Esp32Manager::init () </code></pre>"},{"location":"stm/classEsp32Manager/#function-isinbootloader","title":"function isInBootloader","text":"<pre><code>inline bool Esp32Manager::isInBootloader () const\n</code></pre>"},{"location":"stm/classEsp32Manager/#function-onenrisinginirq","title":"function onEnRisingInIrq","text":"<pre><code>void Esp32Manager::onEnRisingInIrq () </code></pre>"},{"location":"stm/classEsp32Manager/#function-onserialbreakinirq","title":"function onSerialBreakInIrq","text":"<pre><code>void Esp32Manager::onSerialBreakInIrq (\nbool dtr,\nbool rst\n) </code></pre>"},{"location":"stm/classEsp32Manager/#function-poll","title":"function poll","text":"<pre><code>void Esp32Manager::poll () </code></pre>"},{"location":"stm/classEsp32Manager/#function-queuereset","title":"function queueReset","text":"<pre><code>void Esp32Manager::queueReset (\nbool bootloader=false\n) </code></pre>"},{"location":"stm/classEsp32Manager/#function-resetwatchdog","title":"function resetWatchdog","text":"<pre><code>void Esp32Manager::resetWatchdog () </code></pre>"},{"location":"stm/classEsp32Manager/#function-setwatchdoginhibit","title":"function setWatchdogInhibit","text":"<pre><code>void Esp32Manager::setWatchdogInhibit (\nbool inhibit\n) </code></pre>"},{"location":"stm/classEsp32Manager/#function-esp32manager","title":"function ~Esp32Manager","text":"<pre><code>Esp32Manager::~Esp32Manager () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/Esp32Manager.hpp</code></p>"},{"location":"stm/structFontDef/","title":"Struct FontDef","text":"<p>ClassList &gt; FontDef</p>"},{"location":"stm/structFontDef/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t FontHeight const uint8_t FontWidth const uint16_t * data"},{"location":"stm/structFontDef/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/structFontDef/#variable-fontheight","title":"variable FontHeight","text":"<pre><code>uint8_t FontDef::FontHeight;\n</code></pre> <p>Font height in pixels </p>"},{"location":"stm/structFontDef/#variable-fontwidth","title":"variable FontWidth","text":"<pre><code>const uint8_t FontDef::FontWidth;\n</code></pre> <p>Font width in pixels </p>"},{"location":"stm/structFontDef/#variable-data","title":"variable data","text":"<pre><code>const uint16_t* FontDef::data;\n</code></pre> <p>Pointer to data font data array </p> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/OledController_fonts.hpp</code></p>"},{"location":"stm/structMPU6050__t/","title":"Struct MPU6050_t","text":"<p>ClassList &gt; MPU6050_t</p>"},{"location":"stm/structMPU6050__t/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t buffer uint8_t devAddr"},{"location":"stm/structMPU6050__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/structMPU6050__t/#variable-buffer","title":"variable buffer","text":"<pre><code>uint8_t MPU6050_t::buffer[14];\n</code></pre>"},{"location":"stm/structMPU6050__t/#variable-devaddr","title":"variable devAddr","text":"<pre><code>uint8_t MPU6050_t::devAddr;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/Mpu6050.hpp</code></p>"},{"location":"stm/classMessageBufferWrapper/","title":"Class MessageBufferWrapper","text":"<p>template &lt;size_t SizeInBytes&gt;</p> <p>ClassList &gt; MessageBufferWrapper</p>"},{"location":"stm/classMessageBufferWrapper/#public-functions","title":"Public Functions","text":"Type Name MessageBufferWrapper ()  void create ()  MessageBufferHandle_t handle () const size_t pop_front (uint8_t * dst, size_t maxLen, TickType_t ticks_to_wait, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  bool pop_front (T &amp; dst, TickType_t ticks_to_wait, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  bool push_back (uint8_t * data, size_t len, TickType_t ticks_to_wait, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  bool push_back (const T &amp; val, TickType_t ticks_to_wait, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  bool reset ()  ~MessageBufferWrapper ()"},{"location":"stm/classMessageBufferWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/classMessageBufferWrapper/#function-messagebufferwrapper","title":"function MessageBufferWrapper","text":"<pre><code>inline MessageBufferWrapper::MessageBufferWrapper () </code></pre>"},{"location":"stm/classMessageBufferWrapper/#function-create","title":"function create","text":"<pre><code>inline void MessageBufferWrapper::create () </code></pre>"},{"location":"stm/classMessageBufferWrapper/#function-handle","title":"function handle","text":"<pre><code>inline MessageBufferHandle_t MessageBufferWrapper::handle () const\n</code></pre>"},{"location":"stm/classMessageBufferWrapper/#function-pop_front-12","title":"function pop_front [1/2]","text":"<pre><code>inline size_t MessageBufferWrapper::pop_front (\nuint8_t * dst,\nsize_t maxLen,\nTickType_t ticks_to_wait,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"stm/classMessageBufferWrapper/#function-pop_front-22","title":"function pop_front [2/2]","text":"<pre><code>template&lt;typename T typename T&gt;\ninline bool MessageBufferWrapper::pop_front (\nT &amp; dst,\nTickType_t ticks_to_wait,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"stm/classMessageBufferWrapper/#function-push_back-12","title":"function push_back [1/2]","text":"<pre><code>inline bool MessageBufferWrapper::push_back (\nuint8_t * data,\nsize_t len,\nTickType_t ticks_to_wait,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"stm/classMessageBufferWrapper/#function-push_back-22","title":"function push_back [2/2]","text":"<pre><code>template&lt;typename T typename T&gt;\ninline bool MessageBufferWrapper::push_back (\nconst T &amp; val,\nTickType_t ticks_to_wait,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"stm/classMessageBufferWrapper/#function-reset","title":"function reset","text":"<pre><code>inline bool MessageBufferWrapper::reset () </code></pre>"},{"location":"stm/classMessageBufferWrapper/#function-messagebufferwrapper_1","title":"function ~MessageBufferWrapper","text":"<pre><code>inline MessageBufferWrapper::~MessageBufferWrapper () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/MessageBufferWrapper.hpp</code></p>"},{"location":"stm/classMotor/","title":"Class Motor","text":"<p>ClassList &gt; Motor</p>"},{"location":"stm/classMotor/#public-functions","title":"Public Functions","text":"Type Name Motor ()  bool atStandstill () const bool atTargetPosition () const void homePosition (int32_t homedTicks)  MotorMode mode () const void modeChange (MotorMode newMode)  int16_t poll (uint16_t encTicks)  void reportStat (CoprocStat_MotorStat &amp; stat)  void reset ()  void setConfig (const MotorConfig &amp; config)  void setPositionPid (const RegCoefs &amp; coefs)  void setTargetBrakingPower (int16_t brakingPower)  void setTargetPosition (const CoprocReq_MotorReq_SetPosition &amp; req, bool additive)  void setTargetPower (int16_t power)  void setTargetVelocity (int16_t ticksPerSec)  void setVelocityPid (const RegCoefs &amp; coefs)"},{"location":"stm/classMotor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/classMotor/#function-motor","title":"function Motor","text":"<pre><code>inline Motor::Motor () </code></pre>"},{"location":"stm/classMotor/#function-atstandstill","title":"function atStandstill","text":"<pre><code>inline bool Motor::atStandstill () const\n</code></pre>"},{"location":"stm/classMotor/#function-attargetposition","title":"function atTargetPosition","text":"<pre><code>inline bool Motor::atTargetPosition () const\n</code></pre>"},{"location":"stm/classMotor/#function-homeposition","title":"function homePosition","text":"<pre><code>inline void Motor::homePosition (\nint32_t homedTicks\n) </code></pre>"},{"location":"stm/classMotor/#function-mode","title":"function mode","text":"<pre><code>inline MotorMode Motor::mode () const\n</code></pre>"},{"location":"stm/classMotor/#function-modechange","title":"function modeChange","text":"<pre><code>inline void Motor::modeChange (\nMotorMode newMode\n) </code></pre>"},{"location":"stm/classMotor/#function-poll","title":"function poll","text":"<pre><code>inline int16_t Motor::poll (\nuint16_t encTicks\n) </code></pre>"},{"location":"stm/classMotor/#function-reportstat","title":"function reportStat","text":"<pre><code>inline void Motor::reportStat (\nCoprocStat_MotorStat &amp; stat\n) </code></pre>"},{"location":"stm/classMotor/#function-reset","title":"function reset","text":"<pre><code>inline void Motor::reset () </code></pre>"},{"location":"stm/classMotor/#function-setconfig","title":"function setConfig","text":"<pre><code>inline void Motor::setConfig (\nconst MotorConfig &amp; config\n) </code></pre>"},{"location":"stm/classMotor/#function-setpositionpid","title":"function setPositionPid","text":"<pre><code>inline void Motor::setPositionPid (\nconst RegCoefs &amp; coefs\n) </code></pre>"},{"location":"stm/classMotor/#function-settargetbrakingpower","title":"function setTargetBrakingPower","text":"<pre><code>inline void Motor::setTargetBrakingPower (\nint16_t brakingPower\n) </code></pre>"},{"location":"stm/classMotor/#function-settargetposition","title":"function setTargetPosition","text":"<pre><code>inline void Motor::setTargetPosition (\nconst CoprocReq_MotorReq_SetPosition &amp; req,\nbool additive\n) </code></pre>"},{"location":"stm/classMotor/#function-settargetpower","title":"function setTargetPower","text":"<pre><code>inline void Motor::setTargetPower (\nint16_t power\n) </code></pre>"},{"location":"stm/classMotor/#function-settargetvelocity","title":"function setTargetVelocity","text":"<pre><code>inline void Motor::setTargetVelocity (\nint16_t ticksPerSec\n) </code></pre>"},{"location":"stm/classMotor/#function-setvelocitypid","title":"function setVelocityPid","text":"<pre><code>inline void Motor::setVelocityPid (\nconst RegCoefs &amp; coefs\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/Motor.hpp</code></p>"},{"location":"stm/structMpuMotion32/","title":"Struct MpuMotion32","text":"<p>ClassList &gt; MpuMotion32</p>"},{"location":"stm/structMpuMotion32/#public-attributes","title":"Public Attributes","text":"Type Name MpuVector32 accel MpuVector32 gyro"},{"location":"stm/structMpuMotion32/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/structMpuMotion32/#variable-accel","title":"variable accel","text":"<pre><code>MpuVector32 MpuMotion32::accel;\n</code></pre>"},{"location":"stm/structMpuMotion32/#variable-gyro","title":"variable gyro","text":"<pre><code>MpuVector32 MpuMotion32::gyro;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/MpuController.cpp</code></p>"},{"location":"stm/structMpuMotion6/","title":"Struct MpuMotion6","text":"<p>ClassList &gt; MpuMotion6</p>"},{"location":"stm/structMpuMotion6/#public-attributes","title":"Public Attributes","text":"Type Name MpuVector accel MpuVector gyro"},{"location":"stm/structMpuMotion6/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/structMpuMotion6/#variable-accel","title":"variable accel","text":"<pre><code>MpuVector MpuMotion6::accel;\n</code></pre>"},{"location":"stm/structMpuMotion6/#variable-gyro","title":"variable gyro","text":"<pre><code>MpuVector MpuMotion6::gyro;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/MpuController.cpp</code></p>"},{"location":"stm/structMpuVector/","title":"Struct MpuVector","text":"<p>ClassList &gt; MpuVector</p>"},{"location":"stm/structMpuVector/#public-attributes","title":"Public Attributes","text":"Type Name int16_t x int16_t y int16_t z"},{"location":"stm/structMpuVector/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/structMpuVector/#variable-x","title":"variable x","text":"<pre><code>int16_t MpuVector::x;\n</code></pre>"},{"location":"stm/structMpuVector/#variable-y","title":"variable y","text":"<pre><code>int16_t MpuVector::y;\n</code></pre>"},{"location":"stm/structMpuVector/#variable-z","title":"variable z","text":"<pre><code>int16_t MpuVector::z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/MpuController.cpp</code></p>"},{"location":"stm/structMpuVector32/","title":"Struct MpuVector32","text":"<p>ClassList &gt; MpuVector32</p>"},{"location":"stm/structMpuVector32/#public-attributes","title":"Public Attributes","text":"Type Name int32_t x int32_t y int32_t z"},{"location":"stm/structMpuVector32/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/structMpuVector32/#variable-x","title":"variable x","text":"<pre><code>int32_t MpuVector32::x;\n</code></pre>"},{"location":"stm/structMpuVector32/#variable-y","title":"variable y","text":"<pre><code>int32_t MpuVector32::y;\n</code></pre>"},{"location":"stm/structMpuVector32/#variable-z","title":"variable z","text":"<pre><code>int32_t MpuVector32::z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/MpuController.cpp</code></p>"},{"location":"stm/classMutexWrapper/","title":"Class MutexWrapper","text":"<p>ClassList &gt; MutexWrapper</p>"},{"location":"stm/classMutexWrapper/#public-functions","title":"Public Functions","text":"Type Name MutexWrapper ()  void create ()  void lock ()  SemaphoreHandle_t native_handle () const void unlock ()  ~MutexWrapper ()"},{"location":"stm/classMutexWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/classMutexWrapper/#function-mutexwrapper","title":"function MutexWrapper","text":"<pre><code>inline MutexWrapper::MutexWrapper () </code></pre>"},{"location":"stm/classMutexWrapper/#function-create","title":"function create","text":"<pre><code>inline void MutexWrapper::create () </code></pre>"},{"location":"stm/classMutexWrapper/#function-lock","title":"function lock","text":"<pre><code>inline void MutexWrapper::lock () </code></pre>"},{"location":"stm/classMutexWrapper/#function-native_handle","title":"function native_handle","text":"<pre><code>inline SemaphoreHandle_t MutexWrapper::native_handle () const\n</code></pre>"},{"location":"stm/classMutexWrapper/#function-unlock","title":"function unlock","text":"<pre><code>inline void MutexWrapper::unlock () </code></pre>"},{"location":"stm/classMutexWrapper/#function-mutexwrapper_1","title":"function ~MutexWrapper","text":"<pre><code>inline MutexWrapper::~MutexWrapper () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/MutexWrapper.hpp</code></p>"},{"location":"stm/structOLED__VERTEX/","title":"Struct OLED_VERTEX","text":"<p>ClassList &gt; OLED_VERTEX</p>"},{"location":"stm/structOLED__VERTEX/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t x uint8_t y"},{"location":"stm/structOLED__VERTEX/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/structOLED__VERTEX/#variable-x","title":"variable x","text":"<pre><code>uint8_t OLED_VERTEX::x;\n</code></pre>"},{"location":"stm/structOLED__VERTEX/#variable-y","title":"variable y","text":"<pre><code>uint8_t OLED_VERTEX::y;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/OledController.hpp</code></p>"},{"location":"stm/structOLED__t/","title":"Struct OLED_t","text":"<p>ClassList &gt; OLED_t</p>"},{"location":"stm/structOLED__t/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t CurrentX uint16_t CurrentY bool DisplayOn uint8_t Inverted"},{"location":"stm/structOLED__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/structOLED__t/#variable-currentx","title":"variable CurrentX","text":"<pre><code>uint16_t OLED_t::CurrentX;\n</code></pre>"},{"location":"stm/structOLED__t/#variable-currenty","title":"variable CurrentY","text":"<pre><code>uint16_t OLED_t::CurrentY;\n</code></pre>"},{"location":"stm/structOLED__t/#variable-displayon","title":"variable DisplayOn","text":"<pre><code>bool OLED_t::DisplayOn;\n</code></pre>"},{"location":"stm/structOLED__t/#variable-inverted","title":"variable Inverted","text":"<pre><code>uint8_t OLED_t::Inverted;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/OledController.hpp</code></p>"},{"location":"stm/classQueueWrapper/","title":"Class QueueWrapper","text":"<p>template &lt;typename T typename T, UBaseType_t Length&gt;</p> <p>ClassList &gt; QueueWrapper</p>"},{"location":"stm/classQueueWrapper/#public-functions","title":"Public Functions","text":"Type Name QueueWrapper ()  void create ()  QueueHandle_t handle () const bool overwrite (const T &amp; val, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  bool pop_front (T &amp; result, TickType_t ticks_to_wait=portMAX_DELAY, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  bool push_back (const T &amp; val, TickType_t ticks_to_wait=portMAX_DELAY, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  bool push_front (const T &amp; val, TickType_t ticks_to_wait=portMAX_DELAY, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  void reset ()  ~QueueWrapper ()"},{"location":"stm/classQueueWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/classQueueWrapper/#function-queuewrapper-12","title":"function QueueWrapper [1/2]","text":"<pre><code>inline QueueWrapper::QueueWrapper () </code></pre>"},{"location":"stm/classQueueWrapper/#function-create","title":"function create","text":"<pre><code>inline void QueueWrapper::create () </code></pre>"},{"location":"stm/classQueueWrapper/#function-handle","title":"function handle","text":"<pre><code>inline QueueHandle_t QueueWrapper::handle () const\n</code></pre>"},{"location":"stm/classQueueWrapper/#function-overwrite","title":"function overwrite","text":"<pre><code>inline bool QueueWrapper::overwrite (\nconst T &amp; val,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"stm/classQueueWrapper/#function-pop_front","title":"function pop_front","text":"<pre><code>inline bool QueueWrapper::pop_front (\nT &amp; result,\nTickType_t ticks_to_wait=portMAX_DELAY,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"stm/classQueueWrapper/#function-push_back","title":"function push_back","text":"<pre><code>inline bool QueueWrapper::push_back (\nconst T &amp; val,\nTickType_t ticks_to_wait=portMAX_DELAY,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"stm/classQueueWrapper/#function-push_front","title":"function push_front","text":"<pre><code>inline bool QueueWrapper::push_front (\nconst T &amp; val,\nTickType_t ticks_to_wait=portMAX_DELAY,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"stm/classQueueWrapper/#function-reset","title":"function reset","text":"<pre><code>inline void QueueWrapper::reset () </code></pre>"},{"location":"stm/classQueueWrapper/#function-queuewrapper","title":"function ~QueueWrapper","text":"<pre><code>inline QueueWrapper::~QueueWrapper () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/QueueWrapper.hpp</code></p>"},{"location":"stm/structRegulator/","title":"Struct Regulator","text":"<p>ClassList &gt; Regulator</p>"},{"location":"stm/structRegulator/#public-types","title":"Public Types","text":"Type Name typedef uint32_t coef_type typedef int32_t value_type"},{"location":"stm/structRegulator/#public-functions","title":"Public Functions","text":"Type Name coef_type D () const coef_type I () const coef_type P () const Regulator () = default Regulator (value_type max_output, coef_type p, coef_type i, coef_type d)  void clear ()  value_type de () const value_type e () const value_type integrator () const value_type maxOutput ()  constexpr Regulator &amp; operator= (Regulator &amp;&amp; other) = default value_type output () const value_type process (value_type target, value_type actual)  void setD (const coef_type &amp; v)  void setI (const coef_type &amp; v)  void setMaxOutput (value_type max_output)  void setP (const coef_type &amp; v)  void stop (bool s=true)"},{"location":"stm/structRegulator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"stm/structRegulator/#typedef-coef_type","title":"typedef coef_type","text":"<pre><code>typedef uint32_t Regulator::coef_type;\n</code></pre>"},{"location":"stm/structRegulator/#typedef-value_type","title":"typedef value_type","text":"<pre><code>typedef int32_t Regulator::value_type;\n</code></pre>"},{"location":"stm/structRegulator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/structRegulator/#function-d","title":"function D","text":"<pre><code>inline coef_type Regulator::D () const\n</code></pre>"},{"location":"stm/structRegulator/#function-i","title":"function I","text":"<pre><code>inline coef_type Regulator::I () const\n</code></pre>"},{"location":"stm/structRegulator/#function-p","title":"function P","text":"<pre><code>inline coef_type Regulator::P () const\n</code></pre>"},{"location":"stm/structRegulator/#function-regulator-12","title":"function Regulator [1/2]","text":"<pre><code>Regulator::Regulator () = default\n</code></pre>"},{"location":"stm/structRegulator/#function-regulator-22","title":"function Regulator [2/2]","text":"<pre><code>inline Regulator::Regulator (\nvalue_type max_output,\ncoef_type p,\ncoef_type i,\ncoef_type d\n) </code></pre>"},{"location":"stm/structRegulator/#function-clear","title":"function clear","text":"<pre><code>inline void Regulator::clear () </code></pre>"},{"location":"stm/structRegulator/#function-de","title":"function de","text":"<pre><code>inline value_type Regulator::de () const\n</code></pre>"},{"location":"stm/structRegulator/#function-e","title":"function e","text":"<pre><code>inline value_type Regulator::e () const\n</code></pre>"},{"location":"stm/structRegulator/#function-integrator","title":"function integrator","text":"<pre><code>inline value_type Regulator::integrator () const\n</code></pre>"},{"location":"stm/structRegulator/#function-maxoutput","title":"function maxOutput","text":"<pre><code>inline value_type Regulator::maxOutput () </code></pre>"},{"location":"stm/structRegulator/#function-operator","title":"function operator=","text":"<pre><code>constexpr Regulator &amp; Regulator::operator= (\nRegulator &amp;&amp; other\n) = default\n</code></pre>"},{"location":"stm/structRegulator/#function-output","title":"function output","text":"<pre><code>inline value_type Regulator::output () const\n</code></pre>"},{"location":"stm/structRegulator/#function-process","title":"function process","text":"<pre><code>inline value_type Regulator::process (\nvalue_type target,\nvalue_type actual\n) </code></pre>"},{"location":"stm/structRegulator/#function-setd","title":"function setD","text":"<pre><code>inline void Regulator::setD (\nconst coef_type &amp; v\n) </code></pre>"},{"location":"stm/structRegulator/#function-seti","title":"function setI","text":"<pre><code>inline void Regulator::setI (\nconst coef_type &amp; v\n) </code></pre>"},{"location":"stm/structRegulator/#function-setmaxoutput","title":"function setMaxOutput","text":"<pre><code>inline void Regulator::setMaxOutput (\nvalue_type max_output\n) </code></pre>"},{"location":"stm/structRegulator/#function-setp","title":"function setP","text":"<pre><code>inline void Regulator::setP (\nconst coef_type &amp; v\n) </code></pre>"},{"location":"stm/structRegulator/#function-stop","title":"function stop","text":"<pre><code>inline void Regulator::stop (\nbool s=true\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/Regulator.hpp</code></p>"},{"location":"stm/classStreamBufferWrapper/","title":"Class StreamBufferWrapper","text":"<p>template &lt;size_t SizeInBytes&gt;</p> <p>ClassList &gt; StreamBufferWrapper</p>"},{"location":"stm/classStreamBufferWrapper/#public-functions","title":"Public Functions","text":"Type Name StreamBufferWrapper ()  size_t available () const void create (size_t xTriggerLevelBytes=1)  size_t freeSpace () const StreamBufferHandle_t handle () const size_t read (uint8_t * dst, size_t maxLen, TickType_t ticks_to_wait, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  bool reset ()  size_t write (const uint8_t *const data, size_t len, TickType_t ticks_to_wait, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  ~StreamBufferWrapper ()"},{"location":"stm/classStreamBufferWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/classStreamBufferWrapper/#function-streambufferwrapper","title":"function StreamBufferWrapper","text":"<pre><code>inline StreamBufferWrapper::StreamBufferWrapper () </code></pre>"},{"location":"stm/classStreamBufferWrapper/#function-available","title":"function available","text":"<pre><code>inline size_t StreamBufferWrapper::available () const\n</code></pre>"},{"location":"stm/classStreamBufferWrapper/#function-create","title":"function create","text":"<pre><code>inline void StreamBufferWrapper::create (\nsize_t xTriggerLevelBytes=1\n) </code></pre>"},{"location":"stm/classStreamBufferWrapper/#function-freespace","title":"function freeSpace","text":"<pre><code>inline size_t StreamBufferWrapper::freeSpace () const\n</code></pre>"},{"location":"stm/classStreamBufferWrapper/#function-handle","title":"function handle","text":"<pre><code>inline StreamBufferHandle_t StreamBufferWrapper::handle () const\n</code></pre>"},{"location":"stm/classStreamBufferWrapper/#function-read","title":"function read","text":"<pre><code>inline size_t StreamBufferWrapper::read (\nuint8_t * dst,\nsize_t maxLen,\nTickType_t ticks_to_wait,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"stm/classStreamBufferWrapper/#function-reset","title":"function reset","text":"<pre><code>inline bool StreamBufferWrapper::reset () </code></pre>"},{"location":"stm/classStreamBufferWrapper/#function-write","title":"function write","text":"<pre><code>inline size_t StreamBufferWrapper::write (\nconst uint8_t *const data,\nsize_t len,\nTickType_t ticks_to_wait,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"stm/classStreamBufferWrapper/#function-streambufferwrapper_1","title":"function ~StreamBufferWrapper","text":"<pre><code>inline StreamBufferWrapper::~StreamBufferWrapper () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/StreamBufferWrapper.hpp</code></p>"},{"location":"stm/classTaskWrapper/","title":"Class TaskWrapper","text":"<p>template &lt;int StackSizeBytes&gt;</p> <p>ClassList &gt; TaskWrapper</p>"},{"location":"stm/classTaskWrapper/#public-functions","title":"Public Functions","text":"Type Name TaskWrapper ()  TaskHandle_t handle () const bool start (const char * name, UBaseType_t priority, std::function&lt; void()&gt; &amp;&amp; func)  ~TaskWrapper ()"},{"location":"stm/classTaskWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/classTaskWrapper/#function-taskwrapper-12","title":"function TaskWrapper [1/2]","text":"<pre><code>inline TaskWrapper::TaskWrapper () </code></pre>"},{"location":"stm/classTaskWrapper/#function-handle","title":"function handle","text":"<pre><code>inline TaskHandle_t TaskWrapper::handle () const\n</code></pre>"},{"location":"stm/classTaskWrapper/#function-start","title":"function start","text":"<pre><code>inline bool TaskWrapper::start (\nconst char * name,\nUBaseType_t priority,\nstd::function&lt; void()&gt; &amp;&amp; func\n) </code></pre>"},{"location":"stm/classTaskWrapper/#function-taskwrapper","title":"function ~TaskWrapper","text":"<pre><code>inline TaskWrapper::~TaskWrapper () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/TaskWrapper.hpp</code></p>"},{"location":"stm/classTickTimer/","title":"Class TickTimer","text":"<p>ClassList &gt; TickTimer</p>"},{"location":"stm/classTickTimer/#public-functions","title":"Public Functions","text":"Type Name TickTimer ()  bool isActive () const bool poll ()  void restart (uint32_t delayMs)  void stop ()  ~TickTimer ()"},{"location":"stm/classTickTimer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/classTickTimer/#function-ticktimer","title":"function TickTimer","text":"<pre><code>inline TickTimer::TickTimer () </code></pre>"},{"location":"stm/classTickTimer/#function-isactive","title":"function isActive","text":"<pre><code>inline bool TickTimer::isActive () const\n</code></pre>"},{"location":"stm/classTickTimer/#function-poll","title":"function poll","text":"<pre><code>inline bool TickTimer::poll () </code></pre>"},{"location":"stm/classTickTimer/#function-restart","title":"function restart","text":"<pre><code>inline void TickTimer::restart (\nuint32_t delayMs\n) </code></pre>"},{"location":"stm/classTickTimer/#function-stop","title":"function stop","text":"<pre><code>inline void TickTimer::stop () </code></pre>"},{"location":"stm/classTickTimer/#function-ticktimer_1","title":"function ~TickTimer","text":"<pre><code>inline TickTimer::~TickTimer () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/TickTimer.hpp</code></p>"},{"location":"stm/classXorShift/","title":"Class XorShift","text":"<p>ClassList &gt; XorShift</p> <p>Fast deterministic PRNG - https://en.wikipedia.org/wiki/Xorshift .</p> <ul> <li><code>#include &lt;XorShift.hpp&gt;</code></li> </ul>"},{"location":"stm/classXorShift/#public-functions","title":"Public Functions","text":"Type Name XorShift (uint32_t seed=0xb45d9453)  uint32_t next ()"},{"location":"stm/classXorShift/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/classXorShift/#function-xorshift","title":"function XorShift","text":"<pre><code>inline XorShift::XorShift (\nuint32_t seed=0xb45d9453\n) </code></pre>"},{"location":"stm/classXorShift/#function-next","title":"function next","text":"<pre><code>inline uint32_t XorShift::next () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/XorShift.hpp</code></p>"},{"location":"stm/struct____debug__descriptors/","title":"Struct __debug_descriptors","text":"<p>ClassList &gt; __debug_descriptors</p> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/UsbCdcLink.cpp</code></p>"},{"location":"stm/structcdc__config/","title":"Struct cdc_config","text":"<p>ClassList &gt; cdc_config</p>"},{"location":"stm/structcdc__config/#public-attributes","title":"Public Attributes","text":"Type Name struct usb_config_descriptor config struct usb_cdc_acm_desc tunnel_cdc_acm struct usb_cdc_header_desc tunnel_cdc_hdr struct usb_cdc_call_mgmt_desc tunnel_cdc_mgmt struct usb_cdc_union_desc tunnel_cdc_union struct usb_interface_descriptor tunnel_comm struct usb_endpoint_descriptor tunnel_comm_ep struct usb_iad_descriptor tunnel_comm_iad struct usb_interface_descriptor tunnel_data struct usb_endpoint_descriptor tunnel_data_eprx struct usb_endpoint_descriptor tunnel_data_eptx"},{"location":"stm/structcdc__config/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/structcdc__config/#variable-config","title":"variable config","text":"<pre><code>struct usb_config_descriptor cdc_config::config;\n</code></pre>"},{"location":"stm/structcdc__config/#variable-tunnel_cdc_acm","title":"variable tunnel_cdc_acm","text":"<pre><code>struct usb_cdc_acm_desc cdc_config::tunnel_cdc_acm;\n</code></pre>"},{"location":"stm/structcdc__config/#variable-tunnel_cdc_hdr","title":"variable tunnel_cdc_hdr","text":"<pre><code>struct usb_cdc_header_desc cdc_config::tunnel_cdc_hdr;\n</code></pre>"},{"location":"stm/structcdc__config/#variable-tunnel_cdc_mgmt","title":"variable tunnel_cdc_mgmt","text":"<pre><code>struct usb_cdc_call_mgmt_desc cdc_config::tunnel_cdc_mgmt;\n</code></pre>"},{"location":"stm/structcdc__config/#variable-tunnel_cdc_union","title":"variable tunnel_cdc_union","text":"<pre><code>struct usb_cdc_union_desc cdc_config::tunnel_cdc_union;\n</code></pre>"},{"location":"stm/structcdc__config/#variable-tunnel_comm","title":"variable tunnel_comm","text":"<pre><code>struct usb_interface_descriptor cdc_config::tunnel_comm;\n</code></pre>"},{"location":"stm/structcdc__config/#variable-tunnel_comm_ep","title":"variable tunnel_comm_ep","text":"<pre><code>struct usb_endpoint_descriptor cdc_config::tunnel_comm_ep;\n</code></pre>"},{"location":"stm/structcdc__config/#variable-tunnel_comm_iad","title":"variable tunnel_comm_iad","text":"<pre><code>struct usb_iad_descriptor cdc_config::tunnel_comm_iad;\n</code></pre>"},{"location":"stm/structcdc__config/#variable-tunnel_data","title":"variable tunnel_data","text":"<pre><code>struct usb_interface_descriptor cdc_config::tunnel_data;\n</code></pre>"},{"location":"stm/structcdc__config/#variable-tunnel_data_eprx","title":"variable tunnel_data_eprx","text":"<pre><code>struct usb_endpoint_descriptor cdc_config::tunnel_data_eprx;\n</code></pre>"},{"location":"stm/structcdc__config/#variable-tunnel_data_eptx","title":"variable tunnel_data_eptx","text":"<pre><code>struct usb_endpoint_descriptor cdc_config::tunnel_data_eptx;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/UsbCdcLink.cpp</code></p>"},{"location":"stm/structmpu__t/","title":"Struct mpu_t","text":"<p>ClassList &gt; mpu_t</p>"},{"location":"stm/structmpu__t/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t buffer uint8_t devAddr"},{"location":"stm/structmpu__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/structmpu__t/#variable-buffer","title":"variable buffer","text":"<pre><code>uint8_t mpu_t::buffer[14];\n</code></pre>"},{"location":"stm/structmpu__t/#variable-devaddr","title":"variable devAddr","text":"<pre><code>uint8_t mpu_t::devAddr;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/MpuController.hpp</code></p>"},{"location":"stm/Readme_8md/","title":"File Readme.md","text":"<p>FileList &gt; Readme.md</p> <p>Go to the source code of this file.</p> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/Readme.md</code></p>"},{"location":"stm/Readme_8md_source/","title":"File Readme.md","text":"<p>File List &gt; Readme.md</p> <p>Go to the documentation of this file. </p> <pre><code># Source\n\nCode is from [RB3204-RBCX](https://github.com/RoboticsBrno/RB3204-RBCX/tree/master/fw/rbcx-coprocessor/src).\n\nIt is main board for [Robotka](https://robotka.robotickytabor.cz/) robot.\n\n![robotka](/Users/kuba/Documents/git/kuba/mkdoxy/mkdoxy-demo/src-stm32/robotka.jpg)\n</code></pre>"},{"location":"stm/dir_9ba036507fddba3d714985d68e6a47f2/","title":"Dir demo-projets","text":"<p>FileList &gt; demo-projets</p>"},{"location":"stm/dir_9ba036507fddba3d714985d68e6a47f2/#directories","title":"Directories","text":"Type Name dir stm32 <p>The documentation for this class was generated from the following file <code>demo-projets/</code></p>"},{"location":"stm/dir_117ec2946e9b587c21af88bdc5c2cc5e/","title":"Dir demo-projets/stm32","text":"<p>FileList &gt; demo-projets &gt; stm32</p>"},{"location":"stm/dir_117ec2946e9b587c21af88bdc5c2cc5e/#directories","title":"Directories","text":"Type Name dir include dir src <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/</code></p>"},{"location":"stm/dir_edff1a3c8e16f0d391d2e2b28b760d38/","title":"Dir demo-projets/stm32/include","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include</p>"},{"location":"stm/dir_edff1a3c8e16f0d391d2e2b28b760d38/#files","title":"Files","text":"Type Name file Bsp.hpp file ButtonController.hpp file BuzzerController.hpp file CdcUartTunnel.hpp file ControlLink.hpp file DebugLink.hpp file Dispatcher.hpp file Esp32Manager.hpp file FreeRTOSConfig.h file I2cController.hpp file Motor.hpp file MotorController.hpp file Mpu6050.hpp file MpuController.hpp file OledController.hpp file OledController_fonts.hpp file Power.hpp file StupidServoController.hpp file UltrasoundController.hpp file UsbCdcLink.h"},{"location":"stm/dir_edff1a3c8e16f0d391d2e2b28b760d38/#directories","title":"Directories","text":"Type Name dir utils <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/</code></p>"},{"location":"stm/Bsp_8hpp/","title":"File Bsp.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; Bsp.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"FreeRTOSConfig.h\"</code></li> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"stm32f1xx_hal_cortex.h\"</code></li> <li><code>#include \"stm32f1xx_hal_gpio.h\"</code></li> <li><code>#include \"stm32f1xx_ll_adc.h\"</code></li> <li><code>#include \"stm32f1xx_ll_dma.h\"</code></li> <li><code>#include \"stm32f1xx_ll_utils.h\"</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> </ul>"},{"location":"stm/Bsp_8hpp/#public-types","title":"Public Types","text":"Type Name typedef uint32_t ADC_channel_t typedef uint32_t ADC_rank_t typedef uint32_t DMA_channel_t typedef std::pair&lt; GPIO_TypeDef *, uint16_t &gt; PinDef"},{"location":"stm/Bsp_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name ADC_TypeDef *const auxiliaryAdc   = = ADC1 const IRQn_Type auxiliaryAndMotorAdcIRQn   = = ADC1_2_IRQn const unsigned auxiliaryAndMotorAdcIrqPrio   = = 9 const ADC_channel_t batteryMiddleVoltageAdcChannel   = = LL_ADC_CHANNEL_3 const ADC_rank_t batteryMiddleVoltageAdcRank   = = LL_ADC_INJ_RANK_3 const PinDef batteryMiddleVoltagePin   = = std::make_pair(GPIOA, GPIO_PIN_3) const ADC_channel_t batteryVoltageAdcChannel   = = LL_ADC_CHANNEL_6 const ADC_rank_t batteryVoltageAdcRank   = = LL_ADC_INJ_RANK_1 const PinDef batteryVoltagePin   = = std::make_pair(GPIOA, GPIO_PIN_6) const PinDef button1Pin   = = std::make_pair(GPIOE, GPIO_PIN_0) const PinDef button2Pin   = = std::make_pair(GPIOD, GPIO_PIN_10) const PinDef button3Pin   = = std::make_pair(GPIOB, GPIO_PIN_2) const PinDef button4Pin   = = std::make_pair(GPIOD, GPIO_PIN_11) const PinDef buttonOffPin   = = std::make_pair(GPIOE, GPIO_PIN_15) const PinDef buttonOnPin   = = std::make_pair(GPIOD, GPIO_PIN_14) const std::array&lt; PinDef, 6 &gt; buttonPin   = = { buttonOffPin, button1Pin, button2Pin, button3Pin, button4Pin, buttonOnPin } const PinDef buzzerPin   = = std::make_pair(GPIOD, GPIO_PIN_3) USART_TypeDef *const controlUart   = = USART3 DMA_Channel_TypeDef *const controlUartRxDmaChannel   = = DMA1_Channel3 const PinDef controlUartRxPin   = = std::make_pair(GPIOB, GPIO_PIN_11) DMA_Channel_TypeDef *const controlUartTxDmaChannel   = = DMA1_Channel2 const IRQn_Type controlUartTxDmaIRQn   = = DMA1_Channel2_IRQn const unsigned controlUartTxDmaIRQnPrio   = = 8 const PinDef controlUartTxPin   = = std::make_pair(GPIOB, GPIO_PIN_10) USART_TypeDef *const debugUart   = = UART4 const IRQn_Type debugUartIRQn   = = UART4_IRQn const unsigned debugUartIrqPrio   = = 10 DMA_Channel_TypeDef *const debugUartRxDmaChannel   = = DMA2_Channel3 const PinDef debugUartRxPin   = = std::make_pair(GPIOC, GPIO_PIN_11) DMA_Channel_TypeDef *const debugUartTxDmaChannel   = = DMA2_Channel5 const IRQn_Type debugUartTxDmaIRQn   = = DMA2_Channel4_5_IRQn const unsigned debugUartTxDmaIrqPrio   = = 9 const PinDef debugUartTxPin   = = std::make_pair(GPIOC, GPIO_PIN_10) const PinDef encoder1aPin   = = std::make_pair(GPIOD, GPIO_PIN_12) const PinDef encoder1bPin   = = std::make_pair(GPIOD, GPIO_PIN_13) const PinDef encoder2aPin   = = std::make_pair(GPIOA, GPIO_PIN_0) const PinDef encoder2bPin   = = std::make_pair(GPIOA, GPIO_PIN_1) const PinDef encoder3aPin   = = std::make_pair(GPIOA, GPIO_PIN_15) const PinDef encoder3bPin   = = std::make_pair(GPIOB, GPIO_PIN_3) const PinDef encoder4aPin   = = std::make_pair(GPIOB, GPIO_PIN_4) const PinDef encoder4bPin   = = std::make_pair(GPIOB, GPIO_PIN_5) TIM_TypeDef *const encoderTimer   = = { TIM4, TIM5, TIM2, TIM3 } const PinDef esp0Pin   = = std::make_pair(GPIOB, GPIO_PIN_10) const PinDef esp12Pin   = = std::make_pair(GPIOB, GPIO_PIN_15) const PinDef esp15Pin   = = std::make_pair(GPIOB, GPIO_PIN_14) const PinDef esp2Pin   = = std::make_pair(GPIOB, GPIO_PIN_11) const PinDef espEnPin   = = std::make_pair(GPIOD, GPIO_PIN_4) const IRQn_Type i2cErIRQn   = = I2C1_ER_IRQn const IRQn_Type i2cEvIRQn   = = I2C1_EV_IRQn const unsigned i2cIRQnPrio   = = 8 const int i2cPrio   = = 2 const PinDef i2cScl   = = std::make_pair(GPIOB, GPIO_PIN_8) const PinDef i2cSda   = = std::make_pair(GPIOB, GPIO_PIN_9) const PinDef in4aPin   = = std::make_pair(IN4PORT, IN4AMASK) const PinDef in4bPin   = = std::make_pair(IN4PORT, IN4BMASK) const ADC_rank_t internalReferenceVoltageAdcRank   = = LL_ADC_INJ_RANK_2 const PinDef led1Pin   = = std::make_pair(GPIOA, GPIO_PIN_7) const PinDef led2Pin   = = std::make_pair(GPIOA, GPIO_PIN_8) const PinDef led3Pin   = = std::make_pair(GPIOA, GPIO_PIN_9) const PinDef led4Pin   = = std::make_pair(GPIOA, GPIO_PIN_10) const std::array&lt; PinDef, 4 &gt; ledPin   = = { led1Pin, led2Pin, led3Pin, led4Pin } const PinDef ledPins   = = std::make_pair( GPIOA, led1Pin.second | led2Pin.second | led3Pin.second | led4Pin.second) const int mainTaskPrio   = = 4 const int motorTaskPrio   = = 2 const PinDef powerPin   = = std::make_pair(GPIOC, GPIO_PIN_13) const PinDef pwm1aPin   = = std::make_pair(GPIOE, GPIO_PIN_9) const PinDef pwm1bPin   = = std::make_pair(GPIOE, GPIO_PIN_8) const PinDef pwm2aPin   = = std::make_pair(GPIOE, GPIO_PIN_11) const PinDef pwm2bPin   = = std::make_pair(GPIOE, GPIO_PIN_10) const PinDef pwm3aPin   = = std::make_pair(GPIOE, GPIO_PIN_13) const PinDef pwm3bPin   = = std::make_pair(GPIOE, GPIO_PIN_12) const PinDef pwm4Pin   = = std::make_pair(GPIOE, GPIO_PIN_14) TIM_TypeDef *const pwmTimer   = = TIM1 const PinDef servo1Pin   = = std::make_pair(GPIOC, GPIO_PIN_6) const PinDef servo2Pin   = = std::make_pair(GPIOC, GPIO_PIN_7) const PinDef servo3Pin   = = std::make_pair(GPIOC, GPIO_PIN_8) const PinDef servo4Pin   = = std::make_pair(GPIOC, GPIO_PIN_9) const PinDef servoPins   = = std::make_pair(GPIOC, servo1Pin.second | servo2Pin.second | servo3Pin.second | servo4Pin.second) TIM_TypeDef *const servoTimer   = = TIM8 USART_TypeDef *const servoUart   = = UART5 const PinDef servoUartTxRxPin   = = std::make_pair(GPIOC, GPIO_PIN_12) const int softResetTaskPrio   = = configMAX_PRIORITIES - 1 const ADC_rank_t temperatureAdcRank   = = LL_ADC_INJ_RANK_4 USART_TypeDef *const tunnelUart   = = USART2 DMA_Channel_TypeDef *const tunnelUartRxDmaChannel   = = DMA1_Channel6 const PinDef tunnelUartRxPin   = = std::make_pair(GPIOD, GPIO_PIN_6) DMA_Channel_TypeDef *const tunnelUartTxDmaChannel   = = DMA1_Channel7 const PinDef tunnelUartTxPin   = = std::make_pair(GPIOD, GPIO_PIN_5) const int ultrasoundTaskPrio   = = 2 const PinDef usbBusDetectionPin   = = std::make_pair(GPIOA, GPIO_PIN_2) const PinDef usbDnPin   = = std::make_pair(GPIOA, GPIO_PIN_11) const PinDef usbDpPin   = = std::make_pair(GPIOA, GPIO_PIN_12) const PinDef usbDpPullUpPin   = = std::make_pair(USBD_DP_PORT, 1 &lt;&lt; USBD_DP_PIN) const IRQn_Type usbLpIRQn   = = USB_LP_CAN1_RX0_IRQn constexpr unsigned usbLpIRQnPrio   = = 8 USART_TypeDef *const userUart   = = USART1 const PinDef userUartRxPin   = = std::make_pair(GPIOB, GPIO_PIN_7) const PinDef userUartTxPin   = = std::make_pair(GPIOB, GPIO_PIN_6) const PinDef uts1EchoPin   = = std::make_pair(GPIOE, GPIO_PIN_6) const PinDef uts1TrigPin   = = std::make_pair(GPIOE, GPIO_PIN_1) const PinDef uts2EchoPin   = = std::make_pair(GPIOD, GPIO_PIN_7) const PinDef uts2TrigPin   = = std::make_pair(GPIOE, GPIO_PIN_2) const PinDef uts3EchoPin   = = std::make_pair(GPIOD, GPIO_PIN_8) const PinDef uts3TrigPin   = = std::make_pair(GPIOE, GPIO_PIN_3) const PinDef uts4EchoPin   = = std::make_pair(GPIOD, GPIO_PIN_9) const PinDef uts4TrigPin   = = std::make_pair(GPIOE, GPIO_PIN_4) const std::array&lt; PinDef, 4 &gt; utsEchoPin   = = { uts1EchoPin, uts2EchoPin, uts3EchoPin, uts4EchoPin } const uint32_t utsIRQPrio   = = 7 TIM_TypeDef *const utsTimer   = = TIM7 const std::array&lt; PinDef, 4 &gt; utsTrigPin   = = { uts1TrigPin, uts2TrigPin, uts3TrigPin, uts4TrigPin }"},{"location":"stm/Bsp_8hpp/#public-functions","title":"Public Functions","text":"Type Name void LL_ADC_SetChannelSamplingTimeFix (ADC_TypeDef * ADCx, uint32_t Channel, uint32_t SamplingTime)  void LL_GPIO_AF_Remap (uint32_t mask, uint32_t value)  void clocksInit ()  uint32_t getButtons ()  bool isPressed (PinDef button)  void pinInit (GPIO_TypeDef * port, uint32_t pinMask, uint32_t mode, uint32_t pull, uint32_t speed, bool deInitFirst=false)  void pinInit (PinDef pin, uint32_t mode, uint32_t pull, uint32_t speed, bool deInitFirst=false)  bool pinRead (PinDef pin)  void pinToggle (PinDef pin)  void pinWrite (PinDef pin, bool value)  void pinsInit ()  void reinitEspStrappingPins ()  void setLeds (uint32_t ledsOn)  void softReset ()  void softResetInit ()"},{"location":"stm/Bsp_8hpp/#macros","title":"Macros","text":"Type Name define AFIO_MAPR_RESERVED  0xF8E00000 define AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER  ADC1_2_IRQHandler define CONTROLUART_TX_DMA_HANDLER  DMA1_Channel2_IRQHandler define DEBUGUART_HANDLER  UART4_IRQHandler define DEBUGUART_TX_DMA_HANDLER  DMA2_Channel4_5_IRQHandler define IN4AMASK  GPIO_PIN_5 define IN4BMASK  GPIO_PIN_7 define IN4PORT  GPIOE define USB_LP_IRQ_HANDLER  USB_LP_CAN1_RX0_IRQHandler"},{"location":"stm/Bsp_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"stm/Bsp_8hpp/#typedef-adc_channel_t","title":"typedef ADC_channel_t","text":"<pre><code>typedef uint32_t ADC_channel_t;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#typedef-adc_rank_t","title":"typedef ADC_rank_t","text":"<pre><code>typedef uint32_t ADC_rank_t;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#typedef-dma_channel_t","title":"typedef DMA_channel_t","text":"<pre><code>typedef uint32_t DMA_channel_t;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#typedef-pindef","title":"typedef PinDef","text":"<pre><code>using PinDef =  std::pair&lt;GPIO_TypeDef*, uint16_t&gt;;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/Bsp_8hpp/#variable-auxiliaryadc","title":"variable auxiliaryAdc","text":"<pre><code>ADC_TypeDef* const auxiliaryAdc;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-auxiliaryandmotoradcirqn","title":"variable auxiliaryAndMotorAdcIRQn","text":"<pre><code>const IRQn_Type auxiliaryAndMotorAdcIRQn;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-auxiliaryandmotoradcirqprio","title":"variable auxiliaryAndMotorAdcIrqPrio","text":"<pre><code>const unsigned auxiliaryAndMotorAdcIrqPrio;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-batterymiddlevoltageadcchannel","title":"variable batteryMiddleVoltageAdcChannel","text":"<pre><code>const ADC_channel_t batteryMiddleVoltageAdcChannel;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-batterymiddlevoltageadcrank","title":"variable batteryMiddleVoltageAdcRank","text":"<pre><code>const ADC_rank_t batteryMiddleVoltageAdcRank;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-batterymiddlevoltagepin","title":"variable batteryMiddleVoltagePin","text":"<pre><code>const PinDef batteryMiddleVoltagePin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-batteryvoltageadcchannel","title":"variable batteryVoltageAdcChannel","text":"<pre><code>const ADC_channel_t batteryVoltageAdcChannel;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-batteryvoltageadcrank","title":"variable batteryVoltageAdcRank","text":"<pre><code>const ADC_rank_t batteryVoltageAdcRank;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-batteryvoltagepin","title":"variable batteryVoltagePin","text":"<pre><code>const PinDef batteryVoltagePin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-button1pin","title":"variable button1Pin","text":"<pre><code>const PinDef button1Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-button2pin","title":"variable button2Pin","text":"<pre><code>const PinDef button2Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-button3pin","title":"variable button3Pin","text":"<pre><code>const PinDef button3Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-button4pin","title":"variable button4Pin","text":"<pre><code>const PinDef button4Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-buttonoffpin","title":"variable buttonOffPin","text":"<pre><code>const PinDef buttonOffPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-buttononpin","title":"variable buttonOnPin","text":"<pre><code>const PinDef buttonOnPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-buttonpin","title":"variable buttonPin","text":"<pre><code>const std::array&lt;PinDef, 6&gt; buttonPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-buzzerpin","title":"variable buzzerPin","text":"<pre><code>const PinDef buzzerPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-controluart","title":"variable controlUart","text":"<pre><code>USART_TypeDef* const controlUart;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-controluartrxdmachannel","title":"variable controlUartRxDmaChannel","text":"<pre><code>DMA_Channel_TypeDef* const controlUartRxDmaChannel;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-controluartrxpin","title":"variable controlUartRxPin","text":"<pre><code>const PinDef controlUartRxPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-controluarttxdmachannel","title":"variable controlUartTxDmaChannel","text":"<pre><code>DMA_Channel_TypeDef* const controlUartTxDmaChannel;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-controluarttxdmairqn","title":"variable controlUartTxDmaIRQn","text":"<pre><code>const IRQn_Type controlUartTxDmaIRQn;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-controluarttxdmairqnprio","title":"variable controlUartTxDmaIRQnPrio","text":"<pre><code>const unsigned controlUartTxDmaIRQnPrio;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-controluarttxpin","title":"variable controlUartTxPin","text":"<pre><code>const PinDef controlUartTxPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-debuguart","title":"variable debugUart","text":"<pre><code>USART_TypeDef* const debugUart;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-debuguartirqn","title":"variable debugUartIRQn","text":"<pre><code>const IRQn_Type debugUartIRQn;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-debuguartirqprio","title":"variable debugUartIrqPrio","text":"<pre><code>const unsigned debugUartIrqPrio;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-debuguartrxdmachannel","title":"variable debugUartRxDmaChannel","text":"<pre><code>DMA_Channel_TypeDef* const debugUartRxDmaChannel;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-debuguartrxpin","title":"variable debugUartRxPin","text":"<pre><code>const PinDef debugUartRxPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-debuguarttxdmachannel","title":"variable debugUartTxDmaChannel","text":"<pre><code>DMA_Channel_TypeDef* const debugUartTxDmaChannel;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-debuguarttxdmairqn","title":"variable debugUartTxDmaIRQn","text":"<pre><code>const IRQn_Type debugUartTxDmaIRQn;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-debuguarttxdmairqprio","title":"variable debugUartTxDmaIrqPrio","text":"<pre><code>const unsigned debugUartTxDmaIrqPrio;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-debuguarttxpin","title":"variable debugUartTxPin","text":"<pre><code>const PinDef debugUartTxPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-encoder1apin","title":"variable encoder1aPin","text":"<pre><code>const PinDef encoder1aPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-encoder1bpin","title":"variable encoder1bPin","text":"<pre><code>const PinDef encoder1bPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-encoder2apin","title":"variable encoder2aPin","text":"<pre><code>const PinDef encoder2aPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-encoder2bpin","title":"variable encoder2bPin","text":"<pre><code>const PinDef encoder2bPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-encoder3apin","title":"variable encoder3aPin","text":"<pre><code>const PinDef encoder3aPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-encoder3bpin","title":"variable encoder3bPin","text":"<pre><code>const PinDef encoder3bPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-encoder4apin","title":"variable encoder4aPin","text":"<pre><code>const PinDef encoder4aPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-encoder4bpin","title":"variable encoder4bPin","text":"<pre><code>const PinDef encoder4bPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-encodertimer","title":"variable encoderTimer","text":"<pre><code>TIM_TypeDef* const encoderTimer[4];\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-esp0pin","title":"variable esp0Pin","text":"<pre><code>const PinDef esp0Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-esp12pin","title":"variable esp12Pin","text":"<pre><code>const PinDef esp12Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-esp15pin","title":"variable esp15Pin","text":"<pre><code>const PinDef esp15Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-esp2pin","title":"variable esp2Pin","text":"<pre><code>const PinDef esp2Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-espenpin","title":"variable espEnPin","text":"<pre><code>const PinDef espEnPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-i2cerirqn","title":"variable i2cErIRQn","text":"<pre><code>const IRQn_Type i2cErIRQn;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-i2cevirqn","title":"variable i2cEvIRQn","text":"<pre><code>const IRQn_Type i2cEvIRQn;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-i2cirqnprio","title":"variable i2cIRQnPrio","text":"<pre><code>const unsigned i2cIRQnPrio;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-i2cprio","title":"variable i2cPrio","text":"<pre><code>const int i2cPrio;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-i2cscl","title":"variable i2cScl","text":"<pre><code>const PinDef i2cScl;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-i2csda","title":"variable i2cSda","text":"<pre><code>const PinDef i2cSda;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-in4apin","title":"variable in4aPin","text":"<pre><code>const PinDef in4aPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-in4bpin","title":"variable in4bPin","text":"<pre><code>const PinDef in4bPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-internalreferencevoltageadcrank","title":"variable internalReferenceVoltageAdcRank","text":"<pre><code>const ADC_rank_t internalReferenceVoltageAdcRank;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-led1pin","title":"variable led1Pin","text":"<pre><code>const PinDef led1Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-led2pin","title":"variable led2Pin","text":"<pre><code>const PinDef led2Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-led3pin","title":"variable led3Pin","text":"<pre><code>const PinDef led3Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-led4pin","title":"variable led4Pin","text":"<pre><code>const PinDef led4Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-ledpin","title":"variable ledPin","text":"<pre><code>const std::array&lt;PinDef, 4&gt; ledPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-ledpins","title":"variable ledPins","text":"<pre><code>const PinDef ledPins;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-maintaskprio","title":"variable mainTaskPrio","text":"<pre><code>const int mainTaskPrio;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-motortaskprio","title":"variable motorTaskPrio","text":"<pre><code>const int motorTaskPrio;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-powerpin","title":"variable powerPin","text":"<pre><code>const PinDef powerPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-pwm1apin","title":"variable pwm1aPin","text":"<pre><code>const PinDef pwm1aPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-pwm1bpin","title":"variable pwm1bPin","text":"<pre><code>const PinDef pwm1bPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-pwm2apin","title":"variable pwm2aPin","text":"<pre><code>const PinDef pwm2aPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-pwm2bpin","title":"variable pwm2bPin","text":"<pre><code>const PinDef pwm2bPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-pwm3apin","title":"variable pwm3aPin","text":"<pre><code>const PinDef pwm3aPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-pwm3bpin","title":"variable pwm3bPin","text":"<pre><code>const PinDef pwm3bPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-pwm4pin","title":"variable pwm4Pin","text":"<pre><code>const PinDef pwm4Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-pwmtimer","title":"variable pwmTimer","text":"<pre><code>TIM_TypeDef* const pwmTimer;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-servo1pin","title":"variable servo1Pin","text":"<pre><code>const PinDef servo1Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-servo2pin","title":"variable servo2Pin","text":"<pre><code>const PinDef servo2Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-servo3pin","title":"variable servo3Pin","text":"<pre><code>const PinDef servo3Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-servo4pin","title":"variable servo4Pin","text":"<pre><code>const PinDef servo4Pin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-servopins","title":"variable servoPins","text":"<pre><code>const PinDef servoPins;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-servotimer","title":"variable servoTimer","text":"<pre><code>TIM_TypeDef* const servoTimer;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-servouart","title":"variable servoUart","text":"<pre><code>USART_TypeDef* const servoUart;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-servouarttxrxpin","title":"variable servoUartTxRxPin","text":"<pre><code>const PinDef servoUartTxRxPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-softresettaskprio","title":"variable softResetTaskPrio","text":"<pre><code>const int softResetTaskPrio;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-temperatureadcrank","title":"variable temperatureAdcRank","text":"<pre><code>const ADC_rank_t temperatureAdcRank;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-tunneluart","title":"variable tunnelUart","text":"<pre><code>USART_TypeDef* const tunnelUart;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-tunneluartrxdmachannel","title":"variable tunnelUartRxDmaChannel","text":"<pre><code>DMA_Channel_TypeDef* const tunnelUartRxDmaChannel;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-tunneluartrxpin","title":"variable tunnelUartRxPin","text":"<pre><code>const PinDef tunnelUartRxPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-tunneluarttxdmachannel","title":"variable tunnelUartTxDmaChannel","text":"<pre><code>DMA_Channel_TypeDef* const tunnelUartTxDmaChannel;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-tunneluarttxpin","title":"variable tunnelUartTxPin","text":"<pre><code>const PinDef tunnelUartTxPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-ultrasoundtaskprio","title":"variable ultrasoundTaskPrio","text":"<pre><code>const int ultrasoundTaskPrio;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-usbbusdetectionpin","title":"variable usbBusDetectionPin","text":"<pre><code>const PinDef usbBusDetectionPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-usbdnpin","title":"variable usbDnPin","text":"<pre><code>const PinDef usbDnPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-usbdppin","title":"variable usbDpPin","text":"<pre><code>const PinDef usbDpPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-usbdppulluppin","title":"variable usbDpPullUpPin","text":"<pre><code>const PinDef usbDpPullUpPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-usblpirqn","title":"variable usbLpIRQn","text":"<pre><code>const IRQn_Type usbLpIRQn;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-usblpirqnprio","title":"variable usbLpIRQnPrio","text":"<pre><code>constexpr unsigned usbLpIRQnPrio;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-useruart","title":"variable userUart","text":"<pre><code>USART_TypeDef* const userUart;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-useruartrxpin","title":"variable userUartRxPin","text":"<pre><code>const PinDef userUartRxPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-useruarttxpin","title":"variable userUartTxPin","text":"<pre><code>const PinDef userUartTxPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-uts1echopin","title":"variable uts1EchoPin","text":"<pre><code>const PinDef uts1EchoPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-uts1trigpin","title":"variable uts1TrigPin","text":"<pre><code>const PinDef uts1TrigPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-uts2echopin","title":"variable uts2EchoPin","text":"<pre><code>const PinDef uts2EchoPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-uts2trigpin","title":"variable uts2TrigPin","text":"<pre><code>const PinDef uts2TrigPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-uts3echopin","title":"variable uts3EchoPin","text":"<pre><code>const PinDef uts3EchoPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-uts3trigpin","title":"variable uts3TrigPin","text":"<pre><code>const PinDef uts3TrigPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-uts4echopin","title":"variable uts4EchoPin","text":"<pre><code>const PinDef uts4EchoPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-uts4trigpin","title":"variable uts4TrigPin","text":"<pre><code>const PinDef uts4TrigPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-utsechopin","title":"variable utsEchoPin","text":"<pre><code>const std::array&lt;PinDef, 4&gt; utsEchoPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-utsirqprio","title":"variable utsIRQPrio","text":"<pre><code>const uint32_t utsIRQPrio;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-utstimer","title":"variable utsTimer","text":"<pre><code>TIM_TypeDef* const utsTimer;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#variable-utstrigpin","title":"variable utsTrigPin","text":"<pre><code>const std::array&lt;PinDef, 4&gt; utsTrigPin;\n</code></pre>"},{"location":"stm/Bsp_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/Bsp_8hpp/#function-ll_adc_setchannelsamplingtimefix","title":"function LL_ADC_SetChannelSamplingTimeFix","text":"<pre><code>inline void LL_ADC_SetChannelSamplingTimeFix (\nADC_TypeDef * ADCx,\nuint32_t Channel,\nuint32_t SamplingTime\n) </code></pre>"},{"location":"stm/Bsp_8hpp/#function-ll_gpio_af_remap","title":"function LL_GPIO_AF_Remap","text":"<pre><code>inline void LL_GPIO_AF_Remap (\nuint32_t mask,\nuint32_t value\n) </code></pre>"},{"location":"stm/Bsp_8hpp/#function-clocksinit","title":"function clocksInit","text":"<pre><code>inline void clocksInit () </code></pre>"},{"location":"stm/Bsp_8hpp/#function-getbuttons","title":"function getButtons","text":"<pre><code>inline uint32_t getButtons () </code></pre>"},{"location":"stm/Bsp_8hpp/#function-ispressed","title":"function isPressed","text":"<pre><code>inline bool isPressed (\nPinDef button\n) </code></pre>"},{"location":"stm/Bsp_8hpp/#function-pininit","title":"function pinInit","text":"<pre><code>inline void pinInit (\nGPIO_TypeDef * port,\nuint32_t pinMask,\nuint32_t mode,\nuint32_t pull,\nuint32_t speed,\nbool deInitFirst=false\n) </code></pre>"},{"location":"stm/Bsp_8hpp/#function-pininit_1","title":"function pinInit","text":"<pre><code>inline void pinInit (\nPinDef pin,\nuint32_t mode,\nuint32_t pull,\nuint32_t speed,\nbool deInitFirst=false\n) </code></pre>"},{"location":"stm/Bsp_8hpp/#function-pinread","title":"function pinRead","text":"<pre><code>inline bool pinRead (\nPinDef pin\n) </code></pre>"},{"location":"stm/Bsp_8hpp/#function-pintoggle","title":"function pinToggle","text":"<pre><code>inline void pinToggle (\nPinDef pin\n) </code></pre>"},{"location":"stm/Bsp_8hpp/#function-pinwrite","title":"function pinWrite","text":"<pre><code>inline void pinWrite (\nPinDef pin,\nbool value\n) </code></pre>"},{"location":"stm/Bsp_8hpp/#function-pinsinit","title":"function pinsInit","text":"<pre><code>inline void pinsInit () </code></pre>"},{"location":"stm/Bsp_8hpp/#function-reinitespstrappingpins","title":"function reinitEspStrappingPins","text":"<pre><code>inline void reinitEspStrappingPins () </code></pre>"},{"location":"stm/Bsp_8hpp/#function-setleds","title":"function setLeds","text":"<pre><code>inline void setLeds (\nuint32_t ledsOn\n) </code></pre>"},{"location":"stm/Bsp_8hpp/#function-softreset","title":"function softReset","text":"<pre><code>void softReset () </code></pre>"},{"location":"stm/Bsp_8hpp/#function-softresetinit","title":"function softResetInit","text":"<pre><code>void softResetInit () </code></pre>"},{"location":"stm/Bsp_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"stm/Bsp_8hpp/#define-afio_mapr_reserved","title":"define AFIO_MAPR_RESERVED","text":"<pre><code>#define AFIO_MAPR_RESERVED 0xF8E00000\n</code></pre>"},{"location":"stm/Bsp_8hpp/#define-auxiliary_and_motor_adc_irq_handler","title":"define AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER","text":"<pre><code>#define AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER ADC1_2_IRQHandler\n</code></pre>"},{"location":"stm/Bsp_8hpp/#define-controluart_tx_dma_handler","title":"define CONTROLUART_TX_DMA_HANDLER","text":"<pre><code>#define CONTROLUART_TX_DMA_HANDLER DMA1_Channel2_IRQHandler\n</code></pre>"},{"location":"stm/Bsp_8hpp/#define-debuguart_handler","title":"define DEBUGUART_HANDLER","text":"<pre><code>#define DEBUGUART_HANDLER UART4_IRQHandler\n</code></pre>"},{"location":"stm/Bsp_8hpp/#define-debuguart_tx_dma_handler","title":"define DEBUGUART_TX_DMA_HANDLER","text":"<pre><code>#define DEBUGUART_TX_DMA_HANDLER DMA2_Channel4_5_IRQHandler\n</code></pre>"},{"location":"stm/Bsp_8hpp/#define-in4amask","title":"define IN4AMASK","text":"<pre><code>#define IN4AMASK GPIO_PIN_5\n</code></pre>"},{"location":"stm/Bsp_8hpp/#define-in4bmask","title":"define IN4BMASK","text":"<pre><code>#define IN4BMASK GPIO_PIN_7\n</code></pre>"},{"location":"stm/Bsp_8hpp/#define-in4port","title":"define IN4PORT","text":"<pre><code>#define IN4PORT GPIOE\n</code></pre>"},{"location":"stm/Bsp_8hpp/#define-usb_lp_irq_handler","title":"define USB_LP_IRQ_HANDLER","text":"<pre><code>#define USB_LP_IRQ_HANDLER USB_LP_CAN1_RX0_IRQHandler\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/Bsp.hpp</code></p>"},{"location":"stm/Bsp_8hpp_source/","title":"File Bsp.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; Bsp.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"FreeRTOSConfig.h\"\n#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx_hal_cortex.h\"\n#include \"stm32f1xx_hal_gpio.h\"\n#include \"stm32f1xx_ll_adc.h\"\n#include \"stm32f1xx_ll_dma.h\"\n#include \"stm32f1xx_ll_utils.h\"\n\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;cassert&gt;\n\n#include &lt;algorithm&gt;\n\nusing PinDef = std::pair&lt;GPIO_TypeDef*, uint16_t&gt;;\n\ntypedef uint32_t DMA_channel_t;\ntypedef uint32_t ADC_channel_t;\ntypedef uint32_t ADC_rank_t;\n\n#define USB_LP_IRQ_HANDLER USB_LP_CAN1_RX0_IRQHandler\ninline const IRQn_Type usbLpIRQn = USB_LP_CAN1_RX0_IRQn;\ninline constexpr unsigned usbLpIRQnPrio = 8;\n\ninline const int mainTaskPrio = 4;\ninline const int motorTaskPrio = 2;\ninline const int ultrasoundTaskPrio = 2;\ninline const int i2cPrio = 2;\ninline const int softResetTaskPrio = configMAX_PRIORITIES - 1;\n\ninline void pinInit(GPIO_TypeDef* port, uint32_t pinMask, uint32_t mode,\nuint32_t pull, uint32_t speed, bool deInitFirst = false) {\n\n// HAL_GPIO_Init leaves some flags set if called multiple times\n// on the same pin\nif (deInitFirst)\nHAL_GPIO_DeInit(port, pinMask);\n\nGPIO_InitTypeDef init;\ninit.Pin = pinMask;\ninit.Mode = mode;\ninit.Pull = pull;\ninit.Speed = speed;\nHAL_GPIO_Init(port, &amp;init);\n}\n\ninline void pinInit(PinDef pin, uint32_t mode, uint32_t pull, uint32_t speed,\nbool deInitFirst = false) {\npinInit(pin.first, pin.second, mode, pull, speed, deInitFirst);\n}\n\ninline bool pinRead(PinDef pin) {\nreturn HAL_GPIO_ReadPin(pin.first, pin.second) == GPIO_PIN_SET;\n}\n\ninline void pinWrite(PinDef pin, bool value) {\nHAL_GPIO_WritePin(\npin.first, pin.second, value ? GPIO_PIN_SET : GPIO_PIN_RESET);\n}\n\ninline void pinToggle(PinDef pin) { HAL_GPIO_TogglePin(pin.first, pin.second); }\n\n// This is because AFIO_MAPR register bits SWJ_CFG are write-only, so classical approach\n//   read-modify-write does not work.\n//   DO NOT USE LL_GPIO_AF_*Remap* FUNCTIONS!\n#define AFIO_MAPR_RESERVED 0xF8E00000\ninline void LL_GPIO_AF_Remap(uint32_t mask, uint32_t value) {\nstatic uint32_t mapr = 0;\nmask |= AFIO_MAPR_RESERVED;\nmapr = (mapr &amp; ~mask) | (value &amp; ~AFIO_MAPR_RESERVED);\nAFIO-&gt;MAPR = mapr;\n}\n\ninline void LL_ADC_SetChannelSamplingTimeFix(\nADC_TypeDef* ADCx, uint32_t Channel, uint32_t SamplingTime) {\nvolatile uint32_t* const reg\n= (Channel &amp; ADC_SMPR2_REGOFFSET) ? &amp;ADCx-&gt;SMPR2 : &amp;ADCx-&gt;SMPR1;\nconst uint8_t offset = (Channel &amp; ADC_CHANNEL_SMPx_BITOFFSET_MASK)\n&gt;&gt; ADC_CHANNEL_SMPx_BITOFFSET_POS;\n*reg = (*reg &amp; ~(ADC_SMPR2_SMP0 &lt;&lt; offset))\n| (SamplingTime &amp; ADC_SMPR2_SMP0) &lt;&lt; offset;\n}\n\n#if RBCX_HW_VER == 0x0100\n#error \"Unsupported RBCX_HW_VER\"\n#endif\n\ninline const PinDef led1Pin = std::make_pair(GPIOA, GPIO_PIN_7);\ninline const PinDef led2Pin = std::make_pair(GPIOA, GPIO_PIN_8);\ninline const PinDef led3Pin = std::make_pair(GPIOA, GPIO_PIN_9);\ninline const PinDef led4Pin = std::make_pair(GPIOA, GPIO_PIN_10);\ninline const PinDef ledPins = std::make_pair(\nGPIOA, led1Pin.second | led2Pin.second | led3Pin.second | led4Pin.second);\ninline const std::array&lt;PinDef, 4&gt; ledPin\n= { led1Pin, led2Pin, led3Pin, led4Pin };\n\ninline const PinDef powerPin = std::make_pair(GPIOC, GPIO_PIN_13);\n\ninline const PinDef buttonOffPin = std::make_pair(GPIOE, GPIO_PIN_15);\ninline const PinDef button1Pin = std::make_pair(GPIOE, GPIO_PIN_0);\ninline const PinDef button2Pin = std::make_pair(GPIOD, GPIO_PIN_10);\ninline const PinDef button3Pin = std::make_pair(GPIOB, GPIO_PIN_2);\ninline const PinDef button4Pin = std::make_pair(GPIOD, GPIO_PIN_11);\ninline const PinDef buttonOnPin = std::make_pair(GPIOD, GPIO_PIN_14);\ninline const std::array&lt;PinDef, 6&gt; buttonPin = { buttonOffPin, button1Pin,\nbutton2Pin, button3Pin, button4Pin, buttonOnPin };\n\ninline const PinDef uts1TrigPin = std::make_pair(GPIOE, GPIO_PIN_1);\ninline const PinDef uts1EchoPin = std::make_pair(GPIOE, GPIO_PIN_6);\ninline const PinDef uts2TrigPin = std::make_pair(GPIOE, GPIO_PIN_2);\ninline const PinDef uts2EchoPin = std::make_pair(GPIOD, GPIO_PIN_7);\ninline const PinDef uts3TrigPin = std::make_pair(GPIOE, GPIO_PIN_3);\ninline const PinDef uts3EchoPin = std::make_pair(GPIOD, GPIO_PIN_8);\ninline const PinDef uts4TrigPin = std::make_pair(GPIOE, GPIO_PIN_4);\ninline const PinDef uts4EchoPin = std::make_pair(GPIOD, GPIO_PIN_9);\n\ninline const std::array&lt;PinDef, 4&gt; utsTrigPin\n= { uts1TrigPin, uts2TrigPin, uts3TrigPin, uts4TrigPin };\ninline const std::array&lt;PinDef, 4&gt; utsEchoPin\n= { uts1EchoPin, uts2EchoPin, uts3EchoPin, uts4EchoPin };\n\ninline const uint32_t utsIRQPrio = 7;\n\ninline TIM_TypeDef* const utsTimer = TIM7;\n\ninline const PinDef usbDnPin = std::make_pair(GPIOA, GPIO_PIN_11);\ninline const PinDef usbDpPin = std::make_pair(GPIOA, GPIO_PIN_12);\n// defined in platformio.ini, because used by STM USB C library:\ninline const PinDef usbDpPullUpPin\n= std::make_pair(USBD_DP_PORT, 1 &lt;&lt; USBD_DP_PIN);\ninline const PinDef usbBusDetectionPin = std::make_pair(GPIOA, GPIO_PIN_2);\n\ninline const PinDef userUartTxPin = std::make_pair(GPIOB, GPIO_PIN_6);\ninline const PinDef userUartRxPin = std::make_pair(GPIOB, GPIO_PIN_7);\ninline const PinDef tunnelUartTxPin = std::make_pair(GPIOD, GPIO_PIN_5);\ninline const PinDef tunnelUartRxPin = std::make_pair(GPIOD, GPIO_PIN_6);\ninline const PinDef controlUartTxPin = std::make_pair(GPIOB, GPIO_PIN_10);\ninline const PinDef controlUartRxPin = std::make_pair(GPIOB, GPIO_PIN_11);\ninline const PinDef debugUartTxPin = std::make_pair(GPIOC, GPIO_PIN_10);\ninline const PinDef debugUartRxPin = std::make_pair(GPIOC, GPIO_PIN_11);\ninline const PinDef servoUartTxRxPin = std::make_pair(GPIOC, GPIO_PIN_12);\n\ninline const PinDef i2cSda = std::make_pair(GPIOB, GPIO_PIN_9);\ninline const PinDef i2cScl = std::make_pair(GPIOB, GPIO_PIN_8);\n\ninline const IRQn_Type i2cEvIRQn = I2C1_EV_IRQn;\ninline const IRQn_Type i2cErIRQn = I2C1_ER_IRQn;\ninline const unsigned i2cIRQnPrio = 8;\n\ninline USART_TypeDef* const userUart = USART1;\ninline USART_TypeDef* const tunnelUart = USART2;\ninline USART_TypeDef* const controlUart = USART3;\ninline USART_TypeDef* const debugUart = UART4;\ninline USART_TypeDef* const servoUart = UART5;\n\ninline DMA_Channel_TypeDef* const tunnelUartTxDmaChannel = DMA1_Channel7;\ninline DMA_Channel_TypeDef* const tunnelUartRxDmaChannel = DMA1_Channel6;\n\n#define DEBUGUART_TX_DMA_HANDLER DMA2_Channel4_5_IRQHandler\n#define DEBUGUART_HANDLER UART4_IRQHandler\ninline const IRQn_Type debugUartTxDmaIRQn = DMA2_Channel4_5_IRQn;\ninline const IRQn_Type debugUartIRQn = UART4_IRQn;\ninline const unsigned debugUartTxDmaIrqPrio = 9;\ninline const unsigned debugUartIrqPrio = 10;\ninline DMA_Channel_TypeDef* const debugUartTxDmaChannel = DMA2_Channel5;\ninline DMA_Channel_TypeDef* const debugUartRxDmaChannel = DMA2_Channel3;\n\n#define CONTROLUART_TX_DMA_HANDLER DMA1_Channel2_IRQHandler\ninline const IRQn_Type controlUartTxDmaIRQn = DMA1_Channel2_IRQn;\ninline const unsigned controlUartTxDmaIRQnPrio = 8;\ninline DMA_Channel_TypeDef* const controlUartTxDmaChannel = DMA1_Channel2;\ninline DMA_Channel_TypeDef* const controlUartRxDmaChannel = DMA1_Channel3;\n\n#define IN4PORT GPIOE\n#define IN4AMASK GPIO_PIN_5\n#define IN4BMASK GPIO_PIN_7\ninline const PinDef pwm1bPin = std::make_pair(GPIOE, GPIO_PIN_8);\ninline const PinDef pwm1aPin = std::make_pair(GPIOE, GPIO_PIN_9);\ninline const PinDef pwm2bPin = std::make_pair(GPIOE, GPIO_PIN_10);\ninline const PinDef pwm2aPin = std::make_pair(GPIOE, GPIO_PIN_11);\ninline const PinDef pwm3bPin = std::make_pair(GPIOE, GPIO_PIN_12);\ninline const PinDef pwm3aPin = std::make_pair(GPIOE, GPIO_PIN_13);\ninline const PinDef pwm4Pin = std::make_pair(GPIOE, GPIO_PIN_14);\ninline const PinDef in4bPin = std::make_pair(IN4PORT, IN4BMASK);\ninline const PinDef in4aPin = std::make_pair(IN4PORT, IN4AMASK);\n\ninline TIM_TypeDef* const pwmTimer = TIM1;\n\ninline const PinDef encoder1aPin = std::make_pair(GPIOD, GPIO_PIN_12);\ninline const PinDef encoder1bPin = std::make_pair(GPIOD, GPIO_PIN_13);\ninline const PinDef encoder2aPin = std::make_pair(GPIOA, GPIO_PIN_0);\ninline const PinDef encoder2bPin = std::make_pair(GPIOA, GPIO_PIN_1);\ninline const PinDef encoder3aPin = std::make_pair(GPIOA, GPIO_PIN_15);\ninline const PinDef encoder3bPin = std::make_pair(GPIOB, GPIO_PIN_3);\ninline const PinDef encoder4aPin = std::make_pair(GPIOB, GPIO_PIN_4);\ninline const PinDef encoder4bPin = std::make_pair(GPIOB, GPIO_PIN_5);\n\ninline TIM_TypeDef* const encoderTimer[4] = { TIM4, TIM5, TIM2, TIM3 };\n\ninline const PinDef servo1Pin = std::make_pair(GPIOC, GPIO_PIN_6);\ninline const PinDef servo2Pin = std::make_pair(GPIOC, GPIO_PIN_7);\ninline const PinDef servo3Pin = std::make_pair(GPIOC, GPIO_PIN_8);\ninline const PinDef servo4Pin = std::make_pair(GPIOC, GPIO_PIN_9);\ninline const PinDef servoPins = std::make_pair(GPIOC,\nservo1Pin.second | servo2Pin.second | servo3Pin.second | servo4Pin.second);\n\ninline TIM_TypeDef* const servoTimer = TIM8;\n\ninline const PinDef espEnPin = std::make_pair(GPIOD, GPIO_PIN_4);\ninline const PinDef esp0Pin = std::make_pair(GPIOB, GPIO_PIN_10);\ninline const PinDef esp2Pin = std::make_pair(GPIOB, GPIO_PIN_11);\ninline const PinDef esp12Pin = std::make_pair(GPIOB, GPIO_PIN_15);\ninline const PinDef esp15Pin = std::make_pair(GPIOB, GPIO_PIN_14);\n\ninline const PinDef buzzerPin = std::make_pair(GPIOD, GPIO_PIN_3);\n\ninline const ADC_channel_t batteryVoltageAdcChannel = LL_ADC_CHANNEL_6;\ninline const ADC_channel_t batteryMiddleVoltageAdcChannel = LL_ADC_CHANNEL_3;\n\ninline const ADC_rank_t batteryVoltageAdcRank = LL_ADC_INJ_RANK_1;\ninline const ADC_rank_t internalReferenceVoltageAdcRank = LL_ADC_INJ_RANK_2;\ninline const ADC_rank_t batteryMiddleVoltageAdcRank = LL_ADC_INJ_RANK_3;\ninline const ADC_rank_t temperatureAdcRank = LL_ADC_INJ_RANK_4;\n\ninline const PinDef batteryVoltagePin = std::make_pair(GPIOA, GPIO_PIN_6);\ninline const PinDef batteryMiddleVoltagePin = std::make_pair(GPIOA, GPIO_PIN_3);\n\ninline ADC_TypeDef* const auxiliaryAdc = ADC1;\ninline const IRQn_Type auxiliaryAndMotorAdcIRQn = ADC1_2_IRQn;\ninline const unsigned auxiliaryAndMotorAdcIrqPrio = 9;\n#define AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER ADC1_2_IRQHandler\n\ninline void clocksInit() {\nRCC_OscInitTypeDef RCC_OscInitStruct;\nRCC_ClkInitTypeDef RCC_ClkInitStruct;\nRCC_PeriphCLKInitTypeDef PeriphClkInit;\n\nRCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;\nRCC_OscInitStruct.HSEState = RCC_HSE_ON;\nRCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;\nRCC_OscInitStruct.HSIState = RCC_HSI_ON;\nRCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;\nRCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;\nRCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;\nif (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) {\nabort();\n}\n\nRCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK\n| RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;\nRCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\nRCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;\nRCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;\nRCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;\nif (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) {\nabort();\n}\n\nPeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;\nPeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL_DIV1_5;\nPeriphClkInit.AdcClockSelection = RCC_CFGR_ADCPRE_DIV6;\nif (HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInit) != HAL_OK) {\nabort();\n}\n\n__HAL_RCC_GPIOA_CLK_ENABLE();\n__HAL_RCC_GPIOB_CLK_ENABLE();\n__HAL_RCC_GPIOC_CLK_ENABLE();\n__HAL_RCC_GPIOD_CLK_ENABLE();\n__HAL_RCC_GPIOE_CLK_ENABLE();\n__HAL_RCC_AFIO_CLK_ENABLE();\n__HAL_RCC_USART1_CLK_ENABLE();\n__HAL_RCC_USART2_CLK_ENABLE();\n__HAL_RCC_USART3_CLK_ENABLE();\n__HAL_RCC_UART4_CLK_ENABLE();\n__HAL_RCC_UART5_CLK_ENABLE();\n__HAL_RCC_DMA1_CLK_ENABLE();\n__HAL_RCC_DMA2_CLK_ENABLE();\n__HAL_RCC_PWR_CLK_ENABLE();\n__HAL_RCC_BKP_CLK_ENABLE();\n__HAL_RCC_TIM1_CLK_ENABLE();\n__HAL_RCC_TIM2_CLK_ENABLE();\n__HAL_RCC_TIM3_CLK_ENABLE();\n__HAL_RCC_TIM4_CLK_ENABLE();\n__HAL_RCC_TIM5_CLK_ENABLE();\n__HAL_RCC_TIM6_CLK_ENABLE();\n__HAL_RCC_TIM7_CLK_ENABLE();\n__HAL_RCC_TIM8_CLK_ENABLE();\n__HAL_RCC_ADC1_CLK_ENABLE();\n__HAL_RCC_I2C1_CLK_ENABLE();\n}\n\n// Set-up ESP32 strapping pins for the normal mode functions. Esp32Manager\n// handles the strapping process and ESP32 reset, and calls this function\n// after the reset is done so that normal function can be restored.\ninline void reinitEspStrappingPins() {\n// controlUart uses esp0Pin and esp2Pin\npinInit(\ncontrolUartTxPin, GPIO_MODE_AF_PP, GPIO_PULLUP, GPIO_SPEED_FREQ_HIGH);\npinInit(controlUartRxPin, GPIO_MODE_AF_INPUT, GPIO_PULLUP,\nGPIO_SPEED_FREQ_HIGH);\n\n// Other pins are unused during normal function, set them to default state\npinInit(esp12Pin, GPIO_MODE_INPUT, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW, true);\npinInit(esp15Pin, GPIO_MODE_INPUT, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW, true);\n}\n\ninline void pinsInit() {\npinInit(ledPins, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\n\npinWrite(powerPin, 1);\npinInit(powerPin, GPIO_MODE_OUTPUT_OD, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\n\nfor (auto button : buttonPin)\npinInit(button, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_LOW);\n\npinInit(pwm1bPin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(pwm1aPin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(pwm2bPin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(pwm2aPin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(pwm3bPin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(pwm3aPin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(pwm4Pin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(in4bPin, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\npinInit(in4aPin, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\n\npinInit(encoder1aPin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_MEDIUM);\npinInit(encoder1bPin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_MEDIUM);\npinInit(encoder2aPin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_MEDIUM);\npinInit(encoder2bPin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_MEDIUM);\npinInit(encoder3aPin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_MEDIUM);\npinInit(encoder3bPin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_MEDIUM);\npinInit(encoder4aPin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_MEDIUM);\npinInit(encoder4bPin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_MEDIUM);\n\n// I2C\npinInit(i2cScl, GPIO_MODE_AF_OD, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(i2cSda, GPIO_MODE_AF_OD, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\n\n// USB\npinInit(usbDnPin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(usbDpPin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(\nusbDpPullUpPin, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\npinInit(\nusbBusDetectionPin, GPIO_MODE_INPUT, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\n\n//LL_GPIO_AF_EnableRemap_TIM1();\nLL_GPIO_AF_Remap(AFIO_MAPR_TIM1_REMAP, AFIO_MAPR_TIM1_REMAP_FULLREMAP);\n//LL_GPIO_AF_RemapPartial1_TIM2();\nLL_GPIO_AF_Remap(AFIO_MAPR_TIM2_REMAP, AFIO_MAPR_TIM2_REMAP_PARTIALREMAP1);\n//LL_GPIO_AF_RemapPartial_TIM3();\nLL_GPIO_AF_Remap(AFIO_MAPR_TIM3_REMAP, AFIO_MAPR_TIM3_REMAP_PARTIALREMAP);\n//LL_GPIO_AF_EnableRemap_TIM4();\nLL_GPIO_AF_Remap(AFIO_MAPR_TIM4_REMAP, AFIO_MAPR_TIM4_REMAP);\n//LL_GPIO_AF_Remap_SWJ_NOJTAG();\nLL_GPIO_AF_Remap(AFIO_MAPR_SWJ_CFG, AFIO_MAPR_SWJ_CFG_JTAGDISABLE);\n//I2C1-2\nLL_GPIO_AF_Remap(AFIO_MAPR_I2C1_REMAP, AFIO_MAPR_I2C1_REMAP);\n\npinInit(servoPins, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_MEDIUM);\n\nfor (const auto&amp; p : utsTrigPin) {\npinWrite(p, 0);\npinInit(p, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_MEDIUM);\n}\nfor (const auto&amp; p : utsEchoPin) {\npinInit(p, GPIO_MODE_IT_RISING_FALLING, GPIO_PULLDOWN,\nGPIO_SPEED_FREQ_MEDIUM);\n}\n\nLL_GPIO_AF_Remap(AFIO_MAPR_USART1_REMAP, AFIO_MAPR_USART1_REMAP);\nLL_GPIO_AF_Remap(AFIO_MAPR_USART2_REMAP, AFIO_MAPR_USART2_REMAP);\n\nHAL_NVIC_SetPriority(EXTI4_IRQn, 7, 0); // ESP_EN\nHAL_NVIC_EnableIRQ(EXTI4_IRQn);\n\nHAL_NVIC_SetPriority(EXTI9_5_IRQn, utsIRQPrio, 0); // Ultrasound\nHAL_NVIC_EnableIRQ(EXTI9_5_IRQn);\n\nHAL_NVIC_SetPriority(i2cEvIRQn, i2cIRQnPrio, 0);\nHAL_NVIC_SetPriority(i2cErIRQn, i2cIRQnPrio, 0);\nHAL_NVIC_EnableIRQ(i2cEvIRQn);\nHAL_NVIC_EnableIRQ(i2cErIRQn);    pinInit(buzzerPin, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\n\nreinitEspStrappingPins();\n}\n\ninline bool isPressed(PinDef button) {\nreturn button == buttonOnPin ? pinRead(button) : !pinRead(button);\n}\n\ninline uint32_t getButtons() {\nuint32_t buttons = 0;\nfor (size_t i = 0; i &lt; buttonPin.size(); ++i) {\nbuttons |= isPressed(buttonPin[i]) &lt;&lt; i;\n}\nreturn buttons;\n}\n\ninline void setLeds(uint32_t ledsOn) {\nfor (size_t i = 0; i &lt; ledPin.size(); ++i) {\npinWrite(ledPin[i], ledsOn &amp; (1 &lt;&lt; i));\n}\n}\n\nvoid softResetInit();\nvoid softReset(); // Resets all peripherials to initial state, eg. when ESP32 restarts.\n</code></pre>"},{"location":"stm/ButtonController_8hpp/","title":"File ButtonController.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; ButtonController.hpp</p> <p>Go to the source code of this file.</p>"},{"location":"stm/ButtonController_8hpp/#public-functions","title":"Public Functions","text":"Type Name void buttonControllerPoll ()  void buttonControllerSetDebug (bool debug)"},{"location":"stm/ButtonController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/ButtonController_8hpp/#function-buttoncontrollerpoll","title":"function buttonControllerPoll","text":"<pre><code>void buttonControllerPoll () </code></pre>"},{"location":"stm/ButtonController_8hpp/#function-buttoncontrollersetdebug","title":"function buttonControllerSetDebug","text":"<pre><code>void buttonControllerSetDebug (\nbool debug\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/ButtonController.hpp</code></p>"},{"location":"stm/ButtonController_8hpp_source/","title":"File ButtonController.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; ButtonController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\nvoid buttonControllerPoll();\nvoid buttonControllerSetDebug(bool debug);\n</code></pre>"},{"location":"stm/BuzzerController_8hpp/","title":"File BuzzerController.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; BuzzerController.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Bsp.hpp\"</code></li> </ul>"},{"location":"stm/BuzzerController_8hpp/#public-functions","title":"Public Functions","text":"Type Name void buzzerSetState (bool on)"},{"location":"stm/BuzzerController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/BuzzerController_8hpp/#function-buzzersetstate","title":"function buzzerSetState","text":"<pre><code>inline void buzzerSetState (\nbool on\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/BuzzerController.hpp</code></p>"},{"location":"stm/BuzzerController_8hpp_source/","title":"File BuzzerController.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; BuzzerController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"Bsp.hpp\"\n\ninline void buzzerSetState(bool on) { pinWrite(buzzerPin, on); }\n</code></pre>"},{"location":"stm/CdcUartTunnel_8hpp/","title":"File CdcUartTunnel.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; CdcUartTunnel.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"usb_cdc.h\"</code></li> </ul>"},{"location":"stm/CdcUartTunnel_8hpp/#public-functions","title":"Public Functions","text":"Type Name bool tunnelOnSetLineCodingInIrq (const usb_cdc_line_coding &amp; old, const usb_cdc_line_coding &amp; current)  void tunnelPoll ()  void tunnelUartInit ()"},{"location":"stm/CdcUartTunnel_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/CdcUartTunnel_8hpp/#function-tunnelonsetlinecodinginirq","title":"function tunnelOnSetLineCodingInIrq","text":"<pre><code>bool tunnelOnSetLineCodingInIrq (\nconst usb_cdc_line_coding &amp; old,\nconst usb_cdc_line_coding &amp; current\n) </code></pre>"},{"location":"stm/CdcUartTunnel_8hpp/#function-tunnelpoll","title":"function tunnelPoll","text":"<pre><code>void tunnelPoll () </code></pre>"},{"location":"stm/CdcUartTunnel_8hpp/#function-tunneluartinit","title":"function tunnelUartInit","text":"<pre><code>void tunnelUartInit () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/CdcUartTunnel.hpp</code></p>"},{"location":"stm/CdcUartTunnel_8hpp_source/","title":"File CdcUartTunnel.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; CdcUartTunnel.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"usb_cdc.h\"\n\nvoid tunnelUartInit();\nvoid tunnelPoll();\nbool tunnelOnSetLineCodingInIrq(\nconst usb_cdc_line_coding&amp; old, const usb_cdc_line_coding&amp; current);\n</code></pre>"},{"location":"stm/ControlLink_8hpp/","title":"File ControlLink.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; ControlLink.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"stm/ControlLink_8hpp/#public-functions","title":"Public Functions","text":"Type Name void controlLinkReset ()  bool controlLinkRx (CoprocReq &amp; incoming)  void controlLinkTx (const CoprocStat &amp; outgoing)  void controlUartInit ()"},{"location":"stm/ControlLink_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/ControlLink_8hpp/#function-controllinkreset","title":"function controlLinkReset","text":"<pre><code>void controlLinkReset () </code></pre>"},{"location":"stm/ControlLink_8hpp/#function-controllinkrx","title":"function controlLinkRx","text":"<pre><code>bool controlLinkRx (\nCoprocReq &amp; incoming\n) </code></pre>"},{"location":"stm/ControlLink_8hpp/#function-controllinktx","title":"function controlLinkTx","text":"<pre><code>void controlLinkTx (\nconst CoprocStat &amp; outgoing\n) </code></pre>"},{"location":"stm/ControlLink_8hpp/#function-controluartinit","title":"function controlUartInit","text":"<pre><code>void controlUartInit () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/ControlLink.hpp</code></p>"},{"location":"stm/ControlLink_8hpp_source/","title":"File ControlLink.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; ControlLink.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n\n#include \"rbcx.pb.h\"\n\nvoid controlUartInit();\nvoid controlLinkTx(const CoprocStat&amp; outgoing);\nbool controlLinkRx(CoprocReq&amp; incoming);\nvoid controlLinkReset();\n</code></pre>"},{"location":"stm/DebugLink_8hpp/","title":"File DebugLink.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; DebugLink.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;sys/types.h&gt;</code></li> </ul>"},{"location":"stm/DebugLink_8hpp/#public-functions","title":"Public Functions","text":"Type Name void debugLinkPoll ()  ssize_t debugLinkTx (const uint8_t * data, size_t len)  void debugUartInit ()"},{"location":"stm/DebugLink_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/DebugLink_8hpp/#function-debuglinkpoll","title":"function debugLinkPoll","text":"<pre><code>void debugLinkPoll () </code></pre>"},{"location":"stm/DebugLink_8hpp/#function-debuglinktx","title":"function debugLinkTx","text":"<pre><code>ssize_t debugLinkTx (\nconst uint8_t * data,\nsize_t len\n) </code></pre>"},{"location":"stm/DebugLink_8hpp/#function-debuguartinit","title":"function debugUartInit","text":"<pre><code>void debugUartInit () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/DebugLink.hpp</code></p>"},{"location":"stm/DebugLink_8hpp_source/","title":"File DebugLink.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; DebugLink.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n#include &lt;sys/types.h&gt;\n\nvoid debugUartInit();\nvoid debugLinkPoll();\nssize_t debugLinkTx(const uint8_t* data, size_t len);\n</code></pre>"},{"location":"stm/Dispatcher_8hpp/","title":"File Dispatcher.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; Dispatcher.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"stm/Dispatcher_8hpp/#public-functions","title":"Public Functions","text":"Type Name bool dispatcherEnqueueRequest (const CoprocReq &amp; request)  bool dispatcherEnqueueStatus (const CoprocStat &amp; status)  void dispatcherInit ()  void dispatcherPoll ()  void dispatcherReset ()"},{"location":"stm/Dispatcher_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/Dispatcher_8hpp/#function-dispatcherenqueuerequest","title":"function dispatcherEnqueueRequest","text":"<pre><code>bool dispatcherEnqueueRequest (\nconst CoprocReq &amp; request\n) </code></pre>"},{"location":"stm/Dispatcher_8hpp/#function-dispatcherenqueuestatus","title":"function dispatcherEnqueueStatus","text":"<pre><code>bool dispatcherEnqueueStatus (\nconst CoprocStat &amp; status\n) </code></pre>"},{"location":"stm/Dispatcher_8hpp/#function-dispatcherinit","title":"function dispatcherInit","text":"<pre><code>void dispatcherInit () </code></pre>"},{"location":"stm/Dispatcher_8hpp/#function-dispatcherpoll","title":"function dispatcherPoll","text":"<pre><code>void dispatcherPoll () </code></pre>"},{"location":"stm/Dispatcher_8hpp/#function-dispatcherreset","title":"function dispatcherReset","text":"<pre><code>void dispatcherReset () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/Dispatcher.hpp</code></p>"},{"location":"stm/Dispatcher_8hpp_source/","title":"File Dispatcher.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; Dispatcher.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"rbcx.pb.h\"\n\nvoid dispatcherInit();\nbool dispatcherEnqueueStatus(const CoprocStat&amp; status);\nbool dispatcherEnqueueRequest(const CoprocReq&amp; request);\nvoid dispatcherPoll();\nvoid dispatcherReset();\n</code></pre>"},{"location":"stm/Esp32Manager_8hpp/","title":"File Esp32Manager.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; Esp32Manager.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"utils/TickTimer.hpp\"</code></li> </ul>"},{"location":"stm/Esp32Manager_8hpp/#classes","title":"Classes","text":"Type Name class Esp32Manager"},{"location":"stm/Esp32Manager_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name Esp32Manager sEsp32Manager"},{"location":"stm/Esp32Manager_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/Esp32Manager_8hpp/#variable-sesp32manager","title":"variable sEsp32Manager","text":"<pre><code>Esp32Manager sEsp32Manager;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/Esp32Manager.hpp</code></p>"},{"location":"stm/Esp32Manager_8hpp_source/","title":"File Esp32Manager.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; Esp32Manager.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"utils/TickTimer.hpp\"\n\nclass Esp32Manager {\nEsp32Manager(const Esp32Manager&amp;) = delete;\n\npublic:\nEsp32Manager();\n~Esp32Manager();\n\nvoid init();\nvoid poll();\n\nvoid queueReset(bool bootloader = false);\n\nvoid onEnRisingInIrq();\nvoid onSerialBreakInIrq(bool dtr, bool rst);\n\nbool isInBootloader() const { return m_inBootloader; }\nvoid resetWatchdog();\nvoid setWatchdogInhibit(bool inhibit);\n\nprivate:\nenum EnHolderType {\nEnSerialBreaks = 0,\nEnSwReset = 1,\n};\n\nenum QueuedReset {\nRstNone = 0,\nRstNormal = 1,\nRstBootloader = 2,\n};\n\nvoid holdReset(EnHolderType typ);\nvoid releaseReset(EnHolderType typ, bool strapForBootloader = false);\n\nvoid strapPins(bool bootloader);\nvoid unstrapPins();\n\nTickTimer m_unstrapTimer;\nTickTimer m_checkBreakTimer;\nTickTimer m_watchdogTimer;\n\nuint32_t m_enPinHolders;\n\nQueuedReset m_queuedReset;\nbool m_previousEnEdge;\nbool m_lastRts;\nbool m_lastDtr;\nbool m_inBootloader;\nbool m_watchdogInhibit;\n};\n\nextern Esp32Manager sEsp32Manager;\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/","title":"File FreeRTOSConfig.h","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; FreeRTOSConfig.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"stm32f1xx.h\"</code></li> </ul>"},{"location":"stm/FreeRTOSConfig_8h/#macros","title":"Macros","text":"Type Name define INCLUDE_eTaskGetState  1 define INCLUDE_uxTaskGetStackHighWaterMark  1 define INCLUDE_uxTaskPriorityGet  1 define INCLUDE_vTaskDelay  1 define INCLUDE_vTaskDelayUntil  1 define INCLUDE_vTaskDelete  1 define INCLUDE_vTaskPrioritySet  1 define INCLUDE_vTaskSuspend  1 define INCLUDE_xEventGroupSetBitFromISR  1 define INCLUDE_xResumeFromISR  1 define INCLUDE_xTaskAbortDelay  1 define INCLUDE_xTaskGetCurrentTaskHandle  1 define INCLUDE_xTaskGetHandle  1 define INCLUDE_xTaskGetIdleTaskHandle  1 define INCLUDE_xTaskGetSchedulerState  1 define INCLUDE_xTaskResumeFromISR  1 define INCLUDE_xTimerPendFunctionCall  0 define USE_FreeRTOS_HEAP_4 define configASSERT (x)  define configCHECK_FOR_STACK_OVERFLOW  2 define configCPU_CLOCK_HZ  (SystemCoreClock) define configGENERATE_RUN_TIME_STATS  0 define configIDLE_SHOULD_YIELD  1 define configKERNEL_INTERRUPT_PRIORITY      (configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS)) define configLIBRARY_LOWEST_INTERRUPT_PRIORITY  0xf define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY  5 define configMAX_CO_ROUTINE_PRIORITIES  (2) define configMAX_PRIORITIES  (7) define configMAX_SYSCALL_INTERRUPT_PRIORITY      (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS)) define configMAX_TASK_NAME_LEN  (16) define configMINIMAL_STACK_SIZE  ((uint16_t)64) define configPRIO_BITS  4 /* 15 priority levels */ define configQUEUE_REGISTRY_SIZE  8 define configRECORD_STACK_HIGH_ADDRESS  1 define configSUPPORT_DYNAMIC_ALLOCATION  1 define configSUPPORT_STATIC_ALLOCATION  1 define configTICK_RATE_HZ  ((TickType_t)1000) define configTIMER_QUEUE_LENGTH  10 define configTIMER_TASK_PRIORITY  (3) define configTIMER_TASK_STACK_DEPTH  (512) define configTOTAL_HEAP_SIZE  ((size_t)(15 * 1024)) define configUSE_16_BIT_TICKS  0 define configUSE_APPLICATION_TASK_TAG  0 define configUSE_COUNTING_SEMAPHORES  1 define configUSE_CO_ROUTINES  0 define configUSE_IDLE_HOOK  0 define configUSE_MALLOC_FAILED_HOOK  0 define configUSE_MUTEXES  1 define configUSE_PORT_OPTIMISED_TASK_SELECTION  1 define configUSE_PREEMPTION  1 define configUSE_RECURSIVE_MUTEXES  1 define configUSE_TICK_HOOK  1 define configUSE_TIMERS  1 define configUSE_TRACE_FACILITY  1 define vPortSVCHandler  SVC_Handler define xPortPendSVHandler  PendSV_Handler define xPortSysTickHandler  SysTick_Handler"},{"location":"stm/FreeRTOSConfig_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"stm/FreeRTOSConfig_8h/#define-include_etaskgetstate","title":"define INCLUDE_eTaskGetState","text":"<pre><code>#define INCLUDE_eTaskGetState 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-include_uxtaskgetstackhighwatermark","title":"define INCLUDE_uxTaskGetStackHighWaterMark","text":"<pre><code>#define INCLUDE_uxTaskGetStackHighWaterMark 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-include_uxtaskpriorityget","title":"define INCLUDE_uxTaskPriorityGet","text":"<pre><code>#define INCLUDE_uxTaskPriorityGet 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-include_vtaskdelay","title":"define INCLUDE_vTaskDelay","text":"<pre><code>#define INCLUDE_vTaskDelay 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-include_vtaskdelayuntil","title":"define INCLUDE_vTaskDelayUntil","text":"<pre><code>#define INCLUDE_vTaskDelayUntil 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-include_vtaskdelete","title":"define INCLUDE_vTaskDelete","text":"<pre><code>#define INCLUDE_vTaskDelete 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-include_vtaskpriorityset","title":"define INCLUDE_vTaskPrioritySet","text":"<pre><code>#define INCLUDE_vTaskPrioritySet 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-include_vtasksuspend","title":"define INCLUDE_vTaskSuspend","text":"<pre><code>#define INCLUDE_vTaskSuspend 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-include_xeventgroupsetbitfromisr","title":"define INCLUDE_xEventGroupSetBitFromISR","text":"<pre><code>#define INCLUDE_xEventGroupSetBitFromISR 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-include_xresumefromisr","title":"define INCLUDE_xResumeFromISR","text":"<pre><code>#define INCLUDE_xResumeFromISR 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-include_xtaskabortdelay","title":"define INCLUDE_xTaskAbortDelay","text":"<pre><code>#define INCLUDE_xTaskAbortDelay 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-include_xtaskgetcurrenttaskhandle","title":"define INCLUDE_xTaskGetCurrentTaskHandle","text":"<pre><code>#define INCLUDE_xTaskGetCurrentTaskHandle 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-include_xtaskgethandle","title":"define INCLUDE_xTaskGetHandle","text":"<pre><code>#define INCLUDE_xTaskGetHandle 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-include_xtaskgetidletaskhandle","title":"define INCLUDE_xTaskGetIdleTaskHandle","text":"<pre><code>#define INCLUDE_xTaskGetIdleTaskHandle 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-include_xtaskgetschedulerstate","title":"define INCLUDE_xTaskGetSchedulerState","text":"<pre><code>#define INCLUDE_xTaskGetSchedulerState 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-include_xtaskresumefromisr","title":"define INCLUDE_xTaskResumeFromISR","text":"<pre><code>#define INCLUDE_xTaskResumeFromISR 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-include_xtimerpendfunctioncall","title":"define INCLUDE_xTimerPendFunctionCall","text":"<pre><code>#define INCLUDE_xTimerPendFunctionCall 0\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-use_freertos_heap_4","title":"define USE_FreeRTOS_HEAP_4","text":"<pre><code>#define USE_FreeRTOS_HEAP_4 \n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configassert","title":"define configASSERT","text":"<pre><code>#define configASSERT (\nx\n) if ((x) == 0) {                                                            \\\n        taskDISABLE_INTERRUPTS();                                              \\\n        for (;;)                                                               \\\n            ;                                                                  \\\n    }\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configcheck_for_stack_overflow","title":"define configCHECK_FOR_STACK_OVERFLOW","text":"<pre><code>#define configCHECK_FOR_STACK_OVERFLOW 2\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configcpu_clock_hz","title":"define configCPU_CLOCK_HZ","text":"<pre><code>#define configCPU_CLOCK_HZ (SystemCoreClock)\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configgenerate_run_time_stats","title":"define configGENERATE_RUN_TIME_STATS","text":"<pre><code>#define configGENERATE_RUN_TIME_STATS 0\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configidle_should_yield","title":"define configIDLE_SHOULD_YIELD","text":"<pre><code>#define configIDLE_SHOULD_YIELD 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configkernel_interrupt_priority","title":"define configKERNEL_INTERRUPT_PRIORITY","text":"<pre><code>#define configKERNEL_INTERRUPT_PRIORITY (configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS))\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configlibrary_lowest_interrupt_priority","title":"define configLIBRARY_LOWEST_INTERRUPT_PRIORITY","text":"<pre><code>#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY 0xf\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configlibrary_max_syscall_interrupt_priority","title":"define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY","text":"<pre><code>#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 5\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configmax_co_routine_priorities","title":"define configMAX_CO_ROUTINE_PRIORITIES","text":"<pre><code>#define configMAX_CO_ROUTINE_PRIORITIES (2)\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configmax_priorities","title":"define configMAX_PRIORITIES","text":"<pre><code>#define configMAX_PRIORITIES (7)\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configmax_syscall_interrupt_priority","title":"define configMAX_SYSCALL_INTERRUPT_PRIORITY","text":"<pre><code>#define configMAX_SYSCALL_INTERRUPT_PRIORITY (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS))\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configmax_task_name_len","title":"define configMAX_TASK_NAME_LEN","text":"<pre><code>#define configMAX_TASK_NAME_LEN (16)\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configminimal_stack_size","title":"define configMINIMAL_STACK_SIZE","text":"<pre><code>#define configMINIMAL_STACK_SIZE ((uint16_t)64)\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configprio_bits","title":"define configPRIO_BITS","text":"<pre><code>#define configPRIO_BITS 4 /* 15 priority levels */\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configqueue_registry_size","title":"define configQUEUE_REGISTRY_SIZE","text":"<pre><code>#define configQUEUE_REGISTRY_SIZE 8\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configrecord_stack_high_address","title":"define configRECORD_STACK_HIGH_ADDRESS","text":"<pre><code>#define configRECORD_STACK_HIGH_ADDRESS 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configsupport_dynamic_allocation","title":"define configSUPPORT_DYNAMIC_ALLOCATION","text":"<pre><code>#define configSUPPORT_DYNAMIC_ALLOCATION 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configsupport_static_allocation","title":"define configSUPPORT_STATIC_ALLOCATION","text":"<pre><code>#define configSUPPORT_STATIC_ALLOCATION 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configtick_rate_hz","title":"define configTICK_RATE_HZ","text":"<pre><code>#define configTICK_RATE_HZ ((TickType_t)1000)\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configtimer_queue_length","title":"define configTIMER_QUEUE_LENGTH","text":"<pre><code>#define configTIMER_QUEUE_LENGTH 10\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configtimer_task_priority","title":"define configTIMER_TASK_PRIORITY","text":"<pre><code>#define configTIMER_TASK_PRIORITY (3)\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configtimer_task_stack_depth","title":"define configTIMER_TASK_STACK_DEPTH","text":"<pre><code>#define configTIMER_TASK_STACK_DEPTH (512)\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configtotal_heap_size","title":"define configTOTAL_HEAP_SIZE","text":"<pre><code>#define configTOTAL_HEAP_SIZE ((size_t)(15 * 1024))\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configuse_16_bit_ticks","title":"define configUSE_16_BIT_TICKS","text":"<pre><code>#define configUSE_16_BIT_TICKS 0\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configuse_application_task_tag","title":"define configUSE_APPLICATION_TASK_TAG","text":"<pre><code>#define configUSE_APPLICATION_TASK_TAG 0\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configuse_counting_semaphores","title":"define configUSE_COUNTING_SEMAPHORES","text":"<pre><code>#define configUSE_COUNTING_SEMAPHORES 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configuse_co_routines","title":"define configUSE_CO_ROUTINES","text":"<pre><code>#define configUSE_CO_ROUTINES 0\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configuse_idle_hook","title":"define configUSE_IDLE_HOOK","text":"<pre><code>#define configUSE_IDLE_HOOK 0\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configuse_malloc_failed_hook","title":"define configUSE_MALLOC_FAILED_HOOK","text":"<pre><code>#define configUSE_MALLOC_FAILED_HOOK 0\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configuse_mutexes","title":"define configUSE_MUTEXES","text":"<pre><code>#define configUSE_MUTEXES 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configuse_port_optimised_task_selection","title":"define configUSE_PORT_OPTIMISED_TASK_SELECTION","text":"<pre><code>#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configuse_preemption","title":"define configUSE_PREEMPTION","text":"<pre><code>#define configUSE_PREEMPTION 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configuse_recursive_mutexes","title":"define configUSE_RECURSIVE_MUTEXES","text":"<pre><code>#define configUSE_RECURSIVE_MUTEXES 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configuse_tick_hook","title":"define configUSE_TICK_HOOK","text":"<pre><code>#define configUSE_TICK_HOOK 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configuse_timers","title":"define configUSE_TIMERS","text":"<pre><code>#define configUSE_TIMERS 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-configuse_trace_facility","title":"define configUSE_TRACE_FACILITY","text":"<pre><code>#define configUSE_TRACE_FACILITY 1\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-vportsvchandler","title":"define vPortSVCHandler","text":"<pre><code>#define vPortSVCHandler SVC_Handler\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-xportpendsvhandler","title":"define xPortPendSVHandler","text":"<pre><code>#define xPortPendSVHandler PendSV_Handler\n</code></pre>"},{"location":"stm/FreeRTOSConfig_8h/#define-xportsystickhandler","title":"define xPortSysTickHandler","text":"<pre><code>#define xPortSysTickHandler SysTick_Handler\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/FreeRTOSConfig.h</code></p>"},{"location":"stm/FreeRTOSConfig_8h_source/","title":"File FreeRTOSConfig.h","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; FreeRTOSConfig.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.0.1\n * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n#ifndef FREERTOS_CONFIG_H\n#define FREERTOS_CONFIG_H\n\n#include \"stm32f1xx.h\"\n\n/* Ensure stdint is only used by the compiler, and not the assembler. */\n#if defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)\n#include &lt;stdint.h&gt;\nextern uint32_t SystemCoreClock;\n#endif\n\n/*  CMSIS-RTOSv2 defines 56 levels of priorities. To be able to use them\n *  all and avoid application misbehavior, configUSE_PORT_OPTIMISED_TASK_SELECTION\n *  must be set to 0 and configMAX_PRIORITIES to 56\n *\n */\n/* #define configMAX_PRIORITIES                 ( 56 ) */\n#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1\n#define configUSE_PREEMPTION 1\n#define configUSE_IDLE_HOOK 0\n#define configUSE_TICK_HOOK 1\n#define configMAX_PRIORITIES (7)\n#define configSUPPORT_STATIC_ALLOCATION 1\n#define configSUPPORT_DYNAMIC_ALLOCATION 1\n#define configCPU_CLOCK_HZ (SystemCoreClock)\n#define configTICK_RATE_HZ ((TickType_t)1000)\n#define configMINIMAL_STACK_SIZE ((uint16_t)64)\n#define configTOTAL_HEAP_SIZE ((size_t)(15 * 1024))\n#define configMAX_TASK_NAME_LEN (16)\n#define configUSE_TRACE_FACILITY 1\n#define configUSE_16_BIT_TICKS 0\n#define configIDLE_SHOULD_YIELD 1\n#define configUSE_MUTEXES 1\n#define configQUEUE_REGISTRY_SIZE 8\n#define configCHECK_FOR_STACK_OVERFLOW 2\n#define configRECORD_STACK_HIGH_ADDRESS 1\n#define configUSE_RECURSIVE_MUTEXES 1\n#define configUSE_MALLOC_FAILED_HOOK 0\n#define configUSE_APPLICATION_TASK_TAG 0\n#define configUSE_COUNTING_SEMAPHORES 1\n#define configGENERATE_RUN_TIME_STATS 0\n\n/* Co-routine definitions. */\n#define configUSE_CO_ROUTINES 0\n#define configMAX_CO_ROUTINE_PRIORITIES (2)\n\n/* Software timer definitions. */\n// #define configUSE_TIMERS 0\n// #define configTIMER_TASK_PRIORITY (2)\n// #define configTIMER_QUEUE_LENGTH 10\n// #define configTIMER_TASK_STACK_DEPTH (configMINIMAL_STACK_SIZE * 2)\n#define configUSE_TIMERS 1\n#define configTIMER_TASK_PRIORITY (3)\n#define configTIMER_QUEUE_LENGTH 10\n#define configTIMER_TASK_STACK_DEPTH (512)\n\n/* Set the following definitions to 1 to include the API function, or zero\nto exclude the API function. */\n#define INCLUDE_vTaskPrioritySet 1\n#define INCLUDE_uxTaskPriorityGet 1\n#define INCLUDE_vTaskDelete 1\n#define INCLUDE_vTaskSuspend 1\n#define INCLUDE_xResumeFromISR 1\n#define INCLUDE_vTaskDelayUntil 1\n#define INCLUDE_vTaskDelay 1\n#define INCLUDE_xTaskGetSchedulerState 1\n#define INCLUDE_xTaskGetCurrentTaskHandle 1\n#define INCLUDE_uxTaskGetStackHighWaterMark 1\n#define INCLUDE_xTaskGetIdleTaskHandle 1\n#define INCLUDE_eTaskGetState 1\n#define INCLUDE_xEventGroupSetBitFromISR 1\n#define INCLUDE_xTimerPendFunctionCall 0\n#define INCLUDE_xTaskAbortDelay 1\n#define INCLUDE_xTaskGetHandle 1\n#define INCLUDE_xTaskResumeFromISR 1\n\n/*------------- CMSIS-RTOS V2 specific defines -----------*/\n/* When using CMSIS-RTOSv2 set configSUPPORT_STATIC_ALLOCATION to 1\n * is mandatory to avoid compile errors.\n * CMSIS-RTOS V2 implmentation requires the following defines\n *\n#define configSUPPORT_STATIC_ALLOCATION          1   &lt;-- cmsis_os threads are created using xTaskCreateStatic() API\n#define configMAX_PRIORITIES                    (56) &lt;-- Priority range in CMSIS-RTOS V2 is [0 .. 56]\n#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0    &lt;-- when set to 1, configMAX_PRIORITIES can't be more than 32 which is not suitable for the new CMSIS-RTOS v2 priority range\n*/\n\n/* the CMSIS-RTOS V2 FreeRTOS wrapper is dependent on the heap implementation used\n * by the application thus the correct define need to be enabled from the list\n * below\n *\n//define USE_FreeRTOS_HEAP_1\n//define USE_FreeRTOS_HEAP_2\n//define USE_FreeRTOS_HEAP_3\n//define USE_FreeRTOS_HEAP_4\n//define USE_FreeRTOS_HEAP_5\n\n*/\n\n#define USE_FreeRTOS_HEAP_4\n\n/* Cortex-M specific definitions. */\n#ifdef __NVIC_PRIO_BITS\n/* __BVIC_PRIO_BITS will be specified when CMSIS is being used. */\n#define configPRIO_BITS __NVIC_PRIO_BITS\n#else\n#define configPRIO_BITS 4 /* 15 priority levels */\n#endif\n\n/* The lowest interrupt priority that can be used in a call to a \"set priority\"\nfunction. */\n#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY 0xf\n\n/* The highest interrupt priority that can be used by any interrupt service\nroutine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL\nINTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER\nPRIORITY THAN THIS! (higher priorities are lower numeric values. */\n#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 5\n\n/* Interrupt priorities used by the kernel port layer itself.  These are generic\nto all Cortex-M ports, and do not rely on any particular library functions. */\n#define configKERNEL_INTERRUPT_PRIORITY                                        \\\n    (configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS))\n/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!\nSee http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */\n#define configMAX_SYSCALL_INTERRUPT_PRIORITY                                   \\\n    (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS))\n\n/* Normal assert() semantics without relying on the provision of an assert.h\nheader file. */\n#define configASSERT(x)                                                        \\\n    if ((x) == 0) {                                                            \\\n        taskDISABLE_INTERRUPTS();                                              \\\n        for (;;)                                                               \\\n            ;                                                                  \\\n    }\n\n/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS\n   standard names. */\n#define vPortSVCHandler SVC_Handler\n#define xPortPendSVHandler PendSV_Handler\n\n/* IMPORTANT: FreeRTOS is using the SysTick as internal time base, thus make sure the system and peripherials are\n              using a different time base (TIM based for example).\n */\n#define xPortSysTickHandler SysTick_Handler\n\n#endif /* FREERTOS_CONFIG_H */\n</code></pre>"},{"location":"stm/I2cController_8hpp/","title":"File I2cController.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; I2cController.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"rbcx.pb.h\"</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> <li><code>#include \"event_groups.h\"</code></li> </ul>"},{"location":"stm/I2cController_8hpp/#public-types","title":"Public Types","text":"Type Name enum uint32_t I2cEvents"},{"location":"stm/I2cController_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name EventGroupHandle_t i2cEventGroup TaskHandle_t i2cTaskHandle"},{"location":"stm/I2cController_8hpp/#public-functions","title":"Public Functions","text":"Type Name uint8_t I2Cdev_IsDeviceReady (uint16_t DevAddress, uint32_t Trials=2, uint32_t Timeout=0)  uint8_t I2Cdev_Master_Receive (uint16_t DevAddress, uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_Master_Transmit (uint16_t DevAddress, uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_Mem_Read (uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_Mem_Write (uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_Slave_Receive (uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_Slave_Transmit (uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_init ()  uint8_t I2Cdev_readBit (uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t * data, uint16_t timeout)  uint8_t I2Cdev_readBitW (uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t * data, uint16_t timeout)  uint8_t I2Cdev_readBits (uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t * data, uint16_t timeout)  uint8_t I2Cdev_readBitsW (uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t * data, uint16_t timeout)  uint8_t I2Cdev_readByte (uint8_t devAddr, uint8_t regAddr, uint8_t * data, uint16_t timeout)  uint8_t I2Cdev_readBytes (uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t * data, uint16_t timeout)  uint8_t I2Cdev_readWord (uint8_t devAddr, uint8_t regAddr, uint16_t * data, uint16_t timeout)  uint8_t I2Cdev_readWords (uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t * data, uint16_t timeout)  uint8_t I2Cdev_scan ()  uint16_t I2Cdev_writeBit (uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data)  uint16_t I2Cdev_writeBitW (uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t data)  uint16_t I2Cdev_writeBits (uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data)  uint16_t I2Cdev_writeBitsW (uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t data)  uint16_t I2Cdev_writeByte (uint8_t devAddr, uint8_t regAddr, uint8_t data)  uint16_t I2Cdev_writeBytes (uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t * data)  uint16_t I2Cdev_writeWord (uint8_t devAddr, uint8_t regAddr, uint16_t data)  uint16_t I2Cdev_writeWords (uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t * data)  void i2cDispatch (const CoprocReq_I2cReq &amp; req)  void i2cReset ()"},{"location":"stm/I2cController_8hpp/#macros","title":"Macros","text":"Type Name define I2CDEV_DEFAULT_READ_TIMEOUT  10"},{"location":"stm/I2cController_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"stm/I2cController_8hpp/#enum-i2cevents","title":"enum I2cEvents","text":"<pre><code>enum I2cEvents {\nI2C_NONE = 0,\nI2C_MPU_TICK = 1,\nI2C_MESSAGE = 2\n};\n</code></pre>"},{"location":"stm/I2cController_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/I2cController_8hpp/#variable-i2ceventgroup","title":"variable i2cEventGroup","text":"<pre><code>EventGroupHandle_t i2cEventGroup;\n</code></pre>"},{"location":"stm/I2cController_8hpp/#variable-i2ctaskhandle","title":"variable i2cTaskHandle","text":"<pre><code>TaskHandle_t i2cTaskHandle;\n</code></pre>"},{"location":"stm/I2cController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/I2cController_8hpp/#function-i2cdev_isdeviceready","title":"function I2Cdev_IsDeviceReady","text":"<pre><code>uint8_t I2Cdev_IsDeviceReady (\nuint16_t DevAddress,\nuint32_t Trials=2,\nuint32_t Timeout=0\n) </code></pre>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_master_receive","title":"function I2Cdev_Master_Receive","text":"<pre><code>uint8_t I2Cdev_Master_Receive (\nuint16_t DevAddress,\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_master_transmit","title":"function I2Cdev_Master_Transmit","text":"<pre><code>uint8_t I2Cdev_Master_Transmit (\nuint16_t DevAddress,\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_mem_read","title":"function I2Cdev_Mem_Read","text":"<pre><code>uint8_t I2Cdev_Mem_Read (\nuint16_t DevAddress,\nuint16_t MemAddress,\nuint16_t MemAddSize,\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_mem_write","title":"function I2Cdev_Mem_Write","text":"<pre><code>uint8_t I2Cdev_Mem_Write (\nuint16_t DevAddress,\nuint16_t MemAddress,\nuint16_t MemAddSize,\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_slave_receive","title":"function I2Cdev_Slave_Receive","text":"<pre><code>uint8_t I2Cdev_Slave_Receive (\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_slave_transmit","title":"function I2Cdev_Slave_Transmit","text":"<pre><code>uint8_t I2Cdev_Slave_Transmit (\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_init","title":"function I2Cdev_init","text":"<pre><code>uint8_t I2Cdev_init () </code></pre>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_readbit","title":"function I2Cdev_readBit","text":"<pre><code>uint8_t I2Cdev_readBit (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitNum,\nuint8_t * data,\nuint16_t timeout\n) </code></pre> <p>Read a single bit from an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>bitNum</code> Bit position to read (0-7) </li> <li><code>data</code> Container for single bit value </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_readbitw","title":"function I2Cdev_readBitW","text":"<pre><code>uint8_t I2Cdev_readBitW (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitNum,\nuint16_t * data,\nuint16_t timeout\n) </code></pre> <p>Read a single bit from a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>bitNum</code> Bit position to read (0-15) </li> <li><code>data</code> Container for single bit value </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_readbits","title":"function I2Cdev_readBits","text":"<pre><code>uint8_t I2Cdev_readBits (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitStart,\nuint8_t length,\nuint8_t * data,\nuint16_t timeout\n) </code></pre> <p>Read multiple bits from an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>bitStart</code> First bit position to read (0-7) </li> <li><code>length</code> Number of bits to read (not more than 8) </li> <li><code>data</code> Container for right-aligned value (i.e. '101' read from any bitStart position will equal 0x05) </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_readbitsw","title":"function I2Cdev_readBitsW","text":"<pre><code>uint8_t I2Cdev_readBitsW (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitStart,\nuint8_t length,\nuint16_t * data,\nuint16_t timeout\n) </code></pre> <p>Read multiple bits from a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>bitStart</code> First bit position to read (0-15) </li> <li><code>length</code> Number of bits to read (not more than 16) </li> <li><code>data</code> Container for right-aligned value (i.e. '101' read from any bitStart position will equal 0x05) </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (1 = success, 0 = failure, -1 = timeout) </p>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_readbyte","title":"function I2Cdev_readByte","text":"<pre><code>uint8_t I2Cdev_readByte (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t * data,\nuint16_t timeout\n) </code></pre> <p>Read single byte from an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>data</code> Container for byte value read from device </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_readbytes","title":"function I2Cdev_readBytes","text":"<pre><code>uint8_t I2Cdev_readBytes (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t length,\nuint8_t * data,\nuint16_t timeout\n) </code></pre> <p>Read multiple bytes from an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> First register regAddr to read from </li> <li><code>length</code> Number of bytes to read </li> <li><code>data</code> Buffer to store read data in </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Number of bytes read (-1 indicates failure) </p>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_readword","title":"function I2Cdev_readWord","text":"<pre><code>uint8_t I2Cdev_readWord (\nuint8_t devAddr,\nuint8_t regAddr,\nuint16_t * data,\nuint16_t timeout\n) </code></pre> <p>Read single word from a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>data</code> Container for word value read from device </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_readwords","title":"function I2Cdev_readWords","text":"<pre><code>uint8_t I2Cdev_readWords (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t length,\nuint16_t * data,\nuint16_t timeout\n) </code></pre> <p>Read multiple words from a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> First register regAddr to read from </li> <li><code>length</code> Number of words to read </li> <li><code>data</code> Buffer to store read data in </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Number of words read (-1 indicates failure) </p>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_scan","title":"function I2Cdev_scan","text":"<pre><code>uint8_t I2Cdev_scan () </code></pre>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_writebit","title":"function I2Cdev_writeBit","text":"<pre><code>uint16_t I2Cdev_writeBit (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitNum,\nuint8_t data\n) </code></pre> <p>write a single bit in an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to write to </li> <li><code>bitNum</code> Bit position to write (0-7) </li> <li><code>value</code> New bit value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_writebitw","title":"function I2Cdev_writeBitW","text":"<pre><code>uint16_t I2Cdev_writeBitW (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitNum,\nuint16_t data\n) </code></pre> <p>write a single bit in a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to write to </li> <li><code>bitNum</code> Bit position to write (0-15) </li> <li><code>value</code> New bit value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_writebits","title":"function I2Cdev_writeBits","text":"<pre><code>uint16_t I2Cdev_writeBits (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitStart,\nuint8_t length,\nuint8_t data\n) </code></pre> <p>Write multiple bits in an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to write to </li> <li><code>bitStart</code> First bit position to write (0-7) </li> <li><code>length</code> Number of bits to write (not more than 8) </li> <li><code>data</code> Right-aligned value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_writebitsw","title":"function I2Cdev_writeBitsW","text":"<pre><code>uint16_t I2Cdev_writeBitsW (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitStart,\nuint8_t length,\nuint16_t data\n) </code></pre> <p>Write multiple bits in a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to write to </li> <li><code>bitStart</code> First bit position to write (0-15) </li> <li><code>length</code> Number of bits to write (not more than 16) </li> <li><code>data</code> Right-aligned value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_writebyte","title":"function I2Cdev_writeByte","text":"<pre><code>uint16_t I2Cdev_writeByte (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t data\n) </code></pre> <p>Write single byte to an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register address to write to </li> <li><code>data</code> New byte value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_writebytes","title":"function I2Cdev_writeBytes","text":"<pre><code>uint16_t I2Cdev_writeBytes (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t length,\nuint8_t * data\n) </code></pre> <p>Write multiple bytes to an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> First register address to write to </li> <li><code>length</code> Number of bytes to write </li> <li><code>data</code> Buffer to copy new data from </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_writeword","title":"function I2Cdev_writeWord","text":"<pre><code>uint16_t I2Cdev_writeWord (\nuint8_t devAddr,\nuint8_t regAddr,\nuint16_t data\n) </code></pre> <p>Write single word to a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register address to write to </li> <li><code>data</code> New word value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"stm/I2cController_8hpp/#function-i2cdev_writewords","title":"function I2Cdev_writeWords","text":"<pre><code>uint16_t I2Cdev_writeWords (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t length,\nuint16_t * data\n) </code></pre> <p>Write multiple words to a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> First register address to write to </li> <li><code>length</code> Number of words to write </li> <li><code>data</code> Buffer to copy new data from </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"stm/I2cController_8hpp/#function-i2cdispatch","title":"function i2cDispatch","text":"<pre><code>void i2cDispatch (\nconst CoprocReq_I2cReq &amp; req\n) </code></pre>"},{"location":"stm/I2cController_8hpp/#function-i2creset","title":"function i2cReset","text":"<pre><code>void i2cReset () </code></pre>"},{"location":"stm/I2cController_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"stm/I2cController_8hpp/#define-i2cdev_default_read_timeout","title":"define I2CDEV_DEFAULT_READ_TIMEOUT","text":"<pre><code>#define I2CDEV_DEFAULT_READ_TIMEOUT 10\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/I2cController.hpp</code></p>"},{"location":"stm/I2cController_8hpp_source/","title":"File I2cController.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; I2cController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>// I2Cdev library collection - Main I2C device class header file\n// Abstracts bit and byte I2C R/W functions into a convenient class\n// 6/9/2012 by Jeff Rowberg &lt;jeff@rowberg.net&gt;\n// 6/6/2015 by Andrey Voloshin &lt;voloshin@think.in.ua&gt;\n//\n// Changelog:\n//      2015-06-06 - ported to STM32 HAL library from Arduino code\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2013 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n#pragma once\n\n#include \"rbcx.pb.h\"\n\n#include &lt;stdint.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include \"stm32f1xx_hal.h\"\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\n#include \"event_groups.h\"\n\nenum I2cEvents : uint32_t {\nI2C_NONE = 0,\nI2C_MPU_TICK = 1,\nI2C_MESSAGE = 2,\n};\n\nextern TaskHandle_t i2cTaskHandle;\nextern EventGroupHandle_t i2cEventGroup;\n\nvoid i2cDispatch(const CoprocReq_I2cReq&amp; req);\nvoid i2cReset();\n\n#define I2CDEV_DEFAULT_READ_TIMEOUT 10\n\nuint8_t I2Cdev_init();\n\nuint8_t I2Cdev_Master_Transmit(\nuint16_t DevAddress, uint8_t* pData, uint16_t Size, uint32_t Timeout);\nuint8_t I2Cdev_Master_Receive(\nuint16_t DevAddress, uint8_t* pData, uint16_t Size, uint32_t Timeout);\nuint8_t I2Cdev_Slave_Transmit(uint8_t* pData, uint16_t Size, uint32_t Timeout);\nuint8_t I2Cdev_Slave_Receive(uint8_t* pData, uint16_t Size, uint32_t Timeout);\nuint8_t I2Cdev_Mem_Write(uint16_t DevAddress, uint16_t MemAddress,\nuint16_t MemAddSize, uint8_t* pData, uint16_t Size, uint32_t Timeout);\nuint8_t I2Cdev_Mem_Read(uint16_t DevAddress, uint16_t MemAddress,\nuint16_t MemAddSize, uint8_t* pData, uint16_t Size, uint32_t Timeout);\nuint8_t I2Cdev_IsDeviceReady(\nuint16_t DevAddress, uint32_t Trials = 2, uint32_t Timeout = 0);\n\nuint8_t I2Cdev_scan();\n\nuint8_t I2Cdev_readBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum,\nuint8_t* data, uint16_t timeout);\nuint8_t I2Cdev_readBitW(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum,\nuint16_t* data, uint16_t timeout);\nuint8_t I2Cdev_readBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart,\nuint8_t length, uint8_t* data, uint16_t timeout);\nuint8_t I2Cdev_readBitsW(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart,\nuint8_t length, uint16_t* data, uint16_t timeout);\nuint8_t I2Cdev_readByte(\nuint8_t devAddr, uint8_t regAddr, uint8_t* data, uint16_t timeout);\nuint8_t I2Cdev_readWord(\nuint8_t devAddr, uint8_t regAddr, uint16_t* data, uint16_t timeout);\nuint8_t I2Cdev_readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length,\nuint8_t* data, uint16_t timeout);\nuint8_t I2Cdev_readWords(uint8_t devAddr, uint8_t regAddr, uint8_t length,\nuint16_t* data, uint16_t timeout);\n\nuint16_t I2Cdev_writeBit(\nuint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data);\nuint16_t I2Cdev_writeBitW(\nuint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t data);\nuint16_t I2Cdev_writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart,\nuint8_t length, uint8_t data);\nuint16_t I2Cdev_writeBitsW(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart,\nuint8_t length, uint16_t data);\nuint16_t I2Cdev_writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data);\nuint16_t I2Cdev_writeWord(uint8_t devAddr, uint8_t regAddr, uint16_t data);\nuint16_t I2Cdev_writeBytes(\nuint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* data);\nuint16_t I2Cdev_writeWords(\nuint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t* data);\n</code></pre>"},{"location":"stm/Motor_8hpp/","title":"File Motor.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; Motor.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/Regulator.hpp\"</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"stm/Motor_8hpp/#classes","title":"Classes","text":"Type Name class Motor"},{"location":"stm/Motor_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name const uint16_t motorLoopFreq   = = 100"},{"location":"stm/Motor_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/Motor_8hpp/#variable-motorloopfreq","title":"variable motorLoopFreq","text":"<pre><code>const uint16_t motorLoopFreq;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/Motor.hpp</code></p>"},{"location":"stm/Motor_8hpp_source/","title":"File Motor.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; Motor.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"utils/Debug.hpp\"\n#include \"utils/Regulator.hpp\"\n\n#include &lt;stdint.h&gt;\n\ninline const uint16_t motorLoopFreq = 100;\n\nclass Motor {\npublic:\nMotor() {\nm_lastEncTicks = 0;\nreset();\n}\n\nvoid reset() {\nm_velocityReg = Regulator(INT16_MAX, 150000, 300000, 20000);\nm_positionReg = Regulator(500, 1000, 0, 0);\nm_dither = 0;\nm_targetVelocity = 0;\nm_actualPower = 0;\nm_actualPosition = 0;\nm_targetPosition = 0;\nm_actualTicksPerLoop = 0;\nm_posEpsilon = 3;\nm_velEpsilon = 3;\nm_maxAccel = 2000 / motorLoopFreq;\nm_mode = MotorMode_POWER;\n}\n\nbool atTargetPosition() const {\nreturn uint32_t(abs(m_actualPosition - m_targetPosition))\n&lt;= m_posEpsilon;\n}\n\nbool atStandstill() const {\nreturn uint32_t(abs(m_actualTicksPerLoop)) &lt;= m_velEpsilon;\n}\n\nMotorMode mode() const { return m_mode; }\nvoid modeChange(MotorMode newMode) { m_mode = newMode; }\n\nvoid reportStat(CoprocStat_MotorStat&amp; stat) {\nstat.mode = m_mode;\nstat.position = m_actualPosition;\nstat.power = m_actualPower;\nstat.velocity = m_actualTicksPerLoop * motorLoopFreq;\n};\n\nint16_t poll(uint16_t encTicks) {\nm_actualTicksPerLoop = encTicks - m_lastEncTicks;\nm_actualPosition += m_actualTicksPerLoop;\nm_lastEncTicks = encTicks;\n\nswitch (m_mode) {\ncase MotorMode_POSITION:\ncase MotorMode_POSITION_IDLE: {\n// DEBUG(\"i:%ld e:%ld s:%ld -&gt; v:%ld\\n\", m_positionReg.integrator(),\n//     m_positionReg.e(), m_actualPosition, m_positionReg.output());\nif (atTargetPosition() &amp;&amp; atStandstill()) {\nm_positionReg.clear();\nm_targetVelocity = 0;\nmodeChange(MotorMode_POSITION_IDLE);\n} else {\nauto action\n= m_positionReg.process(m_targetPosition, m_actualPosition);\n\n// Limit ramp-up to max acceleration\nif (action &gt; m_targetVelocity + m_maxAccel) {\nm_targetVelocity += m_maxAccel;\n} else if (action &lt; m_targetVelocity - m_maxAccel) {\nm_targetVelocity -= m_maxAccel;\n} else {\nm_targetVelocity = action;\n}\n}\n} // fallthrough\ncase MotorMode_VELOCITY: {\nint16_t targetTicksPerLoop = m_targetVelocity / motorLoopFreq;\nuint16_t targetTicksRem = abs(m_targetVelocity % motorLoopFreq);\nif ((targetTicksRem * 4) / motorLoopFreq &gt; m_dither) {\ntargetTicksPerLoop += m_targetVelocity &lt; 0 ? -1 : 1;\n}\nif (++m_dither &gt;= 4) {\nm_dither = 0;\n}\n\nauto action = m_velocityReg.process(\ntargetTicksPerLoop, m_actualTicksPerLoop);\nm_actualPower = action;\n} break;\ndefault:\nbreak;\n}\nreturn m_actualPower;\n}\n\nvoid setTargetPower(int16_t power) {\nif (m_mode != MotorMode_POWER) {\nmodeChange(MotorMode_POWER);\n}\nm_actualPower = power;\n}\n\nvoid setTargetBrakingPower(int16_t brakingPower) {\nif (m_mode != MotorMode_BRAKE) {\nmodeChange(MotorMode_BRAKE);\n}\nm_actualPower = brakingPower;\n}\n\nvoid setTargetVelocity(int16_t ticksPerSec) {\nif (m_mode != MotorMode_VELOCITY) {\nm_velocityReg.clear();\nmodeChange(MotorMode_VELOCITY);\n}\nm_targetVelocity = ticksPerSec;\n}\n\nvoid homePosition(int32_t homedTicks) {\nm_targetPosition = homedTicks;\nm_actualPosition = homedTicks;\n}\n\nvoid setTargetPosition(\nconst CoprocReq_MotorReq_SetPosition&amp; req, bool additive) {\nif (m_mode != MotorMode_POSITION) {\nm_positionReg.clear();\nmodeChange(MotorMode_POSITION);\n}\nif (additive) {\nm_targetPosition += req.targetPosition;\n} else {\nm_targetPosition = req.targetPosition;\n}\nm_positionReg.setMaxOutput(req.runningVelocity);\n}\n\nvoid setVelocityPid(const RegCoefs&amp; coefs) {\nm_velocityReg.setP(coefs.p);\nm_velocityReg.setI(coefs.i);\nm_velocityReg.setD(coefs.d);\nm_velocityReg.clear();\n}\n\nvoid setPositionPid(const RegCoefs&amp; coefs) {\nm_positionReg.setP(coefs.p);\nm_positionReg.setI(coefs.i);\nm_positionReg.setD(coefs.d);\nm_positionReg.clear();\n}\n\nvoid setConfig(const MotorConfig&amp; config) {\nm_velEpsilon = config.velEpsilon;\nm_posEpsilon = config.posEpsilon;\nm_maxAccel = config.maxAccel / motorLoopFreq;\n}\n\nprivate:\nRegulator m_velocityReg;\nRegulator m_positionReg;\nint16_t m_actualPower;\nint16_t m_targetVelocity;\nint32_t m_targetPosition;\nint32_t m_actualPosition;\nint16_t m_actualTicksPerLoop;\nuint16_t m_dither;\nuint16_t m_lastEncTicks;\nuint16_t m_posEpsilon;\nuint16_t m_velEpsilon;\nuint16_t m_maxAccel;\nMotorMode m_mode;\n};\n</code></pre>"},{"location":"stm/MotorController_8hpp/","title":"File MotorController.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; MotorController.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"stm/MotorController_8hpp/#public-functions","title":"Public Functions","text":"Type Name void motorDispatch (const CoprocReq_MotorReq &amp; request)  void motorInit ()  void motorReset ()"},{"location":"stm/MotorController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/MotorController_8hpp/#function-motordispatch","title":"function motorDispatch","text":"<pre><code>void motorDispatch (\nconst CoprocReq_MotorReq &amp; request\n) </code></pre>"},{"location":"stm/MotorController_8hpp/#function-motorinit","title":"function motorInit","text":"<pre><code>void motorInit () </code></pre>"},{"location":"stm/MotorController_8hpp/#function-motorreset","title":"function motorReset","text":"<pre><code>void motorReset () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/MotorController.hpp</code></p>"},{"location":"stm/MotorController_8hpp_source/","title":"File MotorController.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; MotorController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"rbcx.pb.h\"\n\nvoid motorInit();\nvoid motorDispatch(const CoprocReq_MotorReq&amp; request);\nvoid motorReset();\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/","title":"File Mpu6050.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; Mpu6050.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"I2cController.hpp\"</code></li> <li><code>#include &lt;stdbool.h&gt;</code></li> </ul>"},{"location":"stm/Mpu6050_8hpp/#classes","title":"Classes","text":"Type Name struct MPU6050_t"},{"location":"stm/Mpu6050_8hpp/#public-types","title":"Public Types","text":"Type Name typedef struct MPU6050_t MPU6050_t"},{"location":"stm/Mpu6050_8hpp/#public-functions","title":"Public Functions","text":"Type Name void MPU6050 (uint8_t address)  bool MPU6050_getAccelFIFOEnabled ()  bool MPU6050_getAccelXSelfTest ()  bool MPU6050_getAccelYSelfTest ()  bool MPU6050_getAccelZSelfTest ()  void MPU6050_getAcceleration (int16_t * x, int16_t * y, int16_t * z)  int16_t MPU6050_getAccelerationX ()  int16_t MPU6050_getAccelerationY ()  int16_t MPU6050_getAccelerationZ ()  uint8_t MPU6050_getAccelerometerPowerOnDelay ()  uint8_t MPU6050_getAuxVDDIOLevel ()  bool MPU6050_getClockOutputEnabled ()  uint8_t MPU6050_getClockSource ()  uint8_t MPU6050_getDHPFMode ()  uint8_t MPU6050_getDLPFMode ()  uint8_t MPU6050_getDMPConfig1 ()  uint8_t MPU6050_getDMPConfig2 ()  bool MPU6050_getDMPEnabled ()  bool MPU6050_getDMPInt0Status ()  bool MPU6050_getDMPInt1Status ()  bool MPU6050_getDMPInt2Status ()  bool MPU6050_getDMPInt3Status ()  bool MPU6050_getDMPInt4Status ()  bool MPU6050_getDMPInt5Status ()  uint8_t MPU6050_getDeviceID ()  uint8_t MPU6050_getExternalFrameSync ()  uint8_t MPU6050_getExternalSensorByte (int position)  uint16_t MPU6050_getExternalSensorWord (int position)  bool MPU6050_getExternalShadowDelayEnabled ()  uint8_t MPU6050_getFIFOByte ()  void MPU6050_getFIFOBytes (uint8_t * data, uint8_t length)  uint16_t MPU6050_getFIFOCount ()  bool MPU6050_getFIFOEnabled ()  bool MPU6050_getFSyncInterruptEnabled ()  bool MPU6050_getFSyncInterruptLevel ()  uint8_t MPU6050_getFreefallDetectionCounterDecrement ()  uint8_t MPU6050_getFreefallDetectionDuration ()  uint8_t MPU6050_getFreefallDetectionThreshold ()  uint8_t MPU6050_getFullScaleAccelRange ()  uint8_t MPU6050_getFullScaleGyroRange ()  bool MPU6050_getI2CBypassEnabled ()  bool MPU6050_getI2CMasterModeEnabled ()  bool MPU6050_getIntDMPEnabled ()  bool MPU6050_getIntDMPStatus ()  bool MPU6050_getIntDataReadyEnabled ()  bool MPU6050_getIntDataReadyStatus ()  uint8_t MPU6050_getIntEnabled ()  bool MPU6050_getIntFIFOBufferOverflowEnabled ()  bool MPU6050_getIntFIFOBufferOverflowStatus ()  bool MPU6050_getIntFreefallEnabled ()  bool MPU6050_getIntFreefallStatus ()  bool MPU6050_getIntI2CMasterEnabled ()  bool MPU6050_getIntI2CMasterStatus ()  bool MPU6050_getIntMotionEnabled ()  bool MPU6050_getIntMotionStatus ()  bool MPU6050_getIntPLLReadyEnabled ()  bool MPU6050_getIntPLLReadyStatus ()  uint8_t MPU6050_getIntStatus ()  bool MPU6050_getIntZeroMotionEnabled ()  bool MPU6050_getIntZeroMotionStatus ()  bool MPU6050_getInterruptDrive ()  bool MPU6050_getInterruptLatch ()  bool MPU6050_getInterruptLatchClear ()  bool MPU6050_getInterruptMode ()  bool MPU6050_getLostArbitration ()  uint8_t MPU6050_getMasterClockSpeed ()  void MPU6050_getMotion6 (int16_t * ax, int16_t * ay, int16_t * az, int16_t * gx, int16_t * gy, int16_t * gz)  void MPU6050_getMotion9 (int16_t * ax, int16_t * ay, int16_t * az, int16_t * gx, int16_t * gy, int16_t * gz, int16_t * mx, int16_t * my, int16_t * mz)  uint8_t MPU6050_getMotionDetectionCounterDecrement ()  uint8_t MPU6050_getMotionDetectionDuration ()  uint8_t MPU6050_getMotionDetectionThreshold ()  bool MPU6050_getMultiMasterEnabled ()  uint8_t MPU6050_getOTPBankValid ()  bool MPU6050_getPassthroughStatus ()  uint8_t MPU6050_getRate ()  void MPU6050_getRotation (int16_t * x, int16_t * y, int16_t * z)  int16_t MPU6050_getRotationX ()  int16_t MPU6050_getRotationY ()  int16_t MPU6050_getRotationZ ()  uint8_t MPU6050_getSlate4InputByte ()  bool MPU6050_getSlave0FIFOEnabled ()  bool MPU6050_getSlave0Nack ()  bool MPU6050_getSlave1FIFOEnabled ()  bool MPU6050_getSlave1Nack ()  bool MPU6050_getSlave2FIFOEnabled ()  bool MPU6050_getSlave2Nack ()  bool MPU6050_getSlave3FIFOEnabled ()  bool MPU6050_getSlave3Nack ()  uint8_t MPU6050_getSlave4Address ()  bool MPU6050_getSlave4Enabled ()  bool MPU6050_getSlave4InterruptEnabled ()  bool MPU6050_getSlave4IsDone ()  uint8_t MPU6050_getSlave4MasterDelay ()  bool MPU6050_getSlave4Nack ()  uint8_t MPU6050_getSlave4Register ()  bool MPU6050_getSlave4WriteMode ()  uint8_t MPU6050_getSlaveAddress (uint8_t num)  uint8_t MPU6050_getSlaveDataLength (uint8_t num)  bool MPU6050_getSlaveDelayEnabled (uint8_t num)  bool MPU6050_getSlaveEnabled (uint8_t num)  bool MPU6050_getSlaveReadWriteTransitionEnabled ()  uint8_t MPU6050_getSlaveRegister (uint8_t num)  bool MPU6050_getSlaveWordByteSwap (uint8_t num)  bool MPU6050_getSlaveWordGroupOffset (uint8_t num)  bool MPU6050_getSlaveWriteMode (uint8_t num)  bool MPU6050_getSleepEnabled ()  bool MPU6050_getStandbyXAccelEnabled ()  bool MPU6050_getStandbyXGyroEnabled ()  bool MPU6050_getStandbyYAccelEnabled ()  bool MPU6050_getStandbyYGyroEnabled ()  bool MPU6050_getStandbyZAccelEnabled ()  bool MPU6050_getStandbyZGyroEnabled ()  bool MPU6050_getTempFIFOEnabled ()  bool MPU6050_getTempSensorEnabled ()  int16_t MPU6050_getTemperature ()  bool MPU6050_getWaitForExternalSensorEnabled ()  bool MPU6050_getWakeCycleEnabled ()  uint8_t MPU6050_getWakeFrequency ()  int16_t MPU6050_getXAccelOffset ()  bool MPU6050_getXGyroFIFOEnabled ()  int16_t MPU6050_getXGyroOffset ()  bool MPU6050_getXNegMotionDetected ()  bool MPU6050_getXPosMotionDetected ()  int16_t MPU6050_getYAccelOffset ()  bool MPU6050_getYGyroFIFOEnabled ()  int16_t MPU6050_getYGyroOffset ()  bool MPU6050_getYNegMotionDetected ()  bool MPU6050_getYPosMotionDetected ()  int16_t MPU6050_getZAccelOffset ()  bool MPU6050_getZGyroFIFOEnabled ()  int16_t MPU6050_getZGyroOffset ()  bool MPU6050_getZNegMotionDetected ()  bool MPU6050_getZPosMotionDetected ()  bool MPU6050_getZeroMotionDetected ()  uint8_t MPU6050_getZeroMotionDetectionDuration ()  uint8_t MPU6050_getZeroMotionDetectionThreshold ()  void MPU6050_init ()  void MPU6050_initialize ()  void MPU6050_readMemoryBlock (uint8_t * data, uint16_t dataSize, uint8_t bank, uint8_t address)  uint8_t MPU6050_readMemoryByte ()  void MPU6050_reset ()  void MPU6050_resetAccelerometerPath ()  void MPU6050_resetDMP ()  void MPU6050_resetFIFO ()  void MPU6050_resetGyroscopePath ()  void MPU6050_resetI2CMaster ()  void MPU6050_resetSensors ()  void MPU6050_resetTemperaturePath ()  void MPU6050_setAccelFIFOEnabled (bool enabled)  void MPU6050_setAccelXSelfTest (bool enabled)  void MPU6050_setAccelYSelfTest (bool enabled)  void MPU6050_setAccelZSelfTest (bool enabled)  void MPU6050_setAccelerometerPowerOnDelay (uint8_t delay)  void MPU6050_setAuxVDDIOLevel (uint8_t level)  void MPU6050_setClockOutputEnabled (bool enabled)  void MPU6050_setClockSource (uint8_t source)  void MPU6050_setDHPFMode (uint8_t mode)  void MPU6050_setDLPFMode (uint8_t bandwidth)  void MPU6050_setDMPConfig1 (uint8_t config)  void MPU6050_setDMPConfig2 (uint8_t config)  void MPU6050_setDMPEnabled (bool enabled)  void MPU6050_setDeviceID (uint8_t id)  void MPU6050_setExternalFrameSync (uint8_t sync)  void MPU6050_setExternalShadowDelayEnabled (bool enabled)  void MPU6050_setFIFOByte (uint8_t data)  void MPU6050_setFIFOEnabled (bool enabled)  void MPU6050_setFSyncInterruptEnabled (bool enabled)  void MPU6050_setFSyncInterruptLevel (bool level)  void MPU6050_setFreefallDetectionCounterDecrement (uint8_t decrement)  void MPU6050_setFreefallDetectionDuration (uint8_t duration)  void MPU6050_setFreefallDetectionThreshold (uint8_t threshold)  void MPU6050_setFullScaleAccelRange (uint8_t range)  void MPU6050_setFullScaleGyroRange (uint8_t range)  void MPU6050_setI2CBypassEnabled (bool enabled)  void MPU6050_setI2CMasterModeEnabled (bool enabled)  void MPU6050_setIntDMPEnabled (bool enabled)  void MPU6050_setIntDataReadyEnabled (bool enabled)  void MPU6050_setIntEnabled (uint8_t enabled)  void MPU6050_setIntFIFOBufferOverflowEnabled (bool enabled)  void MPU6050_setIntFreefallEnabled (bool enabled)  void MPU6050_setIntI2CMasterEnabled (bool enabled)  void MPU6050_setIntMotionEnabled (bool enabled)  void MPU6050_setIntPLLReadyEnabled (bool enabled)  void MPU6050_setIntZeroMotionEnabled (bool enabled)  void MPU6050_setInterruptDrive (bool drive)  void MPU6050_setInterruptLatch (bool latch)  void MPU6050_setInterruptLatchClear (bool clear)  void MPU6050_setInterruptMode (bool mode)  void MPU6050_setMasterClockSpeed (uint8_t speed)  void MPU6050_setMemoryBank (uint8_t bank, bool prefetchEnabled, bool userBank)  void MPU6050_setMemoryStartAddress (uint8_t address)  void MPU6050_setMotionDetectionCounterDecrement (uint8_t decrement)  void MPU6050_setMotionDetectionDuration (uint8_t duration)  void MPU6050_setMotionDetectionThreshold (uint8_t threshold)  void MPU6050_setMultiMasterEnabled (bool enabled)  void MPU6050_setOTPBankValid (bool enabled)  void MPU6050_setRate (uint8_t rate)  void MPU6050_setSlave0FIFOEnabled (bool enabled)  void MPU6050_setSlave1FIFOEnabled (bool enabled)  void MPU6050_setSlave2FIFOEnabled (bool enabled)  void MPU6050_setSlave3FIFOEnabled (bool enabled)  void MPU6050_setSlave4Address (uint8_t address)  void MPU6050_setSlave4Enabled (bool enabled)  void MPU6050_setSlave4InterruptEnabled (bool enabled)  void MPU6050_setSlave4MasterDelay (uint8_t delay)  void MPU6050_setSlave4OutputByte (uint8_t data)  void MPU6050_setSlave4Register (uint8_t reg)  void MPU6050_setSlave4WriteMode (bool mode)  void MPU6050_setSlaveAddress (uint8_t num, uint8_t address)  void MPU6050_setSlaveDataLength (uint8_t num, uint8_t length)  void MPU6050_setSlaveDelayEnabled (uint8_t num, bool enabled)  void MPU6050_setSlaveEnabled (uint8_t num, bool enabled)  void MPU6050_setSlaveOutputByte (uint8_t num, uint8_t data)  void MPU6050_setSlaveReadWriteTransitionEnabled (bool enabled)  void MPU6050_setSlaveRegister (uint8_t num, uint8_t reg)  void MPU6050_setSlaveWordByteSwap (uint8_t num, bool enabled)  void MPU6050_setSlaveWordGroupOffset (uint8_t num, bool enabled)  void MPU6050_setSlaveWriteMode (uint8_t num, bool mode)  void MPU6050_setSleepEnabled (bool enabled)  void MPU6050_setStandbyXAccelEnabled (bool enabled)  void MPU6050_setStandbyXGyroEnabled (bool enabled)  void MPU6050_setStandbyYAccelEnabled (bool enabled)  void MPU6050_setStandbyYGyroEnabled (bool enabled)  void MPU6050_setStandbyZAccelEnabled (bool enabled)  void MPU6050_setStandbyZGyroEnabled (bool enabled)  void MPU6050_setTempFIFOEnabled (bool enabled)  void MPU6050_setTempSensorEnabled (bool enabled)  void MPU6050_setWaitForExternalSensorEnabled (bool enabled)  void MPU6050_setWakeCycleEnabled (bool enabled)  void MPU6050_setWakeFrequency (uint8_t frequency)  void MPU6050_setXAccelOffset (int16_t offset)  void MPU6050_setXFineGain (int8_t gain)  void MPU6050_setXGyroFIFOEnabled (bool enabled)  void MPU6050_setXGyroOffset (int16_t offset)  void MPU6050_setXGyroOffsetTC (int8_t offset)  void MPU6050_setYAccelOffset (int16_t offset)  void MPU6050_setYFineGain (int8_t gain)  void MPU6050_setYGyroFIFOEnabled (bool enabled)  void MPU6050_setYGyroOffset (int16_t offset)  void MPU6050_setYGyroOffsetTC (int8_t offset)  void MPU6050_setZAccelOffset (int16_t offset)  void MPU6050_setZFineGain (int8_t gain)  void MPU6050_setZGyroFIFOEnabled (bool enabled)  void MPU6050_setZGyroOffset (int16_t offset)  void MPU6050_setZGyroOffsetTC (int8_t offset)  void MPU6050_setZeroMotionDetectionDuration (uint8_t duration)  void MPU6050_setZeroMotionDetectionThreshold (uint8_t threshold)  void MPU6050_switchSPIEnabled (bool enabled)  bool MPU6050_testConnection ()  void MPU6050_writeMemoryByte (uint8_t data)  uint32_t getExternalSensorDWord (int position)  int8_t getXFineGain ()  int8_t getXGyroOffsetTC ()  int8_t getYFineGain ()  int8_t getYGyroOffsetTC ()  int8_t getZFineGain ()  int8_t getZGyroOffsetTC ()"},{"location":"stm/Mpu6050_8hpp/#macros","title":"Macros","text":"Type Name define MPU6050_ACCEL_FIFO_EN_BIT  3 define MPU6050_ACCEL_FS_16  0x03 define MPU6050_ACCEL_FS_2  0x00 define MPU6050_ACCEL_FS_4  0x01 define MPU6050_ACCEL_FS_8  0x02 define MPU6050_ACONFIG_ACCEL_HPF_BIT  2 define MPU6050_ACONFIG_ACCEL_HPF_LENGTH  3 define MPU6050_ACONFIG_AFS_SEL_BIT  4 define MPU6050_ACONFIG_AFS_SEL_LENGTH  2 define MPU6050_ACONFIG_XA_ST_BIT  7 define MPU6050_ACONFIG_YA_ST_BIT  6 define MPU6050_ACONFIG_ZA_ST_BIT  5 define MPU6050_ADDRESS_AD0_HIGH  0x69 define MPU6050_ADDRESS_AD0_LOW  0x68 define MPU6050_BANKSEL_CFG_USER_BANK_BIT  5 define MPU6050_BANKSEL_MEM_SEL_BIT  4 define MPU6050_BANKSEL_MEM_SEL_LENGTH  5 define MPU6050_BANKSEL_PRFTCH_EN_BIT  6 define MPU6050_CFG_DLPF_CFG_BIT  2 define MPU6050_CFG_DLPF_CFG_LENGTH  3 define MPU6050_CFG_EXT_SYNC_SET_BIT  5 define MPU6050_CFG_EXT_SYNC_SET_LENGTH  3 define MPU6050_CLOCK_DIV_258  0x8 define MPU6050_CLOCK_DIV_267  0x7 define MPU6050_CLOCK_DIV_276  0x6 define MPU6050_CLOCK_DIV_286  0x5 define MPU6050_CLOCK_DIV_296  0x4 define MPU6050_CLOCK_DIV_308  0x3 define MPU6050_CLOCK_DIV_320  0x2 define MPU6050_CLOCK_DIV_333  0x1 define MPU6050_CLOCK_DIV_348  0x0 define MPU6050_CLOCK_DIV_364  0xF define MPU6050_CLOCK_DIV_381  0xE define MPU6050_CLOCK_DIV_400  0xD define MPU6050_CLOCK_DIV_421  0xC define MPU6050_CLOCK_DIV_444  0xB define MPU6050_CLOCK_DIV_471  0xA define MPU6050_CLOCK_DIV_500  0x9 define MPU6050_CLOCK_INTERNAL  0x00 define MPU6050_CLOCK_KEEP_RESET  0x07 define MPU6050_CLOCK_PLL_EXT19M  0x05 define MPU6050_CLOCK_PLL_EXT32K  0x04 define MPU6050_CLOCK_PLL_XGYRO  0x01 define MPU6050_CLOCK_PLL_YGYRO  0x02 define MPU6050_CLOCK_PLL_ZGYRO  0x03 define MPU6050_DEFAULT_ADDRESS  MPU6050_ADDRESS_AD0_LOW define MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT  7 define MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT  0 define MPU6050_DELAYCTRL_I2C_SLV1_DLY_EN_BIT  1 define MPU6050_DELAYCTRL_I2C_SLV2_DLY_EN_BIT  2 define MPU6050_DELAYCTRL_I2C_SLV3_DLY_EN_BIT  3 define MPU6050_DELAYCTRL_I2C_SLV4_DLY_EN_BIT  4 define MPU6050_DETECT_ACCEL_ON_DELAY_BIT  5 define MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH  2 define MPU6050_DETECT_DECREMENT_1  0x1 define MPU6050_DETECT_DECREMENT_2  0x2 define MPU6050_DETECT_DECREMENT_4  0x3 define MPU6050_DETECT_DECREMENT_RESET  0x0 define MPU6050_DETECT_FF_COUNT_BIT  3 define MPU6050_DETECT_FF_COUNT_LENGTH  2 define MPU6050_DETECT_MOT_COUNT_BIT  1 define MPU6050_DETECT_MOT_COUNT_LENGTH  2 define MPU6050_DHPF_0P63  0x04 define MPU6050_DHPF_1P25  0x03 define MPU6050_DHPF_2P5  0x02 define MPU6050_DHPF_5  0x01 define MPU6050_DHPF_HOLD  0x07 define MPU6050_DHPF_RESET  0x00 define MPU6050_DLPF_BW_10  0x05 define MPU6050_DLPF_BW_188  0x01 define MPU6050_DLPF_BW_20  0x04 define MPU6050_DLPF_BW_256  0x00 define MPU6050_DLPF_BW_42  0x03 define MPU6050_DLPF_BW_5  0x06 define MPU6050_DLPF_BW_98  0x02 define MPU6050_DMPINT_0_BIT  0 define MPU6050_DMPINT_1_BIT  1 define MPU6050_DMPINT_2_BIT  2 define MPU6050_DMPINT_3_BIT  3 define MPU6050_DMPINT_4_BIT  4 define MPU6050_DMPINT_5_BIT  5 define MPU6050_DMP_MEMORY_BANKS  8 define MPU6050_DMP_MEMORY_BANK_SIZE  256 define MPU6050_DMP_MEMORY_CHUNK_SIZE  16 define MPU6050_EXT_SYNC_ACCEL_XOUT_L  0x5 define MPU6050_EXT_SYNC_ACCEL_YOUT_L  0x6 define MPU6050_EXT_SYNC_ACCEL_ZOUT_L  0x7 define MPU6050_EXT_SYNC_DISABLED  0x0 define MPU6050_EXT_SYNC_GYRO_XOUT_L  0x2 define MPU6050_EXT_SYNC_GYRO_YOUT_L  0x3 define MPU6050_EXT_SYNC_GYRO_ZOUT_L  0x4 define MPU6050_EXT_SYNC_TEMP_OUT_L  0x1 define MPU6050_GCONFIG_FS_SEL_BIT  4 define MPU6050_GCONFIG_FS_SEL_LENGTH  2 define MPU6050_GYRO_FS_1000  0x02 define MPU6050_GYRO_FS_2000  0x03 define MPU6050_GYRO_FS_250  0x00 define MPU6050_GYRO_FS_500  0x01 define MPU6050_I2C_MST_CLK_BIT  3 define MPU6050_I2C_MST_CLK_LENGTH  4 define MPU6050_I2C_MST_P_NSR_BIT  4 define MPU6050_I2C_SLV4_ADDR_BIT  6 define MPU6050_I2C_SLV4_ADDR_LENGTH  7 define MPU6050_I2C_SLV4_EN_BIT  7 define MPU6050_I2C_SLV4_INT_EN_BIT  6 define MPU6050_I2C_SLV4_MST_DLY_BIT  4 define MPU6050_I2C_SLV4_MST_DLY_LENGTH  5 define MPU6050_I2C_SLV4_REG_DIS_BIT  5 define MPU6050_I2C_SLV4_RW_BIT  7 define MPU6050_I2C_SLV_ADDR_BIT  6 define MPU6050_I2C_SLV_ADDR_LENGTH  7 define MPU6050_I2C_SLV_BYTE_SW_BIT  6 define MPU6050_I2C_SLV_EN_BIT  7 define MPU6050_I2C_SLV_GRP_BIT  4 define MPU6050_I2C_SLV_LEN_BIT  3 define MPU6050_I2C_SLV_LEN_LENGTH  4 define MPU6050_I2C_SLV_REG_DIS_BIT  5 define MPU6050_I2C_SLV_RW_BIT  7 define MPU6050_INTCFG_CLKOUT_EN_BIT  0 define MPU6050_INTCFG_FSYNC_INT_EN_BIT  2 define MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT  3 define MPU6050_INTCFG_I2C_BYPASS_EN_BIT  1 define MPU6050_INTCFG_INT_LEVEL_BIT  7 define MPU6050_INTCFG_INT_OPEN_BIT  6 define MPU6050_INTCFG_INT_RD_CLEAR_BIT  4 define MPU6050_INTCFG_LATCH_INT_EN_BIT  5 define MPU6050_INTCLEAR_ANYREAD  0x01 define MPU6050_INTCLEAR_STATUSREAD  0x00 define MPU6050_INTDRV_OPENDRAIN  0x01 define MPU6050_INTDRV_PUSHPULL  0x00 define MPU6050_INTERRUPT_DATA_RDY_BIT  0 define MPU6050_INTERRUPT_DMP_INT_BIT  1 define MPU6050_INTERRUPT_FF_BIT  7 define MPU6050_INTERRUPT_FIFO_OFLOW_BIT  4 define MPU6050_INTERRUPT_I2C_MST_INT_BIT  3 define MPU6050_INTERRUPT_MOT_BIT  6 define MPU6050_INTERRUPT_PLL_RDY_INT_BIT  2 define MPU6050_INTERRUPT_ZMOT_BIT  5 define MPU6050_INTLATCH_50USPULSE  0x00 define MPU6050_INTLATCH_WAITCLEAR  0x01 define MPU6050_INTMODE_ACTIVEHIGH  0x00 define MPU6050_INTMODE_ACTIVELOW  0x01 define MPU6050_MOTION_MOT_XNEG_BIT  7 define MPU6050_MOTION_MOT_XPOS_BIT  6 define MPU6050_MOTION_MOT_YNEG_BIT  5 define MPU6050_MOTION_MOT_YPOS_BIT  4 define MPU6050_MOTION_MOT_ZNEG_BIT  3 define MPU6050_MOTION_MOT_ZPOS_BIT  2 define MPU6050_MOTION_MOT_ZRMOT_BIT  0 define MPU6050_MST_I2C_LOST_ARB_BIT  5 define MPU6050_MST_I2C_SLV0_NACK_BIT  0 define MPU6050_MST_I2C_SLV1_NACK_BIT  1 define MPU6050_MST_I2C_SLV2_NACK_BIT  2 define MPU6050_MST_I2C_SLV3_NACK_BIT  3 define MPU6050_MST_I2C_SLV4_DONE_BIT  6 define MPU6050_MST_I2C_SLV4_NACK_BIT  4 define MPU6050_MST_PASS_THROUGH_BIT  7 define MPU6050_MULT_MST_EN_BIT  7 define MPU6050_PATHRESET_ACCEL_RESET_BIT  1 define MPU6050_PATHRESET_GYRO_RESET_BIT  2 define MPU6050_PATHRESET_TEMP_RESET_BIT  0 define MPU6050_PWR1_CLKSEL_BIT  2 define MPU6050_PWR1_CLKSEL_LENGTH  3 define MPU6050_PWR1_CYCLE_BIT  5 define MPU6050_PWR1_DEVICE_RESET_BIT  7 define MPU6050_PWR1_SLEEP_BIT  6 define MPU6050_PWR1_TEMP_DIS_BIT  3 define MPU6050_PWR2_LP_WAKE_CTRL_BIT  7 define MPU6050_PWR2_LP_WAKE_CTRL_LENGTH  2 define MPU6050_PWR2_STBY_XA_BIT  5 define MPU6050_PWR2_STBY_XG_BIT  2 define MPU6050_PWR2_STBY_YA_BIT  4 define MPU6050_PWR2_STBY_YG_BIT  1 define MPU6050_PWR2_STBY_ZA_BIT  3 define MPU6050_PWR2_STBY_ZG_BIT  0 define MPU6050_RA_ACCEL_CONFIG  0x1C define MPU6050_RA_ACCEL_XOUT_H  0x3B define MPU6050_RA_ACCEL_XOUT_L  0x3C define MPU6050_RA_ACCEL_YOUT_H  0x3D define MPU6050_RA_ACCEL_YOUT_L  0x3E define MPU6050_RA_ACCEL_ZOUT_H  0x3F define MPU6050_RA_ACCEL_ZOUT_L  0x40 define MPU6050_RA_BANK_SEL  0x6D define MPU6050_RA_CONFIG  0x1A define MPU6050_RA_DMP_CFG_1  0x70 define MPU6050_RA_DMP_CFG_2  0x71 define MPU6050_RA_DMP_INT_STATUS  0x39 define MPU6050_RA_EXT_SENS_DATA_00  0x49 define MPU6050_RA_EXT_SENS_DATA_01  0x4A define MPU6050_RA_EXT_SENS_DATA_02  0x4B define MPU6050_RA_EXT_SENS_DATA_03  0x4C define MPU6050_RA_EXT_SENS_DATA_04  0x4D define MPU6050_RA_EXT_SENS_DATA_05  0x4E define MPU6050_RA_EXT_SENS_DATA_06  0x4F define MPU6050_RA_EXT_SENS_DATA_07  0x50 define MPU6050_RA_EXT_SENS_DATA_08  0x51 define MPU6050_RA_EXT_SENS_DATA_09  0x52 define MPU6050_RA_EXT_SENS_DATA_10  0x53 define MPU6050_RA_EXT_SENS_DATA_11  0x54 define MPU6050_RA_EXT_SENS_DATA_12  0x55 define MPU6050_RA_EXT_SENS_DATA_13  0x56 define MPU6050_RA_EXT_SENS_DATA_14  0x57 define MPU6050_RA_EXT_SENS_DATA_15  0x58 define MPU6050_RA_EXT_SENS_DATA_16  0x59 define MPU6050_RA_EXT_SENS_DATA_17  0x5A define MPU6050_RA_EXT_SENS_DATA_18  0x5B define MPU6050_RA_EXT_SENS_DATA_19  0x5C define MPU6050_RA_EXT_SENS_DATA_20  0x5D define MPU6050_RA_EXT_SENS_DATA_21  0x5E define MPU6050_RA_EXT_SENS_DATA_22  0x5F define MPU6050_RA_EXT_SENS_DATA_23  0x60 define MPU6050_RA_FF_DUR  0x1E define MPU6050_RA_FF_THR  0x1D define MPU6050_RA_FIFO_COUNTH  0x72 define MPU6050_RA_FIFO_COUNTL  0x73 define MPU6050_RA_FIFO_EN  0x23 define MPU6050_RA_FIFO_R_W  0x74 define MPU6050_RA_GYRO_CONFIG  0x1B define MPU6050_RA_GYRO_XOUT_H  0x43 define MPU6050_RA_GYRO_XOUT_L  0x44 define MPU6050_RA_GYRO_YOUT_H  0x45 define MPU6050_RA_GYRO_YOUT_L  0x46 define MPU6050_RA_GYRO_ZOUT_H  0x47 define MPU6050_RA_GYRO_ZOUT_L  0x48 define MPU6050_RA_I2C_MST_CTRL  0x24 define MPU6050_RA_I2C_MST_DELAY_CTRL  0x67 define MPU6050_RA_I2C_MST_STATUS  0x36 define MPU6050_RA_I2C_SLV0_ADDR  0x25 define MPU6050_RA_I2C_SLV0_CTRL  0x27 define MPU6050_RA_I2C_SLV0_DO  0x63 define MPU6050_RA_I2C_SLV0_REG  0x26 define MPU6050_RA_I2C_SLV1_ADDR  0x28 define MPU6050_RA_I2C_SLV1_CTRL  0x2A define MPU6050_RA_I2C_SLV1_DO  0x64 define MPU6050_RA_I2C_SLV1_REG  0x29 define MPU6050_RA_I2C_SLV2_ADDR  0x2B define MPU6050_RA_I2C_SLV2_CTRL  0x2D define MPU6050_RA_I2C_SLV2_DO  0x65 define MPU6050_RA_I2C_SLV2_REG  0x2C define MPU6050_RA_I2C_SLV3_ADDR  0x2E define MPU6050_RA_I2C_SLV3_CTRL  0x30 define MPU6050_RA_I2C_SLV3_DO  0x66 define MPU6050_RA_I2C_SLV3_REG  0x2F define MPU6050_RA_I2C_SLV4_ADDR  0x31 define MPU6050_RA_I2C_SLV4_CTRL  0x34 define MPU6050_RA_I2C_SLV4_DI  0x35 define MPU6050_RA_I2C_SLV4_DO  0x33 define MPU6050_RA_I2C_SLV4_REG  0x32 define MPU6050_RA_INT_ENABLE  0x38 define MPU6050_RA_INT_PIN_CFG  0x37 define MPU6050_RA_INT_STATUS  0x3A define MPU6050_RA_MEM_R_W  0x6F define MPU6050_RA_MEM_START_ADDR  0x6E define MPU6050_RA_MOT_DETECT_CTRL  0x69 define MPU6050_RA_MOT_DETECT_STATUS  0x61 define MPU6050_RA_MOT_DUR  0x20 define MPU6050_RA_MOT_THR  0x1F define MPU6050_RA_PWR_MGMT_1  0x6B define MPU6050_RA_PWR_MGMT_2  0x6C define MPU6050_RA_SIGNAL_PATH_RESET  0x68 define MPU6050_RA_SMPLRT_DIV  0x19 define MPU6050_RA_TEMP_OUT_H  0x41 define MPU6050_RA_TEMP_OUT_L  0x42 define MPU6050_RA_USER_CTRL  0x6A define MPU6050_RA_WHO_AM_I  0x75 define MPU6050_RA_XA_OFFS_H  0x06 define MPU6050_RA_XA_OFFS_L_TC  0x07 define MPU6050_RA_XG_OFFS_TC  0x00 define MPU6050_RA_XG_OFFS_USRH  0x13 define MPU6050_RA_XG_OFFS_USRL  0x14 define MPU6050_RA_X_FINE_GAIN  0x03 define MPU6050_RA_YA_OFFS_H  0x08 define MPU6050_RA_YA_OFFS_L_TC  0x09 define MPU6050_RA_YG_OFFS_TC  0x01 define MPU6050_RA_YG_OFFS_USRH  0x15 define MPU6050_RA_YG_OFFS_USRL  0x16 define MPU6050_RA_Y_FINE_GAIN  0x04 define MPU6050_RA_ZA_OFFS_H  0x0A define MPU6050_RA_ZA_OFFS_L_TC  0x0B define MPU6050_RA_ZG_OFFS_TC  0x02 define MPU6050_RA_ZG_OFFS_USRH  0x17 define MPU6050_RA_ZG_OFFS_USRL  0x18 define MPU6050_RA_ZRMOT_DUR  0x22 define MPU6050_RA_ZRMOT_THR  0x21 define MPU6050_RA_Z_FINE_GAIN  0x05 define MPU6050_SLV0_FIFO_EN_BIT  0 define MPU6050_SLV1_FIFO_EN_BIT  1 define MPU6050_SLV2_FIFO_EN_BIT  2 define MPU6050_SLV_3_FIFO_EN_BIT  5 define MPU6050_TC_OFFSET_BIT  6 define MPU6050_TC_OFFSET_LENGTH  6 define MPU6050_TC_OTP_BNK_VLD_BIT  0 define MPU6050_TC_PWR_MODE_BIT  7 define MPU6050_TEMP_FIFO_EN_BIT  7 define MPU6050_USERCTRL_DMP_EN_BIT  7 define MPU6050_USERCTRL_DMP_RESET_BIT  3 define MPU6050_USERCTRL_FIFO_EN_BIT  6 define MPU6050_USERCTRL_FIFO_RESET_BIT  2 define MPU6050_USERCTRL_I2C_IF_DIS_BIT  4 define MPU6050_USERCTRL_I2C_MST_EN_BIT  5 define MPU6050_USERCTRL_I2C_MST_RESET_BIT  1 define MPU6050_USERCTRL_SIG_COND_RESET_BIT  0 define MPU6050_VDDIO_LEVEL_VDD  1 define MPU6050_VDDIO_LEVEL_VLOGIC  0 define MPU6050_WAIT_FOR_ES_BIT  6 define MPU6050_WAKE_FREQ_10  0x3 define MPU6050_WAKE_FREQ_1P25  0x0 define MPU6050_WAKE_FREQ_2P5  0x1 define MPU6050_WAKE_FREQ_5  0x2 define MPU6050_WHO_AM_I_BIT  6 define MPU6050_WHO_AM_I_LENGTH  6 define MPU6050_XG_FIFO_EN_BIT  6 define MPU6050_YG_FIFO_EN_BIT  5 define MPU6050_ZG_FIFO_EN_BIT  4"},{"location":"stm/Mpu6050_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"stm/Mpu6050_8hpp/#typedef-mpu6050_t","title":"typedef MPU6050_t","text":"<pre><code>typedef struct MPU6050_t MPU6050_t;\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/Mpu6050_8hpp/#function-mpu6050","title":"function MPU6050","text":"<pre><code>void MPU6050 (\nuint8_t address\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getaccelfifoenabled","title":"function MPU6050_getAccelFIFOEnabled","text":"<pre><code>bool MPU6050_getAccelFIFOEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getaccelxselftest","title":"function MPU6050_getAccelXSelfTest","text":"<pre><code>bool MPU6050_getAccelXSelfTest () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getaccelyselftest","title":"function MPU6050_getAccelYSelfTest","text":"<pre><code>bool MPU6050_getAccelYSelfTest () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getaccelzselftest","title":"function MPU6050_getAccelZSelfTest","text":"<pre><code>bool MPU6050_getAccelZSelfTest () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getacceleration","title":"function MPU6050_getAcceleration","text":"<pre><code>void MPU6050_getAcceleration (\nint16_t * x,\nint16_t * y,\nint16_t * z\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getaccelerationx","title":"function MPU6050_getAccelerationX","text":"<pre><code>int16_t MPU6050_getAccelerationX () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getaccelerationy","title":"function MPU6050_getAccelerationY","text":"<pre><code>int16_t MPU6050_getAccelerationY () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getaccelerationz","title":"function MPU6050_getAccelerationZ","text":"<pre><code>int16_t MPU6050_getAccelerationZ () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getaccelerometerpowerondelay","title":"function MPU6050_getAccelerometerPowerOnDelay","text":"<pre><code>uint8_t MPU6050_getAccelerometerPowerOnDelay () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getauxvddiolevel","title":"function MPU6050_getAuxVDDIOLevel","text":"<pre><code>uint8_t MPU6050_getAuxVDDIOLevel () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getclockoutputenabled","title":"function MPU6050_getClockOutputEnabled","text":"<pre><code>bool MPU6050_getClockOutputEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getclocksource","title":"function MPU6050_getClockSource","text":"<pre><code>uint8_t MPU6050_getClockSource () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getdhpfmode","title":"function MPU6050_getDHPFMode","text":"<pre><code>uint8_t MPU6050_getDHPFMode () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getdlpfmode","title":"function MPU6050_getDLPFMode","text":"<pre><code>uint8_t MPU6050_getDLPFMode () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getdmpconfig1","title":"function MPU6050_getDMPConfig1","text":"<pre><code>uint8_t MPU6050_getDMPConfig1 () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getdmpconfig2","title":"function MPU6050_getDMPConfig2","text":"<pre><code>uint8_t MPU6050_getDMPConfig2 () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getdmpenabled","title":"function MPU6050_getDMPEnabled","text":"<pre><code>bool MPU6050_getDMPEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getdmpint0status","title":"function MPU6050_getDMPInt0Status","text":"<pre><code>bool MPU6050_getDMPInt0Status () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getdmpint1status","title":"function MPU6050_getDMPInt1Status","text":"<pre><code>bool MPU6050_getDMPInt1Status () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getdmpint2status","title":"function MPU6050_getDMPInt2Status","text":"<pre><code>bool MPU6050_getDMPInt2Status () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getdmpint3status","title":"function MPU6050_getDMPInt3Status","text":"<pre><code>bool MPU6050_getDMPInt3Status () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getdmpint4status","title":"function MPU6050_getDMPInt4Status","text":"<pre><code>bool MPU6050_getDMPInt4Status () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getdmpint5status","title":"function MPU6050_getDMPInt5Status","text":"<pre><code>bool MPU6050_getDMPInt5Status () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getdeviceid","title":"function MPU6050_getDeviceID","text":"<pre><code>uint8_t MPU6050_getDeviceID () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getexternalframesync","title":"function MPU6050_getExternalFrameSync","text":"<pre><code>uint8_t MPU6050_getExternalFrameSync () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getexternalsensorbyte","title":"function MPU6050_getExternalSensorByte","text":"<pre><code>uint8_t MPU6050_getExternalSensorByte (\nint position\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getexternalsensorword","title":"function MPU6050_getExternalSensorWord","text":"<pre><code>uint16_t MPU6050_getExternalSensorWord (\nint position\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getexternalshadowdelayenabled","title":"function MPU6050_getExternalShadowDelayEnabled","text":"<pre><code>bool MPU6050_getExternalShadowDelayEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getfifobyte","title":"function MPU6050_getFIFOByte","text":"<pre><code>uint8_t MPU6050_getFIFOByte () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getfifobytes","title":"function MPU6050_getFIFOBytes","text":"<pre><code>void MPU6050_getFIFOBytes (\nuint8_t * data,\nuint8_t length\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getfifocount","title":"function MPU6050_getFIFOCount","text":"<pre><code>uint16_t MPU6050_getFIFOCount () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getfifoenabled","title":"function MPU6050_getFIFOEnabled","text":"<pre><code>bool MPU6050_getFIFOEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getfsyncinterruptenabled","title":"function MPU6050_getFSyncInterruptEnabled","text":"<pre><code>bool MPU6050_getFSyncInterruptEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getfsyncinterruptlevel","title":"function MPU6050_getFSyncInterruptLevel","text":"<pre><code>bool MPU6050_getFSyncInterruptLevel () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getfreefalldetectioncounterdecrement","title":"function MPU6050_getFreefallDetectionCounterDecrement","text":"<pre><code>uint8_t MPU6050_getFreefallDetectionCounterDecrement () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getfreefalldetectionduration","title":"function MPU6050_getFreefallDetectionDuration","text":"<pre><code>uint8_t MPU6050_getFreefallDetectionDuration () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getfreefalldetectionthreshold","title":"function MPU6050_getFreefallDetectionThreshold","text":"<pre><code>uint8_t MPU6050_getFreefallDetectionThreshold () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getfullscaleaccelrange","title":"function MPU6050_getFullScaleAccelRange","text":"<pre><code>uint8_t MPU6050_getFullScaleAccelRange () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getfullscalegyrorange","title":"function MPU6050_getFullScaleGyroRange","text":"<pre><code>uint8_t MPU6050_getFullScaleGyroRange () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_geti2cbypassenabled","title":"function MPU6050_getI2CBypassEnabled","text":"<pre><code>bool MPU6050_getI2CBypassEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_geti2cmastermodeenabled","title":"function MPU6050_getI2CMasterModeEnabled","text":"<pre><code>bool MPU6050_getI2CMasterModeEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getintdmpenabled","title":"function MPU6050_getIntDMPEnabled","text":"<pre><code>bool MPU6050_getIntDMPEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getintdmpstatus","title":"function MPU6050_getIntDMPStatus","text":"<pre><code>bool MPU6050_getIntDMPStatus () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getintdatareadyenabled","title":"function MPU6050_getIntDataReadyEnabled","text":"<pre><code>bool MPU6050_getIntDataReadyEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getintdatareadystatus","title":"function MPU6050_getIntDataReadyStatus","text":"<pre><code>bool MPU6050_getIntDataReadyStatus () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getintenabled","title":"function MPU6050_getIntEnabled","text":"<pre><code>uint8_t MPU6050_getIntEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getintfifobufferoverflowenabled","title":"function MPU6050_getIntFIFOBufferOverflowEnabled","text":"<pre><code>bool MPU6050_getIntFIFOBufferOverflowEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getintfifobufferoverflowstatus","title":"function MPU6050_getIntFIFOBufferOverflowStatus","text":"<pre><code>bool MPU6050_getIntFIFOBufferOverflowStatus () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getintfreefallenabled","title":"function MPU6050_getIntFreefallEnabled","text":"<pre><code>bool MPU6050_getIntFreefallEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getintfreefallstatus","title":"function MPU6050_getIntFreefallStatus","text":"<pre><code>bool MPU6050_getIntFreefallStatus () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getinti2cmasterenabled","title":"function MPU6050_getIntI2CMasterEnabled","text":"<pre><code>bool MPU6050_getIntI2CMasterEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getinti2cmasterstatus","title":"function MPU6050_getIntI2CMasterStatus","text":"<pre><code>bool MPU6050_getIntI2CMasterStatus () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getintmotionenabled","title":"function MPU6050_getIntMotionEnabled","text":"<pre><code>bool MPU6050_getIntMotionEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getintmotionstatus","title":"function MPU6050_getIntMotionStatus","text":"<pre><code>bool MPU6050_getIntMotionStatus () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getintpllreadyenabled","title":"function MPU6050_getIntPLLReadyEnabled","text":"<pre><code>bool MPU6050_getIntPLLReadyEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getintpllreadystatus","title":"function MPU6050_getIntPLLReadyStatus","text":"<pre><code>bool MPU6050_getIntPLLReadyStatus () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getintstatus","title":"function MPU6050_getIntStatus","text":"<pre><code>uint8_t MPU6050_getIntStatus () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getintzeromotionenabled","title":"function MPU6050_getIntZeroMotionEnabled","text":"<pre><code>bool MPU6050_getIntZeroMotionEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getintzeromotionstatus","title":"function MPU6050_getIntZeroMotionStatus","text":"<pre><code>bool MPU6050_getIntZeroMotionStatus () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getinterruptdrive","title":"function MPU6050_getInterruptDrive","text":"<pre><code>bool MPU6050_getInterruptDrive () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getinterruptlatch","title":"function MPU6050_getInterruptLatch","text":"<pre><code>bool MPU6050_getInterruptLatch () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getinterruptlatchclear","title":"function MPU6050_getInterruptLatchClear","text":"<pre><code>bool MPU6050_getInterruptLatchClear () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getinterruptmode","title":"function MPU6050_getInterruptMode","text":"<pre><code>bool MPU6050_getInterruptMode () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getlostarbitration","title":"function MPU6050_getLostArbitration","text":"<pre><code>bool MPU6050_getLostArbitration () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getmasterclockspeed","title":"function MPU6050_getMasterClockSpeed","text":"<pre><code>uint8_t MPU6050_getMasterClockSpeed () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getmotion6","title":"function MPU6050_getMotion6","text":"<pre><code>void MPU6050_getMotion6 (\nint16_t * ax,\nint16_t * ay,\nint16_t * az,\nint16_t * gx,\nint16_t * gy,\nint16_t * gz\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getmotion9","title":"function MPU6050_getMotion9","text":"<pre><code>void MPU6050_getMotion9 (\nint16_t * ax,\nint16_t * ay,\nint16_t * az,\nint16_t * gx,\nint16_t * gy,\nint16_t * gz,\nint16_t * mx,\nint16_t * my,\nint16_t * mz\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getmotiondetectioncounterdecrement","title":"function MPU6050_getMotionDetectionCounterDecrement","text":"<pre><code>uint8_t MPU6050_getMotionDetectionCounterDecrement () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getmotiondetectionduration","title":"function MPU6050_getMotionDetectionDuration","text":"<pre><code>uint8_t MPU6050_getMotionDetectionDuration () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getmotiondetectionthreshold","title":"function MPU6050_getMotionDetectionThreshold","text":"<pre><code>uint8_t MPU6050_getMotionDetectionThreshold () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getmultimasterenabled","title":"function MPU6050_getMultiMasterEnabled","text":"<pre><code>bool MPU6050_getMultiMasterEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getotpbankvalid","title":"function MPU6050_getOTPBankValid","text":"<pre><code>uint8_t MPU6050_getOTPBankValid () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getpassthroughstatus","title":"function MPU6050_getPassthroughStatus","text":"<pre><code>bool MPU6050_getPassthroughStatus () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getrate","title":"function MPU6050_getRate","text":"<pre><code>uint8_t MPU6050_getRate () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getrotation","title":"function MPU6050_getRotation","text":"<pre><code>void MPU6050_getRotation (\nint16_t * x,\nint16_t * y,\nint16_t * z\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getrotationx","title":"function MPU6050_getRotationX","text":"<pre><code>int16_t MPU6050_getRotationX () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getrotationy","title":"function MPU6050_getRotationY","text":"<pre><code>int16_t MPU6050_getRotationY () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getrotationz","title":"function MPU6050_getRotationZ","text":"<pre><code>int16_t MPU6050_getRotationZ () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslate4inputbyte","title":"function MPU6050_getSlate4InputByte","text":"<pre><code>uint8_t MPU6050_getSlate4InputByte () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslave0fifoenabled","title":"function MPU6050_getSlave0FIFOEnabled","text":"<pre><code>bool MPU6050_getSlave0FIFOEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslave0nack","title":"function MPU6050_getSlave0Nack","text":"<pre><code>bool MPU6050_getSlave0Nack () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslave1fifoenabled","title":"function MPU6050_getSlave1FIFOEnabled","text":"<pre><code>bool MPU6050_getSlave1FIFOEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslave1nack","title":"function MPU6050_getSlave1Nack","text":"<pre><code>bool MPU6050_getSlave1Nack () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslave2fifoenabled","title":"function MPU6050_getSlave2FIFOEnabled","text":"<pre><code>bool MPU6050_getSlave2FIFOEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslave2nack","title":"function MPU6050_getSlave2Nack","text":"<pre><code>bool MPU6050_getSlave2Nack () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslave3fifoenabled","title":"function MPU6050_getSlave3FIFOEnabled","text":"<pre><code>bool MPU6050_getSlave3FIFOEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslave3nack","title":"function MPU6050_getSlave3Nack","text":"<pre><code>bool MPU6050_getSlave3Nack () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslave4address","title":"function MPU6050_getSlave4Address","text":"<pre><code>uint8_t MPU6050_getSlave4Address () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslave4enabled","title":"function MPU6050_getSlave4Enabled","text":"<pre><code>bool MPU6050_getSlave4Enabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslave4interruptenabled","title":"function MPU6050_getSlave4InterruptEnabled","text":"<pre><code>bool MPU6050_getSlave4InterruptEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslave4isdone","title":"function MPU6050_getSlave4IsDone","text":"<pre><code>bool MPU6050_getSlave4IsDone () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslave4masterdelay","title":"function MPU6050_getSlave4MasterDelay","text":"<pre><code>uint8_t MPU6050_getSlave4MasterDelay () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslave4nack","title":"function MPU6050_getSlave4Nack","text":"<pre><code>bool MPU6050_getSlave4Nack () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslave4register","title":"function MPU6050_getSlave4Register","text":"<pre><code>uint8_t MPU6050_getSlave4Register () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslave4writemode","title":"function MPU6050_getSlave4WriteMode","text":"<pre><code>bool MPU6050_getSlave4WriteMode () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslaveaddress","title":"function MPU6050_getSlaveAddress","text":"<pre><code>uint8_t MPU6050_getSlaveAddress (\nuint8_t num\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslavedatalength","title":"function MPU6050_getSlaveDataLength","text":"<pre><code>uint8_t MPU6050_getSlaveDataLength (\nuint8_t num\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslavedelayenabled","title":"function MPU6050_getSlaveDelayEnabled","text":"<pre><code>bool MPU6050_getSlaveDelayEnabled (\nuint8_t num\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslaveenabled","title":"function MPU6050_getSlaveEnabled","text":"<pre><code>bool MPU6050_getSlaveEnabled (\nuint8_t num\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslavereadwritetransitionenabled","title":"function MPU6050_getSlaveReadWriteTransitionEnabled","text":"<pre><code>bool MPU6050_getSlaveReadWriteTransitionEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslaveregister","title":"function MPU6050_getSlaveRegister","text":"<pre><code>uint8_t MPU6050_getSlaveRegister (\nuint8_t num\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslavewordbyteswap","title":"function MPU6050_getSlaveWordByteSwap","text":"<pre><code>bool MPU6050_getSlaveWordByteSwap (\nuint8_t num\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslavewordgroupoffset","title":"function MPU6050_getSlaveWordGroupOffset","text":"<pre><code>bool MPU6050_getSlaveWordGroupOffset (\nuint8_t num\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getslavewritemode","title":"function MPU6050_getSlaveWriteMode","text":"<pre><code>bool MPU6050_getSlaveWriteMode (\nuint8_t num\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getsleepenabled","title":"function MPU6050_getSleepEnabled","text":"<pre><code>bool MPU6050_getSleepEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getstandbyxaccelenabled","title":"function MPU6050_getStandbyXAccelEnabled","text":"<pre><code>bool MPU6050_getStandbyXAccelEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getstandbyxgyroenabled","title":"function MPU6050_getStandbyXGyroEnabled","text":"<pre><code>bool MPU6050_getStandbyXGyroEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getstandbyyaccelenabled","title":"function MPU6050_getStandbyYAccelEnabled","text":"<pre><code>bool MPU6050_getStandbyYAccelEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getstandbyygyroenabled","title":"function MPU6050_getStandbyYGyroEnabled","text":"<pre><code>bool MPU6050_getStandbyYGyroEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getstandbyzaccelenabled","title":"function MPU6050_getStandbyZAccelEnabled","text":"<pre><code>bool MPU6050_getStandbyZAccelEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getstandbyzgyroenabled","title":"function MPU6050_getStandbyZGyroEnabled","text":"<pre><code>bool MPU6050_getStandbyZGyroEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_gettempfifoenabled","title":"function MPU6050_getTempFIFOEnabled","text":"<pre><code>bool MPU6050_getTempFIFOEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_gettempsensorenabled","title":"function MPU6050_getTempSensorEnabled","text":"<pre><code>bool MPU6050_getTempSensorEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_gettemperature","title":"function MPU6050_getTemperature","text":"<pre><code>int16_t MPU6050_getTemperature () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getwaitforexternalsensorenabled","title":"function MPU6050_getWaitForExternalSensorEnabled","text":"<pre><code>bool MPU6050_getWaitForExternalSensorEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getwakecycleenabled","title":"function MPU6050_getWakeCycleEnabled","text":"<pre><code>bool MPU6050_getWakeCycleEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getwakefrequency","title":"function MPU6050_getWakeFrequency","text":"<pre><code>uint8_t MPU6050_getWakeFrequency () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getxacceloffset","title":"function MPU6050_getXAccelOffset","text":"<pre><code>int16_t MPU6050_getXAccelOffset () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getxgyrofifoenabled","title":"function MPU6050_getXGyroFIFOEnabled","text":"<pre><code>bool MPU6050_getXGyroFIFOEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getxgyrooffset","title":"function MPU6050_getXGyroOffset","text":"<pre><code>int16_t MPU6050_getXGyroOffset () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getxnegmotiondetected","title":"function MPU6050_getXNegMotionDetected","text":"<pre><code>bool MPU6050_getXNegMotionDetected () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getxposmotiondetected","title":"function MPU6050_getXPosMotionDetected","text":"<pre><code>bool MPU6050_getXPosMotionDetected () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getyacceloffset","title":"function MPU6050_getYAccelOffset","text":"<pre><code>int16_t MPU6050_getYAccelOffset () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getygyrofifoenabled","title":"function MPU6050_getYGyroFIFOEnabled","text":"<pre><code>bool MPU6050_getYGyroFIFOEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getygyrooffset","title":"function MPU6050_getYGyroOffset","text":"<pre><code>int16_t MPU6050_getYGyroOffset () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getynegmotiondetected","title":"function MPU6050_getYNegMotionDetected","text":"<pre><code>bool MPU6050_getYNegMotionDetected () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getyposmotiondetected","title":"function MPU6050_getYPosMotionDetected","text":"<pre><code>bool MPU6050_getYPosMotionDetected () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getzacceloffset","title":"function MPU6050_getZAccelOffset","text":"<pre><code>int16_t MPU6050_getZAccelOffset () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getzgyrofifoenabled","title":"function MPU6050_getZGyroFIFOEnabled","text":"<pre><code>bool MPU6050_getZGyroFIFOEnabled () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getzgyrooffset","title":"function MPU6050_getZGyroOffset","text":"<pre><code>int16_t MPU6050_getZGyroOffset () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getznegmotiondetected","title":"function MPU6050_getZNegMotionDetected","text":"<pre><code>bool MPU6050_getZNegMotionDetected () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getzposmotiondetected","title":"function MPU6050_getZPosMotionDetected","text":"<pre><code>bool MPU6050_getZPosMotionDetected () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getzeromotiondetected","title":"function MPU6050_getZeroMotionDetected","text":"<pre><code>bool MPU6050_getZeroMotionDetected () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getzeromotiondetectionduration","title":"function MPU6050_getZeroMotionDetectionDuration","text":"<pre><code>uint8_t MPU6050_getZeroMotionDetectionDuration () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_getzeromotiondetectionthreshold","title":"function MPU6050_getZeroMotionDetectionThreshold","text":"<pre><code>uint8_t MPU6050_getZeroMotionDetectionThreshold () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_init","title":"function MPU6050_init","text":"<pre><code>void MPU6050_init () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_initialize","title":"function MPU6050_initialize","text":"<pre><code>void MPU6050_initialize () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_readmemoryblock","title":"function MPU6050_readMemoryBlock","text":"<pre><code>void MPU6050_readMemoryBlock (\nuint8_t * data,\nuint16_t dataSize,\nuint8_t bank,\nuint8_t address\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_readmemorybyte","title":"function MPU6050_readMemoryByte","text":"<pre><code>uint8_t MPU6050_readMemoryByte () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_reset","title":"function MPU6050_reset","text":"<pre><code>void MPU6050_reset () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_resetaccelerometerpath","title":"function MPU6050_resetAccelerometerPath","text":"<pre><code>void MPU6050_resetAccelerometerPath () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_resetdmp","title":"function MPU6050_resetDMP","text":"<pre><code>void MPU6050_resetDMP () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_resetfifo","title":"function MPU6050_resetFIFO","text":"<pre><code>void MPU6050_resetFIFO () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_resetgyroscopepath","title":"function MPU6050_resetGyroscopePath","text":"<pre><code>void MPU6050_resetGyroscopePath () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_reseti2cmaster","title":"function MPU6050_resetI2CMaster","text":"<pre><code>void MPU6050_resetI2CMaster () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_resetsensors","title":"function MPU6050_resetSensors","text":"<pre><code>void MPU6050_resetSensors () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_resettemperaturepath","title":"function MPU6050_resetTemperaturePath","text":"<pre><code>void MPU6050_resetTemperaturePath () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setaccelfifoenabled","title":"function MPU6050_setAccelFIFOEnabled","text":"<pre><code>void MPU6050_setAccelFIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setaccelxselftest","title":"function MPU6050_setAccelXSelfTest","text":"<pre><code>void MPU6050_setAccelXSelfTest (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setaccelyselftest","title":"function MPU6050_setAccelYSelfTest","text":"<pre><code>void MPU6050_setAccelYSelfTest (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setaccelzselftest","title":"function MPU6050_setAccelZSelfTest","text":"<pre><code>void MPU6050_setAccelZSelfTest (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setaccelerometerpowerondelay","title":"function MPU6050_setAccelerometerPowerOnDelay","text":"<pre><code>void MPU6050_setAccelerometerPowerOnDelay (\nuint8_t delay\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setauxvddiolevel","title":"function MPU6050_setAuxVDDIOLevel","text":"<pre><code>void MPU6050_setAuxVDDIOLevel (\nuint8_t level\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setclockoutputenabled","title":"function MPU6050_setClockOutputEnabled","text":"<pre><code>void MPU6050_setClockOutputEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setclocksource","title":"function MPU6050_setClockSource","text":"<pre><code>void MPU6050_setClockSource (\nuint8_t source\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setdhpfmode","title":"function MPU6050_setDHPFMode","text":"<pre><code>void MPU6050_setDHPFMode (\nuint8_t mode\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setdlpfmode","title":"function MPU6050_setDLPFMode","text":"<pre><code>void MPU6050_setDLPFMode (\nuint8_t bandwidth\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setdmpconfig1","title":"function MPU6050_setDMPConfig1","text":"<pre><code>void MPU6050_setDMPConfig1 (\nuint8_t config\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setdmpconfig2","title":"function MPU6050_setDMPConfig2","text":"<pre><code>void MPU6050_setDMPConfig2 (\nuint8_t config\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setdmpenabled","title":"function MPU6050_setDMPEnabled","text":"<pre><code>void MPU6050_setDMPEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setdeviceid","title":"function MPU6050_setDeviceID","text":"<pre><code>void MPU6050_setDeviceID (\nuint8_t id\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setexternalframesync","title":"function MPU6050_setExternalFrameSync","text":"<pre><code>void MPU6050_setExternalFrameSync (\nuint8_t sync\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setexternalshadowdelayenabled","title":"function MPU6050_setExternalShadowDelayEnabled","text":"<pre><code>void MPU6050_setExternalShadowDelayEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setfifobyte","title":"function MPU6050_setFIFOByte","text":"<pre><code>void MPU6050_setFIFOByte (\nuint8_t data\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setfifoenabled","title":"function MPU6050_setFIFOEnabled","text":"<pre><code>void MPU6050_setFIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setfsyncinterruptenabled","title":"function MPU6050_setFSyncInterruptEnabled","text":"<pre><code>void MPU6050_setFSyncInterruptEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setfsyncinterruptlevel","title":"function MPU6050_setFSyncInterruptLevel","text":"<pre><code>void MPU6050_setFSyncInterruptLevel (\nbool level\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setfreefalldetectioncounterdecrement","title":"function MPU6050_setFreefallDetectionCounterDecrement","text":"<pre><code>void MPU6050_setFreefallDetectionCounterDecrement (\nuint8_t decrement\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setfreefalldetectionduration","title":"function MPU6050_setFreefallDetectionDuration","text":"<pre><code>void MPU6050_setFreefallDetectionDuration (\nuint8_t duration\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setfreefalldetectionthreshold","title":"function MPU6050_setFreefallDetectionThreshold","text":"<pre><code>void MPU6050_setFreefallDetectionThreshold (\nuint8_t threshold\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setfullscaleaccelrange","title":"function MPU6050_setFullScaleAccelRange","text":"<pre><code>void MPU6050_setFullScaleAccelRange (\nuint8_t range\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setfullscalegyrorange","title":"function MPU6050_setFullScaleGyroRange","text":"<pre><code>void MPU6050_setFullScaleGyroRange (\nuint8_t range\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_seti2cbypassenabled","title":"function MPU6050_setI2CBypassEnabled","text":"<pre><code>void MPU6050_setI2CBypassEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_seti2cmastermodeenabled","title":"function MPU6050_setI2CMasterModeEnabled","text":"<pre><code>void MPU6050_setI2CMasterModeEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setintdmpenabled","title":"function MPU6050_setIntDMPEnabled","text":"<pre><code>void MPU6050_setIntDMPEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setintdatareadyenabled","title":"function MPU6050_setIntDataReadyEnabled","text":"<pre><code>void MPU6050_setIntDataReadyEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setintenabled","title":"function MPU6050_setIntEnabled","text":"<pre><code>void MPU6050_setIntEnabled (\nuint8_t enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setintfifobufferoverflowenabled","title":"function MPU6050_setIntFIFOBufferOverflowEnabled","text":"<pre><code>void MPU6050_setIntFIFOBufferOverflowEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setintfreefallenabled","title":"function MPU6050_setIntFreefallEnabled","text":"<pre><code>void MPU6050_setIntFreefallEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setinti2cmasterenabled","title":"function MPU6050_setIntI2CMasterEnabled","text":"<pre><code>void MPU6050_setIntI2CMasterEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setintmotionenabled","title":"function MPU6050_setIntMotionEnabled","text":"<pre><code>void MPU6050_setIntMotionEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setintpllreadyenabled","title":"function MPU6050_setIntPLLReadyEnabled","text":"<pre><code>void MPU6050_setIntPLLReadyEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setintzeromotionenabled","title":"function MPU6050_setIntZeroMotionEnabled","text":"<pre><code>void MPU6050_setIntZeroMotionEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setinterruptdrive","title":"function MPU6050_setInterruptDrive","text":"<pre><code>void MPU6050_setInterruptDrive (\nbool drive\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setinterruptlatch","title":"function MPU6050_setInterruptLatch","text":"<pre><code>void MPU6050_setInterruptLatch (\nbool latch\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setinterruptlatchclear","title":"function MPU6050_setInterruptLatchClear","text":"<pre><code>void MPU6050_setInterruptLatchClear (\nbool clear\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setinterruptmode","title":"function MPU6050_setInterruptMode","text":"<pre><code>void MPU6050_setInterruptMode (\nbool mode\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setmasterclockspeed","title":"function MPU6050_setMasterClockSpeed","text":"<pre><code>void MPU6050_setMasterClockSpeed (\nuint8_t speed\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setmemorybank","title":"function MPU6050_setMemoryBank","text":"<pre><code>void MPU6050_setMemoryBank (\nuint8_t bank,\nbool prefetchEnabled,\nbool userBank\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setmemorystartaddress","title":"function MPU6050_setMemoryStartAddress","text":"<pre><code>void MPU6050_setMemoryStartAddress (\nuint8_t address\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setmotiondetectioncounterdecrement","title":"function MPU6050_setMotionDetectionCounterDecrement","text":"<pre><code>void MPU6050_setMotionDetectionCounterDecrement (\nuint8_t decrement\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setmotiondetectionduration","title":"function MPU6050_setMotionDetectionDuration","text":"<pre><code>void MPU6050_setMotionDetectionDuration (\nuint8_t duration\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setmotiondetectionthreshold","title":"function MPU6050_setMotionDetectionThreshold","text":"<pre><code>void MPU6050_setMotionDetectionThreshold (\nuint8_t threshold\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setmultimasterenabled","title":"function MPU6050_setMultiMasterEnabled","text":"<pre><code>void MPU6050_setMultiMasterEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setotpbankvalid","title":"function MPU6050_setOTPBankValid","text":"<pre><code>void MPU6050_setOTPBankValid (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setrate","title":"function MPU6050_setRate","text":"<pre><code>void MPU6050_setRate (\nuint8_t rate\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslave0fifoenabled","title":"function MPU6050_setSlave0FIFOEnabled","text":"<pre><code>void MPU6050_setSlave0FIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslave1fifoenabled","title":"function MPU6050_setSlave1FIFOEnabled","text":"<pre><code>void MPU6050_setSlave1FIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslave2fifoenabled","title":"function MPU6050_setSlave2FIFOEnabled","text":"<pre><code>void MPU6050_setSlave2FIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslave3fifoenabled","title":"function MPU6050_setSlave3FIFOEnabled","text":"<pre><code>void MPU6050_setSlave3FIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslave4address","title":"function MPU6050_setSlave4Address","text":"<pre><code>void MPU6050_setSlave4Address (\nuint8_t address\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslave4enabled","title":"function MPU6050_setSlave4Enabled","text":"<pre><code>void MPU6050_setSlave4Enabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslave4interruptenabled","title":"function MPU6050_setSlave4InterruptEnabled","text":"<pre><code>void MPU6050_setSlave4InterruptEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslave4masterdelay","title":"function MPU6050_setSlave4MasterDelay","text":"<pre><code>void MPU6050_setSlave4MasterDelay (\nuint8_t delay\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslave4outputbyte","title":"function MPU6050_setSlave4OutputByte","text":"<pre><code>void MPU6050_setSlave4OutputByte (\nuint8_t data\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslave4register","title":"function MPU6050_setSlave4Register","text":"<pre><code>void MPU6050_setSlave4Register (\nuint8_t reg\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslave4writemode","title":"function MPU6050_setSlave4WriteMode","text":"<pre><code>void MPU6050_setSlave4WriteMode (\nbool mode\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslaveaddress","title":"function MPU6050_setSlaveAddress","text":"<pre><code>void MPU6050_setSlaveAddress (\nuint8_t num,\nuint8_t address\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslavedatalength","title":"function MPU6050_setSlaveDataLength","text":"<pre><code>void MPU6050_setSlaveDataLength (\nuint8_t num,\nuint8_t length\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslavedelayenabled","title":"function MPU6050_setSlaveDelayEnabled","text":"<pre><code>void MPU6050_setSlaveDelayEnabled (\nuint8_t num,\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslaveenabled","title":"function MPU6050_setSlaveEnabled","text":"<pre><code>void MPU6050_setSlaveEnabled (\nuint8_t num,\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslaveoutputbyte","title":"function MPU6050_setSlaveOutputByte","text":"<pre><code>void MPU6050_setSlaveOutputByte (\nuint8_t num,\nuint8_t data\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslavereadwritetransitionenabled","title":"function MPU6050_setSlaveReadWriteTransitionEnabled","text":"<pre><code>void MPU6050_setSlaveReadWriteTransitionEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslaveregister","title":"function MPU6050_setSlaveRegister","text":"<pre><code>void MPU6050_setSlaveRegister (\nuint8_t num,\nuint8_t reg\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslavewordbyteswap","title":"function MPU6050_setSlaveWordByteSwap","text":"<pre><code>void MPU6050_setSlaveWordByteSwap (\nuint8_t num,\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslavewordgroupoffset","title":"function MPU6050_setSlaveWordGroupOffset","text":"<pre><code>void MPU6050_setSlaveWordGroupOffset (\nuint8_t num,\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setslavewritemode","title":"function MPU6050_setSlaveWriteMode","text":"<pre><code>void MPU6050_setSlaveWriteMode (\nuint8_t num,\nbool mode\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setsleepenabled","title":"function MPU6050_setSleepEnabled","text":"<pre><code>void MPU6050_setSleepEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setstandbyxaccelenabled","title":"function MPU6050_setStandbyXAccelEnabled","text":"<pre><code>void MPU6050_setStandbyXAccelEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setstandbyxgyroenabled","title":"function MPU6050_setStandbyXGyroEnabled","text":"<pre><code>void MPU6050_setStandbyXGyroEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setstandbyyaccelenabled","title":"function MPU6050_setStandbyYAccelEnabled","text":"<pre><code>void MPU6050_setStandbyYAccelEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setstandbyygyroenabled","title":"function MPU6050_setStandbyYGyroEnabled","text":"<pre><code>void MPU6050_setStandbyYGyroEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setstandbyzaccelenabled","title":"function MPU6050_setStandbyZAccelEnabled","text":"<pre><code>void MPU6050_setStandbyZAccelEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setstandbyzgyroenabled","title":"function MPU6050_setStandbyZGyroEnabled","text":"<pre><code>void MPU6050_setStandbyZGyroEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_settempfifoenabled","title":"function MPU6050_setTempFIFOEnabled","text":"<pre><code>void MPU6050_setTempFIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_settempsensorenabled","title":"function MPU6050_setTempSensorEnabled","text":"<pre><code>void MPU6050_setTempSensorEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setwaitforexternalsensorenabled","title":"function MPU6050_setWaitForExternalSensorEnabled","text":"<pre><code>void MPU6050_setWaitForExternalSensorEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setwakecycleenabled","title":"function MPU6050_setWakeCycleEnabled","text":"<pre><code>void MPU6050_setWakeCycleEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setwakefrequency","title":"function MPU6050_setWakeFrequency","text":"<pre><code>void MPU6050_setWakeFrequency (\nuint8_t frequency\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setxacceloffset","title":"function MPU6050_setXAccelOffset","text":"<pre><code>void MPU6050_setXAccelOffset (\nint16_t offset\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setxfinegain","title":"function MPU6050_setXFineGain","text":"<pre><code>void MPU6050_setXFineGain (\nint8_t gain\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setxgyrofifoenabled","title":"function MPU6050_setXGyroFIFOEnabled","text":"<pre><code>void MPU6050_setXGyroFIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setxgyrooffset","title":"function MPU6050_setXGyroOffset","text":"<pre><code>void MPU6050_setXGyroOffset (\nint16_t offset\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setxgyrooffsettc","title":"function MPU6050_setXGyroOffsetTC","text":"<pre><code>void MPU6050_setXGyroOffsetTC (\nint8_t offset\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setyacceloffset","title":"function MPU6050_setYAccelOffset","text":"<pre><code>void MPU6050_setYAccelOffset (\nint16_t offset\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setyfinegain","title":"function MPU6050_setYFineGain","text":"<pre><code>void MPU6050_setYFineGain (\nint8_t gain\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setygyrofifoenabled","title":"function MPU6050_setYGyroFIFOEnabled","text":"<pre><code>void MPU6050_setYGyroFIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setygyrooffset","title":"function MPU6050_setYGyroOffset","text":"<pre><code>void MPU6050_setYGyroOffset (\nint16_t offset\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setygyrooffsettc","title":"function MPU6050_setYGyroOffsetTC","text":"<pre><code>void MPU6050_setYGyroOffsetTC (\nint8_t offset\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setzacceloffset","title":"function MPU6050_setZAccelOffset","text":"<pre><code>void MPU6050_setZAccelOffset (\nint16_t offset\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setzfinegain","title":"function MPU6050_setZFineGain","text":"<pre><code>void MPU6050_setZFineGain (\nint8_t gain\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setzgyrofifoenabled","title":"function MPU6050_setZGyroFIFOEnabled","text":"<pre><code>void MPU6050_setZGyroFIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setzgyrooffset","title":"function MPU6050_setZGyroOffset","text":"<pre><code>void MPU6050_setZGyroOffset (\nint16_t offset\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setzgyrooffsettc","title":"function MPU6050_setZGyroOffsetTC","text":"<pre><code>void MPU6050_setZGyroOffsetTC (\nint8_t offset\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setzeromotiondetectionduration","title":"function MPU6050_setZeroMotionDetectionDuration","text":"<pre><code>void MPU6050_setZeroMotionDetectionDuration (\nuint8_t duration\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_setzeromotiondetectionthreshold","title":"function MPU6050_setZeroMotionDetectionThreshold","text":"<pre><code>void MPU6050_setZeroMotionDetectionThreshold (\nuint8_t threshold\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_switchspienabled","title":"function MPU6050_switchSPIEnabled","text":"<pre><code>void MPU6050_switchSPIEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_testconnection","title":"function MPU6050_testConnection","text":"<pre><code>bool MPU6050_testConnection () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-mpu6050_writememorybyte","title":"function MPU6050_writeMemoryByte","text":"<pre><code>void MPU6050_writeMemoryByte (\nuint8_t data\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-getexternalsensordword","title":"function getExternalSensorDWord","text":"<pre><code>uint32_t getExternalSensorDWord (\nint position\n) </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-getxfinegain","title":"function getXFineGain","text":"<pre><code>int8_t getXFineGain () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-getxgyrooffsettc","title":"function getXGyroOffsetTC","text":"<pre><code>int8_t getXGyroOffsetTC () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-getyfinegain","title":"function getYFineGain","text":"<pre><code>int8_t getYFineGain () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-getygyrooffsettc","title":"function getYGyroOffsetTC","text":"<pre><code>int8_t getYGyroOffsetTC () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-getzfinegain","title":"function getZFineGain","text":"<pre><code>int8_t getZFineGain () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#function-getzgyrooffsettc","title":"function getZGyroOffsetTC","text":"<pre><code>int8_t getZGyroOffsetTC () </code></pre>"},{"location":"stm/Mpu6050_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_accel_fifo_en_bit","title":"define MPU6050_ACCEL_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_ACCEL_FIFO_EN_BIT 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_accel_fs_16","title":"define MPU6050_ACCEL_FS_16","text":"<pre><code>#define MPU6050_ACCEL_FS_16 0x03\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_accel_fs_2","title":"define MPU6050_ACCEL_FS_2","text":"<pre><code>#define MPU6050_ACCEL_FS_2 0x00\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_accel_fs_4","title":"define MPU6050_ACCEL_FS_4","text":"<pre><code>#define MPU6050_ACCEL_FS_4 0x01\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_accel_fs_8","title":"define MPU6050_ACCEL_FS_8","text":"<pre><code>#define MPU6050_ACCEL_FS_8 0x02\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_aconfig_accel_hpf_bit","title":"define MPU6050_ACONFIG_ACCEL_HPF_BIT","text":"<pre><code>#define MPU6050_ACONFIG_ACCEL_HPF_BIT 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_aconfig_accel_hpf_length","title":"define MPU6050_ACONFIG_ACCEL_HPF_LENGTH","text":"<pre><code>#define MPU6050_ACONFIG_ACCEL_HPF_LENGTH 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_aconfig_afs_sel_bit","title":"define MPU6050_ACONFIG_AFS_SEL_BIT","text":"<pre><code>#define MPU6050_ACONFIG_AFS_SEL_BIT 4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_aconfig_afs_sel_length","title":"define MPU6050_ACONFIG_AFS_SEL_LENGTH","text":"<pre><code>#define MPU6050_ACONFIG_AFS_SEL_LENGTH 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_aconfig_xa_st_bit","title":"define MPU6050_ACONFIG_XA_ST_BIT","text":"<pre><code>#define MPU6050_ACONFIG_XA_ST_BIT 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_aconfig_ya_st_bit","title":"define MPU6050_ACONFIG_YA_ST_BIT","text":"<pre><code>#define MPU6050_ACONFIG_YA_ST_BIT 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_aconfig_za_st_bit","title":"define MPU6050_ACONFIG_ZA_ST_BIT","text":"<pre><code>#define MPU6050_ACONFIG_ZA_ST_BIT 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_address_ad0_high","title":"define MPU6050_ADDRESS_AD0_HIGH","text":"<pre><code>#define MPU6050_ADDRESS_AD0_HIGH 0x69\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_address_ad0_low","title":"define MPU6050_ADDRESS_AD0_LOW","text":"<pre><code>#define MPU6050_ADDRESS_AD0_LOW 0x68\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_banksel_cfg_user_bank_bit","title":"define MPU6050_BANKSEL_CFG_USER_BANK_BIT","text":"<pre><code>#define MPU6050_BANKSEL_CFG_USER_BANK_BIT 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_banksel_mem_sel_bit","title":"define MPU6050_BANKSEL_MEM_SEL_BIT","text":"<pre><code>#define MPU6050_BANKSEL_MEM_SEL_BIT 4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_banksel_mem_sel_length","title":"define MPU6050_BANKSEL_MEM_SEL_LENGTH","text":"<pre><code>#define MPU6050_BANKSEL_MEM_SEL_LENGTH 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_banksel_prftch_en_bit","title":"define MPU6050_BANKSEL_PRFTCH_EN_BIT","text":"<pre><code>#define MPU6050_BANKSEL_PRFTCH_EN_BIT 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_cfg_dlpf_cfg_bit","title":"define MPU6050_CFG_DLPF_CFG_BIT","text":"<pre><code>#define MPU6050_CFG_DLPF_CFG_BIT 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_cfg_dlpf_cfg_length","title":"define MPU6050_CFG_DLPF_CFG_LENGTH","text":"<pre><code>#define MPU6050_CFG_DLPF_CFG_LENGTH 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_cfg_ext_sync_set_bit","title":"define MPU6050_CFG_EXT_SYNC_SET_BIT","text":"<pre><code>#define MPU6050_CFG_EXT_SYNC_SET_BIT 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_cfg_ext_sync_set_length","title":"define MPU6050_CFG_EXT_SYNC_SET_LENGTH","text":"<pre><code>#define MPU6050_CFG_EXT_SYNC_SET_LENGTH 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_div_258","title":"define MPU6050_CLOCK_DIV_258","text":"<pre><code>#define MPU6050_CLOCK_DIV_258 0x8\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_div_267","title":"define MPU6050_CLOCK_DIV_267","text":"<pre><code>#define MPU6050_CLOCK_DIV_267 0x7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_div_276","title":"define MPU6050_CLOCK_DIV_276","text":"<pre><code>#define MPU6050_CLOCK_DIV_276 0x6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_div_286","title":"define MPU6050_CLOCK_DIV_286","text":"<pre><code>#define MPU6050_CLOCK_DIV_286 0x5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_div_296","title":"define MPU6050_CLOCK_DIV_296","text":"<pre><code>#define MPU6050_CLOCK_DIV_296 0x4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_div_308","title":"define MPU6050_CLOCK_DIV_308","text":"<pre><code>#define MPU6050_CLOCK_DIV_308 0x3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_div_320","title":"define MPU6050_CLOCK_DIV_320","text":"<pre><code>#define MPU6050_CLOCK_DIV_320 0x2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_div_333","title":"define MPU6050_CLOCK_DIV_333","text":"<pre><code>#define MPU6050_CLOCK_DIV_333 0x1\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_div_348","title":"define MPU6050_CLOCK_DIV_348","text":"<pre><code>#define MPU6050_CLOCK_DIV_348 0x0\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_div_364","title":"define MPU6050_CLOCK_DIV_364","text":"<pre><code>#define MPU6050_CLOCK_DIV_364 0xF\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_div_381","title":"define MPU6050_CLOCK_DIV_381","text":"<pre><code>#define MPU6050_CLOCK_DIV_381 0xE\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_div_400","title":"define MPU6050_CLOCK_DIV_400","text":"<pre><code>#define MPU6050_CLOCK_DIV_400 0xD\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_div_421","title":"define MPU6050_CLOCK_DIV_421","text":"<pre><code>#define MPU6050_CLOCK_DIV_421 0xC\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_div_444","title":"define MPU6050_CLOCK_DIV_444","text":"<pre><code>#define MPU6050_CLOCK_DIV_444 0xB\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_div_471","title":"define MPU6050_CLOCK_DIV_471","text":"<pre><code>#define MPU6050_CLOCK_DIV_471 0xA\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_div_500","title":"define MPU6050_CLOCK_DIV_500","text":"<pre><code>#define MPU6050_CLOCK_DIV_500 0x9\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_internal","title":"define MPU6050_CLOCK_INTERNAL","text":"<pre><code>#define MPU6050_CLOCK_INTERNAL 0x00\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_keep_reset","title":"define MPU6050_CLOCK_KEEP_RESET","text":"<pre><code>#define MPU6050_CLOCK_KEEP_RESET 0x07\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_pll_ext19m","title":"define MPU6050_CLOCK_PLL_EXT19M","text":"<pre><code>#define MPU6050_CLOCK_PLL_EXT19M 0x05\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_pll_ext32k","title":"define MPU6050_CLOCK_PLL_EXT32K","text":"<pre><code>#define MPU6050_CLOCK_PLL_EXT32K 0x04\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_pll_xgyro","title":"define MPU6050_CLOCK_PLL_XGYRO","text":"<pre><code>#define MPU6050_CLOCK_PLL_XGYRO 0x01\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_pll_ygyro","title":"define MPU6050_CLOCK_PLL_YGYRO","text":"<pre><code>#define MPU6050_CLOCK_PLL_YGYRO 0x02\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_clock_pll_zgyro","title":"define MPU6050_CLOCK_PLL_ZGYRO","text":"<pre><code>#define MPU6050_CLOCK_PLL_ZGYRO 0x03\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_default_address","title":"define MPU6050_DEFAULT_ADDRESS","text":"<pre><code>#define MPU6050_DEFAULT_ADDRESS MPU6050_ADDRESS_AD0_LOW\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_delayctrl_delay_es_shadow_bit","title":"define MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT","text":"<pre><code>#define MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_delayctrl_i2c_slv0_dly_en_bit","title":"define MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT","text":"<pre><code>#define MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT 0\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_delayctrl_i2c_slv1_dly_en_bit","title":"define MPU6050_DELAYCTRL_I2C_SLV1_DLY_EN_BIT","text":"<pre><code>#define MPU6050_DELAYCTRL_I2C_SLV1_DLY_EN_BIT 1\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_delayctrl_i2c_slv2_dly_en_bit","title":"define MPU6050_DELAYCTRL_I2C_SLV2_DLY_EN_BIT","text":"<pre><code>#define MPU6050_DELAYCTRL_I2C_SLV2_DLY_EN_BIT 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_delayctrl_i2c_slv3_dly_en_bit","title":"define MPU6050_DELAYCTRL_I2C_SLV3_DLY_EN_BIT","text":"<pre><code>#define MPU6050_DELAYCTRL_I2C_SLV3_DLY_EN_BIT 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_delayctrl_i2c_slv4_dly_en_bit","title":"define MPU6050_DELAYCTRL_I2C_SLV4_DLY_EN_BIT","text":"<pre><code>#define MPU6050_DELAYCTRL_I2C_SLV4_DLY_EN_BIT 4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_detect_accel_on_delay_bit","title":"define MPU6050_DETECT_ACCEL_ON_DELAY_BIT","text":"<pre><code>#define MPU6050_DETECT_ACCEL_ON_DELAY_BIT 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_detect_accel_on_delay_length","title":"define MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH","text":"<pre><code>#define MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_detect_decrement_1","title":"define MPU6050_DETECT_DECREMENT_1","text":"<pre><code>#define MPU6050_DETECT_DECREMENT_1 0x1\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_detect_decrement_2","title":"define MPU6050_DETECT_DECREMENT_2","text":"<pre><code>#define MPU6050_DETECT_DECREMENT_2 0x2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_detect_decrement_4","title":"define MPU6050_DETECT_DECREMENT_4","text":"<pre><code>#define MPU6050_DETECT_DECREMENT_4 0x3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_detect_decrement_reset","title":"define MPU6050_DETECT_DECREMENT_RESET","text":"<pre><code>#define MPU6050_DETECT_DECREMENT_RESET 0x0\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_detect_ff_count_bit","title":"define MPU6050_DETECT_FF_COUNT_BIT","text":"<pre><code>#define MPU6050_DETECT_FF_COUNT_BIT 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_detect_ff_count_length","title":"define MPU6050_DETECT_FF_COUNT_LENGTH","text":"<pre><code>#define MPU6050_DETECT_FF_COUNT_LENGTH 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_detect_mot_count_bit","title":"define MPU6050_DETECT_MOT_COUNT_BIT","text":"<pre><code>#define MPU6050_DETECT_MOT_COUNT_BIT 1\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_detect_mot_count_length","title":"define MPU6050_DETECT_MOT_COUNT_LENGTH","text":"<pre><code>#define MPU6050_DETECT_MOT_COUNT_LENGTH 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dhpf_0p63","title":"define MPU6050_DHPF_0P63","text":"<pre><code>#define MPU6050_DHPF_0P63 0x04\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dhpf_1p25","title":"define MPU6050_DHPF_1P25","text":"<pre><code>#define MPU6050_DHPF_1P25 0x03\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dhpf_2p5","title":"define MPU6050_DHPF_2P5","text":"<pre><code>#define MPU6050_DHPF_2P5 0x02\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dhpf_5","title":"define MPU6050_DHPF_5","text":"<pre><code>#define MPU6050_DHPF_5 0x01\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dhpf_hold","title":"define MPU6050_DHPF_HOLD","text":"<pre><code>#define MPU6050_DHPF_HOLD 0x07\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dhpf_reset","title":"define MPU6050_DHPF_RESET","text":"<pre><code>#define MPU6050_DHPF_RESET 0x00\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dlpf_bw_10","title":"define MPU6050_DLPF_BW_10","text":"<pre><code>#define MPU6050_DLPF_BW_10 0x05\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dlpf_bw_188","title":"define MPU6050_DLPF_BW_188","text":"<pre><code>#define MPU6050_DLPF_BW_188 0x01\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dlpf_bw_20","title":"define MPU6050_DLPF_BW_20","text":"<pre><code>#define MPU6050_DLPF_BW_20 0x04\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dlpf_bw_256","title":"define MPU6050_DLPF_BW_256","text":"<pre><code>#define MPU6050_DLPF_BW_256 0x00\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dlpf_bw_42","title":"define MPU6050_DLPF_BW_42","text":"<pre><code>#define MPU6050_DLPF_BW_42 0x03\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dlpf_bw_5","title":"define MPU6050_DLPF_BW_5","text":"<pre><code>#define MPU6050_DLPF_BW_5 0x06\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dlpf_bw_98","title":"define MPU6050_DLPF_BW_98","text":"<pre><code>#define MPU6050_DLPF_BW_98 0x02\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dmpint_0_bit","title":"define MPU6050_DMPINT_0_BIT","text":"<pre><code>#define MPU6050_DMPINT_0_BIT 0\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dmpint_1_bit","title":"define MPU6050_DMPINT_1_BIT","text":"<pre><code>#define MPU6050_DMPINT_1_BIT 1\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dmpint_2_bit","title":"define MPU6050_DMPINT_2_BIT","text":"<pre><code>#define MPU6050_DMPINT_2_BIT 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dmpint_3_bit","title":"define MPU6050_DMPINT_3_BIT","text":"<pre><code>#define MPU6050_DMPINT_3_BIT 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dmpint_4_bit","title":"define MPU6050_DMPINT_4_BIT","text":"<pre><code>#define MPU6050_DMPINT_4_BIT 4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dmpint_5_bit","title":"define MPU6050_DMPINT_5_BIT","text":"<pre><code>#define MPU6050_DMPINT_5_BIT 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dmp_memory_banks","title":"define MPU6050_DMP_MEMORY_BANKS","text":"<pre><code>#define MPU6050_DMP_MEMORY_BANKS 8\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dmp_memory_bank_size","title":"define MPU6050_DMP_MEMORY_BANK_SIZE","text":"<pre><code>#define MPU6050_DMP_MEMORY_BANK_SIZE 256\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_dmp_memory_chunk_size","title":"define MPU6050_DMP_MEMORY_CHUNK_SIZE","text":"<pre><code>#define MPU6050_DMP_MEMORY_CHUNK_SIZE 16\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ext_sync_accel_xout_l","title":"define MPU6050_EXT_SYNC_ACCEL_XOUT_L","text":"<pre><code>#define MPU6050_EXT_SYNC_ACCEL_XOUT_L 0x5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ext_sync_accel_yout_l","title":"define MPU6050_EXT_SYNC_ACCEL_YOUT_L","text":"<pre><code>#define MPU6050_EXT_SYNC_ACCEL_YOUT_L 0x6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ext_sync_accel_zout_l","title":"define MPU6050_EXT_SYNC_ACCEL_ZOUT_L","text":"<pre><code>#define MPU6050_EXT_SYNC_ACCEL_ZOUT_L 0x7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ext_sync_disabled","title":"define MPU6050_EXT_SYNC_DISABLED","text":"<pre><code>#define MPU6050_EXT_SYNC_DISABLED 0x0\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ext_sync_gyro_xout_l","title":"define MPU6050_EXT_SYNC_GYRO_XOUT_L","text":"<pre><code>#define MPU6050_EXT_SYNC_GYRO_XOUT_L 0x2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ext_sync_gyro_yout_l","title":"define MPU6050_EXT_SYNC_GYRO_YOUT_L","text":"<pre><code>#define MPU6050_EXT_SYNC_GYRO_YOUT_L 0x3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ext_sync_gyro_zout_l","title":"define MPU6050_EXT_SYNC_GYRO_ZOUT_L","text":"<pre><code>#define MPU6050_EXT_SYNC_GYRO_ZOUT_L 0x4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ext_sync_temp_out_l","title":"define MPU6050_EXT_SYNC_TEMP_OUT_L","text":"<pre><code>#define MPU6050_EXT_SYNC_TEMP_OUT_L 0x1\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_gconfig_fs_sel_bit","title":"define MPU6050_GCONFIG_FS_SEL_BIT","text":"<pre><code>#define MPU6050_GCONFIG_FS_SEL_BIT 4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_gconfig_fs_sel_length","title":"define MPU6050_GCONFIG_FS_SEL_LENGTH","text":"<pre><code>#define MPU6050_GCONFIG_FS_SEL_LENGTH 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_gyro_fs_1000","title":"define MPU6050_GYRO_FS_1000","text":"<pre><code>#define MPU6050_GYRO_FS_1000 0x02\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_gyro_fs_2000","title":"define MPU6050_GYRO_FS_2000","text":"<pre><code>#define MPU6050_GYRO_FS_2000 0x03\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_gyro_fs_250","title":"define MPU6050_GYRO_FS_250","text":"<pre><code>#define MPU6050_GYRO_FS_250 0x00\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_gyro_fs_500","title":"define MPU6050_GYRO_FS_500","text":"<pre><code>#define MPU6050_GYRO_FS_500 0x01\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_mst_clk_bit","title":"define MPU6050_I2C_MST_CLK_BIT","text":"<pre><code>#define MPU6050_I2C_MST_CLK_BIT 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_mst_clk_length","title":"define MPU6050_I2C_MST_CLK_LENGTH","text":"<pre><code>#define MPU6050_I2C_MST_CLK_LENGTH 4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_mst_p_nsr_bit","title":"define MPU6050_I2C_MST_P_NSR_BIT","text":"<pre><code>#define MPU6050_I2C_MST_P_NSR_BIT 4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv4_addr_bit","title":"define MPU6050_I2C_SLV4_ADDR_BIT","text":"<pre><code>#define MPU6050_I2C_SLV4_ADDR_BIT 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv4_addr_length","title":"define MPU6050_I2C_SLV4_ADDR_LENGTH","text":"<pre><code>#define MPU6050_I2C_SLV4_ADDR_LENGTH 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv4_en_bit","title":"define MPU6050_I2C_SLV4_EN_BIT","text":"<pre><code>#define MPU6050_I2C_SLV4_EN_BIT 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv4_int_en_bit","title":"define MPU6050_I2C_SLV4_INT_EN_BIT","text":"<pre><code>#define MPU6050_I2C_SLV4_INT_EN_BIT 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv4_mst_dly_bit","title":"define MPU6050_I2C_SLV4_MST_DLY_BIT","text":"<pre><code>#define MPU6050_I2C_SLV4_MST_DLY_BIT 4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv4_mst_dly_length","title":"define MPU6050_I2C_SLV4_MST_DLY_LENGTH","text":"<pre><code>#define MPU6050_I2C_SLV4_MST_DLY_LENGTH 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv4_reg_dis_bit","title":"define MPU6050_I2C_SLV4_REG_DIS_BIT","text":"<pre><code>#define MPU6050_I2C_SLV4_REG_DIS_BIT 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv4_rw_bit","title":"define MPU6050_I2C_SLV4_RW_BIT","text":"<pre><code>#define MPU6050_I2C_SLV4_RW_BIT 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_addr_bit","title":"define MPU6050_I2C_SLV_ADDR_BIT","text":"<pre><code>#define MPU6050_I2C_SLV_ADDR_BIT 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_addr_length","title":"define MPU6050_I2C_SLV_ADDR_LENGTH","text":"<pre><code>#define MPU6050_I2C_SLV_ADDR_LENGTH 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_byte_sw_bit","title":"define MPU6050_I2C_SLV_BYTE_SW_BIT","text":"<pre><code>#define MPU6050_I2C_SLV_BYTE_SW_BIT 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_en_bit","title":"define MPU6050_I2C_SLV_EN_BIT","text":"<pre><code>#define MPU6050_I2C_SLV_EN_BIT 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_grp_bit","title":"define MPU6050_I2C_SLV_GRP_BIT","text":"<pre><code>#define MPU6050_I2C_SLV_GRP_BIT 4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_len_bit","title":"define MPU6050_I2C_SLV_LEN_BIT","text":"<pre><code>#define MPU6050_I2C_SLV_LEN_BIT 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_len_length","title":"define MPU6050_I2C_SLV_LEN_LENGTH","text":"<pre><code>#define MPU6050_I2C_SLV_LEN_LENGTH 4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_reg_dis_bit","title":"define MPU6050_I2C_SLV_REG_DIS_BIT","text":"<pre><code>#define MPU6050_I2C_SLV_REG_DIS_BIT 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_rw_bit","title":"define MPU6050_I2C_SLV_RW_BIT","text":"<pre><code>#define MPU6050_I2C_SLV_RW_BIT 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_intcfg_clkout_en_bit","title":"define MPU6050_INTCFG_CLKOUT_EN_BIT","text":"<pre><code>#define MPU6050_INTCFG_CLKOUT_EN_BIT 0\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_intcfg_fsync_int_en_bit","title":"define MPU6050_INTCFG_FSYNC_INT_EN_BIT","text":"<pre><code>#define MPU6050_INTCFG_FSYNC_INT_EN_BIT 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_intcfg_fsync_int_level_bit","title":"define MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT","text":"<pre><code>#define MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_intcfg_i2c_bypass_en_bit","title":"define MPU6050_INTCFG_I2C_BYPASS_EN_BIT","text":"<pre><code>#define MPU6050_INTCFG_I2C_BYPASS_EN_BIT 1\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_intcfg_int_level_bit","title":"define MPU6050_INTCFG_INT_LEVEL_BIT","text":"<pre><code>#define MPU6050_INTCFG_INT_LEVEL_BIT 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_intcfg_int_open_bit","title":"define MPU6050_INTCFG_INT_OPEN_BIT","text":"<pre><code>#define MPU6050_INTCFG_INT_OPEN_BIT 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_intcfg_int_rd_clear_bit","title":"define MPU6050_INTCFG_INT_RD_CLEAR_BIT","text":"<pre><code>#define MPU6050_INTCFG_INT_RD_CLEAR_BIT 4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_intcfg_latch_int_en_bit","title":"define MPU6050_INTCFG_LATCH_INT_EN_BIT","text":"<pre><code>#define MPU6050_INTCFG_LATCH_INT_EN_BIT 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_intclear_anyread","title":"define MPU6050_INTCLEAR_ANYREAD","text":"<pre><code>#define MPU6050_INTCLEAR_ANYREAD 0x01\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_intclear_statusread","title":"define MPU6050_INTCLEAR_STATUSREAD","text":"<pre><code>#define MPU6050_INTCLEAR_STATUSREAD 0x00\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_intdrv_opendrain","title":"define MPU6050_INTDRV_OPENDRAIN","text":"<pre><code>#define MPU6050_INTDRV_OPENDRAIN 0x01\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_intdrv_pushpull","title":"define MPU6050_INTDRV_PUSHPULL","text":"<pre><code>#define MPU6050_INTDRV_PUSHPULL 0x00\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_interrupt_data_rdy_bit","title":"define MPU6050_INTERRUPT_DATA_RDY_BIT","text":"<pre><code>#define MPU6050_INTERRUPT_DATA_RDY_BIT 0\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_interrupt_dmp_int_bit","title":"define MPU6050_INTERRUPT_DMP_INT_BIT","text":"<pre><code>#define MPU6050_INTERRUPT_DMP_INT_BIT 1\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_interrupt_ff_bit","title":"define MPU6050_INTERRUPT_FF_BIT","text":"<pre><code>#define MPU6050_INTERRUPT_FF_BIT 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_interrupt_fifo_oflow_bit","title":"define MPU6050_INTERRUPT_FIFO_OFLOW_BIT","text":"<pre><code>#define MPU6050_INTERRUPT_FIFO_OFLOW_BIT 4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_interrupt_i2c_mst_int_bit","title":"define MPU6050_INTERRUPT_I2C_MST_INT_BIT","text":"<pre><code>#define MPU6050_INTERRUPT_I2C_MST_INT_BIT 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_interrupt_mot_bit","title":"define MPU6050_INTERRUPT_MOT_BIT","text":"<pre><code>#define MPU6050_INTERRUPT_MOT_BIT 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_interrupt_pll_rdy_int_bit","title":"define MPU6050_INTERRUPT_PLL_RDY_INT_BIT","text":"<pre><code>#define MPU6050_INTERRUPT_PLL_RDY_INT_BIT 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_interrupt_zmot_bit","title":"define MPU6050_INTERRUPT_ZMOT_BIT","text":"<pre><code>#define MPU6050_INTERRUPT_ZMOT_BIT 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_intlatch_50uspulse","title":"define MPU6050_INTLATCH_50USPULSE","text":"<pre><code>#define MPU6050_INTLATCH_50USPULSE 0x00\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_intlatch_waitclear","title":"define MPU6050_INTLATCH_WAITCLEAR","text":"<pre><code>#define MPU6050_INTLATCH_WAITCLEAR 0x01\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_intmode_activehigh","title":"define MPU6050_INTMODE_ACTIVEHIGH","text":"<pre><code>#define MPU6050_INTMODE_ACTIVEHIGH 0x00\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_intmode_activelow","title":"define MPU6050_INTMODE_ACTIVELOW","text":"<pre><code>#define MPU6050_INTMODE_ACTIVELOW 0x01\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_motion_mot_xneg_bit","title":"define MPU6050_MOTION_MOT_XNEG_BIT","text":"<pre><code>#define MPU6050_MOTION_MOT_XNEG_BIT 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_motion_mot_xpos_bit","title":"define MPU6050_MOTION_MOT_XPOS_BIT","text":"<pre><code>#define MPU6050_MOTION_MOT_XPOS_BIT 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_motion_mot_yneg_bit","title":"define MPU6050_MOTION_MOT_YNEG_BIT","text":"<pre><code>#define MPU6050_MOTION_MOT_YNEG_BIT 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_motion_mot_ypos_bit","title":"define MPU6050_MOTION_MOT_YPOS_BIT","text":"<pre><code>#define MPU6050_MOTION_MOT_YPOS_BIT 4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_motion_mot_zneg_bit","title":"define MPU6050_MOTION_MOT_ZNEG_BIT","text":"<pre><code>#define MPU6050_MOTION_MOT_ZNEG_BIT 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_motion_mot_zpos_bit","title":"define MPU6050_MOTION_MOT_ZPOS_BIT","text":"<pre><code>#define MPU6050_MOTION_MOT_ZPOS_BIT 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_motion_mot_zrmot_bit","title":"define MPU6050_MOTION_MOT_ZRMOT_BIT","text":"<pre><code>#define MPU6050_MOTION_MOT_ZRMOT_BIT 0\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_mst_i2c_lost_arb_bit","title":"define MPU6050_MST_I2C_LOST_ARB_BIT","text":"<pre><code>#define MPU6050_MST_I2C_LOST_ARB_BIT 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_mst_i2c_slv0_nack_bit","title":"define MPU6050_MST_I2C_SLV0_NACK_BIT","text":"<pre><code>#define MPU6050_MST_I2C_SLV0_NACK_BIT 0\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_mst_i2c_slv1_nack_bit","title":"define MPU6050_MST_I2C_SLV1_NACK_BIT","text":"<pre><code>#define MPU6050_MST_I2C_SLV1_NACK_BIT 1\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_mst_i2c_slv2_nack_bit","title":"define MPU6050_MST_I2C_SLV2_NACK_BIT","text":"<pre><code>#define MPU6050_MST_I2C_SLV2_NACK_BIT 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_mst_i2c_slv3_nack_bit","title":"define MPU6050_MST_I2C_SLV3_NACK_BIT","text":"<pre><code>#define MPU6050_MST_I2C_SLV3_NACK_BIT 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_mst_i2c_slv4_done_bit","title":"define MPU6050_MST_I2C_SLV4_DONE_BIT","text":"<pre><code>#define MPU6050_MST_I2C_SLV4_DONE_BIT 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_mst_i2c_slv4_nack_bit","title":"define MPU6050_MST_I2C_SLV4_NACK_BIT","text":"<pre><code>#define MPU6050_MST_I2C_SLV4_NACK_BIT 4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_mst_pass_through_bit","title":"define MPU6050_MST_PASS_THROUGH_BIT","text":"<pre><code>#define MPU6050_MST_PASS_THROUGH_BIT 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_mult_mst_en_bit","title":"define MPU6050_MULT_MST_EN_BIT","text":"<pre><code>#define MPU6050_MULT_MST_EN_BIT 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pathreset_accel_reset_bit","title":"define MPU6050_PATHRESET_ACCEL_RESET_BIT","text":"<pre><code>#define MPU6050_PATHRESET_ACCEL_RESET_BIT 1\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pathreset_gyro_reset_bit","title":"define MPU6050_PATHRESET_GYRO_RESET_BIT","text":"<pre><code>#define MPU6050_PATHRESET_GYRO_RESET_BIT 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pathreset_temp_reset_bit","title":"define MPU6050_PATHRESET_TEMP_RESET_BIT","text":"<pre><code>#define MPU6050_PATHRESET_TEMP_RESET_BIT 0\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pwr1_clksel_bit","title":"define MPU6050_PWR1_CLKSEL_BIT","text":"<pre><code>#define MPU6050_PWR1_CLKSEL_BIT 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pwr1_clksel_length","title":"define MPU6050_PWR1_CLKSEL_LENGTH","text":"<pre><code>#define MPU6050_PWR1_CLKSEL_LENGTH 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pwr1_cycle_bit","title":"define MPU6050_PWR1_CYCLE_BIT","text":"<pre><code>#define MPU6050_PWR1_CYCLE_BIT 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pwr1_device_reset_bit","title":"define MPU6050_PWR1_DEVICE_RESET_BIT","text":"<pre><code>#define MPU6050_PWR1_DEVICE_RESET_BIT 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pwr1_sleep_bit","title":"define MPU6050_PWR1_SLEEP_BIT","text":"<pre><code>#define MPU6050_PWR1_SLEEP_BIT 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pwr1_temp_dis_bit","title":"define MPU6050_PWR1_TEMP_DIS_BIT","text":"<pre><code>#define MPU6050_PWR1_TEMP_DIS_BIT 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pwr2_lp_wake_ctrl_bit","title":"define MPU6050_PWR2_LP_WAKE_CTRL_BIT","text":"<pre><code>#define MPU6050_PWR2_LP_WAKE_CTRL_BIT 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pwr2_lp_wake_ctrl_length","title":"define MPU6050_PWR2_LP_WAKE_CTRL_LENGTH","text":"<pre><code>#define MPU6050_PWR2_LP_WAKE_CTRL_LENGTH 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pwr2_stby_xa_bit","title":"define MPU6050_PWR2_STBY_XA_BIT","text":"<pre><code>#define MPU6050_PWR2_STBY_XA_BIT 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pwr2_stby_xg_bit","title":"define MPU6050_PWR2_STBY_XG_BIT","text":"<pre><code>#define MPU6050_PWR2_STBY_XG_BIT 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pwr2_stby_ya_bit","title":"define MPU6050_PWR2_STBY_YA_BIT","text":"<pre><code>#define MPU6050_PWR2_STBY_YA_BIT 4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pwr2_stby_yg_bit","title":"define MPU6050_PWR2_STBY_YG_BIT","text":"<pre><code>#define MPU6050_PWR2_STBY_YG_BIT 1\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pwr2_stby_za_bit","title":"define MPU6050_PWR2_STBY_ZA_BIT","text":"<pre><code>#define MPU6050_PWR2_STBY_ZA_BIT 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_pwr2_stby_zg_bit","title":"define MPU6050_PWR2_STBY_ZG_BIT","text":"<pre><code>#define MPU6050_PWR2_STBY_ZG_BIT 0\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_accel_config","title":"define MPU6050_RA_ACCEL_CONFIG","text":"<pre><code>#define MPU6050_RA_ACCEL_CONFIG 0x1C\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_accel_xout_h","title":"define MPU6050_RA_ACCEL_XOUT_H","text":"<pre><code>#define MPU6050_RA_ACCEL_XOUT_H 0x3B\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_accel_xout_l","title":"define MPU6050_RA_ACCEL_XOUT_L","text":"<pre><code>#define MPU6050_RA_ACCEL_XOUT_L 0x3C\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_accel_yout_h","title":"define MPU6050_RA_ACCEL_YOUT_H","text":"<pre><code>#define MPU6050_RA_ACCEL_YOUT_H 0x3D\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_accel_yout_l","title":"define MPU6050_RA_ACCEL_YOUT_L","text":"<pre><code>#define MPU6050_RA_ACCEL_YOUT_L 0x3E\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_accel_zout_h","title":"define MPU6050_RA_ACCEL_ZOUT_H","text":"<pre><code>#define MPU6050_RA_ACCEL_ZOUT_H 0x3F\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_accel_zout_l","title":"define MPU6050_RA_ACCEL_ZOUT_L","text":"<pre><code>#define MPU6050_RA_ACCEL_ZOUT_L 0x40\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_bank_sel","title":"define MPU6050_RA_BANK_SEL","text":"<pre><code>#define MPU6050_RA_BANK_SEL 0x6D\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_config","title":"define MPU6050_RA_CONFIG","text":"<pre><code>#define MPU6050_RA_CONFIG 0x1A\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_dmp_cfg_1","title":"define MPU6050_RA_DMP_CFG_1","text":"<pre><code>#define MPU6050_RA_DMP_CFG_1 0x70\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_dmp_cfg_2","title":"define MPU6050_RA_DMP_CFG_2","text":"<pre><code>#define MPU6050_RA_DMP_CFG_2 0x71\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_dmp_int_status","title":"define MPU6050_RA_DMP_INT_STATUS","text":"<pre><code>#define MPU6050_RA_DMP_INT_STATUS 0x39\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_00","title":"define MPU6050_RA_EXT_SENS_DATA_00","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_00 0x49\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_01","title":"define MPU6050_RA_EXT_SENS_DATA_01","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_01 0x4A\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_02","title":"define MPU6050_RA_EXT_SENS_DATA_02","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_02 0x4B\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_03","title":"define MPU6050_RA_EXT_SENS_DATA_03","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_03 0x4C\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_04","title":"define MPU6050_RA_EXT_SENS_DATA_04","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_04 0x4D\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_05","title":"define MPU6050_RA_EXT_SENS_DATA_05","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_05 0x4E\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_06","title":"define MPU6050_RA_EXT_SENS_DATA_06","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_06 0x4F\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_07","title":"define MPU6050_RA_EXT_SENS_DATA_07","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_07 0x50\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_08","title":"define MPU6050_RA_EXT_SENS_DATA_08","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_08 0x51\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_09","title":"define MPU6050_RA_EXT_SENS_DATA_09","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_09 0x52\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_10","title":"define MPU6050_RA_EXT_SENS_DATA_10","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_10 0x53\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_11","title":"define MPU6050_RA_EXT_SENS_DATA_11","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_11 0x54\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_12","title":"define MPU6050_RA_EXT_SENS_DATA_12","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_12 0x55\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_13","title":"define MPU6050_RA_EXT_SENS_DATA_13","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_13 0x56\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_14","title":"define MPU6050_RA_EXT_SENS_DATA_14","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_14 0x57\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_15","title":"define MPU6050_RA_EXT_SENS_DATA_15","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_15 0x58\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_16","title":"define MPU6050_RA_EXT_SENS_DATA_16","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_16 0x59\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_17","title":"define MPU6050_RA_EXT_SENS_DATA_17","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_17 0x5A\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_18","title":"define MPU6050_RA_EXT_SENS_DATA_18","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_18 0x5B\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_19","title":"define MPU6050_RA_EXT_SENS_DATA_19","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_19 0x5C\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_20","title":"define MPU6050_RA_EXT_SENS_DATA_20","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_20 0x5D\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_21","title":"define MPU6050_RA_EXT_SENS_DATA_21","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_21 0x5E\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_22","title":"define MPU6050_RA_EXT_SENS_DATA_22","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_22 0x5F\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_23","title":"define MPU6050_RA_EXT_SENS_DATA_23","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_23 0x60\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ff_dur","title":"define MPU6050_RA_FF_DUR","text":"<pre><code>#define MPU6050_RA_FF_DUR 0x1E\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ff_thr","title":"define MPU6050_RA_FF_THR","text":"<pre><code>#define MPU6050_RA_FF_THR 0x1D\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_fifo_counth","title":"define MPU6050_RA_FIFO_COUNTH","text":"<pre><code>#define MPU6050_RA_FIFO_COUNTH 0x72\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_fifo_countl","title":"define MPU6050_RA_FIFO_COUNTL","text":"<pre><code>#define MPU6050_RA_FIFO_COUNTL 0x73\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_fifo_en","title":"define MPU6050_RA_FIFO_EN","text":"<pre><code>#define MPU6050_RA_FIFO_EN 0x23\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_fifo_r_w","title":"define MPU6050_RA_FIFO_R_W","text":"<pre><code>#define MPU6050_RA_FIFO_R_W 0x74\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_gyro_config","title":"define MPU6050_RA_GYRO_CONFIG","text":"<pre><code>#define MPU6050_RA_GYRO_CONFIG 0x1B\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_gyro_xout_h","title":"define MPU6050_RA_GYRO_XOUT_H","text":"<pre><code>#define MPU6050_RA_GYRO_XOUT_H 0x43\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_gyro_xout_l","title":"define MPU6050_RA_GYRO_XOUT_L","text":"<pre><code>#define MPU6050_RA_GYRO_XOUT_L 0x44\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_gyro_yout_h","title":"define MPU6050_RA_GYRO_YOUT_H","text":"<pre><code>#define MPU6050_RA_GYRO_YOUT_H 0x45\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_gyro_yout_l","title":"define MPU6050_RA_GYRO_YOUT_L","text":"<pre><code>#define MPU6050_RA_GYRO_YOUT_L 0x46\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_gyro_zout_h","title":"define MPU6050_RA_GYRO_ZOUT_H","text":"<pre><code>#define MPU6050_RA_GYRO_ZOUT_H 0x47\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_gyro_zout_l","title":"define MPU6050_RA_GYRO_ZOUT_L","text":"<pre><code>#define MPU6050_RA_GYRO_ZOUT_L 0x48\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_mst_ctrl","title":"define MPU6050_RA_I2C_MST_CTRL","text":"<pre><code>#define MPU6050_RA_I2C_MST_CTRL 0x24\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_mst_delay_ctrl","title":"define MPU6050_RA_I2C_MST_DELAY_CTRL","text":"<pre><code>#define MPU6050_RA_I2C_MST_DELAY_CTRL 0x67\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_mst_status","title":"define MPU6050_RA_I2C_MST_STATUS","text":"<pre><code>#define MPU6050_RA_I2C_MST_STATUS 0x36\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv0_addr","title":"define MPU6050_RA_I2C_SLV0_ADDR","text":"<pre><code>#define MPU6050_RA_I2C_SLV0_ADDR 0x25\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv0_ctrl","title":"define MPU6050_RA_I2C_SLV0_CTRL","text":"<pre><code>#define MPU6050_RA_I2C_SLV0_CTRL 0x27\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv0_do","title":"define MPU6050_RA_I2C_SLV0_DO","text":"<pre><code>#define MPU6050_RA_I2C_SLV0_DO 0x63\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv0_reg","title":"define MPU6050_RA_I2C_SLV0_REG","text":"<pre><code>#define MPU6050_RA_I2C_SLV0_REG 0x26\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv1_addr","title":"define MPU6050_RA_I2C_SLV1_ADDR","text":"<pre><code>#define MPU6050_RA_I2C_SLV1_ADDR 0x28\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv1_ctrl","title":"define MPU6050_RA_I2C_SLV1_CTRL","text":"<pre><code>#define MPU6050_RA_I2C_SLV1_CTRL 0x2A\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv1_do","title":"define MPU6050_RA_I2C_SLV1_DO","text":"<pre><code>#define MPU6050_RA_I2C_SLV1_DO 0x64\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv1_reg","title":"define MPU6050_RA_I2C_SLV1_REG","text":"<pre><code>#define MPU6050_RA_I2C_SLV1_REG 0x29\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv2_addr","title":"define MPU6050_RA_I2C_SLV2_ADDR","text":"<pre><code>#define MPU6050_RA_I2C_SLV2_ADDR 0x2B\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv2_ctrl","title":"define MPU6050_RA_I2C_SLV2_CTRL","text":"<pre><code>#define MPU6050_RA_I2C_SLV2_CTRL 0x2D\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv2_do","title":"define MPU6050_RA_I2C_SLV2_DO","text":"<pre><code>#define MPU6050_RA_I2C_SLV2_DO 0x65\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv2_reg","title":"define MPU6050_RA_I2C_SLV2_REG","text":"<pre><code>#define MPU6050_RA_I2C_SLV2_REG 0x2C\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv3_addr","title":"define MPU6050_RA_I2C_SLV3_ADDR","text":"<pre><code>#define MPU6050_RA_I2C_SLV3_ADDR 0x2E\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv3_ctrl","title":"define MPU6050_RA_I2C_SLV3_CTRL","text":"<pre><code>#define MPU6050_RA_I2C_SLV3_CTRL 0x30\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv3_do","title":"define MPU6050_RA_I2C_SLV3_DO","text":"<pre><code>#define MPU6050_RA_I2C_SLV3_DO 0x66\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv3_reg","title":"define MPU6050_RA_I2C_SLV3_REG","text":"<pre><code>#define MPU6050_RA_I2C_SLV3_REG 0x2F\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv4_addr","title":"define MPU6050_RA_I2C_SLV4_ADDR","text":"<pre><code>#define MPU6050_RA_I2C_SLV4_ADDR 0x31\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv4_ctrl","title":"define MPU6050_RA_I2C_SLV4_CTRL","text":"<pre><code>#define MPU6050_RA_I2C_SLV4_CTRL 0x34\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv4_di","title":"define MPU6050_RA_I2C_SLV4_DI","text":"<pre><code>#define MPU6050_RA_I2C_SLV4_DI 0x35\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv4_do","title":"define MPU6050_RA_I2C_SLV4_DO","text":"<pre><code>#define MPU6050_RA_I2C_SLV4_DO 0x33\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv4_reg","title":"define MPU6050_RA_I2C_SLV4_REG","text":"<pre><code>#define MPU6050_RA_I2C_SLV4_REG 0x32\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_int_enable","title":"define MPU6050_RA_INT_ENABLE","text":"<pre><code>#define MPU6050_RA_INT_ENABLE 0x38\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_int_pin_cfg","title":"define MPU6050_RA_INT_PIN_CFG","text":"<pre><code>#define MPU6050_RA_INT_PIN_CFG 0x37\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_int_status","title":"define MPU6050_RA_INT_STATUS","text":"<pre><code>#define MPU6050_RA_INT_STATUS 0x3A\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_mem_r_w","title":"define MPU6050_RA_MEM_R_W","text":"<pre><code>#define MPU6050_RA_MEM_R_W 0x6F\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_mem_start_addr","title":"define MPU6050_RA_MEM_START_ADDR","text":"<pre><code>#define MPU6050_RA_MEM_START_ADDR 0x6E\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_mot_detect_ctrl","title":"define MPU6050_RA_MOT_DETECT_CTRL","text":"<pre><code>#define MPU6050_RA_MOT_DETECT_CTRL 0x69\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_mot_detect_status","title":"define MPU6050_RA_MOT_DETECT_STATUS","text":"<pre><code>#define MPU6050_RA_MOT_DETECT_STATUS 0x61\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_mot_dur","title":"define MPU6050_RA_MOT_DUR","text":"<pre><code>#define MPU6050_RA_MOT_DUR 0x20\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_mot_thr","title":"define MPU6050_RA_MOT_THR","text":"<pre><code>#define MPU6050_RA_MOT_THR 0x1F\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_pwr_mgmt_1","title":"define MPU6050_RA_PWR_MGMT_1","text":"<pre><code>#define MPU6050_RA_PWR_MGMT_1 0x6B\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_pwr_mgmt_2","title":"define MPU6050_RA_PWR_MGMT_2","text":"<pre><code>#define MPU6050_RA_PWR_MGMT_2 0x6C\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_signal_path_reset","title":"define MPU6050_RA_SIGNAL_PATH_RESET","text":"<pre><code>#define MPU6050_RA_SIGNAL_PATH_RESET 0x68\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_smplrt_div","title":"define MPU6050_RA_SMPLRT_DIV","text":"<pre><code>#define MPU6050_RA_SMPLRT_DIV 0x19\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_temp_out_h","title":"define MPU6050_RA_TEMP_OUT_H","text":"<pre><code>#define MPU6050_RA_TEMP_OUT_H 0x41\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_temp_out_l","title":"define MPU6050_RA_TEMP_OUT_L","text":"<pre><code>#define MPU6050_RA_TEMP_OUT_L 0x42\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_user_ctrl","title":"define MPU6050_RA_USER_CTRL","text":"<pre><code>#define MPU6050_RA_USER_CTRL 0x6A\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_who_am_i","title":"define MPU6050_RA_WHO_AM_I","text":"<pre><code>#define MPU6050_RA_WHO_AM_I 0x75\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_xa_offs_h","title":"define MPU6050_RA_XA_OFFS_H","text":"<pre><code>#define MPU6050_RA_XA_OFFS_H 0x06\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_xa_offs_l_tc","title":"define MPU6050_RA_XA_OFFS_L_TC","text":"<pre><code>#define MPU6050_RA_XA_OFFS_L_TC 0x07\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_xg_offs_tc","title":"define MPU6050_RA_XG_OFFS_TC","text":"<pre><code>#define MPU6050_RA_XG_OFFS_TC 0x00\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_xg_offs_usrh","title":"define MPU6050_RA_XG_OFFS_USRH","text":"<pre><code>#define MPU6050_RA_XG_OFFS_USRH 0x13\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_xg_offs_usrl","title":"define MPU6050_RA_XG_OFFS_USRL","text":"<pre><code>#define MPU6050_RA_XG_OFFS_USRL 0x14\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_x_fine_gain","title":"define MPU6050_RA_X_FINE_GAIN","text":"<pre><code>#define MPU6050_RA_X_FINE_GAIN 0x03\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ya_offs_h","title":"define MPU6050_RA_YA_OFFS_H","text":"<pre><code>#define MPU6050_RA_YA_OFFS_H 0x08\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_ya_offs_l_tc","title":"define MPU6050_RA_YA_OFFS_L_TC","text":"<pre><code>#define MPU6050_RA_YA_OFFS_L_TC 0x09\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_yg_offs_tc","title":"define MPU6050_RA_YG_OFFS_TC","text":"<pre><code>#define MPU6050_RA_YG_OFFS_TC 0x01\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_yg_offs_usrh","title":"define MPU6050_RA_YG_OFFS_USRH","text":"<pre><code>#define MPU6050_RA_YG_OFFS_USRH 0x15\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_yg_offs_usrl","title":"define MPU6050_RA_YG_OFFS_USRL","text":"<pre><code>#define MPU6050_RA_YG_OFFS_USRL 0x16\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_y_fine_gain","title":"define MPU6050_RA_Y_FINE_GAIN","text":"<pre><code>#define MPU6050_RA_Y_FINE_GAIN 0x04\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_za_offs_h","title":"define MPU6050_RA_ZA_OFFS_H","text":"<pre><code>#define MPU6050_RA_ZA_OFFS_H 0x0A\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_za_offs_l_tc","title":"define MPU6050_RA_ZA_OFFS_L_TC","text":"<pre><code>#define MPU6050_RA_ZA_OFFS_L_TC 0x0B\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_zg_offs_tc","title":"define MPU6050_RA_ZG_OFFS_TC","text":"<pre><code>#define MPU6050_RA_ZG_OFFS_TC 0x02\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_zg_offs_usrh","title":"define MPU6050_RA_ZG_OFFS_USRH","text":"<pre><code>#define MPU6050_RA_ZG_OFFS_USRH 0x17\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_zg_offs_usrl","title":"define MPU6050_RA_ZG_OFFS_USRL","text":"<pre><code>#define MPU6050_RA_ZG_OFFS_USRL 0x18\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_zrmot_dur","title":"define MPU6050_RA_ZRMOT_DUR","text":"<pre><code>#define MPU6050_RA_ZRMOT_DUR 0x22\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_zrmot_thr","title":"define MPU6050_RA_ZRMOT_THR","text":"<pre><code>#define MPU6050_RA_ZRMOT_THR 0x21\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_ra_z_fine_gain","title":"define MPU6050_RA_Z_FINE_GAIN","text":"<pre><code>#define MPU6050_RA_Z_FINE_GAIN 0x05\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_slv0_fifo_en_bit","title":"define MPU6050_SLV0_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_SLV0_FIFO_EN_BIT 0\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_slv1_fifo_en_bit","title":"define MPU6050_SLV1_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_SLV1_FIFO_EN_BIT 1\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_slv2_fifo_en_bit","title":"define MPU6050_SLV2_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_SLV2_FIFO_EN_BIT 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_slv_3_fifo_en_bit","title":"define MPU6050_SLV_3_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_SLV_3_FIFO_EN_BIT 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_tc_offset_bit","title":"define MPU6050_TC_OFFSET_BIT","text":"<pre><code>#define MPU6050_TC_OFFSET_BIT 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_tc_offset_length","title":"define MPU6050_TC_OFFSET_LENGTH","text":"<pre><code>#define MPU6050_TC_OFFSET_LENGTH 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_tc_otp_bnk_vld_bit","title":"define MPU6050_TC_OTP_BNK_VLD_BIT","text":"<pre><code>#define MPU6050_TC_OTP_BNK_VLD_BIT 0\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_tc_pwr_mode_bit","title":"define MPU6050_TC_PWR_MODE_BIT","text":"<pre><code>#define MPU6050_TC_PWR_MODE_BIT 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_temp_fifo_en_bit","title":"define MPU6050_TEMP_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_TEMP_FIFO_EN_BIT 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_userctrl_dmp_en_bit","title":"define MPU6050_USERCTRL_DMP_EN_BIT","text":"<pre><code>#define MPU6050_USERCTRL_DMP_EN_BIT 7\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_userctrl_dmp_reset_bit","title":"define MPU6050_USERCTRL_DMP_RESET_BIT","text":"<pre><code>#define MPU6050_USERCTRL_DMP_RESET_BIT 3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_userctrl_fifo_en_bit","title":"define MPU6050_USERCTRL_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_USERCTRL_FIFO_EN_BIT 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_userctrl_fifo_reset_bit","title":"define MPU6050_USERCTRL_FIFO_RESET_BIT","text":"<pre><code>#define MPU6050_USERCTRL_FIFO_RESET_BIT 2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_userctrl_i2c_if_dis_bit","title":"define MPU6050_USERCTRL_I2C_IF_DIS_BIT","text":"<pre><code>#define MPU6050_USERCTRL_I2C_IF_DIS_BIT 4\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_userctrl_i2c_mst_en_bit","title":"define MPU6050_USERCTRL_I2C_MST_EN_BIT","text":"<pre><code>#define MPU6050_USERCTRL_I2C_MST_EN_BIT 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_userctrl_i2c_mst_reset_bit","title":"define MPU6050_USERCTRL_I2C_MST_RESET_BIT","text":"<pre><code>#define MPU6050_USERCTRL_I2C_MST_RESET_BIT 1\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_userctrl_sig_cond_reset_bit","title":"define MPU6050_USERCTRL_SIG_COND_RESET_BIT","text":"<pre><code>#define MPU6050_USERCTRL_SIG_COND_RESET_BIT 0\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_vddio_level_vdd","title":"define MPU6050_VDDIO_LEVEL_VDD","text":"<pre><code>#define MPU6050_VDDIO_LEVEL_VDD 1\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_vddio_level_vlogic","title":"define MPU6050_VDDIO_LEVEL_VLOGIC","text":"<pre><code>#define MPU6050_VDDIO_LEVEL_VLOGIC 0\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_wait_for_es_bit","title":"define MPU6050_WAIT_FOR_ES_BIT","text":"<pre><code>#define MPU6050_WAIT_FOR_ES_BIT 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_wake_freq_10","title":"define MPU6050_WAKE_FREQ_10","text":"<pre><code>#define MPU6050_WAKE_FREQ_10 0x3\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_wake_freq_1p25","title":"define MPU6050_WAKE_FREQ_1P25","text":"<pre><code>#define MPU6050_WAKE_FREQ_1P25 0x0\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_wake_freq_2p5","title":"define MPU6050_WAKE_FREQ_2P5","text":"<pre><code>#define MPU6050_WAKE_FREQ_2P5 0x1\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_wake_freq_5","title":"define MPU6050_WAKE_FREQ_5","text":"<pre><code>#define MPU6050_WAKE_FREQ_5 0x2\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_who_am_i_bit","title":"define MPU6050_WHO_AM_I_BIT","text":"<pre><code>#define MPU6050_WHO_AM_I_BIT 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_who_am_i_length","title":"define MPU6050_WHO_AM_I_LENGTH","text":"<pre><code>#define MPU6050_WHO_AM_I_LENGTH 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_xg_fifo_en_bit","title":"define MPU6050_XG_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_XG_FIFO_EN_BIT 6\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_yg_fifo_en_bit","title":"define MPU6050_YG_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_YG_FIFO_EN_BIT 5\n</code></pre>"},{"location":"stm/Mpu6050_8hpp/#define-mpu6050_zg_fifo_en_bit","title":"define MPU6050_ZG_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_ZG_FIFO_EN_BIT 4\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/Mpu6050.hpp</code></p>"},{"location":"stm/Mpu6050_8hpp_source/","title":"File Mpu6050.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; Mpu6050.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>// I2Cdev library collection - MPU6050 I2C device class\n// Based on InvenSense MPU-6050 register map document rev. 2.0, 5/19/2011 (RM-MPU-6000A-00)\n// 10/3/2011 by Jeff Rowberg &lt;jeff@rowberg.net&gt;\n// 11/28/2014 by Marton Sebok &lt;sebokmarton@gmail.com&gt;\n//\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//     ...        - ongoing debug release\n//     2014-11-28 - ported to PIC18 peripheral library from Arduino code\n//     2017-03-11 - tested basic functions on STM32\n\n// NOTE: THIS IS ONLY A PARIAL RELEASE. THIS DEVICE CLASS IS CURRENTLY UNDERGOING ACTIVE\n// DEVELOPMENT AND IS STILL MISSING SOME IMPORTANT FEATURES. PLEASE KEEP THIS IN MIND IF\n// YOU DECIDE TO USE THIS PARTICULAR CODE FOR ANYTHING.\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2012 Jeff Rowberg\nCopyright (c) 2014 Marton Sebok\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#ifndef _MPU6050_H_\n#define _MPU6050_H_\n\n#include \"I2cController.hpp\"\n#include &lt;stdbool.h&gt;\n\n// clang-format off\n\n#if ((defined MPU6050_INCLUDE_DMP_MOTIONAPPS20) || (defined MPU6050_INCLUDE_DMP_MOTIONAPPS41))\n#error DMP is not supported yet\n#endif\n\n#define MPU6050_ADDRESS_AD0_LOW     0x68 // address pin low (GND), default for InvenSense evaluation board\n#define MPU6050_ADDRESS_AD0_HIGH    0x69 // address pin high (VCC)\n#define MPU6050_DEFAULT_ADDRESS     MPU6050_ADDRESS_AD0_LOW\n\n#define MPU6050_RA_XG_OFFS_TC       0x00 //[7] PWR_MODE, [6:1] XG_OFFS_TC, [0] OTP_BNK_VLD\n#define MPU6050_RA_YG_OFFS_TC       0x01 //[7] PWR_MODE, [6:1] YG_OFFS_TC, [0] OTP_BNK_VLD\n#define MPU6050_RA_ZG_OFFS_TC       0x02 //[7] PWR_MODE, [6:1] ZG_OFFS_TC, [0] OTP_BNK_VLD\n#define MPU6050_RA_X_FINE_GAIN      0x03 //[7:0] X_FINE_GAIN\n#define MPU6050_RA_Y_FINE_GAIN      0x04 //[7:0] Y_FINE_GAIN\n#define MPU6050_RA_Z_FINE_GAIN      0x05 //[7:0] Z_FINE_GAIN\n#define MPU6050_RA_XA_OFFS_H        0x06 //[15:0] XA_OFFS\n#define MPU6050_RA_XA_OFFS_L_TC     0x07\n#define MPU6050_RA_YA_OFFS_H        0x08 //[15:0] YA_OFFS\n#define MPU6050_RA_YA_OFFS_L_TC     0x09\n#define MPU6050_RA_ZA_OFFS_H        0x0A //[15:0] ZA_OFFS\n#define MPU6050_RA_ZA_OFFS_L_TC     0x0B\n#define MPU6050_RA_XG_OFFS_USRH     0x13 //[15:0] XG_OFFS_USR\n#define MPU6050_RA_XG_OFFS_USRL     0x14\n#define MPU6050_RA_YG_OFFS_USRH     0x15 //[15:0] YG_OFFS_USR\n#define MPU6050_RA_YG_OFFS_USRL     0x16\n#define MPU6050_RA_ZG_OFFS_USRH     0x17 //[15:0] ZG_OFFS_USR\n#define MPU6050_RA_ZG_OFFS_USRL     0x18\n#define MPU6050_RA_SMPLRT_DIV       0x19\n#define MPU6050_RA_CONFIG           0x1A\n#define MPU6050_RA_GYRO_CONFIG      0x1B\n#define MPU6050_RA_ACCEL_CONFIG     0x1C\n#define MPU6050_RA_FF_THR           0x1D\n#define MPU6050_RA_FF_DUR           0x1E\n#define MPU6050_RA_MOT_THR          0x1F\n#define MPU6050_RA_MOT_DUR          0x20\n#define MPU6050_RA_ZRMOT_THR        0x21\n#define MPU6050_RA_ZRMOT_DUR        0x22\n#define MPU6050_RA_FIFO_EN          0x23\n#define MPU6050_RA_I2C_MST_CTRL     0x24\n#define MPU6050_RA_I2C_SLV0_ADDR    0x25\n#define MPU6050_RA_I2C_SLV0_REG     0x26\n#define MPU6050_RA_I2C_SLV0_CTRL    0x27\n#define MPU6050_RA_I2C_SLV1_ADDR    0x28\n#define MPU6050_RA_I2C_SLV1_REG     0x29\n#define MPU6050_RA_I2C_SLV1_CTRL    0x2A\n#define MPU6050_RA_I2C_SLV2_ADDR    0x2B\n#define MPU6050_RA_I2C_SLV2_REG     0x2C\n#define MPU6050_RA_I2C_SLV2_CTRL    0x2D\n#define MPU6050_RA_I2C_SLV3_ADDR    0x2E\n#define MPU6050_RA_I2C_SLV3_REG     0x2F\n#define MPU6050_RA_I2C_SLV3_CTRL    0x30\n#define MPU6050_RA_I2C_SLV4_ADDR    0x31\n#define MPU6050_RA_I2C_SLV4_REG     0x32\n#define MPU6050_RA_I2C_SLV4_DO      0x33\n#define MPU6050_RA_I2C_SLV4_CTRL    0x34\n#define MPU6050_RA_I2C_SLV4_DI      0x35\n#define MPU6050_RA_I2C_MST_STATUS   0x36\n#define MPU6050_RA_INT_PIN_CFG      0x37\n#define MPU6050_RA_INT_ENABLE       0x38\n#define MPU6050_RA_DMP_INT_STATUS   0x39\n#define MPU6050_RA_INT_STATUS       0x3A\n#define MPU6050_RA_ACCEL_XOUT_H     0x3B\n#define MPU6050_RA_ACCEL_XOUT_L     0x3C\n#define MPU6050_RA_ACCEL_YOUT_H     0x3D\n#define MPU6050_RA_ACCEL_YOUT_L     0x3E\n#define MPU6050_RA_ACCEL_ZOUT_H     0x3F\n#define MPU6050_RA_ACCEL_ZOUT_L     0x40\n#define MPU6050_RA_TEMP_OUT_H       0x41\n#define MPU6050_RA_TEMP_OUT_L       0x42\n#define MPU6050_RA_GYRO_XOUT_H      0x43\n#define MPU6050_RA_GYRO_XOUT_L      0x44\n#define MPU6050_RA_GYRO_YOUT_H      0x45\n#define MPU6050_RA_GYRO_YOUT_L      0x46\n#define MPU6050_RA_GYRO_ZOUT_H      0x47\n#define MPU6050_RA_GYRO_ZOUT_L      0x48\n#define MPU6050_RA_EXT_SENS_DATA_00 0x49\n#define MPU6050_RA_EXT_SENS_DATA_01 0x4A\n#define MPU6050_RA_EXT_SENS_DATA_02 0x4B\n#define MPU6050_RA_EXT_SENS_DATA_03 0x4C\n#define MPU6050_RA_EXT_SENS_DATA_04 0x4D\n#define MPU6050_RA_EXT_SENS_DATA_05 0x4E\n#define MPU6050_RA_EXT_SENS_DATA_06 0x4F\n#define MPU6050_RA_EXT_SENS_DATA_07 0x50\n#define MPU6050_RA_EXT_SENS_DATA_08 0x51\n#define MPU6050_RA_EXT_SENS_DATA_09 0x52\n#define MPU6050_RA_EXT_SENS_DATA_10 0x53\n#define MPU6050_RA_EXT_SENS_DATA_11 0x54\n#define MPU6050_RA_EXT_SENS_DATA_12 0x55\n#define MPU6050_RA_EXT_SENS_DATA_13 0x56\n#define MPU6050_RA_EXT_SENS_DATA_14 0x57\n#define MPU6050_RA_EXT_SENS_DATA_15 0x58\n#define MPU6050_RA_EXT_SENS_DATA_16 0x59\n#define MPU6050_RA_EXT_SENS_DATA_17 0x5A\n#define MPU6050_RA_EXT_SENS_DATA_18 0x5B\n#define MPU6050_RA_EXT_SENS_DATA_19 0x5C\n#define MPU6050_RA_EXT_SENS_DATA_20 0x5D\n#define MPU6050_RA_EXT_SENS_DATA_21 0x5E\n#define MPU6050_RA_EXT_SENS_DATA_22 0x5F\n#define MPU6050_RA_EXT_SENS_DATA_23 0x60\n#define MPU6050_RA_MOT_DETECT_STATUS    0x61\n#define MPU6050_RA_I2C_SLV0_DO      0x63\n#define MPU6050_RA_I2C_SLV1_DO      0x64\n#define MPU6050_RA_I2C_SLV2_DO      0x65\n#define MPU6050_RA_I2C_SLV3_DO      0x66\n#define MPU6050_RA_I2C_MST_DELAY_CTRL   0x67\n#define MPU6050_RA_SIGNAL_PATH_RESET    0x68\n#define MPU6050_RA_MOT_DETECT_CTRL      0x69\n#define MPU6050_RA_USER_CTRL        0x6A\n#define MPU6050_RA_PWR_MGMT_1       0x6B\n#define MPU6050_RA_PWR_MGMT_2       0x6C\n#define MPU6050_RA_BANK_SEL         0x6D\n#define MPU6050_RA_MEM_START_ADDR   0x6E\n#define MPU6050_RA_MEM_R_W          0x6F\n#define MPU6050_RA_DMP_CFG_1        0x70\n#define MPU6050_RA_DMP_CFG_2        0x71\n#define MPU6050_RA_FIFO_COUNTH      0x72\n#define MPU6050_RA_FIFO_COUNTL      0x73\n#define MPU6050_RA_FIFO_R_W         0x74\n#define MPU6050_RA_WHO_AM_I         0x75\n\n#define MPU6050_TC_PWR_MODE_BIT     7\n#define MPU6050_TC_OFFSET_BIT       6\n#define MPU6050_TC_OFFSET_LENGTH    6\n#define MPU6050_TC_OTP_BNK_VLD_BIT  0\n\n#define MPU6050_VDDIO_LEVEL_VLOGIC  0\n#define MPU6050_VDDIO_LEVEL_VDD     1\n\n#define MPU6050_CFG_EXT_SYNC_SET_BIT    5\n#define MPU6050_CFG_EXT_SYNC_SET_LENGTH 3\n#define MPU6050_CFG_DLPF_CFG_BIT    2\n#define MPU6050_CFG_DLPF_CFG_LENGTH 3\n\n#define MPU6050_EXT_SYNC_DISABLED       0x0\n#define MPU6050_EXT_SYNC_TEMP_OUT_L     0x1\n#define MPU6050_EXT_SYNC_GYRO_XOUT_L    0x2\n#define MPU6050_EXT_SYNC_GYRO_YOUT_L    0x3\n#define MPU6050_EXT_SYNC_GYRO_ZOUT_L    0x4\n#define MPU6050_EXT_SYNC_ACCEL_XOUT_L   0x5\n#define MPU6050_EXT_SYNC_ACCEL_YOUT_L   0x6\n#define MPU6050_EXT_SYNC_ACCEL_ZOUT_L   0x7\n\n#define MPU6050_DLPF_BW_256         0x00\n#define MPU6050_DLPF_BW_188         0x01\n#define MPU6050_DLPF_BW_98          0x02\n#define MPU6050_DLPF_BW_42          0x03\n#define MPU6050_DLPF_BW_20          0x04\n#define MPU6050_DLPF_BW_10          0x05\n#define MPU6050_DLPF_BW_5           0x06\n\n#define MPU6050_GCONFIG_FS_SEL_BIT      4\n#define MPU6050_GCONFIG_FS_SEL_LENGTH   2\n\n#define MPU6050_GYRO_FS_250         0x00\n#define MPU6050_GYRO_FS_500         0x01\n#define MPU6050_GYRO_FS_1000        0x02\n#define MPU6050_GYRO_FS_2000        0x03\n\n#define MPU6050_ACONFIG_XA_ST_BIT           7\n#define MPU6050_ACONFIG_YA_ST_BIT           6\n#define MPU6050_ACONFIG_ZA_ST_BIT           5\n#define MPU6050_ACONFIG_AFS_SEL_BIT         4\n#define MPU6050_ACONFIG_AFS_SEL_LENGTH      2\n#define MPU6050_ACONFIG_ACCEL_HPF_BIT       2\n#define MPU6050_ACONFIG_ACCEL_HPF_LENGTH    3\n\n#define MPU6050_ACCEL_FS_2          0x00\n#define MPU6050_ACCEL_FS_4          0x01\n#define MPU6050_ACCEL_FS_8          0x02\n#define MPU6050_ACCEL_FS_16         0x03\n\n#define MPU6050_DHPF_RESET          0x00\n#define MPU6050_DHPF_5              0x01\n#define MPU6050_DHPF_2P5            0x02\n#define MPU6050_DHPF_1P25           0x03\n#define MPU6050_DHPF_0P63           0x04\n#define MPU6050_DHPF_HOLD           0x07\n\n#define MPU6050_TEMP_FIFO_EN_BIT    7\n#define MPU6050_XG_FIFO_EN_BIT      6\n#define MPU6050_YG_FIFO_EN_BIT      5\n#define MPU6050_ZG_FIFO_EN_BIT      4\n#define MPU6050_ACCEL_FIFO_EN_BIT   3\n#define MPU6050_SLV2_FIFO_EN_BIT    2\n#define MPU6050_SLV1_FIFO_EN_BIT    1\n#define MPU6050_SLV0_FIFO_EN_BIT    0\n\n#define MPU6050_MULT_MST_EN_BIT     7\n#define MPU6050_WAIT_FOR_ES_BIT     6\n#define MPU6050_SLV_3_FIFO_EN_BIT   5\n#define MPU6050_I2C_MST_P_NSR_BIT   4\n#define MPU6050_I2C_MST_CLK_BIT     3\n#define MPU6050_I2C_MST_CLK_LENGTH  4\n\n#define MPU6050_CLOCK_DIV_348       0x0\n#define MPU6050_CLOCK_DIV_333       0x1\n#define MPU6050_CLOCK_DIV_320       0x2\n#define MPU6050_CLOCK_DIV_308       0x3\n#define MPU6050_CLOCK_DIV_296       0x4\n#define MPU6050_CLOCK_DIV_286       0x5\n#define MPU6050_CLOCK_DIV_276       0x6\n#define MPU6050_CLOCK_DIV_267       0x7\n#define MPU6050_CLOCK_DIV_258       0x8\n#define MPU6050_CLOCK_DIV_500       0x9\n#define MPU6050_CLOCK_DIV_471       0xA\n#define MPU6050_CLOCK_DIV_444       0xB\n#define MPU6050_CLOCK_DIV_421       0xC\n#define MPU6050_CLOCK_DIV_400       0xD\n#define MPU6050_CLOCK_DIV_381       0xE\n#define MPU6050_CLOCK_DIV_364       0xF\n\n#define MPU6050_I2C_SLV_RW_BIT      7\n#define MPU6050_I2C_SLV_ADDR_BIT    6\n#define MPU6050_I2C_SLV_ADDR_LENGTH 7\n#define MPU6050_I2C_SLV_EN_BIT      7\n#define MPU6050_I2C_SLV_BYTE_SW_BIT 6\n#define MPU6050_I2C_SLV_REG_DIS_BIT 5\n#define MPU6050_I2C_SLV_GRP_BIT     4\n#define MPU6050_I2C_SLV_LEN_BIT     3\n#define MPU6050_I2C_SLV_LEN_LENGTH  4\n\n#define MPU6050_I2C_SLV4_RW_BIT         7\n#define MPU6050_I2C_SLV4_ADDR_BIT       6\n#define MPU6050_I2C_SLV4_ADDR_LENGTH    7\n#define MPU6050_I2C_SLV4_EN_BIT         7\n#define MPU6050_I2C_SLV4_INT_EN_BIT     6\n#define MPU6050_I2C_SLV4_REG_DIS_BIT    5\n#define MPU6050_I2C_SLV4_MST_DLY_BIT    4\n#define MPU6050_I2C_SLV4_MST_DLY_LENGTH 5\n\n#define MPU6050_MST_PASS_THROUGH_BIT    7\n#define MPU6050_MST_I2C_SLV4_DONE_BIT   6\n#define MPU6050_MST_I2C_LOST_ARB_BIT    5\n#define MPU6050_MST_I2C_SLV4_NACK_BIT   4\n#define MPU6050_MST_I2C_SLV3_NACK_BIT   3\n#define MPU6050_MST_I2C_SLV2_NACK_BIT   2\n#define MPU6050_MST_I2C_SLV1_NACK_BIT   1\n#define MPU6050_MST_I2C_SLV0_NACK_BIT   0\n\n#define MPU6050_INTCFG_INT_LEVEL_BIT        7\n#define MPU6050_INTCFG_INT_OPEN_BIT         6\n#define MPU6050_INTCFG_LATCH_INT_EN_BIT     5\n#define MPU6050_INTCFG_INT_RD_CLEAR_BIT     4\n#define MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT  3\n#define MPU6050_INTCFG_FSYNC_INT_EN_BIT     2\n#define MPU6050_INTCFG_I2C_BYPASS_EN_BIT    1\n#define MPU6050_INTCFG_CLKOUT_EN_BIT        0\n\n#define MPU6050_INTMODE_ACTIVEHIGH  0x00\n#define MPU6050_INTMODE_ACTIVELOW   0x01\n\n#define MPU6050_INTDRV_PUSHPULL     0x00\n#define MPU6050_INTDRV_OPENDRAIN    0x01\n\n#define MPU6050_INTLATCH_50USPULSE  0x00\n#define MPU6050_INTLATCH_WAITCLEAR  0x01\n\n#define MPU6050_INTCLEAR_STATUSREAD 0x00\n#define MPU6050_INTCLEAR_ANYREAD    0x01\n\n#define MPU6050_INTERRUPT_FF_BIT            7\n#define MPU6050_INTERRUPT_MOT_BIT           6\n#define MPU6050_INTERRUPT_ZMOT_BIT          5\n#define MPU6050_INTERRUPT_FIFO_OFLOW_BIT    4\n#define MPU6050_INTERRUPT_I2C_MST_INT_BIT   3\n#define MPU6050_INTERRUPT_PLL_RDY_INT_BIT   2\n#define MPU6050_INTERRUPT_DMP_INT_BIT       1\n#define MPU6050_INTERRUPT_DATA_RDY_BIT      0\n\n// TODO: figure out what these actually do\n// UMPL source code is not very obivous\n#define MPU6050_DMPINT_5_BIT            5\n#define MPU6050_DMPINT_4_BIT            4\n#define MPU6050_DMPINT_3_BIT            3\n#define MPU6050_DMPINT_2_BIT            2\n#define MPU6050_DMPINT_1_BIT            1\n#define MPU6050_DMPINT_0_BIT            0\n\n#define MPU6050_MOTION_MOT_XNEG_BIT     7\n#define MPU6050_MOTION_MOT_XPOS_BIT     6\n#define MPU6050_MOTION_MOT_YNEG_BIT     5\n#define MPU6050_MOTION_MOT_YPOS_BIT     4\n#define MPU6050_MOTION_MOT_ZNEG_BIT     3\n#define MPU6050_MOTION_MOT_ZPOS_BIT     2\n#define MPU6050_MOTION_MOT_ZRMOT_BIT    0\n\n#define MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT   7\n#define MPU6050_DELAYCTRL_I2C_SLV4_DLY_EN_BIT   4\n#define MPU6050_DELAYCTRL_I2C_SLV3_DLY_EN_BIT   3\n#define MPU6050_DELAYCTRL_I2C_SLV2_DLY_EN_BIT   2\n#define MPU6050_DELAYCTRL_I2C_SLV1_DLY_EN_BIT   1\n#define MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT   0\n\n#define MPU6050_PATHRESET_GYRO_RESET_BIT    2\n#define MPU6050_PATHRESET_ACCEL_RESET_BIT   1\n#define MPU6050_PATHRESET_TEMP_RESET_BIT    0\n\n#define MPU6050_DETECT_ACCEL_ON_DELAY_BIT       5\n#define MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH    2\n#define MPU6050_DETECT_FF_COUNT_BIT             3\n#define MPU6050_DETECT_FF_COUNT_LENGTH          2\n#define MPU6050_DETECT_MOT_COUNT_BIT            1\n#define MPU6050_DETECT_MOT_COUNT_LENGTH         2\n\n#define MPU6050_DETECT_DECREMENT_RESET  0x0\n#define MPU6050_DETECT_DECREMENT_1      0x1\n#define MPU6050_DETECT_DECREMENT_2      0x2\n#define MPU6050_DETECT_DECREMENT_4      0x3\n\n#define MPU6050_USERCTRL_DMP_EN_BIT             7\n#define MPU6050_USERCTRL_FIFO_EN_BIT            6\n#define MPU6050_USERCTRL_I2C_MST_EN_BIT         5\n#define MPU6050_USERCTRL_I2C_IF_DIS_BIT         4\n#define MPU6050_USERCTRL_DMP_RESET_BIT          3\n#define MPU6050_USERCTRL_FIFO_RESET_BIT         2\n#define MPU6050_USERCTRL_I2C_MST_RESET_BIT      1\n#define MPU6050_USERCTRL_SIG_COND_RESET_BIT     0\n\n#define MPU6050_PWR1_DEVICE_RESET_BIT   7\n#define MPU6050_PWR1_SLEEP_BIT          6\n#define MPU6050_PWR1_CYCLE_BIT          5\n#define MPU6050_PWR1_TEMP_DIS_BIT       3\n#define MPU6050_PWR1_CLKSEL_BIT         2\n#define MPU6050_PWR1_CLKSEL_LENGTH      3\n\n#define MPU6050_CLOCK_INTERNAL          0x00\n#define MPU6050_CLOCK_PLL_XGYRO         0x01\n#define MPU6050_CLOCK_PLL_YGYRO         0x02\n#define MPU6050_CLOCK_PLL_ZGYRO         0x03\n#define MPU6050_CLOCK_PLL_EXT32K        0x04\n#define MPU6050_CLOCK_PLL_EXT19M        0x05\n#define MPU6050_CLOCK_KEEP_RESET        0x07\n\n#define MPU6050_PWR2_LP_WAKE_CTRL_BIT       7\n#define MPU6050_PWR2_LP_WAKE_CTRL_LENGTH    2\n#define MPU6050_PWR2_STBY_XA_BIT            5\n#define MPU6050_PWR2_STBY_YA_BIT            4\n#define MPU6050_PWR2_STBY_ZA_BIT            3\n#define MPU6050_PWR2_STBY_XG_BIT            2\n#define MPU6050_PWR2_STBY_YG_BIT            1\n#define MPU6050_PWR2_STBY_ZG_BIT            0\n\n#define MPU6050_WAKE_FREQ_1P25      0x0\n#define MPU6050_WAKE_FREQ_2P5       0x1\n#define MPU6050_WAKE_FREQ_5         0x2\n#define MPU6050_WAKE_FREQ_10        0x3\n\n#define MPU6050_BANKSEL_PRFTCH_EN_BIT       6\n#define MPU6050_BANKSEL_CFG_USER_BANK_BIT   5\n#define MPU6050_BANKSEL_MEM_SEL_BIT         4\n#define MPU6050_BANKSEL_MEM_SEL_LENGTH      5\n\n#define MPU6050_WHO_AM_I_BIT        6\n#define MPU6050_WHO_AM_I_LENGTH     6\n\n#define MPU6050_DMP_MEMORY_BANKS        8\n#define MPU6050_DMP_MEMORY_BANK_SIZE    256\n#define MPU6050_DMP_MEMORY_CHUNK_SIZE   16\n\n// note: DMP code memory blocks defined at end of header file\n\ntypedef struct MPU6050_t {\nuint8_t devAddr;\nuint8_t buffer[14];\n} MPU6050_t;\n\nvoid MPU6050_init();\n\nvoid MPU6050(uint8_t address);\n\nvoid MPU6050_initialize();\nbool MPU6050_testConnection();\n\n// AUX_VDDIO register\nuint8_t MPU6050_getAuxVDDIOLevel();\nvoid MPU6050_setAuxVDDIOLevel(uint8_t level);\n\n// SMPLRT_DIV register\nuint8_t MPU6050_getRate();\nvoid MPU6050_setRate(uint8_t rate);\n\n// CONFIG register\nuint8_t MPU6050_getExternalFrameSync();\nvoid MPU6050_setExternalFrameSync(uint8_t sync);\nuint8_t MPU6050_getDLPFMode();\nvoid MPU6050_setDLPFMode(uint8_t bandwidth);\n\n// GYRO_CONFIG register\nuint8_t MPU6050_getFullScaleGyroRange();\nvoid MPU6050_setFullScaleGyroRange(uint8_t range);\n\n// ACCEL_CONFIG register\nbool MPU6050_getAccelXSelfTest();\nvoid MPU6050_setAccelXSelfTest(bool enabled);\nbool MPU6050_getAccelYSelfTest();\nvoid MPU6050_setAccelYSelfTest(bool enabled);\nbool MPU6050_getAccelZSelfTest();\nvoid MPU6050_setAccelZSelfTest(bool enabled);\nuint8_t MPU6050_getFullScaleAccelRange();\nvoid MPU6050_setFullScaleAccelRange(uint8_t range);\nuint8_t MPU6050_getDHPFMode();\nvoid MPU6050_setDHPFMode(uint8_t mode);\n\n// FF_THR register\nuint8_t MPU6050_getFreefallDetectionThreshold();\nvoid MPU6050_setFreefallDetectionThreshold(uint8_t threshold);\n\n// FF_DUR register\nuint8_t MPU6050_getFreefallDetectionDuration();\nvoid MPU6050_setFreefallDetectionDuration(uint8_t duration);\n\n// MOT_THR register\nuint8_t MPU6050_getMotionDetectionThreshold();\nvoid MPU6050_setMotionDetectionThreshold(uint8_t threshold);\n\n// MOT_DUR register\nuint8_t MPU6050_getMotionDetectionDuration();\nvoid MPU6050_setMotionDetectionDuration(uint8_t duration);\n\n// ZRMOT_THR register\nuint8_t MPU6050_getZeroMotionDetectionThreshold();\nvoid MPU6050_setZeroMotionDetectionThreshold(uint8_t threshold);\n\n// ZRMOT_DUR register\nuint8_t MPU6050_getZeroMotionDetectionDuration();\nvoid MPU6050_setZeroMotionDetectionDuration(uint8_t duration);\n\n// FIFO_EN register\nbool MPU6050_getTempFIFOEnabled();\nvoid MPU6050_setTempFIFOEnabled(bool enabled);\nbool MPU6050_getXGyroFIFOEnabled();\nvoid MPU6050_setXGyroFIFOEnabled(bool enabled);\nbool MPU6050_getYGyroFIFOEnabled();\nvoid MPU6050_setYGyroFIFOEnabled(bool enabled);\nbool MPU6050_getZGyroFIFOEnabled();\nvoid MPU6050_setZGyroFIFOEnabled(bool enabled);\nbool MPU6050_getAccelFIFOEnabled();\nvoid MPU6050_setAccelFIFOEnabled(bool enabled);\nbool MPU6050_getSlave2FIFOEnabled();\nvoid MPU6050_setSlave2FIFOEnabled(bool enabled);\nbool MPU6050_getSlave1FIFOEnabled();\nvoid MPU6050_setSlave1FIFOEnabled(bool enabled);\nbool MPU6050_getSlave0FIFOEnabled();\nvoid MPU6050_setSlave0FIFOEnabled(bool enabled);\n\n// I2C_MST_CTRL register\nbool MPU6050_getMultiMasterEnabled();\nvoid MPU6050_setMultiMasterEnabled(bool enabled);\nbool MPU6050_getWaitForExternalSensorEnabled();\nvoid MPU6050_setWaitForExternalSensorEnabled(bool enabled);\nbool MPU6050_getSlave3FIFOEnabled();\nvoid MPU6050_setSlave3FIFOEnabled(bool enabled);\nbool MPU6050_getSlaveReadWriteTransitionEnabled();\nvoid MPU6050_setSlaveReadWriteTransitionEnabled(bool enabled);\nuint8_t MPU6050_getMasterClockSpeed();\nvoid MPU6050_setMasterClockSpeed(uint8_t speed);\n\n// I2C_SLV* registers (Slave 0-3)\nuint8_t MPU6050_getSlaveAddress(uint8_t num);\nvoid MPU6050_setSlaveAddress(uint8_t num, uint8_t address);\nuint8_t MPU6050_getSlaveRegister(uint8_t num);\nvoid MPU6050_setSlaveRegister(uint8_t num, uint8_t reg);\nbool MPU6050_getSlaveEnabled(uint8_t num);\nvoid MPU6050_setSlaveEnabled(uint8_t num, bool enabled);\nbool MPU6050_getSlaveWordByteSwap(uint8_t num);\nvoid MPU6050_setSlaveWordByteSwap(uint8_t num, bool enabled);\nbool MPU6050_getSlaveWriteMode(uint8_t num);\nvoid MPU6050_setSlaveWriteMode(uint8_t num, bool mode);\nbool MPU6050_getSlaveWordGroupOffset(uint8_t num);\nvoid MPU6050_setSlaveWordGroupOffset(uint8_t num, bool enabled);\nuint8_t MPU6050_getSlaveDataLength(uint8_t num);\nvoid MPU6050_setSlaveDataLength(uint8_t num, uint8_t length);\n\n// I2C_SLV* registers (Slave 4)\nuint8_t MPU6050_getSlave4Address();\nvoid MPU6050_setSlave4Address(uint8_t address);\nuint8_t MPU6050_getSlave4Register();\nvoid MPU6050_setSlave4Register(uint8_t reg);\nvoid MPU6050_setSlave4OutputByte(uint8_t data);\nbool MPU6050_getSlave4Enabled();\nvoid MPU6050_setSlave4Enabled(bool enabled);\nbool MPU6050_getSlave4InterruptEnabled();\nvoid MPU6050_setSlave4InterruptEnabled(bool enabled);\nbool MPU6050_getSlave4WriteMode();\nvoid MPU6050_setSlave4WriteMode(bool mode);\nuint8_t MPU6050_getSlave4MasterDelay();\nvoid MPU6050_setSlave4MasterDelay(uint8_t delay);\nuint8_t MPU6050_getSlate4InputByte();\n\n// I2C_MST_STATUS register\nbool MPU6050_getPassthroughStatus();\nbool MPU6050_getSlave4IsDone();\nbool MPU6050_getLostArbitration();\nbool MPU6050_getSlave4Nack();\nbool MPU6050_getSlave3Nack();\nbool MPU6050_getSlave2Nack();\nbool MPU6050_getSlave1Nack();\nbool MPU6050_getSlave0Nack();\n\n// INT_PIN_CFG register\nbool MPU6050_getInterruptMode();\nvoid MPU6050_setInterruptMode(bool mode);\nbool MPU6050_getInterruptDrive();\nvoid MPU6050_setInterruptDrive(bool drive);\nbool MPU6050_getInterruptLatch();\nvoid MPU6050_setInterruptLatch(bool latch);\nbool MPU6050_getInterruptLatchClear();\nvoid MPU6050_setInterruptLatchClear(bool clear);\nbool MPU6050_getFSyncInterruptLevel();\nvoid MPU6050_setFSyncInterruptLevel(bool level);\nbool MPU6050_getFSyncInterruptEnabled();\nvoid MPU6050_setFSyncInterruptEnabled(bool enabled);\nbool MPU6050_getI2CBypassEnabled();\nvoid MPU6050_setI2CBypassEnabled(bool enabled);\nbool MPU6050_getClockOutputEnabled();\nvoid MPU6050_setClockOutputEnabled(bool enabled);\n\n// INT_ENABLE register\nuint8_t MPU6050_getIntEnabled();\nvoid MPU6050_setIntEnabled(uint8_t enabled);\nbool MPU6050_getIntFreefallEnabled();\nvoid MPU6050_setIntFreefallEnabled(bool enabled);\nbool MPU6050_getIntMotionEnabled();\nvoid MPU6050_setIntMotionEnabled(bool enabled);\nbool MPU6050_getIntZeroMotionEnabled();\nvoid MPU6050_setIntZeroMotionEnabled(bool enabled);\nbool MPU6050_getIntFIFOBufferOverflowEnabled();\nvoid MPU6050_setIntFIFOBufferOverflowEnabled(bool enabled);\nbool MPU6050_getIntI2CMasterEnabled();\nvoid MPU6050_setIntI2CMasterEnabled(bool enabled);\nbool MPU6050_getIntDataReadyEnabled();\nvoid MPU6050_setIntDataReadyEnabled(bool enabled);\n\n// INT_STATUS register\nuint8_t MPU6050_getIntStatus();\nbool MPU6050_getIntFreefallStatus();\nbool MPU6050_getIntMotionStatus();\nbool MPU6050_getIntZeroMotionStatus();\nbool MPU6050_getIntFIFOBufferOverflowStatus();\nbool MPU6050_getIntI2CMasterStatus();\nbool MPU6050_getIntDataReadyStatus();\n\n// ACCEL_*OUT_* registers\nvoid MPU6050_getMotion9(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz, int16_t* mx, int16_t* my, int16_t* mz);\nvoid MPU6050_getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz);\nvoid MPU6050_getAcceleration(int16_t* x, int16_t* y, int16_t* z);\nint16_t MPU6050_getAccelerationX();\nint16_t MPU6050_getAccelerationY();\nint16_t MPU6050_getAccelerationZ();\n\n// TEMP_OUT_* registers\nint16_t MPU6050_getTemperature();\n\n// GYRO_*OUT_* registers\nvoid MPU6050_getRotation(int16_t* x, int16_t* y, int16_t* z);\nint16_t MPU6050_getRotationX();\nint16_t MPU6050_getRotationY();\nint16_t MPU6050_getRotationZ();\n\n// EXT_SENS_DATA_* registers\nuint8_t MPU6050_getExternalSensorByte(int position);\nuint16_t MPU6050_getExternalSensorWord(int position);\nuint32_t getExternalSensorDWord(int position);\n\n// MOT_DETECT_STATUS register\nbool MPU6050_getXNegMotionDetected();\nbool MPU6050_getXPosMotionDetected();\nbool MPU6050_getYNegMotionDetected();\nbool MPU6050_getYPosMotionDetected();\nbool MPU6050_getZNegMotionDetected();\nbool MPU6050_getZPosMotionDetected();\nbool MPU6050_getZeroMotionDetected();\n\n// I2C_SLV*_DO register\nvoid MPU6050_setSlaveOutputByte(uint8_t num, uint8_t data);\n\n// I2C_MST_DELAY_CTRL register\nbool MPU6050_getExternalShadowDelayEnabled();\nvoid MPU6050_setExternalShadowDelayEnabled(bool enabled);\nbool MPU6050_getSlaveDelayEnabled(uint8_t num);\nvoid MPU6050_setSlaveDelayEnabled(uint8_t num, bool enabled);\n\n// SIGNAL_PATH_RESET register\nvoid MPU6050_resetGyroscopePath();\nvoid MPU6050_resetAccelerometerPath();\nvoid MPU6050_resetTemperaturePath();\n\n// MOT_DETECT_CTRL register\nuint8_t MPU6050_getAccelerometerPowerOnDelay();\nvoid MPU6050_setAccelerometerPowerOnDelay(uint8_t delay);\nuint8_t MPU6050_getFreefallDetectionCounterDecrement();\nvoid MPU6050_setFreefallDetectionCounterDecrement(uint8_t decrement);\nuint8_t MPU6050_getMotionDetectionCounterDecrement();\nvoid MPU6050_setMotionDetectionCounterDecrement(uint8_t decrement);\n\n// USER_CTRL register\nbool MPU6050_getFIFOEnabled();\nvoid MPU6050_setFIFOEnabled(bool enabled);\nbool MPU6050_getI2CMasterModeEnabled();\nvoid MPU6050_setI2CMasterModeEnabled(bool enabled);\nvoid MPU6050_switchSPIEnabled(bool enabled);\nvoid MPU6050_resetFIFO();\nvoid MPU6050_resetI2CMaster();\nvoid MPU6050_resetSensors();\n\n// PWR_MGMT_1 register\nvoid MPU6050_reset();\nbool MPU6050_getSleepEnabled();\nvoid MPU6050_setSleepEnabled(bool enabled);\nbool MPU6050_getWakeCycleEnabled();\nvoid MPU6050_setWakeCycleEnabled(bool enabled);\nbool MPU6050_getTempSensorEnabled();\nvoid MPU6050_setTempSensorEnabled(bool enabled);\nuint8_t MPU6050_getClockSource();\nvoid MPU6050_setClockSource(uint8_t source);\n\n// PWR_MGMT_2 register\nuint8_t MPU6050_getWakeFrequency();\nvoid MPU6050_setWakeFrequency(uint8_t frequency);\nbool MPU6050_getStandbyXAccelEnabled();\nvoid MPU6050_setStandbyXAccelEnabled(bool enabled);\nbool MPU6050_getStandbyYAccelEnabled();\nvoid MPU6050_setStandbyYAccelEnabled(bool enabled);\nbool MPU6050_getStandbyZAccelEnabled();\nvoid MPU6050_setStandbyZAccelEnabled(bool enabled);\nbool MPU6050_getStandbyXGyroEnabled();\nvoid MPU6050_setStandbyXGyroEnabled(bool enabled);\nbool MPU6050_getStandbyYGyroEnabled();\nvoid MPU6050_setStandbyYGyroEnabled(bool enabled);\nbool MPU6050_getStandbyZGyroEnabled();\nvoid MPU6050_setStandbyZGyroEnabled(bool enabled);\n\n// FIFO_COUNT_* registers\nuint16_t MPU6050_getFIFOCount();\n\n// FIFO_R_W register\nuint8_t MPU6050_getFIFOByte();\nvoid MPU6050_setFIFOByte(uint8_t data);\nvoid MPU6050_getFIFOBytes(uint8_t *data, uint8_t length);\n\n// WHO_AM_I register\nuint8_t MPU6050_getDeviceID();\nvoid MPU6050_setDeviceID(uint8_t id);\n\n// ======== UNDOCUMENTED/DMP REGISTERS/METHODS ========\n\n// XG_OFFS_TC register\nuint8_t MPU6050_getOTPBankValid();\nvoid MPU6050_setOTPBankValid(bool enabled);\nint8_t getXGyroOffsetTC();\nvoid MPU6050_setXGyroOffsetTC(int8_t offset);\n\n// YG_OFFS_TC register\nint8_t getYGyroOffsetTC();\nvoid MPU6050_setYGyroOffsetTC(int8_t offset);\n\n// ZG_OFFS_TC register\nint8_t getZGyroOffsetTC();\nvoid MPU6050_setZGyroOffsetTC(int8_t offset);\n\n// X_FINE_GAIN register\nint8_t getXFineGain();\nvoid MPU6050_setXFineGain(int8_t gain);\n\n// Y_FINE_GAIN register\nint8_t getYFineGain();\nvoid MPU6050_setYFineGain(int8_t gain);\n\n// Z_FINE_GAIN register\nint8_t getZFineGain();\nvoid MPU6050_setZFineGain(int8_t gain);\n\n// XA_OFFS_* registers\nint16_t MPU6050_getXAccelOffset();\nvoid MPU6050_setXAccelOffset(int16_t offset);\n\n// YA_OFFS_* register\nint16_t MPU6050_getYAccelOffset();\nvoid MPU6050_setYAccelOffset(int16_t offset);\n\n// ZA_OFFS_* register\nint16_t MPU6050_getZAccelOffset();\nvoid MPU6050_setZAccelOffset(int16_t offset);\n\n// XG_OFFS_USR* registers\nint16_t MPU6050_getXGyroOffset();\nvoid MPU6050_setXGyroOffset(int16_t offset);\n\n// YG_OFFS_USR* register\nint16_t MPU6050_getYGyroOffset();\nvoid MPU6050_setYGyroOffset(int16_t offset);\n\n// ZG_OFFS_USR* register\nint16_t MPU6050_getZGyroOffset();\nvoid MPU6050_setZGyroOffset(int16_t offset);\n\n// INT_ENABLE register (DMP functions)\nbool MPU6050_getIntPLLReadyEnabled();\nvoid MPU6050_setIntPLLReadyEnabled(bool enabled);\nbool MPU6050_getIntDMPEnabled();\nvoid MPU6050_setIntDMPEnabled(bool enabled);\n\n// DMP_INT_STATUS\nbool MPU6050_getDMPInt5Status();\nbool MPU6050_getDMPInt4Status();\nbool MPU6050_getDMPInt3Status();\nbool MPU6050_getDMPInt2Status();\nbool MPU6050_getDMPInt1Status();\nbool MPU6050_getDMPInt0Status();\n\n// INT_STATUS register (DMP functions)\nbool MPU6050_getIntPLLReadyStatus();\nbool MPU6050_getIntDMPStatus();\n\n// USER_CTRL register (DMP functions)\nbool MPU6050_getDMPEnabled();\nvoid MPU6050_setDMPEnabled(bool enabled);\nvoid MPU6050_resetDMP();\n\n// BANK_SEL register\nvoid MPU6050_setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank);\n\n// MEM_START_ADDR register\nvoid MPU6050_setMemoryStartAddress(uint8_t address);\n\n// MEM_R_W register\nuint8_t MPU6050_readMemoryByte();\nvoid MPU6050_writeMemoryByte(uint8_t data);\nvoid MPU6050_readMemoryBlock(uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address);\n//bool MPU6050_writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem);\n//bool MPU6050_writeProgMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify);\n\n//bool MPU6050_writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize, bool useProgMem);\n//bool MPU6050_writeProgDMPConfigurationSet(const uint8_t *data, uint16_t dataSize);\n\n// DMP_CFG_1 register\nuint8_t MPU6050_getDMPConfig1();\nvoid MPU6050_setDMPConfig1(uint8_t config);\n\n// DMP_CFG_2 register\nuint8_t MPU6050_getDMPConfig2();\nvoid MPU6050_setDMPConfig2(uint8_t config);\n\n#endif /* _MPU6050_H_ */\n</code></pre>"},{"location":"stm/MpuController_8hpp/","title":"File MpuController.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; MpuController.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"I2cController.hpp\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> <li><code>#include &lt;stdbool.h&gt;</code></li> </ul>"},{"location":"stm/MpuController_8hpp/#classes","title":"Classes","text":"Type Name struct mpu_t"},{"location":"stm/MpuController_8hpp/#public-types","title":"Public Types","text":"Type Name typedef struct mpu_t mpu_t"},{"location":"stm/MpuController_8hpp/#public-functions","title":"Public Functions","text":"Type Name uint32_t getExternalSensorDWord (int position)  int8_t getXFineGain ()  int8_t getXGyroOffsetTC ()  int8_t getYFineGain ()  int8_t getYGyroOffsetTC ()  int8_t getZFineGain ()  int8_t getZGyroOffsetTC ()  void mpuCreate ()  void mpuDispatch (const CoprocReq_MpuReq &amp; request)  void mpuInitialize ()  void mpuReset ()  void mpuTick ()  bool mpu_getAccelFIFOEnabled ()  bool mpu_getAccelXSelfTest ()  bool mpu_getAccelYSelfTest ()  bool mpu_getAccelZSelfTest ()  void mpu_getAcceleration (int16_t * x, int16_t * y, int16_t * z)  int16_t mpu_getAccelerationX ()  int16_t mpu_getAccelerationY ()  int16_t mpu_getAccelerationZ ()  uint8_t mpu_getAccelerometerPowerOnDelay ()  uint8_t mpu_getAuxVDDIOLevel ()  bool mpu_getClockOutputEnabled ()  uint8_t mpu_getClockSource ()  uint8_t mpu_getDHPFMode ()  uint8_t mpu_getDLPFMode ()  uint8_t mpu_getDMPConfig1 ()  uint8_t mpu_getDMPConfig2 ()  bool mpu_getDMPEnabled ()  bool mpu_getDMPInt0Status ()  bool mpu_getDMPInt1Status ()  bool mpu_getDMPInt2Status ()  bool mpu_getDMPInt3Status ()  bool mpu_getDMPInt4Status ()  bool mpu_getDMPInt5Status ()  uint8_t mpu_getDeviceID ()  uint8_t mpu_getExternalFrameSync ()  uint8_t mpu_getExternalSensorByte (int position)  uint16_t mpu_getExternalSensorWord (int position)  bool mpu_getExternalShadowDelayEnabled ()  uint8_t mpu_getFIFOByte ()  void mpu_getFIFOBytes (uint8_t * data, uint8_t length)  uint16_t mpu_getFIFOCount ()  bool mpu_getFIFOEnabled ()  bool mpu_getFSyncInterruptEnabled ()  bool mpu_getFSyncInterruptLevel ()  uint8_t mpu_getFreefallDetectionCounterDecrement ()  uint8_t mpu_getFreefallDetectionDuration ()  uint8_t mpu_getFreefallDetectionThreshold ()  uint8_t mpu_getFullScaleAccelRange ()  uint8_t mpu_getFullScaleGyroRange ()  bool mpu_getI2CBypassEnabled ()  bool mpu_getI2CMasterModeEnabled ()  bool mpu_getIntDMPEnabled ()  bool mpu_getIntDMPStatus ()  bool mpu_getIntDataReadyEnabled ()  bool mpu_getIntDataReadyStatus ()  uint8_t mpu_getIntEnabled ()  bool mpu_getIntFIFOBufferOverflowEnabled ()  bool mpu_getIntFIFOBufferOverflowStatus ()  bool mpu_getIntFreefallEnabled ()  bool mpu_getIntFreefallStatus ()  bool mpu_getIntI2CMasterEnabled ()  bool mpu_getIntI2CMasterStatus ()  bool mpu_getIntMotionEnabled ()  bool mpu_getIntMotionStatus ()  bool mpu_getIntPLLReadyEnabled ()  bool mpu_getIntPLLReadyStatus ()  uint8_t mpu_getIntStatus ()  bool mpu_getIntZeroMotionEnabled ()  bool mpu_getIntZeroMotionStatus ()  bool mpu_getInterruptDrive ()  bool mpu_getInterruptLatch ()  bool mpu_getInterruptLatchClear ()  bool mpu_getInterruptMode ()  bool mpu_getLostArbitration ()  uint8_t mpu_getMasterClockSpeed ()  void mpu_getMotion6 (int16_t * ax, int16_t * ay, int16_t * az, int16_t * gx, int16_t * gy, int16_t * gz)  void mpu_getMotion9 (int16_t * ax, int16_t * ay, int16_t * az, int16_t * gx, int16_t * gy, int16_t * gz, int16_t * mx, int16_t * my, int16_t * mz)  uint8_t mpu_getMotionDetectionCounterDecrement ()  uint8_t mpu_getMotionDetectionDuration ()  uint8_t mpu_getMotionDetectionThreshold ()  bool mpu_getMultiMasterEnabled ()  uint8_t mpu_getOTPBankValid ()  bool mpu_getPassthroughStatus ()  uint8_t mpu_getRate ()  void mpu_getRotation (int16_t * x, int16_t * y, int16_t * z)  int16_t mpu_getRotationX ()  int16_t mpu_getRotationY ()  int16_t mpu_getRotationZ ()  uint8_t mpu_getSlate4InputByte ()  bool mpu_getSlave0FIFOEnabled ()  bool mpu_getSlave0Nack ()  bool mpu_getSlave1FIFOEnabled ()  bool mpu_getSlave1Nack ()  bool mpu_getSlave2FIFOEnabled ()  bool mpu_getSlave2Nack ()  bool mpu_getSlave3FIFOEnabled ()  bool mpu_getSlave3Nack ()  uint8_t mpu_getSlave4Address ()  bool mpu_getSlave4Enabled ()  bool mpu_getSlave4InterruptEnabled ()  bool mpu_getSlave4IsDone ()  uint8_t mpu_getSlave4MasterDelay ()  bool mpu_getSlave4Nack ()  uint8_t mpu_getSlave4Register ()  bool mpu_getSlave4WriteMode ()  uint8_t mpu_getSlaveAddress (uint8_t num)  uint8_t mpu_getSlaveDataLength (uint8_t num)  bool mpu_getSlaveDelayEnabled (uint8_t num)  bool mpu_getSlaveEnabled (uint8_t num)  bool mpu_getSlaveReadWriteTransitionEnabled ()  uint8_t mpu_getSlaveRegister (uint8_t num)  bool mpu_getSlaveWordByteSwap (uint8_t num)  bool mpu_getSlaveWordGroupOffset (uint8_t num)  bool mpu_getSlaveWriteMode (uint8_t num)  bool mpu_getSleepEnabled ()  bool mpu_getStandbyXAccelEnabled ()  bool mpu_getStandbyXGyroEnabled ()  bool mpu_getStandbyYAccelEnabled ()  bool mpu_getStandbyYGyroEnabled ()  bool mpu_getStandbyZAccelEnabled ()  bool mpu_getStandbyZGyroEnabled ()  bool mpu_getTempFIFOEnabled ()  bool mpu_getTempSensorEnabled ()  int16_t mpu_getTemperature ()  bool mpu_getWaitForExternalSensorEnabled ()  bool mpu_getWakeCycleEnabled ()  uint8_t mpu_getWakeFrequency ()  int16_t mpu_getXAccelOffset ()  bool mpu_getXGyroFIFOEnabled ()  int16_t mpu_getXGyroOffset ()  bool mpu_getXNegMotionDetected ()  bool mpu_getXPosMotionDetected ()  int16_t mpu_getYAccelOffset ()  bool mpu_getYGyroFIFOEnabled ()  int16_t mpu_getYGyroOffset ()  bool mpu_getYNegMotionDetected ()  bool mpu_getYPosMotionDetected ()  int16_t mpu_getZAccelOffset ()  bool mpu_getZGyroFIFOEnabled ()  int16_t mpu_getZGyroOffset ()  bool mpu_getZNegMotionDetected ()  bool mpu_getZPosMotionDetected ()  bool mpu_getZeroMotionDetected ()  uint8_t mpu_getZeroMotionDetectionDuration ()  uint8_t mpu_getZeroMotionDetectionThreshold ()  void mpu_readMemoryBlock (uint8_t * data, uint16_t dataSize, uint8_t bank, uint8_t address)  uint8_t mpu_readMemoryByte ()  void mpu_reset ()  void mpu_resetAccelerometerPath ()  void mpu_resetDMP ()  void mpu_resetFIFO ()  void mpu_resetGyroscopePath ()  void mpu_resetI2CMaster ()  void mpu_resetSensors ()  void mpu_resetTemperaturePath ()  void mpu_setAccelFIFOEnabled (bool enabled)  void mpu_setAccelXSelfTest (bool enabled)  void mpu_setAccelYSelfTest (bool enabled)  void mpu_setAccelZSelfTest (bool enabled)  void mpu_setAccelerometerPowerOnDelay (uint8_t delay)  void mpu_setAuxVDDIOLevel (uint8_t level)  void mpu_setClockOutputEnabled (bool enabled)  void mpu_setClockSource (uint8_t source)  void mpu_setDHPFMode (uint8_t mode)  void mpu_setDLPFMode (uint8_t bandwidth)  void mpu_setDMPConfig1 (uint8_t config)  void mpu_setDMPConfig2 (uint8_t config)  void mpu_setDMPEnabled (bool enabled)  void mpu_setDeviceID (uint8_t id)  void mpu_setExternalFrameSync (uint8_t sync)  void mpu_setExternalShadowDelayEnabled (bool enabled)  void mpu_setFIFOByte (uint8_t data)  void mpu_setFIFOEnabled (bool enabled)  void mpu_setFSyncInterruptEnabled (bool enabled)  void mpu_setFSyncInterruptLevel (bool level)  void mpu_setFreefallDetectionCounterDecrement (uint8_t decrement)  void mpu_setFreefallDetectionDuration (uint8_t duration)  void mpu_setFreefallDetectionThreshold (uint8_t threshold)  void mpu_setFullScaleAccelRange (uint8_t range)  void mpu_setFullScaleGyroRange (uint8_t range)  void mpu_setI2CBypassEnabled (bool enabled)  void mpu_setI2CMasterModeEnabled (bool enabled)  void mpu_setIntDMPEnabled (bool enabled)  void mpu_setIntDataReadyEnabled (bool enabled)  void mpu_setIntEnabled (uint8_t enabled)  void mpu_setIntFIFOBufferOverflowEnabled (bool enabled)  void mpu_setIntFreefallEnabled (bool enabled)  void mpu_setIntI2CMasterEnabled (bool enabled)  void mpu_setIntMotionEnabled (bool enabled)  void mpu_setIntPLLReadyEnabled (bool enabled)  void mpu_setIntZeroMotionEnabled (bool enabled)  void mpu_setInterruptDrive (bool drive)  void mpu_setInterruptLatch (bool latch)  void mpu_setInterruptLatchClear (bool clear)  void mpu_setInterruptMode (bool mode)  void mpu_setMasterClockSpeed (uint8_t speed)  void mpu_setMemoryBank (uint8_t bank, bool prefetchEnabled, bool userBank)  void mpu_setMemoryStartAddress (uint8_t address)  void mpu_setMotionDetectionCounterDecrement (uint8_t decrement)  void mpu_setMotionDetectionDuration (uint8_t duration)  void mpu_setMotionDetectionThreshold (uint8_t threshold)  void mpu_setMultiMasterEnabled (bool enabled)  void mpu_setOTPBankValid (bool enabled)  void mpu_setRate (uint8_t rate)  void mpu_setSlave0FIFOEnabled (bool enabled)  void mpu_setSlave1FIFOEnabled (bool enabled)  void mpu_setSlave2FIFOEnabled (bool enabled)  void mpu_setSlave3FIFOEnabled (bool enabled)  void mpu_setSlave4Address (uint8_t address)  void mpu_setSlave4Enabled (bool enabled)  void mpu_setSlave4InterruptEnabled (bool enabled)  void mpu_setSlave4MasterDelay (uint8_t delay)  void mpu_setSlave4OutputByte (uint8_t data)  void mpu_setSlave4Register (uint8_t reg)  void mpu_setSlave4WriteMode (bool mode)  void mpu_setSlaveAddress (uint8_t num, uint8_t address)  void mpu_setSlaveDataLength (uint8_t num, uint8_t length)  void mpu_setSlaveDelayEnabled (uint8_t num, bool enabled)  void mpu_setSlaveEnabled (uint8_t num, bool enabled)  void mpu_setSlaveOutputByte (uint8_t num, uint8_t data)  void mpu_setSlaveReadWriteTransitionEnabled (bool enabled)  void mpu_setSlaveRegister (uint8_t num, uint8_t reg)  void mpu_setSlaveWordByteSwap (uint8_t num, bool enabled)  void mpu_setSlaveWordGroupOffset (uint8_t num, bool enabled)  void mpu_setSlaveWriteMode (uint8_t num, bool mode)  void mpu_setSleepEnabled (bool enabled)  void mpu_setStandbyXAccelEnabled (bool enabled)  void mpu_setStandbyXGyroEnabled (bool enabled)  void mpu_setStandbyYAccelEnabled (bool enabled)  void mpu_setStandbyYGyroEnabled (bool enabled)  void mpu_setStandbyZAccelEnabled (bool enabled)  void mpu_setStandbyZGyroEnabled (bool enabled)  void mpu_setTempFIFOEnabled (bool enabled)  void mpu_setTempSensorEnabled (bool enabled)  void mpu_setWaitForExternalSensorEnabled (bool enabled)  void mpu_setWakeCycleEnabled (bool enabled)  void mpu_setWakeFrequency (uint8_t frequency)  void mpu_setXAccelOffset (int16_t offset)  void mpu_setXFineGain (int8_t gain)  void mpu_setXGyroFIFOEnabled (bool enabled)  void mpu_setXGyroOffset (int16_t offset)  void mpu_setXGyroOffsetTC (int8_t offset)  void mpu_setYAccelOffset (int16_t offset)  void mpu_setYFineGain (int8_t gain)  void mpu_setYGyroFIFOEnabled (bool enabled)  void mpu_setYGyroOffset (int16_t offset)  void mpu_setYGyroOffsetTC (int8_t offset)  void mpu_setZAccelOffset (int16_t offset)  void mpu_setZFineGain (int8_t gain)  void mpu_setZGyroFIFOEnabled (bool enabled)  void mpu_setZGyroOffset (int16_t offset)  void mpu_setZGyroOffsetTC (int8_t offset)  void mpu_setZeroMotionDetectionDuration (uint8_t duration)  void mpu_setZeroMotionDetectionThreshold (uint8_t threshold)  void mpu_switchSPIEnabled (bool enabled)  bool mpu_testConnection ()  void mpu_writeMemoryByte (uint8_t data)"},{"location":"stm/MpuController_8hpp/#macros","title":"Macros","text":"Type Name define mpu_ACCEL_FIFO_EN_BIT  3 define mpu_ACCEL_FS_16  0x03 define mpu_ACCEL_FS_2  0x00 define mpu_ACCEL_FS_4  0x01 define mpu_ACCEL_FS_8  0x02 define mpu_ACONFIG_ACCEL_HPF_BIT  2 define mpu_ACONFIG_ACCEL_HPF_LENGTH  3 define mpu_ACONFIG_AFS_SEL_BIT  4 define mpu_ACONFIG_AFS_SEL_LENGTH  2 define mpu_ACONFIG_XA_ST_BIT  7 define mpu_ACONFIG_YA_ST_BIT  6 define mpu_ACONFIG_ZA_ST_BIT  5 define mpu_ADDRESS_AD0_HIGH  0x69 define mpu_ADDRESS_AD0_LOW      0x68 define mpu_BANKSEL_CFG_USER_BANK_BIT  5 define mpu_BANKSEL_MEM_SEL_BIT  4 define mpu_BANKSEL_MEM_SEL_LENGTH  5 define mpu_BANKSEL_PRFTCH_EN_BIT  6 define mpu_CFG_DLPF_CFG_BIT  2 define mpu_CFG_DLPF_CFG_LENGTH  3 define mpu_CFG_EXT_SYNC_SET_BIT  5 define mpu_CFG_EXT_SYNC_SET_LENGTH  3 define mpu_CLOCK_DIV_258  0x8 define mpu_CLOCK_DIV_267  0x7 define mpu_CLOCK_DIV_276  0x6 define mpu_CLOCK_DIV_286  0x5 define mpu_CLOCK_DIV_296  0x4 define mpu_CLOCK_DIV_308  0x3 define mpu_CLOCK_DIV_320  0x2 define mpu_CLOCK_DIV_333  0x1 define mpu_CLOCK_DIV_348  0x0 define mpu_CLOCK_DIV_364  0xF define mpu_CLOCK_DIV_381  0xE define mpu_CLOCK_DIV_400  0xD define mpu_CLOCK_DIV_421  0xC define mpu_CLOCK_DIV_444  0xB define mpu_CLOCK_DIV_471  0xA define mpu_CLOCK_DIV_500  0x9 define mpu_CLOCK_INTERNAL  0x00 define mpu_CLOCK_KEEP_RESET  0x07 define mpu_CLOCK_PLL_EXT19M  0x05 define mpu_CLOCK_PLL_EXT32K  0x04 define mpu_CLOCK_PLL_XGYRO  0x01 define mpu_CLOCK_PLL_YGYRO  0x02 define mpu_CLOCK_PLL_ZGYRO  0x03 define mpu_DEFAULT_ADDRESS  mpu_ADDRESS_AD0_LOW define mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT  7 define mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT  0 define mpu_DELAYCTRL_I2C_SLV1_DLY_EN_BIT  1 define mpu_DELAYCTRL_I2C_SLV2_DLY_EN_BIT  2 define mpu_DELAYCTRL_I2C_SLV3_DLY_EN_BIT  3 define mpu_DELAYCTRL_I2C_SLV4_DLY_EN_BIT  4 define mpu_DETECT_ACCEL_ON_DELAY_BIT  5 define mpu_DETECT_ACCEL_ON_DELAY_LENGTH  2 define mpu_DETECT_DECREMENT_1  0x1 define mpu_DETECT_DECREMENT_2  0x2 define mpu_DETECT_DECREMENT_4  0x3 define mpu_DETECT_DECREMENT_RESET  0x0 define mpu_DETECT_FF_COUNT_BIT  3 define mpu_DETECT_FF_COUNT_LENGTH  2 define mpu_DETECT_MOT_COUNT_BIT  1 define mpu_DETECT_MOT_COUNT_LENGTH  2 define mpu_DHPF_0P63  0x04 define mpu_DHPF_1P25  0x03 define mpu_DHPF_2P5  0x02 define mpu_DHPF_5  0x01 define mpu_DHPF_HOLD  0x07 define mpu_DHPF_RESET  0x00 define mpu_DLPF_BW_10  0x05 define mpu_DLPF_BW_188  0x01 define mpu_DLPF_BW_20  0x04 define mpu_DLPF_BW_256  0x00 define mpu_DLPF_BW_42  0x03 define mpu_DLPF_BW_5  0x06 define mpu_DLPF_BW_98  0x02 define mpu_DMPINT_0_BIT  0 define mpu_DMPINT_1_BIT  1 define mpu_DMPINT_2_BIT  2 define mpu_DMPINT_3_BIT  3 define mpu_DMPINT_4_BIT  4 define mpu_DMPINT_5_BIT  5 define mpu_DMP_MEMORY_BANKS  8 define mpu_DMP_MEMORY_BANK_SIZE  256 define mpu_DMP_MEMORY_CHUNK_SIZE  16 define mpu_EXT_SYNC_ACCEL_XOUT_L  0x5 define mpu_EXT_SYNC_ACCEL_YOUT_L  0x6 define mpu_EXT_SYNC_ACCEL_ZOUT_L  0x7 define mpu_EXT_SYNC_DISABLED  0x0 define mpu_EXT_SYNC_GYRO_XOUT_L  0x2 define mpu_EXT_SYNC_GYRO_YOUT_L  0x3 define mpu_EXT_SYNC_GYRO_ZOUT_L  0x4 define mpu_EXT_SYNC_TEMP_OUT_L  0x1 define mpu_GCONFIG_FS_SEL_BIT  4 define mpu_GCONFIG_FS_SEL_LENGTH  2 define mpu_GYRO_FS_1000  0x02 define mpu_GYRO_FS_2000  0x03 define mpu_GYRO_FS_250  0x00 define mpu_GYRO_FS_500  0x01 define mpu_I2C_MST_CLK_BIT  3 define mpu_I2C_MST_CLK_LENGTH  4 define mpu_I2C_MST_P_NSR_BIT  4 define mpu_I2C_SLV4_ADDR_BIT  6 define mpu_I2C_SLV4_ADDR_LENGTH  7 define mpu_I2C_SLV4_EN_BIT  7 define mpu_I2C_SLV4_INT_EN_BIT  6 define mpu_I2C_SLV4_MST_DLY_BIT  4 define mpu_I2C_SLV4_MST_DLY_LENGTH  5 define mpu_I2C_SLV4_REG_DIS_BIT  5 define mpu_I2C_SLV4_RW_BIT  7 define mpu_I2C_SLV_ADDR_BIT  6 define mpu_I2C_SLV_ADDR_LENGTH  7 define mpu_I2C_SLV_BYTE_SW_BIT  6 define mpu_I2C_SLV_EN_BIT  7 define mpu_I2C_SLV_GRP_BIT  4 define mpu_I2C_SLV_LEN_BIT  3 define mpu_I2C_SLV_LEN_LENGTH  4 define mpu_I2C_SLV_REG_DIS_BIT  5 define mpu_I2C_SLV_RW_BIT  7 define mpu_INTCFG_CLKOUT_EN_BIT  0 define mpu_INTCFG_FSYNC_INT_EN_BIT  2 define mpu_INTCFG_FSYNC_INT_LEVEL_BIT  3 define mpu_INTCFG_I2C_BYPASS_EN_BIT  1 define mpu_INTCFG_INT_LEVEL_BIT  7 define mpu_INTCFG_INT_OPEN_BIT  6 define mpu_INTCFG_INT_RD_CLEAR_BIT  4 define mpu_INTCFG_LATCH_INT_EN_BIT  5 define mpu_INTCLEAR_ANYREAD  0x01 define mpu_INTCLEAR_STATUSREAD  0x00 define mpu_INTDRV_OPENDRAIN  0x01 define mpu_INTDRV_PUSHPULL  0x00 define mpu_INTERRUPT_DATA_RDY_BIT  0 define mpu_INTERRUPT_DMP_INT_BIT  1 define mpu_INTERRUPT_FF_BIT  7 define mpu_INTERRUPT_FIFO_OFLOW_BIT  4 define mpu_INTERRUPT_I2C_MST_INT_BIT  3 define mpu_INTERRUPT_MOT_BIT  6 define mpu_INTERRUPT_PLL_RDY_INT_BIT  2 define mpu_INTERRUPT_ZMOT_BIT  5 define mpu_INTLATCH_50USPULSE  0x00 define mpu_INTLATCH_WAITCLEAR  0x01 define mpu_INTMODE_ACTIVEHIGH  0x00 define mpu_INTMODE_ACTIVELOW  0x01 define mpu_MOTION_MOT_XNEG_BIT  7 define mpu_MOTION_MOT_XPOS_BIT  6 define mpu_MOTION_MOT_YNEG_BIT  5 define mpu_MOTION_MOT_YPOS_BIT  4 define mpu_MOTION_MOT_ZNEG_BIT  3 define mpu_MOTION_MOT_ZPOS_BIT  2 define mpu_MOTION_MOT_ZRMOT_BIT  0 define mpu_MST_I2C_LOST_ARB_BIT  5 define mpu_MST_I2C_SLV0_NACK_BIT  0 define mpu_MST_I2C_SLV1_NACK_BIT  1 define mpu_MST_I2C_SLV2_NACK_BIT  2 define mpu_MST_I2C_SLV3_NACK_BIT  3 define mpu_MST_I2C_SLV4_DONE_BIT  6 define mpu_MST_I2C_SLV4_NACK_BIT  4 define mpu_MST_PASS_THROUGH_BIT  7 define mpu_MULT_MST_EN_BIT  7 define mpu_PATHRESET_ACCEL_RESET_BIT  1 define mpu_PATHRESET_GYRO_RESET_BIT  2 define mpu_PATHRESET_TEMP_RESET_BIT  0 define mpu_PWR1_CLKSEL_BIT  2 define mpu_PWR1_CLKSEL_LENGTH  3 define mpu_PWR1_CYCLE_BIT  5 define mpu_PWR1_DEVICE_RESET_BIT  7 define mpu_PWR1_SLEEP_BIT  6 define mpu_PWR1_TEMP_DIS_BIT  3 define mpu_PWR2_LP_WAKE_CTRL_BIT  7 define mpu_PWR2_LP_WAKE_CTRL_LENGTH  2 define mpu_PWR2_STBY_XA_BIT  5 define mpu_PWR2_STBY_XG_BIT  2 define mpu_PWR2_STBY_YA_BIT  4 define mpu_PWR2_STBY_YG_BIT  1 define mpu_PWR2_STBY_ZA_BIT  3 define mpu_PWR2_STBY_ZG_BIT  0 define mpu_RA_ACCEL_CONFIG  0x1C define mpu_RA_ACCEL_XOUT_H  0x3B define mpu_RA_ACCEL_XOUT_L  0x3C define mpu_RA_ACCEL_YOUT_H  0x3D define mpu_RA_ACCEL_YOUT_L  0x3E define mpu_RA_ACCEL_ZOUT_H  0x3F define mpu_RA_ACCEL_ZOUT_L  0x40 define mpu_RA_BANK_SEL  0x6D define mpu_RA_CONFIG  0x1A define mpu_RA_DMP_CFG_1  0x70 define mpu_RA_DMP_CFG_2  0x71 define mpu_RA_DMP_INT_STATUS  0x39 define mpu_RA_EXT_SENS_DATA_00  0x49 define mpu_RA_EXT_SENS_DATA_01  0x4A define mpu_RA_EXT_SENS_DATA_02  0x4B define mpu_RA_EXT_SENS_DATA_03  0x4C define mpu_RA_EXT_SENS_DATA_04  0x4D define mpu_RA_EXT_SENS_DATA_05  0x4E define mpu_RA_EXT_SENS_DATA_06  0x4F define mpu_RA_EXT_SENS_DATA_07  0x50 define mpu_RA_EXT_SENS_DATA_08  0x51 define mpu_RA_EXT_SENS_DATA_09  0x52 define mpu_RA_EXT_SENS_DATA_10  0x53 define mpu_RA_EXT_SENS_DATA_11  0x54 define mpu_RA_EXT_SENS_DATA_12  0x55 define mpu_RA_EXT_SENS_DATA_13  0x56 define mpu_RA_EXT_SENS_DATA_14  0x57 define mpu_RA_EXT_SENS_DATA_15  0x58 define mpu_RA_EXT_SENS_DATA_16  0x59 define mpu_RA_EXT_SENS_DATA_17  0x5A define mpu_RA_EXT_SENS_DATA_18  0x5B define mpu_RA_EXT_SENS_DATA_19  0x5C define mpu_RA_EXT_SENS_DATA_20  0x5D define mpu_RA_EXT_SENS_DATA_21  0x5E define mpu_RA_EXT_SENS_DATA_22  0x5F define mpu_RA_EXT_SENS_DATA_23  0x60 define mpu_RA_FF_DUR  0x1E define mpu_RA_FF_THR  0x1D define mpu_RA_FIFO_COUNTH  0x72 define mpu_RA_FIFO_COUNTL  0x73 define mpu_RA_FIFO_EN  0x23 define mpu_RA_FIFO_R_W  0x74 define mpu_RA_GYRO_CONFIG  0x1B define mpu_RA_GYRO_XOUT_H  0x43 define mpu_RA_GYRO_XOUT_L  0x44 define mpu_RA_GYRO_YOUT_H  0x45 define mpu_RA_GYRO_YOUT_L  0x46 define mpu_RA_GYRO_ZOUT_H  0x47 define mpu_RA_GYRO_ZOUT_L  0x48 define mpu_RA_I2C_MST_CTRL  0x24 define mpu_RA_I2C_MST_DELAY_CTRL  0x67 define mpu_RA_I2C_MST_STATUS  0x36 define mpu_RA_I2C_SLV0_ADDR  0x25 define mpu_RA_I2C_SLV0_CTRL  0x27 define mpu_RA_I2C_SLV0_DO  0x63 define mpu_RA_I2C_SLV0_REG  0x26 define mpu_RA_I2C_SLV1_ADDR  0x28 define mpu_RA_I2C_SLV1_CTRL  0x2A define mpu_RA_I2C_SLV1_DO  0x64 define mpu_RA_I2C_SLV1_REG  0x29 define mpu_RA_I2C_SLV2_ADDR  0x2B define mpu_RA_I2C_SLV2_CTRL  0x2D define mpu_RA_I2C_SLV2_DO  0x65 define mpu_RA_I2C_SLV2_REG  0x2C define mpu_RA_I2C_SLV3_ADDR  0x2E define mpu_RA_I2C_SLV3_CTRL  0x30 define mpu_RA_I2C_SLV3_DO  0x66 define mpu_RA_I2C_SLV3_REG  0x2F define mpu_RA_I2C_SLV4_ADDR  0x31 define mpu_RA_I2C_SLV4_CTRL  0x34 define mpu_RA_I2C_SLV4_DI  0x35 define mpu_RA_I2C_SLV4_DO  0x33 define mpu_RA_I2C_SLV4_REG  0x32 define mpu_RA_INT_ENABLE  0x38 define mpu_RA_INT_PIN_CFG  0x37 define mpu_RA_INT_STATUS  0x3A define mpu_RA_MEM_R_W  0x6F define mpu_RA_MEM_START_ADDR  0x6E define mpu_RA_MOT_DETECT_CTRL  0x69 define mpu_RA_MOT_DETECT_STATUS  0x61 define mpu_RA_MOT_DUR  0x20 define mpu_RA_MOT_THR  0x1F define mpu_RA_PWR_MGMT_1  0x6B define mpu_RA_PWR_MGMT_2  0x6C define mpu_RA_SIGNAL_PATH_RESET  0x68 define mpu_RA_SMPLRT_DIV  0x19 define mpu_RA_TEMP_OUT_H  0x41 define mpu_RA_TEMP_OUT_L  0x42 define mpu_RA_USER_CTRL  0x6A define mpu_RA_WHO_AM_I  0x75 define mpu_RA_XA_OFFS_H  0x06 define mpu_RA_XA_OFFS_L_TC  0x07 define mpu_RA_XG_OFFS_TC  0x00 define mpu_RA_XG_OFFS_USRH  0x13 define mpu_RA_XG_OFFS_USRL  0x14 define mpu_RA_X_FINE_GAIN  0x03 define mpu_RA_YA_OFFS_H  0x08 define mpu_RA_YA_OFFS_L_TC  0x09 define mpu_RA_YG_OFFS_TC  0x01 define mpu_RA_YG_OFFS_USRH  0x15 define mpu_RA_YG_OFFS_USRL  0x16 define mpu_RA_Y_FINE_GAIN  0x04 define mpu_RA_ZA_OFFS_H  0x0A define mpu_RA_ZA_OFFS_L_TC  0x0B define mpu_RA_ZG_OFFS_TC  0x02 define mpu_RA_ZG_OFFS_USRH  0x17 define mpu_RA_ZG_OFFS_USRL  0x18 define mpu_RA_ZRMOT_DUR  0x22 define mpu_RA_ZRMOT_THR  0x21 define mpu_RA_Z_FINE_GAIN  0x05 define mpu_SLV0_FIFO_EN_BIT  0 define mpu_SLV1_FIFO_EN_BIT  1 define mpu_SLV2_FIFO_EN_BIT  2 define mpu_SLV_3_FIFO_EN_BIT  5 define mpu_TC_OFFSET_BIT  6 define mpu_TC_OFFSET_LENGTH  6 define mpu_TC_OTP_BNK_VLD_BIT  0 define mpu_TC_PWR_MODE_BIT  7 define mpu_TEMP_FIFO_EN_BIT  7 define mpu_USERCTRL_DMP_EN_BIT  7 define mpu_USERCTRL_DMP_RESET_BIT  3 define mpu_USERCTRL_FIFO_EN_BIT  6 define mpu_USERCTRL_FIFO_RESET_BIT  2 define mpu_USERCTRL_I2C_IF_DIS_BIT  4 define mpu_USERCTRL_I2C_MST_EN_BIT  5 define mpu_USERCTRL_I2C_MST_RESET_BIT  1 define mpu_USERCTRL_SIG_COND_RESET_BIT  0 define mpu_VDDIO_LEVEL_VDD  1 define mpu_VDDIO_LEVEL_VLOGIC  0 define mpu_WAIT_FOR_ES_BIT  6 define mpu_WAKE_FREQ_10  0x3 define mpu_WAKE_FREQ_1P25  0x0 define mpu_WAKE_FREQ_2P5  0x1 define mpu_WAKE_FREQ_5  0x2 define mpu_WHO_AM_I_BIT  6 define mpu_WHO_AM_I_LENGTH  6 define mpu_XG_FIFO_EN_BIT  6 define mpu_YG_FIFO_EN_BIT  5 define mpu_ZG_FIFO_EN_BIT  4"},{"location":"stm/MpuController_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"stm/MpuController_8hpp/#typedef-mpu_t","title":"typedef mpu_t","text":"<pre><code>typedef struct mpu_t mpu_t;\n</code></pre>"},{"location":"stm/MpuController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/MpuController_8hpp/#function-getexternalsensordword","title":"function getExternalSensorDWord","text":"<pre><code>uint32_t getExternalSensorDWord (\nint position\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-getxfinegain","title":"function getXFineGain","text":"<pre><code>int8_t getXFineGain () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-getxgyrooffsettc","title":"function getXGyroOffsetTC","text":"<pre><code>int8_t getXGyroOffsetTC () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-getyfinegain","title":"function getYFineGain","text":"<pre><code>int8_t getYFineGain () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-getygyrooffsettc","title":"function getYGyroOffsetTC","text":"<pre><code>int8_t getYGyroOffsetTC () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-getzfinegain","title":"function getZFineGain","text":"<pre><code>int8_t getZFineGain () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-getzgyrooffsettc","title":"function getZGyroOffsetTC","text":"<pre><code>int8_t getZGyroOffsetTC () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpucreate","title":"function mpuCreate","text":"<pre><code>void mpuCreate () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpudispatch","title":"function mpuDispatch","text":"<pre><code>void mpuDispatch (\nconst CoprocReq_MpuReq &amp; request\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpuinitialize","title":"function mpuInitialize","text":"<pre><code>void mpuInitialize () </code></pre> <p>Power on and prepare for general usage. This will activate the device and take it out of sleep mode (which must be done after start-up). This function also sets both the accelerometer and the gyroscope to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets the clock source to use the X Gyro for reference, which is slightly better than the default internal clock source. </p>"},{"location":"stm/MpuController_8hpp/#function-mpureset","title":"function mpuReset","text":"<pre><code>void mpuReset () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mputick","title":"function mpuTick","text":"<pre><code>void mpuTick () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getaccelfifoenabled","title":"function mpu_getAccelFIFOEnabled","text":"<pre><code>bool mpu_getAccelFIFOEnabled () </code></pre> <p>Get accelerometer FIFO enabled value. When set to 1, this bit enables ACCEL_XOUT_H, ACCEL_XOUT_L, ACCEL_YOUT_H, ACCEL_YOUT_L, ACCEL_ZOUT_H, and ACCEL_ZOUT_L (Registers 59 to 64) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current accelerometer FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getaccelxselftest","title":"function mpu_getAccelXSelfTest","text":"<pre><code>bool mpu_getAccelXSelfTest () </code></pre> <p>Get self-test enabled setting for accelerometer X axis. </p> <p>Returns:</p> <p>Self-test enabled value </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getaccelyselftest","title":"function mpu_getAccelYSelfTest","text":"<pre><code>bool mpu_getAccelYSelfTest () </code></pre> <p>Get self-test enabled value for accelerometer Y axis. </p> <p>Returns:</p> <p>Self-test enabled value </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getaccelzselftest","title":"function mpu_getAccelZSelfTest","text":"<pre><code>bool mpu_getAccelZSelfTest () </code></pre> <p>Get self-test enabled value for accelerometer Z axis. </p> <p>Returns:</p> <p>Self-test enabled value </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getacceleration","title":"function mpu_getAcceleration","text":"<pre><code>void mpu_getAcceleration (\nint16_t * x,\nint16_t * y,\nint16_t * z\n) </code></pre> <p>Get 3-axis accelerometer readings. These registers store the most recent accelerometer measurements. Accelerometer measurements are written to these registers at the Sample Rate as defined in Register 25.</p> <p>The accelerometer measurement registers, along with the temperature measurement registers, gyroscope measurement registers, and external sensor data registers, are composed of two sets of registers: an internal register set and a user-facing read register set.</p> <p>The data within the accelerometer sensors' internal register set is always updated at the Sample Rate. Meanwhile, the user-facing read register set duplicates the internal register set's data values whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.</p> <p>Each 16-bit accelerometer measurement has a full scale defined in ACCEL_FS (Register 28). For each full scale setting, the accelerometers' sensitivity per LSB in ACCEL_xOUT is shown in the table below:</p> <p>Parameters:</p> <ul> <li><code>x</code> 16-bit signed integer container for X-axis acceleration </li> <li><code>y</code> 16-bit signed integer container for Y-axis acceleration </li> <li><code>z</code> 16-bit signed integer container for Z-axis acceleration </li> </ul> <p>See also: mpu_RA_GYRO_XOUT_H </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getaccelerationx","title":"function mpu_getAccelerationX","text":"<pre><code>int16_t mpu_getAccelerationX () </code></pre> <p>Get X-axis accelerometer reading. </p> <p>Returns:</p> <p>X-axis acceleration measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_ACCEL_XOUT_H </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getaccelerationy","title":"function mpu_getAccelerationY","text":"<pre><code>int16_t mpu_getAccelerationY () </code></pre> <p>Get Y-axis accelerometer reading. </p> <p>Returns:</p> <p>Y-axis acceleration measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_ACCEL_YOUT_H </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getaccelerationz","title":"function mpu_getAccelerationZ","text":"<pre><code>int16_t mpu_getAccelerationZ () </code></pre> <p>Get Z-axis accelerometer reading. </p> <p>Returns:</p> <p>Z-axis acceleration measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_ACCEL_ZOUT_H </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getaccelerometerpowerondelay","title":"function mpu_getAccelerometerPowerOnDelay","text":"<pre><code>uint8_t mpu_getAccelerometerPowerOnDelay () </code></pre> <p>Get accelerometer power-on delay. The accelerometer data path provides samples to the sensor registers, Motion detection, Zero Motion detection, and Free Fall detection modules. The signal path contains filters which must be flushed on wake-up with new samples before the detection modules begin operations. The default wake-up delay, of 4ms can be lengthened by up to 3ms. This additional delay is specified in ACCEL_ON_DELAY in units of 1 LSB = 1 ms. The user may select any value above zero unless instructed otherwise by InvenSense. Please refer to Section 8 of the MPU-6000/MPU-6050 Product Specification document for further information regarding the detection modules. </p> <p>Returns:</p> <p>Current accelerometer power-on delay </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_ACCEL_ON_DELAY_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getauxvddiolevel","title":"function mpu_getAuxVDDIOLevel","text":"<pre><code>uint8_t mpu_getAuxVDDIOLevel () </code></pre> <p>Get the auxiliary I2C supply voltage level. When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to the MPU-6000, which does not have a VLOGIC pin. </p> <p>Returns:</p> <p>I2C supply voltage level (0=VLOGIC, 1=VDD) </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getclockoutputenabled","title":"function mpu_getClockOutputEnabled","text":"<pre><code>bool mpu_getClockOutputEnabled () </code></pre> <p>Get reference clock output enabled status. When this bit is equal to 1, a reference clock output is provided at the CLKOUT pin. When this bit is equal to 0, the clock output is disabled. For further information regarding CLKOUT, please refer to the MPU-60X0 Product Specification document. </p> <p>Returns:</p> <p>Current reference clock output enabled status </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_CLKOUT_EN_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getclocksource","title":"function mpu_getClockSource","text":"<pre><code>uint8_t mpu_getClockSource () </code></pre> <p>Get clock source setting. </p> <p>Returns:</p> <p>Current clock source setting </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_CLKSEL_BIT </p> <p>See also: mpu_PWR1_CLKSEL_LENGTH </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getdhpfmode","title":"function mpu_getDHPFMode","text":"<pre><code>uint8_t mpu_getDHPFMode () </code></pre> <p>Get the high-pass filter configuration. The DHPF is a filter module in the path leading to motion detectors (Free Fall, Motion threshold, and Zero Motion). The high pass filter output is not available to the data registers (see Figure in Section 8 of the MPU-6000/ MPU-6050 Product Specification document).</p> <p>The high pass filter has three modes:</p> <p>Returns:</p> <p>Current high-pass filter configuration </p> <p>See also: mpu_DHPF_RESET </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getdlpfmode","title":"function mpu_getDLPFMode","text":"<pre><code>uint8_t mpu_getDLPFMode () </code></pre> <p>Get digital low-pass filter configuration. The DLPF_CFG parameter sets the digital low pass filter configuration. It also determines the internal sampling rate used by the device as shown in the table below.</p> <p>Note: The accelerometer output rate is 1kHz. This means that for a Sample Rate greater than 1kHz, the same accelerometer sample may be output to the FIFO, DMP, and sensor registers more than once.</p> <p>Returns:</p> <p>DLFP configuration </p> <p>See also: mpu_RA_CONFIG </p> <p>See also: mpu_CFG_DLPF_CFG_BIT </p> <p>See also: mpu_CFG_DLPF_CFG_LENGTH </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getdmpconfig1","title":"function mpu_getDMPConfig1","text":"<pre><code>uint8_t mpu_getDMPConfig1 () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getdmpconfig2","title":"function mpu_getDMPConfig2","text":"<pre><code>uint8_t mpu_getDMPConfig2 () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getdmpenabled","title":"function mpu_getDMPEnabled","text":"<pre><code>bool mpu_getDMPEnabled () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getdmpint0status","title":"function mpu_getDMPInt0Status","text":"<pre><code>bool mpu_getDMPInt0Status () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getdmpint1status","title":"function mpu_getDMPInt1Status","text":"<pre><code>bool mpu_getDMPInt1Status () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getdmpint2status","title":"function mpu_getDMPInt2Status","text":"<pre><code>bool mpu_getDMPInt2Status () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getdmpint3status","title":"function mpu_getDMPInt3Status","text":"<pre><code>bool mpu_getDMPInt3Status () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getdmpint4status","title":"function mpu_getDMPInt4Status","text":"<pre><code>bool mpu_getDMPInt4Status () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getdmpint5status","title":"function mpu_getDMPInt5Status","text":"<pre><code>bool mpu_getDMPInt5Status () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getdeviceid","title":"function mpu_getDeviceID","text":"<pre><code>uint8_t mpu_getDeviceID () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getexternalframesync","title":"function mpu_getExternalFrameSync","text":"<pre><code>uint8_t mpu_getExternalFrameSync () </code></pre> <p>Get external FSYNC configuration. Configures the external Frame Synchronization (FSYNC) pin sampling. An external signal connected to the FSYNC pin can be sampled by configuring EXT_SYNC_SET. Signal changes to the FSYNC pin are latched so that short strobes may be captured. The latched FSYNC signal will be sampled at the Sampling Rate, as defined in register 25. After sampling, the latch will reset to the current FSYNC signal state.</p> <p>The sampled value will be reported in place of the least significant bit in a sensor data register determined by the value of EXT_SYNC_SET according to the following table.</p> <p>Returns:</p> <p>FSYNC configuration value </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getexternalsensorbyte","title":"function mpu_getExternalSensorByte","text":"<pre><code>uint8_t mpu_getExternalSensorByte (\nint position\n) </code></pre> <p>Read single byte from external sensor data register. These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53).</p> <p>External sensor data is written to these registers at the Sample Rate as defined in Register 25. This access rate can be reduced by using the Slave Delay Enable registers (Register 103).</p> <p>External sensor data registers, along with the gyroscope measurement registers, accelerometer measurement registers, and temperature measurement registers, are composed of two sets of registers: an internal register set and a user-facing read register set.</p> <p>The data within the external sensors' internal register set is always updated at the Sample Rate (or the reduced access rate) whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.</p> <p>Data is placed in these external sensor data registers according to I2C_SLV0_CTRL, I2C_SLV1_CTRL, I2C_SLV2_CTRL, and I2C_SLV3_CTRL (Registers 39, 42, 45, and 48). When more than zero bytes are read (I2C_SLVx_LEN &gt; 0) from an enabled slave (I2C_SLVx_EN = 1), the slave is read at the Sample Rate (as defined in Register 25) or delayed rate (if specified in Register 52 and 103). During each Sample cycle, slave reads are performed in order of Slave number. If all slaves are enabled with more than zero bytes to be read, the order will be Slave 0, followed by Slave 1, Slave 2, and Slave 3.</p> <p>Each enabled slave will have EXT_SENS_DATA registers associated with it by number of bytes read (I2C_SLVx_LEN) in order of slave number, starting from EXT_SENS_DATA_00. Note that this means enabling or disabling a slave may change the higher numbered slaves' associated registers. Furthermore, if fewer total bytes are being read from the external sensors as a result of such a change, then the data remaining in the registers which no longer have an associated slave device (i.e. high numbered registers) will remain in these previously allocated registers unless reset.</p> <p>If the sum of the read lengths of all SLVx transactions exceed the number of available EXT_SENS_DATA registers, the excess bytes will be dropped. There are 24 EXT_SENS_DATA registers and hence the total read lengths between all the slaves cannot be greater than 24 or some bytes will be lost.</p> <p>Note: Slave 4's behavior is distinct from that of Slaves 0-3. For further information regarding the characteristics of Slave 4, please refer to Registers 49 to 53.</p> <p>EXAMPLE: Suppose that Slave 0 is enabled with 4 bytes to be read (I2C_SLV0_EN = 1 and I2C_SLV0_LEN = 4) while Slave 1 is enabled with 2 bytes to be read so that I2C_SLV1_EN = 1 and I2C_SLV1_LEN = 2. In such a situation, EXT_SENS_DATA _00 through _03 will be associated with Slave 0, while EXT_SENS_DATA _04 and 05 will be associated with Slave 1. If Slave 2 is enabled as well, registers starting from EXT_SENS_DATA_06 will be allocated to Slave 2.</p> <p>If Slave 2 is disabled while Slave 3 is enabled in this same situation, then registers starting from EXT_SENS_DATA_06 will be allocated to Slave 3 instead.</p> <p>REGISTER ALLOCATION FOR DYNAMIC DISABLE VS. NORMAL DISABLE: If a slave is disabled at any time, the space initially allocated to the slave in the EXT_SENS_DATA register, will remain associated with that slave. This is to avoid dynamic adjustment of the register allocation.</p> <p>The allocation of the EXT_SENS_DATA registers is recomputed only when (1) all slaves are disabled, or (2) the I2C_MST_RST bit is set (Register 106).</p> <p>This above is also true if one of the slaves gets NACKed and stops functioning.</p> <p>Parameters:</p> <ul> <li><code>position</code> Starting position (0-23) </li> </ul> <p>Returns:</p> <p>Byte read from register </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getexternalsensorword","title":"function mpu_getExternalSensorWord","text":"<pre><code>uint16_t mpu_getExternalSensorWord (\nint position\n) </code></pre> <p>Read word (2 bytes) from external sensor data registers. </p> <p>Parameters:</p> <ul> <li><code>position</code> Starting position (0-21) </li> </ul> <p>Returns:</p> <p>Word read from register </p> <p>See also: getExternalSensorByte() </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getexternalshadowdelayenabled","title":"function mpu_getExternalShadowDelayEnabled","text":"<pre><code>bool mpu_getExternalShadowDelayEnabled () </code></pre> <p>Get external data shadow delay enabled status. This register is used to specify the timing of external sensor data shadowing. When DELAY_ES_SHADOW is set to 1, shadowing of external sensor data is delayed until all data has been received. </p> <p>Returns:</p> <p>Current external data shadow delay enabled status. </p> <p>See also: mpu_RA_I2C_MST_DELAY_CTRL </p> <p>See also: mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getfifobyte","title":"function mpu_getFIFOByte","text":"<pre><code>uint8_t mpu_getFIFOByte () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getfifobytes","title":"function mpu_getFIFOBytes","text":"<pre><code>void mpu_getFIFOBytes (\nuint8_t * data,\nuint8_t length\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getfifocount","title":"function mpu_getFIFOCount","text":"<pre><code>uint16_t mpu_getFIFOCount () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getfifoenabled","title":"function mpu_getFIFOEnabled","text":"<pre><code>bool mpu_getFIFOEnabled () </code></pre> <p>Get FIFO enabled status. When this bit is set to 0, the FIFO mpu6050.buffer is disabled. The FIFO mpu6050.buffer cannot be written to or read from while disabled. The FIFO mpu6050.buffer's state does not change unless the MPU-60X0 is power cycled. </p> <p>Returns:</p> <p>Current FIFO enabled status </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_FIFO_EN_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getfsyncinterruptenabled","title":"function mpu_getFSyncInterruptEnabled","text":"<pre><code>bool mpu_getFSyncInterruptEnabled () </code></pre> <p>Get FSYNC pin interrupt enabled setting. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled setting </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_FSYNC_INT_EN_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getfsyncinterruptlevel","title":"function mpu_getFSyncInterruptLevel","text":"<pre><code>bool mpu_getFSyncInterruptLevel () </code></pre> <p>Get FSYNC interrupt logic level mode. </p> <p>Returns:</p> <p>Current FSYNC interrupt mode (0=active-high, 1=active-low) </p> <p>See also: getFSyncInterruptMode() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_FSYNC_INT_LEVEL_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getfreefalldetectioncounterdecrement","title":"function mpu_getFreefallDetectionCounterDecrement","text":"<pre><code>uint8_t mpu_getFreefallDetectionCounterDecrement () </code></pre> <p>Get Free Fall detection counter decrement configuration. Detection is registered by the Free Fall detection module after accelerometer measurements meet their respective threshold conditions over a specified number of samples. When the threshold conditions are met, the corresponding detection counter increments by 1. The user may control the rate at which the detection counter decrements when the threshold condition is not met by configuring FF_COUNT. The decrement rate can be set according to the following table:</p> <p>When FF_COUNT is configured to 0 (reset), any non-qualifying sample will reset the counter to 0. For further information on Free Fall detection, please refer to Registers 29 to 32.</p> <p>Returns:</p> <p>Current decrement configuration </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_FF_COUNT_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getfreefalldetectionduration","title":"function mpu_getFreefallDetectionDuration","text":"<pre><code>uint8_t mpu_getFreefallDetectionDuration () </code></pre> <p>Get free-fall event duration threshold. This register configures the duration counter threshold for Free Fall event detection. The duration counter ticks at 1kHz, therefore FF_DUR has a unit of 1 LSB = 1 ms.</p> <p>The Free Fall duration counter increments while the absolute value of the accelerometer measurements are each less than the detection threshold (Register 29). The Free Fall interrupt is triggered when the Free Fall duration counter reaches the time specified in this register.</p> <p>For more details on the Free Fall detection interrupt, see Section 8.2 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current free-fall duration threshold value (LSB = 1ms) </p> <p>See also: mpu_RA_FF_DUR </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getfreefalldetectionthreshold","title":"function mpu_getFreefallDetectionThreshold","text":"<pre><code>uint8_t mpu_getFreefallDetectionThreshold () </code></pre> <p>Get free-fall event acceleration threshold. This register configures the detection threshold for Free Fall event detection. The unit of FF_THR is 1LSB = 2mg. Free Fall is detected when the absolute value of the accelerometer measurements for the three axes are each less than the detection threshold. This condition increments the Free Fall duration counter (Register 30). The Free Fall interrupt is triggered when the Free Fall duration counter reaches the time specified in FF_DUR.</p> <p>For more details on the Free Fall detection interrupt, see Section 8.2 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current free-fall acceleration threshold value (LSB = 2mg) </p> <p>See also: mpu_RA_FF_THR </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getfullscaleaccelrange","title":"function mpu_getFullScaleAccelRange","text":"<pre><code>uint8_t mpu_getFullScaleAccelRange () </code></pre> <p>Get full-scale accelerometer range. The FS_SEL parameter allows setting the full-scale range of the accelerometer sensors, as described in the table below.</p> <p>Returns:</p> <p>Current full-scale accelerometer range setting </p> <p>See also: mpu_ACCEL_FS_2 </p> <p>See also: mpu_RA_ACCEL_CONFIG </p> <p>See also: mpu_ACONFIG_AFS_SEL_BIT </p> <p>See also: mpu_ACONFIG_AFS_SEL_LENGTH </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getfullscalegyrorange","title":"function mpu_getFullScaleGyroRange","text":"<pre><code>uint8_t mpu_getFullScaleGyroRange () </code></pre> <p>Get full-scale gyroscope range. The FS_SEL parameter allows setting the full-scale range of the gyro sensors, as described in the table below.</p> <p>Returns:</p> <p>Current full-scale gyroscope range setting </p> <p>See also: mpu_GYRO_FS_250 </p> <p>See also: mpu_RA_GYRO_CONFIG </p> <p>See also: mpu_GCONFIG_FS_SEL_BIT </p> <p>See also: mpu_GCONFIG_FS_SEL_LENGTH </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_geti2cbypassenabled","title":"function mpu_getI2CBypassEnabled","text":"<pre><code>bool mpu_getI2CBypassEnabled () </code></pre> <p>Get I2C bypass enabled status. When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to 0, the host application processor will be able to directly access the auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host application processor will not be able to directly access the auxiliary I2C bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106 bit[5]). </p> <p>Returns:</p> <p>Current I2C bypass enabled status </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_I2C_BYPASS_EN_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_geti2cmastermodeenabled","title":"function mpu_getI2CMasterModeEnabled","text":"<pre><code>bool mpu_getI2CMasterModeEnabled () </code></pre> <p>Get I2C Master Mode enabled status. When this mode is enabled, the MPU-60X0 acts as the I2C Master to the external sensor slave devices on the auxiliary I2C bus. When this bit is cleared to 0, the auxiliary I2C bus lines (AUX_DA and AUX_CL) are logically driven by the primary I2C bus (SDA and SCL). This is a precondition to enabling Bypass Mode. For further information regarding Bypass Mode, please refer to Register 55. </p> <p>Returns:</p> <p>Current I2C Master Mode enabled status </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_I2C_MST_EN_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getintdmpenabled","title":"function mpu_getIntDMPEnabled","text":"<pre><code>bool mpu_getIntDMPEnabled () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getintdmpstatus","title":"function mpu_getIntDMPStatus","text":"<pre><code>bool mpu_getIntDMPStatus () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getintdatareadyenabled","title":"function mpu_getIntDataReadyEnabled","text":"<pre><code>bool mpu_getIntDataReadyEnabled () </code></pre> <p>Get Data Ready interrupt enabled setting. This event occurs each time a write operation to all of the sensor registers has been completed. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_DATA_RDY_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getintdatareadystatus","title":"function mpu_getIntDataReadyStatus","text":"<pre><code>bool mpu_getIntDataReadyStatus () </code></pre> <p>Get Data Ready interrupt status. This bit automatically sets to 1 when a Data Ready interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_DATA_RDY_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getintenabled","title":"function mpu_getIntEnabled","text":"<pre><code>uint8_t mpu_getIntEnabled () </code></pre> <p>Get full interrupt enabled status. Full register byte for all interrupts, for quick reading. Each bit will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getintfifobufferoverflowenabled","title":"function mpu_getIntFIFOBufferOverflowEnabled","text":"<pre><code>bool mpu_getIntFIFOBufferOverflowEnabled () </code></pre> <p>Get FIFO Buffer Overflow interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FIFO_OFLOW_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getintfifobufferoverflowstatus","title":"function mpu_getIntFIFOBufferOverflowStatus","text":"<pre><code>bool mpu_getIntFIFOBufferOverflowStatus () </code></pre> <p>Get FIFO Buffer Overflow interrupt status. This bit automatically sets to 1 when a Free Fall interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_FIFO_OFLOW_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getintfreefallenabled","title":"function mpu_getIntFreefallEnabled","text":"<pre><code>bool mpu_getIntFreefallEnabled () </code></pre> <p>Get Free Fall interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getintfreefallstatus","title":"function mpu_getIntFreefallStatus","text":"<pre><code>bool mpu_getIntFreefallStatus () </code></pre> <p>Get Free Fall interrupt status. This bit automatically sets to 1 when a Free Fall interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getinti2cmasterenabled","title":"function mpu_getIntI2CMasterEnabled","text":"<pre><code>bool mpu_getIntI2CMasterEnabled () </code></pre> <p>Get I2C Master interrupt enabled status. This enables any of the I2C Master interrupt sources to generate an interrupt. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_I2C_MST_INT_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getinti2cmasterstatus","title":"function mpu_getIntI2CMasterStatus","text":"<pre><code>bool mpu_getIntI2CMasterStatus () </code></pre> <p>Get I2C Master interrupt status. This bit automatically sets to 1 when an I2C Master interrupt has been generated. For a list of I2C Master interrupts, please refer to Register 54. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_I2C_MST_INT_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getintmotionenabled","title":"function mpu_getIntMotionEnabled","text":"<pre><code>bool mpu_getIntMotionEnabled () </code></pre> <p>Get Motion Detection interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_MOT_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getintmotionstatus","title":"function mpu_getIntMotionStatus","text":"<pre><code>bool mpu_getIntMotionStatus () </code></pre> <p>Get Motion Detection interrupt status. This bit automatically sets to 1 when a Motion Detection interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_MOT_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getintpllreadyenabled","title":"function mpu_getIntPLLReadyEnabled","text":"<pre><code>bool mpu_getIntPLLReadyEnabled () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getintpllreadystatus","title":"function mpu_getIntPLLReadyStatus","text":"<pre><code>bool mpu_getIntPLLReadyStatus () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getintstatus","title":"function mpu_getIntStatus","text":"<pre><code>uint8_t mpu_getIntStatus () </code></pre> <p>Get full set of interrupt status bits. These bits clear to 0 after the register has been read. Very useful for getting multiple INT statuses, since each single bit read clears all of them because it has to read the whole byte. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getintzeromotionenabled","title":"function mpu_getIntZeroMotionEnabled","text":"<pre><code>bool mpu_getIntZeroMotionEnabled () </code></pre> <p>Get Zero Motion Detection interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_ZMOT_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getintzeromotionstatus","title":"function mpu_getIntZeroMotionStatus","text":"<pre><code>bool mpu_getIntZeroMotionStatus () </code></pre> <p>Get Zero Motion Detection interrupt status. This bit automatically sets to 1 when a Zero Motion Detection interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_ZMOT_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getinterruptdrive","title":"function mpu_getInterruptDrive","text":"<pre><code>bool mpu_getInterruptDrive () </code></pre> <p>Get interrupt drive mode. Will be set 0 for push-pull, 1 for open-drain. </p> <p>Returns:</p> <p>Current interrupt drive mode (0=push-pull, 1=open-drain) </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_OPEN_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getinterruptlatch","title":"function mpu_getInterruptLatch","text":"<pre><code>bool mpu_getInterruptLatch () </code></pre> <p>Get interrupt latch mode. Will be set 0 for 50us-pulse, 1 for latch-until-int-cleared. </p> <p>Returns:</p> <p>Current latch mode (0=50us-pulse, 1=latch-until-int-cleared) </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_LATCH_INT_EN_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getinterruptlatchclear","title":"function mpu_getInterruptLatchClear","text":"<pre><code>bool mpu_getInterruptLatchClear () </code></pre> <p>Get interrupt latch clear mode. Will be set 0 for status-read-only, 1 for any-register-read. </p> <p>Returns:</p> <p>Current latch clear mode (0=status-read-only, 1=any-register-read) </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_RD_CLEAR_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getinterruptmode","title":"function mpu_getInterruptMode","text":"<pre><code>bool mpu_getInterruptMode () </code></pre> <p>Get interrupt logic level mode. Will be set 0 for active-high, 1 for active-low. </p> <p>Returns:</p> <p>Current interrupt mode (0=active-high, 1=active-low) </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_LEVEL_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getlostarbitration","title":"function mpu_getLostArbitration","text":"<pre><code>bool mpu_getLostArbitration () </code></pre> <p>Get master arbitration lost status. This bit automatically sets to 1 when the I2C Master has lost arbitration of the auxiliary I2C bus (an error condition). This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Master arbitration lost status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getmasterclockspeed","title":"function mpu_getMasterClockSpeed","text":"<pre><code>uint8_t mpu_getMasterClockSpeed () </code></pre> <p>Get I2C master clock speed. I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:</p> <p>Returns:</p> <p>Current I2C master clock speed </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getmotion6","title":"function mpu_getMotion6","text":"<pre><code>void mpu_getMotion6 (\nint16_t * ax,\nint16_t * ay,\nint16_t * az,\nint16_t * gx,\nint16_t * gy,\nint16_t * gz\n) </code></pre> <p>Get raw 6-axis motion sensor readings (accel/gyro). Retrieves all currently available motion sensor values. </p> <p>Parameters:</p> <ul> <li><code>ax</code> 16-bit signed integer container for accelerometer X-axis value </li> <li><code>ay</code> 16-bit signed integer container for accelerometer Y-axis value </li> <li><code>az</code> 16-bit signed integer container for accelerometer Z-axis value </li> <li><code>gx</code> 16-bit signed integer container for gyroscope X-axis value </li> <li><code>gy</code> 16-bit signed integer container for gyroscope Y-axis value </li> <li><code>gz</code> 16-bit signed integer container for gyroscope Z-axis value </li> </ul> <p>See also: getAcceleration() </p> <p>See also: getRotation() </p> <p>See also: mpu_RA_ACCEL_XOUT_H </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getmotion9","title":"function mpu_getMotion9","text":"<pre><code>void mpu_getMotion9 (\nint16_t * ax,\nint16_t * ay,\nint16_t * az,\nint16_t * gx,\nint16_t * gy,\nint16_t * gz,\nint16_t * mx,\nint16_t * my,\nint16_t * mz\n) </code></pre> <p>Get raw 9-axis motion sensor readings (accel/gyro/compass). FUNCTION NOT FULLY IMPLEMENTED YET. </p> <p>Parameters:</p> <ul> <li><code>ax</code> 16-bit signed integer container for accelerometer X-axis value </li> <li><code>ay</code> 16-bit signed integer container for accelerometer Y-axis value </li> <li><code>az</code> 16-bit signed integer container for accelerometer Z-axis value </li> <li><code>gx</code> 16-bit signed integer container for gyroscope X-axis value </li> <li><code>gy</code> 16-bit signed integer container for gyroscope Y-axis value </li> <li><code>gz</code> 16-bit signed integer container for gyroscope Z-axis value </li> <li><code>mx</code> 16-bit signed integer container for magnetometer X-axis value </li> <li><code>my</code> 16-bit signed integer container for magnetometer Y-axis value </li> <li><code>mz</code> 16-bit signed integer container for magnetometer Z-axis value </li> </ul> <p>See also: getMotion6() </p> <p>See also: getAcceleration() </p> <p>See also: getRotation() </p> <p>See also: mpu_RA_ACCEL_XOUT_H </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getmotiondetectioncounterdecrement","title":"function mpu_getMotionDetectionCounterDecrement","text":"<pre><code>uint8_t mpu_getMotionDetectionCounterDecrement () </code></pre> <p>Get Motion detection counter decrement configuration. Detection is registered by the Motion detection module after accelerometer measurements meet their respective threshold conditions over a specified number of samples. When the threshold conditions are met, the corresponding detection counter increments by 1. The user may control the rate at which the detection counter decrements when the threshold condition is not met by configuring MOT_COUNT. The decrement rate can be set according to the following table:</p> <p>When MOT_COUNT is configured to 0 (reset), any non-qualifying sample will reset the counter to 0. For further information on Motion detection, please refer to Registers 29 to 32. </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getmotiondetectionduration","title":"function mpu_getMotionDetectionDuration","text":"<pre><code>uint8_t mpu_getMotionDetectionDuration () </code></pre> <p>Get motion detection event duration threshold. This register configures the duration counter threshold for Motion interrupt generation. The duration counter ticks at 1 kHz, therefore MOT_DUR has a unit of 1LSB = 1ms. The Motion detection duration counter increments when the absolute value of any of the accelerometer measurements exceeds the Motion detection threshold (Register 31). The Motion detection interrupt is triggered when the Motion detection counter reaches the time count specified in this register.</p> <p>For more details on the Motion detection interrupt, see Section 8.3 of the MPU-6000/MPU-6050 Product Specification document.</p> <p>Returns:</p> <p>Current motion detection duration threshold value (LSB = 1ms) </p> <p>See also: mpu_RA_MOT_DUR </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getmotiondetectionthreshold","title":"function mpu_getMotionDetectionThreshold","text":"<pre><code>uint8_t mpu_getMotionDetectionThreshold () </code></pre> <p>Get motion detection event acceleration threshold. This register configures the detection threshold for Motion interrupt generation. The unit of MOT_THR is 1LSB = 2mg. Motion is detected when the absolute value of any of the accelerometer measurements exceeds this Motion detection threshold. This condition increments the Motion detection duration counter (Register 32). The Motion detection interrupt is triggered when the Motion Detection counter reaches the time count specified in MOT_DUR (Register 32).</p> <p>The Motion interrupt will indicate the axis and polarity of detected motion in MOT_DETECT_STATUS (Register 97).</p> <p>For more details on the Motion detection interrupt, see Section 8.3 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current motion detection acceleration threshold value (LSB = 2mg) </p> <p>See also: mpu_RA_MOT_THR </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getmultimasterenabled","title":"function mpu_getMultiMasterEnabled","text":"<pre><code>bool mpu_getMultiMasterEnabled () </code></pre> <p>Get multi-master enabled value. Multi-master capability allows multiple I2C masters to operate on the same bus. In circuits where multi-master capability is required, set MULT_MST_EN to 1. This will increase current drawn by approximately 30uA.</p> <p>In circuits where multi-master capability is required, the state of the I2C bus must always be monitored by each separate I2C Master. Before an I2C Master can assume arbitration of the bus, it must first confirm that no other I2C Master has arbitration of the bus. When MULT_MST_EN is set to 1, the MPU-60X0's bus arbitration detection logic is turned on, enabling it to detect when the bus is available.</p> <p>Returns:</p> <p>Current multi-master enabled value </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getotpbankvalid","title":"function mpu_getOTPBankValid","text":"<pre><code>uint8_t mpu_getOTPBankValid () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getpassthroughstatus","title":"function mpu_getPassthroughStatus","text":"<pre><code>bool mpu_getPassthroughStatus () </code></pre> <p>Get FSYNC interrupt status. This bit reflects the status of the FSYNC interrupt from an external device into the MPU-60X0. This is used as a way to pass an external interrupt through the MPU-60X0 to the host application processor. When set to 1, this bit will cause an interrupt if FSYNC_INT_EN is asserted in INT_PIN_CFG (Register 55). </p> <p>Returns:</p> <p>FSYNC interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getrate","title":"function mpu_getRate","text":"<pre><code>uint8_t mpu_getRate () </code></pre> <p>Get gyroscope output rate divider. The sensor register output, FIFO output, DMP sampling, Motion detection, Zero Motion detection, and Free Fall detection are all based on the Sample Rate. The Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV:</p> <p>Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)</p> <p>where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or 7), and 1kHz when the DLPF is enabled (see Register 26).</p> <p>Note: The accelerometer output rate is 1kHz. This means that for a Sample Rate greater than 1kHz, the same accelerometer sample may be output to the FIFO, DMP, and sensor registers more than once.</p> <p>For a diagram of the gyroscope and accelerometer signal paths, see Section 8 of the MPU-6000/MPU-6050 Product Specification document.</p> <p>Returns:</p> <p>Current sample rate </p> <p>See also: mpu_RA_SMPLRT_DIV </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getrotation","title":"function mpu_getRotation","text":"<pre><code>void mpu_getRotation (\nint16_t * x,\nint16_t * y,\nint16_t * z\n) </code></pre> <p>Get 3-axis gyroscope readings. These gyroscope measurement registers, along with the accelerometer measurement registers, temperature measurement registers, and external sensor data registers, are composed of two sets of registers: an internal register set and a user-facing read register set. The data within the gyroscope sensors' internal register set is always updated at the Sample Rate. Meanwhile, the user-facing read register set duplicates the internal register set's data values whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.</p> <p>Each 16-bit gyroscope measurement has a full scale defined in FS_SEL (Register 27). For each full scale setting, the gyroscopes' sensitivity per LSB in GYRO_xOUT is shown in the table below:</p> <p>Parameters:</p> <ul> <li><code>x</code> 16-bit signed integer container for X-axis rotation </li> <li><code>y</code> 16-bit signed integer container for Y-axis rotation </li> <li><code>z</code> 16-bit signed integer container for Z-axis rotation </li> </ul> <p>See also: getMotion6() </p> <p>See also: mpu_RA_GYRO_XOUT_H </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getrotationx","title":"function mpu_getRotationX","text":"<pre><code>int16_t mpu_getRotationX () </code></pre> <p>Get X-axis gyroscope reading. </p> <p>Returns:</p> <p>X-axis rotation measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_GYRO_XOUT_H </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getrotationy","title":"function mpu_getRotationY","text":"<pre><code>int16_t mpu_getRotationY () </code></pre> <p>Get Y-axis gyroscope reading. </p> <p>Returns:</p> <p>Y-axis rotation measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_GYRO_YOUT_H </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getrotationz","title":"function mpu_getRotationZ","text":"<pre><code>int16_t mpu_getRotationZ () </code></pre> <p>Get Z-axis gyroscope reading. </p> <p>Returns:</p> <p>Z-axis rotation measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_GYRO_ZOUT_H </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslate4inputbyte","title":"function mpu_getSlate4InputByte","text":"<pre><code>uint8_t mpu_getSlate4InputByte () </code></pre> <p>Get last available byte read from Slave 4. This register stores the data read from Slave 4. This field is populated after a read transaction. </p> <p>Returns:</p> <p>Last available byte read from to Slave 4 </p> <p>See also: mpu_RA_I2C_SLV4_DI </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslave0fifoenabled","title":"function mpu_getSlave0FIFOEnabled","text":"<pre><code>bool mpu_getSlave0FIFOEnabled () </code></pre> <p>Get Slave 0 FIFO enabled value. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 0 to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current Slave 0 FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslave0nack","title":"function mpu_getSlave0Nack","text":"<pre><code>bool mpu_getSlave0Nack () </code></pre> <p>Get Slave 0 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 0. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 0 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslave1fifoenabled","title":"function mpu_getSlave1FIFOEnabled","text":"<pre><code>bool mpu_getSlave1FIFOEnabled () </code></pre> <p>Get Slave 1 FIFO enabled value. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 1 to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current Slave 1 FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslave1nack","title":"function mpu_getSlave1Nack","text":"<pre><code>bool mpu_getSlave1Nack () </code></pre> <p>Get Slave 1 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 1. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 1 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslave2fifoenabled","title":"function mpu_getSlave2FIFOEnabled","text":"<pre><code>bool mpu_getSlave2FIFOEnabled () </code></pre> <p>Get Slave 2 FIFO enabled value. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 2 to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current Slave 2 FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslave2nack","title":"function mpu_getSlave2Nack","text":"<pre><code>bool mpu_getSlave2Nack () </code></pre> <p>Get Slave 2 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 2. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 2 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslave3fifoenabled","title":"function mpu_getSlave3FIFOEnabled","text":"<pre><code>bool mpu_getSlave3FIFOEnabled () </code></pre> <p>Get Slave 3 FIFO enabled value. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 3 to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current Slave 3 FIFO enabled value </p> <p>See also: mpu_RA_MST_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslave3nack","title":"function mpu_getSlave3Nack","text":"<pre><code>bool mpu_getSlave3Nack () </code></pre> <p>Get Slave 3 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 3. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 3 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslave4address","title":"function mpu_getSlave4Address","text":"<pre><code>uint8_t mpu_getSlave4Address () </code></pre> <p>Get the I2C address of Slave 4. Note that Bit 7 (MSB) controls read/write mode. If Bit 7 is set, it's a read operation, and if it is cleared, then it's a write operation. The remaining bits (6-0) are the 7-bit device address of the slave device.</p> <p>Returns:</p> <p>Current address for Slave 4 </p> <p>See also: getSlaveAddress() </p> <p>See also: mpu_RA_I2C_SLV4_ADDR </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslave4enabled","title":"function mpu_getSlave4Enabled","text":"<pre><code>bool mpu_getSlave4Enabled () </code></pre> <p>Get the enabled value for the Slave 4. When set to 1, this bit enables Slave 4 for data transfer operations. When cleared to 0, this bit disables Slave 4 from data transfer operations. </p> <p>Returns:</p> <p>Current enabled value for Slave 4 </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslave4interruptenabled","title":"function mpu_getSlave4InterruptEnabled","text":"<pre><code>bool mpu_getSlave4InterruptEnabled () </code></pre> <p>Get the enabled value for Slave 4 transaction interrupts. When set to 1, this bit enables the generation of an interrupt signal upon completion of a Slave 4 transaction. When cleared to 0, this bit disables the generation of an interrupt signal upon completion of a Slave 4 transaction. The interrupt status can be observed in Register 54.</p> <p>Returns:</p> <p>Current enabled value for Slave 4 transaction interrupts. </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslave4isdone","title":"function mpu_getSlave4IsDone","text":"<pre><code>bool mpu_getSlave4IsDone () </code></pre> <p>Get Slave 4 transaction done status. Automatically sets to 1 when a Slave 4 transaction has completed. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted and if the SLV_4_DONE_INT bit is asserted in the I2C_SLV4_CTRL register (Register 52). </p> <p>Returns:</p> <p>Slave 4 transaction done status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslave4masterdelay","title":"function mpu_getSlave4MasterDelay","text":"<pre><code>uint8_t mpu_getSlave4MasterDelay () </code></pre> <p>Get Slave 4 master delay value. This configures the reduced access rate of I2C slaves relative to the Sample Rate. When a slave's access rate is decreased relative to the Sample Rate, the slave is accessed every:  This base Sample Rate in turn is determined by SMPLRT_DIV (register 25) and DLPF_CFG (register 26). Whether a slave's access rate is reduced relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL (register 103). For further information regarding the Sample Rate, please refer to register 25.</p> <p>Returns:</p> <p>Current Slave 4 master delay value </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslave4nack","title":"function mpu_getSlave4Nack","text":"<pre><code>bool mpu_getSlave4Nack () </code></pre> <p>Get Slave 4 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 4. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 4 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslave4register","title":"function mpu_getSlave4Register","text":"<pre><code>uint8_t mpu_getSlave4Register () </code></pre> <p>Get the active internal register for the Slave 4. Read/write operations for this slave will be done to whatever internal register address is stored in this MPU register.</p> <p>Returns:</p> <p>Current active register for Slave 4 </p> <p>See also: mpu_RA_I2C_SLV4_REG </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslave4writemode","title":"function mpu_getSlave4WriteMode","text":"<pre><code>bool mpu_getSlave4WriteMode () </code></pre> <p>Get write mode for Slave 4. When set to 1, the transaction will read or write data only. When cleared to 0, the transaction will write a register address prior to reading or writing data. This should equal 0 when specifying the register address within the Slave device to/from which the ensuing data transaction will take place.</p> <p>Returns:</p> <p>Current write mode for Slave 4 (0 = register address + data, 1 = data only) </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslaveaddress","title":"function mpu_getSlaveAddress","text":"<pre><code>uint8_t mpu_getSlaveAddress (\nuint8_t num\n) </code></pre> <p>Get the I2C address of the specified slave (0-3). Note that Bit 7 (MSB) controls read/write mode. If Bit 7 is set, it's a read operation, and if it is cleared, then it's a write operation. The remaining bits (6-0) are the 7-bit device address of the slave device.</p> <p>In read mode, the result of the read is placed in the lowest available EXT_SENS_DATA register. For further information regarding the allocation of read results, please refer to the EXT_SENS_DATA register description (Registers 73 - 96).</p> <p>The MPU-6050 supports a total of five slaves, but Slave 4 has unique characteristics, and so it has its own functions (getSlave4* and setSlave4*).</p> <p>I2C data transactions are performed at the Sample Rate, as defined in Register 25. The user is responsible for ensuring that I2C data transactions to and from each enabled Slave can be completed within a single period of the Sample Rate.</p> <p>The I2C slave access rate can be reduced relative to the Sample Rate. This reduced access rate is determined by I2C_MST_DLY (Register 52). Whether a slave's access rate is reduced relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL (Register 103).</p> <p>The processing order for the slaves is fixed. The sequence followed for processing the slaves is Slave 0, Slave 1, Slave 2, Slave 3 and Slave 4. If a particular Slave is disabled it will be skipped.</p> <p>Each slave can either be accessed at the sample rate or at a reduced sample rate. In a case where some slaves are accessed at the Sample Rate and some slaves are accessed at the reduced rate, the sequence of accessing the slaves (Slave 0 to Slave 4) is still followed. However, the reduced rate slaves will be skipped if their access rate dictates that they should not be accessed during that particular cycle. For further information regarding the reduced access rate, please refer to Register 52. Whether a slave is accessed at the Sample Rate or at the reduced rate is determined by the Delay Enable bits in Register 103.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current address for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_ADDR </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslavedatalength","title":"function mpu_getSlaveDataLength","text":"<pre><code>uint8_t mpu_getSlaveDataLength (\nuint8_t num\n) </code></pre> <p>Get number of bytes to read for the specified slave (0-3). Specifies the number of bytes transferred to and from Slave 0. Clearing this bit to 0 is equivalent to disabling the register by writing 0 to I2C_SLV0_EN. </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Number of bytes to read for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslavedelayenabled","title":"function mpu_getSlaveDelayEnabled","text":"<pre><code>bool mpu_getSlaveDelayEnabled (\nuint8_t num\n) </code></pre> <p>Get slave delay enabled status. When a particular slave delay is enabled, the rate of access for the that slave device is reduced. When a slave's access rate is decreased relative to the Sample Rate, the slave is accessed every:  This base Sample Rate in turn is determined by SMPLRT_DIV (register * 25) and DLPF_CFG (register 26).</p> <p>For further information regarding I2C_MST_DLY, please refer to register 52. For further information regarding the Sample Rate, please refer to register 25.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-4) </li> </ul> <p>Returns:</p> <p>Current slave delay enabled status. </p> <p>See also: mpu_RA_I2C_MST_DELAY_CTRL </p> <p>See also: mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslaveenabled","title":"function mpu_getSlaveEnabled","text":"<pre><code>bool mpu_getSlaveEnabled (\nuint8_t num\n) </code></pre> <p>Get the enabled value for the specified slave (0-3). When set to 1, this bit enables Slave 0 for data transfer operations. When cleared to 0, this bit disables Slave 0 from data transfer operations. </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current enabled value for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslavereadwritetransitionenabled","title":"function mpu_getSlaveReadWriteTransitionEnabled","text":"<pre><code>bool mpu_getSlaveReadWriteTransitionEnabled () </code></pre> <p>Get slave read/write transition enabled value. The I2C_MST_P_NSR bit configures the I2C Master's transition from one slave read to the next slave read. If the bit equals 0, there will be a restart between reads. If the bit equals 1, there will be a stop followed by a start of the following read. When a write transaction follows a read transaction, the stop followed by a start of the successive write will be always used.</p> <p>Returns:</p> <p>Current slave read/write transition enabled value </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslaveregister","title":"function mpu_getSlaveRegister","text":"<pre><code>uint8_t mpu_getSlaveRegister (\nuint8_t num\n) </code></pre> <p>Get the active internal register for the specified slave (0-3). Read/write operations for this slave will be done to whatever internal register address is stored in this MPU register.</p> <p>The MPU-6050 supports a total of five slaves, but Slave 4 has unique characteristics, and so it has its own functions.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current active register for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_REG </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslavewordbyteswap","title":"function mpu_getSlaveWordByteSwap","text":"<pre><code>bool mpu_getSlaveWordByteSwap (\nuint8_t num\n) </code></pre> <p>Get word pair byte-swapping enabled for the specified slave (0-3). When set to 1, this bit enables byte swapping. When byte swapping is enabled, the high and low bytes of a word pair are swapped. Please refer to I2C_SLV0_GRP for the pairing convention of the word pairs. When cleared to 0, bytes transferred to and from Slave 0 will be written to EXT_SENS_DATA registers in the order they were transferred.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current word pair byte-swapping enabled value for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslavewordgroupoffset","title":"function mpu_getSlaveWordGroupOffset","text":"<pre><code>bool mpu_getSlaveWordGroupOffset (\nuint8_t num\n) </code></pre> <p>Get word pair grouping order offset for the specified slave (0-3). This sets specifies the grouping order of word pairs received from registers. When cleared to 0, bytes from register addresses 0 and 1, 2 and 3, etc (even, then odd register addresses) are paired to form a word. When set to 1, bytes from register addresses are paired 1 and 2, 3 and 4, etc. (odd, then even register addresses) are paired to form a word.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current word pair grouping order offset for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getslavewritemode","title":"function mpu_getSlaveWriteMode","text":"<pre><code>bool mpu_getSlaveWriteMode (\nuint8_t num\n) </code></pre> <p>Get write mode for the specified slave (0-3). When set to 1, the transaction will read or write data only. When cleared to 0, the transaction will write a register address prior to reading or writing data. This should equal 0 when specifying the register address within the Slave device to/from which the ensuing data transaction will take place.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current write mode for specified slave (0 = register address + data, 1 = data only) </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getsleepenabled","title":"function mpu_getSleepEnabled","text":"<pre><code>bool mpu_getSleepEnabled () </code></pre> <p>Get sleep mode status. Setting the SLEEP bit in the register puts the device into very low power sleep mode. In this mode, only the serial interface and internal registers remain active, allowing for a very low standby current. Clearing this bit puts the device back into normal mode. To save power, the individual standby selections for each of the gyros should be used if any gyro axis is not used by the application. </p> <p>Returns:</p> <p>Current sleep mode enabled status </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_SLEEP_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getstandbyxaccelenabled","title":"function mpu_getStandbyXAccelEnabled","text":"<pre><code>bool mpu_getStandbyXAccelEnabled () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getstandbyxgyroenabled","title":"function mpu_getStandbyXGyroEnabled","text":"<pre><code>bool mpu_getStandbyXGyroEnabled () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getstandbyyaccelenabled","title":"function mpu_getStandbyYAccelEnabled","text":"<pre><code>bool mpu_getStandbyYAccelEnabled () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getstandbyygyroenabled","title":"function mpu_getStandbyYGyroEnabled","text":"<pre><code>bool mpu_getStandbyYGyroEnabled () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getstandbyzaccelenabled","title":"function mpu_getStandbyZAccelEnabled","text":"<pre><code>bool mpu_getStandbyZAccelEnabled () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getstandbyzgyroenabled","title":"function mpu_getStandbyZGyroEnabled","text":"<pre><code>bool mpu_getStandbyZGyroEnabled () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_gettempfifoenabled","title":"function mpu_getTempFIFOEnabled","text":"<pre><code>bool mpu_getTempFIFOEnabled () </code></pre> <p>Get temperature FIFO enabled value. When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L (Registers 65 and 66) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current temperature FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_gettempsensorenabled","title":"function mpu_getTempSensorEnabled","text":"<pre><code>bool mpu_getTempSensorEnabled () </code></pre> <p>Get temperature sensor enabled status. Control the usage of the internal temperature sensor.</p> <p>Note: this register stores the disabled value, but for consistency with the rest of the code, the function is named and used with standard true/false values to indicate whether the sensor is enabled or disabled, respectively.</p> <p>Returns:</p> <p>Current temperature sensor enabled status </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_TEMP_DIS_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_gettemperature","title":"function mpu_getTemperature","text":"<pre><code>int16_t mpu_getTemperature () </code></pre> <p>Get current internal temperature. </p> <p>Returns:</p> <p>Temperature reading in 16-bit 2's complement format </p> <p>See also: mpu_RA_TEMP_OUT_H </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getwaitforexternalsensorenabled","title":"function mpu_getWaitForExternalSensorEnabled","text":"<pre><code>bool mpu_getWaitForExternalSensorEnabled () </code></pre> <p>Get wait-for-external-sensor-data enabled value. When the WAIT_FOR_ES bit is set to 1, the Data Ready interrupt will be delayed until External Sensor data from the Slave Devices are loaded into the EXT_SENS_DATA registers. This is used to ensure that both the internal sensor data (i.e. from gyro and accel) and external sensor data have been loaded to their respective data registers (i.e. the data is synced) when the Data Ready interrupt is triggered.</p> <p>Returns:</p> <p>Current wait-for-external-sensor-data enabled value </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getwakecycleenabled","title":"function mpu_getWakeCycleEnabled","text":"<pre><code>bool mpu_getWakeCycleEnabled () </code></pre> <p>Get wake cycle enabled status. When this bit is set to 1 and SLEEP is disabled, the MPU-60X0 will cycle between sleep mode and waking up to take a single sample of data from active sensors at a rate determined by LP_WAKE_CTRL (register 108). </p> <p>Returns:</p> <p>Current sleep mode enabled status </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_CYCLE_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getwakefrequency","title":"function mpu_getWakeFrequency","text":"<pre><code>uint8_t mpu_getWakeFrequency () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getxacceloffset","title":"function mpu_getXAccelOffset","text":"<pre><code>int16_t mpu_getXAccelOffset () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getxgyrofifoenabled","title":"function mpu_getXGyroFIFOEnabled","text":"<pre><code>bool mpu_getXGyroFIFOEnabled () </code></pre> <p>Get gyroscope X-axis FIFO enabled value. When set to 1, this bit enables GYRO_XOUT_H and GYRO_XOUT_L (Registers 67 and 68) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current gyroscope X-axis FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getxgyrooffset","title":"function mpu_getXGyroOffset","text":"<pre><code>int16_t mpu_getXGyroOffset () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getxnegmotiondetected","title":"function mpu_getXNegMotionDetected","text":"<pre><code>bool mpu_getXNegMotionDetected () </code></pre> <p>Get X-axis negative motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_XNEG_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getxposmotiondetected","title":"function mpu_getXPosMotionDetected","text":"<pre><code>bool mpu_getXPosMotionDetected () </code></pre> <p>Get X-axis positive motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_XPOS_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getyacceloffset","title":"function mpu_getYAccelOffset","text":"<pre><code>int16_t mpu_getYAccelOffset () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getygyrofifoenabled","title":"function mpu_getYGyroFIFOEnabled","text":"<pre><code>bool mpu_getYGyroFIFOEnabled () </code></pre> <p>Get gyroscope Y-axis FIFO enabled value. When set to 1, this bit enables GYRO_YOUT_H and GYRO_YOUT_L (Registers 69 and 70) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current gyroscope Y-axis FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getygyrooffset","title":"function mpu_getYGyroOffset","text":"<pre><code>int16_t mpu_getYGyroOffset () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getynegmotiondetected","title":"function mpu_getYNegMotionDetected","text":"<pre><code>bool mpu_getYNegMotionDetected () </code></pre> <p>Get Y-axis negative motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_YNEG_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getyposmotiondetected","title":"function mpu_getYPosMotionDetected","text":"<pre><code>bool mpu_getYPosMotionDetected () </code></pre> <p>Get Y-axis positive motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_YPOS_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getzacceloffset","title":"function mpu_getZAccelOffset","text":"<pre><code>int16_t mpu_getZAccelOffset () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getzgyrofifoenabled","title":"function mpu_getZGyroFIFOEnabled","text":"<pre><code>bool mpu_getZGyroFIFOEnabled () </code></pre> <p>Get gyroscope Z-axis FIFO enabled value. When set to 1, this bit enables GYRO_ZOUT_H and GYRO_ZOUT_L (Registers 71 and 72) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current gyroscope Z-axis FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getzgyrooffset","title":"function mpu_getZGyroOffset","text":"<pre><code>int16_t mpu_getZGyroOffset () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_getznegmotiondetected","title":"function mpu_getZNegMotionDetected","text":"<pre><code>bool mpu_getZNegMotionDetected () </code></pre> <p>Get Z-axis negative motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_ZNEG_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getzposmotiondetected","title":"function mpu_getZPosMotionDetected","text":"<pre><code>bool mpu_getZPosMotionDetected () </code></pre> <p>Get Z-axis positive motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_ZPOS_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getzeromotiondetected","title":"function mpu_getZeroMotionDetected","text":"<pre><code>bool mpu_getZeroMotionDetected () </code></pre> <p>Get zero motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_ZRMOT_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getzeromotiondetectionduration","title":"function mpu_getZeroMotionDetectionDuration","text":"<pre><code>uint8_t mpu_getZeroMotionDetectionDuration () </code></pre> <p>Get zero motion detection event duration threshold. This register configures the duration counter threshold for Zero Motion interrupt generation. The duration counter ticks at 16 Hz, therefore ZRMOT_DUR has a unit of 1 LSB = 64 ms. The Zero Motion duration counter increments while the absolute value of the accelerometer measurements are each less than the detection threshold (Register 33). The Zero Motion interrupt is triggered when the Zero Motion duration counter reaches the time count specified in this register.</p> <p>For more details on the Zero Motion detection interrupt, see Section 8.4 of the MPU-6000/MPU-6050 Product Specification document, as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current zero motion detection duration threshold value (LSB = 64ms) </p> <p>See also: mpu_RA_ZRMOT_DUR </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_getzeromotiondetectionthreshold","title":"function mpu_getZeroMotionDetectionThreshold","text":"<pre><code>uint8_t mpu_getZeroMotionDetectionThreshold () </code></pre> <p>Get zero motion detection event acceleration threshold. This register configures the detection threshold for Zero Motion interrupt generation. The unit of ZRMOT_THR is 1LSB = 2mg. Zero Motion is detected when the absolute value of the accelerometer measurements for the 3 axes are each less than the detection threshold. This condition increments the Zero Motion duration counter (Register 34). The Zero Motion interrupt is triggered when the Zero Motion duration counter reaches the time count specified in ZRMOT_DUR (Register 34).</p> <p>Unlike Free Fall or Motion detection, Zero Motion detection triggers an interrupt both when Zero Motion is first detected and when Zero Motion is no longer detected.</p> <p>When a zero motion event is detected, a Zero Motion Status will be indicated in the MOT_DETECT_STATUS register (Register 97). When a motion-to-zero-motion condition is detected, the status bit is set to 1. When a zero-motion-to- motion condition is detected, the status bit is set to 0.</p> <p>For more details on the Zero Motion detection interrupt, see Section 8.4 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current zero motion detection acceleration threshold value (LSB = 2mg) </p> <p>See also: mpu_RA_ZRMOT_THR </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_readmemoryblock","title":"function mpu_readMemoryBlock","text":"<pre><code>void mpu_readMemoryBlock (\nuint8_t * data,\nuint16_t dataSize,\nuint8_t bank,\nuint8_t address\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_readmemorybyte","title":"function mpu_readMemoryByte","text":"<pre><code>uint8_t mpu_readMemoryByte () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_reset","title":"function mpu_reset","text":"<pre><code>void mpu_reset () </code></pre> <p>Trigger a full device reset. A small delay of ~50ms may be desirable after triggering a reset. </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_DEVICE_RESET_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_resetaccelerometerpath","title":"function mpu_resetAccelerometerPath","text":"<pre><code>void mpu_resetAccelerometerPath () </code></pre> <p>Reset accelerometer signal path. The reset will revert the signal path analog to digital converters and filters to their power up configurations. </p> <p>See also: mpu_RA_SIGNAL_PATH_RESET </p> <p>See also: mpu_PATHRESET_ACCEL_RESET_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_resetdmp","title":"function mpu_resetDMP","text":"<pre><code>void mpu_resetDMP () </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_resetfifo","title":"function mpu_resetFIFO","text":"<pre><code>void mpu_resetFIFO () </code></pre> <p>Reset the FIFO. This bit resets the FIFO mpu6050.buffer when set to 1 while FIFO_EN equals 0. This bit automatically clears to 0 after the reset has been triggered. </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_FIFO_RESET_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_resetgyroscopepath","title":"function mpu_resetGyroscopePath","text":"<pre><code>void mpu_resetGyroscopePath () </code></pre> <p>Reset gyroscope signal path. The reset will revert the signal path analog to digital converters and filters to their power up configurations. </p> <p>See also: mpu_RA_SIGNAL_PATH_RESET </p> <p>See also: mpu_PATHRESET_GYRO_RESET_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_reseti2cmaster","title":"function mpu_resetI2CMaster","text":"<pre><code>void mpu_resetI2CMaster () </code></pre> <p>Reset the I2C Master. This bit resets the I2C Master when set to 1 while I2C_MST_EN equals 0. This bit automatically clears to 0 after the reset has been triggered. </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_I2C_MST_RESET_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_resetsensors","title":"function mpu_resetSensors","text":"<pre><code>void mpu_resetSensors () </code></pre> <p>Reset all sensor registers and signal paths. When set to 1, this bit resets the signal paths for all sensors (gyroscopes, accelerometers, and temperature sensor). This operation will also clear the sensor registers. This bit automatically clears to 0 after the reset has been triggered.</p> <p>When resetting only the signal path (and not the sensor registers), please use Register 104, SIGNAL_PATH_RESET.</p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_SIG_COND_RESET_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_resettemperaturepath","title":"function mpu_resetTemperaturePath","text":"<pre><code>void mpu_resetTemperaturePath () </code></pre> <p>Reset temperature sensor signal path. The reset will revert the signal path analog to digital converters and filters to their power up configurations. </p> <p>See also: mpu_RA_SIGNAL_PATH_RESET </p> <p>See also: mpu_PATHRESET_TEMP_RESET_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setaccelfifoenabled","title":"function mpu_setAccelFIFOEnabled","text":"<pre><code>void mpu_setAccelFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set accelerometer FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New accelerometer FIFO enabled value </li> </ul> <p>See also: getAccelFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setaccelxselftest","title":"function mpu_setAccelXSelfTest","text":"<pre><code>void mpu_setAccelXSelfTest (\nbool enabled\n) </code></pre> <p>Get self-test enabled setting for accelerometer X axis. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> Self-test enabled value </li> </ul> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setaccelyselftest","title":"function mpu_setAccelYSelfTest","text":"<pre><code>void mpu_setAccelYSelfTest (\nbool enabled\n) </code></pre> <p>Get self-test enabled value for accelerometer Y axis. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> Self-test enabled value </li> </ul> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setaccelzselftest","title":"function mpu_setAccelZSelfTest","text":"<pre><code>void mpu_setAccelZSelfTest (\nbool enabled\n) </code></pre> <p>Set self-test enabled value for accelerometer Z axis. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> Self-test enabled value </li> </ul> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setaccelerometerpowerondelay","title":"function mpu_setAccelerometerPowerOnDelay","text":"<pre><code>void mpu_setAccelerometerPowerOnDelay (\nuint8_t delay\n) </code></pre> <p>Set accelerometer power-on delay. </p> <p>Parameters:</p> <ul> <li><code>delay</code> New accelerometer power-on delay (0-3) </li> </ul> <p>See also: getAccelerometerPowerOnDelay() </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_ACCEL_ON_DELAY_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setauxvddiolevel","title":"function mpu_setAuxVDDIOLevel","text":"<pre><code>void mpu_setAuxVDDIOLevel (\nuint8_t level\n) </code></pre> <p>Set the auxiliary I2C supply voltage level. When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to the MPU-6000, which does not have a VLOGIC pin. </p> <p>Parameters:</p> <ul> <li><code>level</code> I2C supply voltage level (0=VLOGIC, 1=VDD) </li> </ul>"},{"location":"stm/MpuController_8hpp/#function-mpu_setclockoutputenabled","title":"function mpu_setClockOutputEnabled","text":"<pre><code>void mpu_setClockOutputEnabled (\nbool enabled\n) </code></pre> <p>Set reference clock output enabled status. When this bit is equal to 1, a reference clock output is provided at the CLKOUT pin. When this bit is equal to 0, the clock output is disabled. For further information regarding CLKOUT, please refer to the MPU-60X0 Product Specification document. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New reference clock output enabled status </li> </ul> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_CLKOUT_EN_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setclocksource","title":"function mpu_setClockSource","text":"<pre><code>void mpu_setClockSource (\nuint8_t source\n) </code></pre> <p>Set clock source setting. An internal 8MHz oscillator, gyroscope based clock, or external sources can be selected as the MPU-60X0 clock source. When the internal 8 MHz oscillator or an external source is chosen as the clock source, the MPU-60X0 can operate in low power modes with the gyroscopes disabled.</p> <p>Upon power up, the MPU-60X0 clock source defaults to the internal oscillator. However, it is highly recommended that the device be configured to use one of the gyroscopes (or an external clock source) as the clock reference for improved stability. The clock source can be selected according to the following table:</p> <p>Parameters:</p> <ul> <li><code>source</code> New clock source setting </li> </ul> <p>See also: getClockSource() </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_CLKSEL_BIT </p> <p>See also: mpu_PWR1_CLKSEL_LENGTH </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setdhpfmode","title":"function mpu_setDHPFMode","text":"<pre><code>void mpu_setDHPFMode (\nuint8_t mode\n) </code></pre> <p>Set the high-pass filter configuration. </p> <p>Parameters:</p> <ul> <li><code>bandwidth</code> New high-pass filter configuration </li> </ul> <p>See also: setDHPFMode() </p> <p>See also: mpu_DHPF_RESET </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setdlpfmode","title":"function mpu_setDLPFMode","text":"<pre><code>void mpu_setDLPFMode (\nuint8_t bandwidth\n) </code></pre> <p>Set digital low-pass filter configuration. </p> <p>Parameters:</p> <ul> <li><code>mode</code> New DLFP configuration setting </li> </ul> <p>See also: getDLPFBandwidth() </p> <p>See also: mpu_DLPF_BW_256 </p> <p>See also: mpu_RA_CONFIG </p> <p>See also: mpu_CFG_DLPF_CFG_BIT </p> <p>See also: mpu_CFG_DLPF_CFG_LENGTH </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setdmpconfig1","title":"function mpu_setDMPConfig1","text":"<pre><code>void mpu_setDMPConfig1 (\nuint8_t config\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setdmpconfig2","title":"function mpu_setDMPConfig2","text":"<pre><code>void mpu_setDMPConfig2 (\nuint8_t config\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setdmpenabled","title":"function mpu_setDMPEnabled","text":"<pre><code>void mpu_setDMPEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setdeviceid","title":"function mpu_setDeviceID","text":"<pre><code>void mpu_setDeviceID (\nuint8_t id\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setexternalframesync","title":"function mpu_setExternalFrameSync","text":"<pre><code>void mpu_setExternalFrameSync (\nuint8_t sync\n) </code></pre> <p>Set external FSYNC configuration. </p> <p>See also: getExternalFrameSync() </p> <p>See also: mpu_RA_CONFIG </p> <p>Parameters:</p> <ul> <li><code>sync</code> New FSYNC configuration value </li> </ul>"},{"location":"stm/MpuController_8hpp/#function-mpu_setexternalshadowdelayenabled","title":"function mpu_setExternalShadowDelayEnabled","text":"<pre><code>void mpu_setExternalShadowDelayEnabled (\nbool enabled\n) </code></pre> <p>Set external data shadow delay enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New external data shadow delay enabled status. </li> </ul> <p>See also: getExternalShadowDelayEnabled() </p> <p>See also: mpu_RA_I2C_MST_DELAY_CTRL </p> <p>See also: mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setfifobyte","title":"function mpu_setFIFOByte","text":"<pre><code>void mpu_setFIFOByte (\nuint8_t data\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setfifoenabled","title":"function mpu_setFIFOEnabled","text":"<pre><code>void mpu_setFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set FIFO enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New FIFO enabled status </li> </ul> <p>See also: getFIFOEnabled() </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_FIFO_EN_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setfsyncinterruptenabled","title":"function mpu_setFSyncInterruptEnabled","text":"<pre><code>void mpu_setFSyncInterruptEnabled (\nbool enabled\n) </code></pre> <p>Set FSYNC pin interrupt enabled setting. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New FSYNC pin interrupt enabled setting </li> </ul> <p>See also: getFSyncInterruptEnabled() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_FSYNC_INT_EN_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setfsyncinterruptlevel","title":"function mpu_setFSyncInterruptLevel","text":"<pre><code>void mpu_setFSyncInterruptLevel (\nbool level\n) </code></pre> <p>Set FSYNC interrupt logic level mode. </p> <p>Parameters:</p> <ul> <li><code>mode</code> New FSYNC interrupt mode (0=active-high, 1=active-low) </li> </ul> <p>See also: getFSyncInterruptMode() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_FSYNC_INT_LEVEL_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setfreefalldetectioncounterdecrement","title":"function mpu_setFreefallDetectionCounterDecrement","text":"<pre><code>void mpu_setFreefallDetectionCounterDecrement (\nuint8_t decrement\n) </code></pre> <p>Set Free Fall detection counter decrement configuration. </p> <p>Parameters:</p> <ul> <li><code>decrement</code> New decrement configuration value </li> </ul> <p>See also: getFreefallDetectionCounterDecrement() </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_FF_COUNT_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setfreefalldetectionduration","title":"function mpu_setFreefallDetectionDuration","text":"<pre><code>void mpu_setFreefallDetectionDuration (\nuint8_t duration\n) </code></pre> <p>Get free-fall event duration threshold. </p> <p>Parameters:</p> <ul> <li><code>duration</code> New free-fall duration threshold value (LSB = 1ms) </li> </ul> <p>See also: getFreefallDetectionDuration() </p> <p>See also: mpu_RA_FF_DUR </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setfreefalldetectionthreshold","title":"function mpu_setFreefallDetectionThreshold","text":"<pre><code>void mpu_setFreefallDetectionThreshold (\nuint8_t threshold\n) </code></pre> <p>Get free-fall event acceleration threshold. </p> <p>Parameters:</p> <ul> <li><code>threshold</code> New free-fall acceleration threshold value (LSB = 2mg) </li> </ul> <p>See also: getFreefallDetectionThreshold() </p> <p>See also: mpu_RA_FF_THR </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setfullscaleaccelrange","title":"function mpu_setFullScaleAccelRange","text":"<pre><code>void mpu_setFullScaleAccelRange (\nuint8_t range\n) </code></pre> <p>Set full-scale accelerometer range. </p> <p>Parameters:</p> <ul> <li><code>range</code> New full-scale accelerometer range setting </li> </ul> <p>See also: getFullScaleAccelRange() </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setfullscalegyrorange","title":"function mpu_setFullScaleGyroRange","text":"<pre><code>void mpu_setFullScaleGyroRange (\nuint8_t range\n) </code></pre> <p>Set full-scale gyroscope range. </p> <p>Parameters:</p> <ul> <li><code>range</code> New full-scale gyroscope range value </li> </ul> <p>See also: getFullScaleRange() </p> <p>See also: mpu_GYRO_FS_250 </p> <p>See also: mpu_RA_GYRO_CONFIG </p> <p>See also: mpu_GCONFIG_FS_SEL_BIT </p> <p>See also: mpu_GCONFIG_FS_SEL_LENGTH </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_seti2cbypassenabled","title":"function mpu_setI2CBypassEnabled","text":"<pre><code>void mpu_setI2CBypassEnabled (\nbool enabled\n) </code></pre> <p>Set I2C bypass enabled status. When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to 0, the host application processor will be able to directly access the auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host application processor will not be able to directly access the auxiliary I2C bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106 bit[5]). </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New I2C bypass enabled status </li> </ul> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_I2C_BYPASS_EN_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_seti2cmastermodeenabled","title":"function mpu_setI2CMasterModeEnabled","text":"<pre><code>void mpu_setI2CMasterModeEnabled (\nbool enabled\n) </code></pre> <p>Set I2C Master Mode enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New I2C Master Mode enabled status </li> </ul> <p>See also: getI2CMasterModeEnabled() </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_I2C_MST_EN_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setintdmpenabled","title":"function mpu_setIntDMPEnabled","text":"<pre><code>void mpu_setIntDMPEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setintdatareadyenabled","title":"function mpu_setIntDataReadyEnabled","text":"<pre><code>void mpu_setIntDataReadyEnabled (\nbool enabled\n) </code></pre> <p>Set Data Ready interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntDataReadyEnabled() </p> <p>See also: mpu_RA_INT_CFG </p> <p>See also: mpu_INTERRUPT_DATA_RDY_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setintenabled","title":"function mpu_setIntEnabled","text":"<pre><code>void mpu_setIntEnabled (\nuint8_t enabled\n) </code></pre> <p>Set full interrupt enabled status. Full register byte for all interrupts, for quick reading. Each bit should be set 0 for disabled, 1 for enabled. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntFreefallEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setintfifobufferoverflowenabled","title":"function mpu_setIntFIFOBufferOverflowEnabled","text":"<pre><code>void mpu_setIntFIFOBufferOverflowEnabled (\nbool enabled\n) </code></pre> <p>Set FIFO Buffer Overflow interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntFIFOBufferOverflowEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FIFO_OFLOW_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setintfreefallenabled","title":"function mpu_setIntFreefallEnabled","text":"<pre><code>void mpu_setIntFreefallEnabled (\nbool enabled\n) </code></pre> <p>Set Free Fall interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntFreefallEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setinti2cmasterenabled","title":"function mpu_setIntI2CMasterEnabled","text":"<pre><code>void mpu_setIntI2CMasterEnabled (\nbool enabled\n) </code></pre> <p>Set I2C Master interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntI2CMasterEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_I2C_MST_INT_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setintmotionenabled","title":"function mpu_setIntMotionEnabled","text":"<pre><code>void mpu_setIntMotionEnabled (\nbool enabled\n) </code></pre> <p>Set Motion Detection interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntMotionEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_MOT_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setintpllreadyenabled","title":"function mpu_setIntPLLReadyEnabled","text":"<pre><code>void mpu_setIntPLLReadyEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setintzeromotionenabled","title":"function mpu_setIntZeroMotionEnabled","text":"<pre><code>void mpu_setIntZeroMotionEnabled (\nbool enabled\n) </code></pre> <p>Set Zero Motion Detection interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntZeroMotionEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_ZMOT_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setinterruptdrive","title":"function mpu_setInterruptDrive","text":"<pre><code>void mpu_setInterruptDrive (\nbool drive\n) </code></pre> <p>Set interrupt drive mode. </p> <p>Parameters:</p> <ul> <li><code>drive</code> New interrupt drive mode (0=push-pull, 1=open-drain) </li> </ul> <p>See also: getInterruptDrive() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_OPEN_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setinterruptlatch","title":"function mpu_setInterruptLatch","text":"<pre><code>void mpu_setInterruptLatch (\nbool latch\n) </code></pre> <p>Set interrupt latch mode. </p> <p>Parameters:</p> <ul> <li><code>latch</code> New latch mode (0=50us-pulse, 1=latch-until-int-cleared) </li> </ul> <p>See also: getInterruptLatch() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_LATCH_INT_EN_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setinterruptlatchclear","title":"function mpu_setInterruptLatchClear","text":"<pre><code>void mpu_setInterruptLatchClear (\nbool clear\n) </code></pre> <p>Set interrupt latch clear mode. </p> <p>Parameters:</p> <ul> <li><code>clear</code> New latch clear mode (0=status-read-only, 1=any-register-read) </li> </ul> <p>See also: getInterruptLatchClear() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_RD_CLEAR_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setinterruptmode","title":"function mpu_setInterruptMode","text":"<pre><code>void mpu_setInterruptMode (\nbool mode\n) </code></pre> <p>Set interrupt logic level mode. </p> <p>Parameters:</p> <ul> <li><code>mode</code> New interrupt mode (0=active-high, 1=active-low) </li> </ul> <p>See also: getInterruptMode() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_LEVEL_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setmasterclockspeed","title":"function mpu_setMasterClockSpeed","text":"<pre><code>void mpu_setMasterClockSpeed (\nuint8_t speed\n) </code></pre> <p>Set I2C master clock speed. @reparam speed Current I2C master clock speed </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setmemorybank","title":"function mpu_setMemoryBank","text":"<pre><code>void mpu_setMemoryBank (\nuint8_t bank,\nbool prefetchEnabled,\nbool userBank\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setmemorystartaddress","title":"function mpu_setMemoryStartAddress","text":"<pre><code>void mpu_setMemoryStartAddress (\nuint8_t address\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setmotiondetectioncounterdecrement","title":"function mpu_setMotionDetectionCounterDecrement","text":"<pre><code>void mpu_setMotionDetectionCounterDecrement (\nuint8_t decrement\n) </code></pre> <p>Set Motion detection counter decrement configuration. </p> <p>Parameters:</p> <ul> <li><code>decrement</code> New decrement configuration value </li> </ul> <p>See also: getMotionDetectionCounterDecrement() </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_MOT_COUNT_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setmotiondetectionduration","title":"function mpu_setMotionDetectionDuration","text":"<pre><code>void mpu_setMotionDetectionDuration (\nuint8_t duration\n) </code></pre> <p>Set motion detection event duration threshold. </p> <p>Parameters:</p> <ul> <li><code>duration</code> New motion detection duration threshold value (LSB = 1ms) </li> </ul> <p>See also: getMotionDetectionDuration() </p> <p>See also: mpu_RA_MOT_DUR </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setmotiondetectionthreshold","title":"function mpu_setMotionDetectionThreshold","text":"<pre><code>void mpu_setMotionDetectionThreshold (\nuint8_t threshold\n) </code></pre> <p>Set free-fall event acceleration threshold. </p> <p>Parameters:</p> <ul> <li><code>threshold</code> New motion detection acceleration threshold value (LSB = 2mg) </li> </ul> <p>See also: getMotionDetectionThreshold() </p> <p>See also: mpu_RA_MOT_THR </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setmultimasterenabled","title":"function mpu_setMultiMasterEnabled","text":"<pre><code>void mpu_setMultiMasterEnabled (\nbool enabled\n) </code></pre> <p>Set multi-master enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New multi-master enabled value </li> </ul> <p>See also: getMultiMasterEnabled() </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setotpbankvalid","title":"function mpu_setOTPBankValid","text":"<pre><code>void mpu_setOTPBankValid (\nbool enabled\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setrate","title":"function mpu_setRate","text":"<pre><code>void mpu_setRate (\nuint8_t rate\n) </code></pre> <p>Set gyroscope sample rate divider. </p> <p>Parameters:</p> <ul> <li><code>rate</code> New sample rate divider </li> </ul> <p>See also: getRate() </p> <p>See also: mpu_RA_SMPLRT_DIV </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslave0fifoenabled","title":"function mpu_setSlave0FIFOEnabled","text":"<pre><code>void mpu_setSlave0FIFOEnabled (\nbool enabled\n) </code></pre> <p>Set Slave 0 FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New Slave 0 FIFO enabled value </li> </ul> <p>See also: getSlave0FIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslave1fifoenabled","title":"function mpu_setSlave1FIFOEnabled","text":"<pre><code>void mpu_setSlave1FIFOEnabled (\nbool enabled\n) </code></pre> <p>Set Slave 1 FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New Slave 1 FIFO enabled value </li> </ul> <p>See also: getSlave1FIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslave2fifoenabled","title":"function mpu_setSlave2FIFOEnabled","text":"<pre><code>void mpu_setSlave2FIFOEnabled (\nbool enabled\n) </code></pre> <p>Set Slave 2 FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New Slave 2 FIFO enabled value </li> </ul> <p>See also: getSlave2FIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslave3fifoenabled","title":"function mpu_setSlave3FIFOEnabled","text":"<pre><code>void mpu_setSlave3FIFOEnabled (\nbool enabled\n) </code></pre> <p>Set Slave 3 FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New Slave 3 FIFO enabled value </li> </ul> <p>See also: getSlave3FIFOEnabled() </p> <p>See also: mpu_RA_MST_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslave4address","title":"function mpu_setSlave4Address","text":"<pre><code>void mpu_setSlave4Address (\nuint8_t address\n) </code></pre> <p>Set the I2C address of Slave 4. </p> <p>Parameters:</p> <ul> <li><code>address</code> New address for Slave 4 </li> </ul> <p>See also: getSlave4Address() </p> <p>See also: mpu_RA_I2C_SLV4_ADDR </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslave4enabled","title":"function mpu_setSlave4Enabled","text":"<pre><code>void mpu_setSlave4Enabled (\nbool enabled\n) </code></pre> <p>Set the enabled value for Slave 4. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New enabled value for Slave 4 </li> </ul> <p>See also: getSlave4Enabled() </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslave4interruptenabled","title":"function mpu_setSlave4InterruptEnabled","text":"<pre><code>void mpu_setSlave4InterruptEnabled (\nbool enabled\n) </code></pre> <p>Set the enabled value for Slave 4 transaction interrupts. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New enabled value for Slave 4 transaction interrupts. </li> </ul> <p>See also: getSlave4InterruptEnabled() </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslave4masterdelay","title":"function mpu_setSlave4MasterDelay","text":"<pre><code>void mpu_setSlave4MasterDelay (\nuint8_t delay\n) </code></pre> <p>Set Slave 4 master delay value. </p> <p>Parameters:</p> <ul> <li><code>delay</code> New Slave 4 master delay value </li> </ul> <p>See also: getSlave4MasterDelay() </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslave4outputbyte","title":"function mpu_setSlave4OutputByte","text":"<pre><code>void mpu_setSlave4OutputByte (\nuint8_t data\n) </code></pre> <p>Set new byte to write to Slave 4. This register stores the data to be written into the Slave 4. If I2C_SLV4_RW is set 1 (set to read), this register has no effect. </p> <p>Parameters:</p> <ul> <li><code>data</code> New byte to write to Slave 4 </li> </ul> <p>See also: mpu_RA_I2C_SLV4_DO </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslave4register","title":"function mpu_setSlave4Register","text":"<pre><code>void mpu_setSlave4Register (\nuint8_t reg\n) </code></pre> <p>Set the active internal register for Slave 4. </p> <p>Parameters:</p> <ul> <li><code>reg</code> New active register for Slave 4 </li> </ul> <p>See also: getSlave4Register() </p> <p>See also: mpu_RA_I2C_SLV4_REG </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslave4writemode","title":"function mpu_setSlave4WriteMode","text":"<pre><code>void mpu_setSlave4WriteMode (\nbool mode\n) </code></pre> <p>Set write mode for the Slave 4. </p> <p>Parameters:</p> <ul> <li><code>mode</code> New write mode for Slave 4 (0 = register address + data, 1 = data only) </li> </ul> <p>See also: getSlave4WriteMode() </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslaveaddress","title":"function mpu_setSlaveAddress","text":"<pre><code>void mpu_setSlaveAddress (\nuint8_t num,\nuint8_t address\n) </code></pre> <p>Set the I2C address of the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>address</code> New address for specified slave </li> </ul> <p>See also: getSlaveAddress() </p> <p>See also: mpu_RA_I2C_SLV0_ADDR </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslavedatalength","title":"function mpu_setSlaveDataLength","text":"<pre><code>void mpu_setSlaveDataLength (\nuint8_t num,\nuint8_t length\n) </code></pre> <p>Set number of bytes to read for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>length</code> Number of bytes to read for specified slave </li> </ul> <p>See also: getSlaveDataLength() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslavedelayenabled","title":"function mpu_setSlaveDelayEnabled","text":"<pre><code>void mpu_setSlaveDelayEnabled (\nuint8_t num,\nbool enabled\n) </code></pre> <p>Set slave delay enabled status. </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-4) </li> <li><code>enabled</code> New slave delay enabled status. </li> </ul> <p>See also: mpu_RA_I2C_MST_DELAY_CTRL </p> <p>See also: mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslaveenabled","title":"function mpu_setSlaveEnabled","text":"<pre><code>void mpu_setSlaveEnabled (\nuint8_t num,\nbool enabled\n) </code></pre> <p>Set the enabled value for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>enabled</code> New enabled value for specified slave </li> </ul> <p>See also: getSlaveEnabled() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslaveoutputbyte","title":"function mpu_setSlaveOutputByte","text":"<pre><code>void mpu_setSlaveOutputByte (\nuint8_t num,\nuint8_t data\n) </code></pre> <p>Write byte to Data Output container for specified slave. This register holds the output data written into Slave when Slave is set to write mode. For further information regarding Slave control, please refer to Registers 37 to 39 and immediately following. </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>data</code> Byte to write </li> </ul> <p>See also: mpu_RA_I2C_SLV0_DO </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslavereadwritetransitionenabled","title":"function mpu_setSlaveReadWriteTransitionEnabled","text":"<pre><code>void mpu_setSlaveReadWriteTransitionEnabled (\nbool enabled\n) </code></pre> <p>Set slave read/write transition enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New slave read/write transition enabled value </li> </ul> <p>See also: getSlaveReadWriteTransitionEnabled() </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslaveregister","title":"function mpu_setSlaveRegister","text":"<pre><code>void mpu_setSlaveRegister (\nuint8_t num,\nuint8_t reg\n) </code></pre> <p>Set the active internal register for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>reg</code> New active register for specified slave </li> </ul> <p>See also: getSlaveRegister() </p> <p>See also: mpu_RA_I2C_SLV0_REG </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslavewordbyteswap","title":"function mpu_setSlaveWordByteSwap","text":"<pre><code>void mpu_setSlaveWordByteSwap (\nuint8_t num,\nbool enabled\n) </code></pre> <p>Set word pair byte-swapping enabled for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>enabled</code> New word pair byte-swapping enabled value for specified slave </li> </ul> <p>See also: getSlaveWordByteSwap() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslavewordgroupoffset","title":"function mpu_setSlaveWordGroupOffset","text":"<pre><code>void mpu_setSlaveWordGroupOffset (\nuint8_t num,\nbool enabled\n) </code></pre> <p>Set word pair grouping order offset for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>enabled</code> New word pair grouping order offset for specified slave </li> </ul> <p>See also: getSlaveWordGroupOffset() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setslavewritemode","title":"function mpu_setSlaveWriteMode","text":"<pre><code>void mpu_setSlaveWriteMode (\nuint8_t num,\nbool mode\n) </code></pre> <p>Set write mode for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>mode</code> New write mode for specified slave (0 = register address + data, 1 = data only) </li> </ul> <p>See also: getSlaveWriteMode() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setsleepenabled","title":"function mpu_setSleepEnabled","text":"<pre><code>void mpu_setSleepEnabled (\nbool enabled\n) </code></pre> <p>Set sleep mode status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New sleep mode enabled status </li> </ul> <p>See also: getSleepEnabled() </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_SLEEP_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setstandbyxaccelenabled","title":"function mpu_setStandbyXAccelEnabled","text":"<pre><code>void mpu_setStandbyXAccelEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setstandbyxgyroenabled","title":"function mpu_setStandbyXGyroEnabled","text":"<pre><code>void mpu_setStandbyXGyroEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setstandbyyaccelenabled","title":"function mpu_setStandbyYAccelEnabled","text":"<pre><code>void mpu_setStandbyYAccelEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setstandbyygyroenabled","title":"function mpu_setStandbyYGyroEnabled","text":"<pre><code>void mpu_setStandbyYGyroEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setstandbyzaccelenabled","title":"function mpu_setStandbyZAccelEnabled","text":"<pre><code>void mpu_setStandbyZAccelEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setstandbyzgyroenabled","title":"function mpu_setStandbyZGyroEnabled","text":"<pre><code>void mpu_setStandbyZGyroEnabled (\nbool enabled\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_settempfifoenabled","title":"function mpu_setTempFIFOEnabled","text":"<pre><code>void mpu_setTempFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set temperature FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New temperature FIFO enabled value </li> </ul> <p>See also: getTempFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_settempsensorenabled","title":"function mpu_setTempSensorEnabled","text":"<pre><code>void mpu_setTempSensorEnabled (\nbool enabled\n) </code></pre> <p>Set temperature sensor enabled status. Note: this register stores the disabled value, but for consistency with the rest of the code, the function is named and used with standard true/false values to indicate whether the sensor is enabled or disabled, respectively.</p> <p>Parameters:</p> <ul> <li><code>enabled</code> New temperature sensor enabled status </li> </ul> <p>See also: getTempSensorEnabled() </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_TEMP_DIS_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setwaitforexternalsensorenabled","title":"function mpu_setWaitForExternalSensorEnabled","text":"<pre><code>void mpu_setWaitForExternalSensorEnabled (\nbool enabled\n) </code></pre> <p>Set wait-for-external-sensor-data enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New wait-for-external-sensor-data enabled value </li> </ul> <p>See also: getWaitForExternalSensorEnabled() </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setwakecycleenabled","title":"function mpu_setWakeCycleEnabled","text":"<pre><code>void mpu_setWakeCycleEnabled (\nbool enabled\n) </code></pre> <p>Set wake cycle enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New sleep mode enabled status </li> </ul> <p>See also: getWakeCycleEnabled() </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_CYCLE_BIT </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setwakefrequency","title":"function mpu_setWakeFrequency","text":"<pre><code>void mpu_setWakeFrequency (\nuint8_t frequency\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setxacceloffset","title":"function mpu_setXAccelOffset","text":"<pre><code>void mpu_setXAccelOffset (\nint16_t offset\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setxfinegain","title":"function mpu_setXFineGain","text":"<pre><code>void mpu_setXFineGain (\nint8_t gain\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setxgyrofifoenabled","title":"function mpu_setXGyroFIFOEnabled","text":"<pre><code>void mpu_setXGyroFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set gyroscope X-axis FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New gyroscope X-axis FIFO enabled value </li> </ul> <p>See also: getXGyroFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setxgyrooffset","title":"function mpu_setXGyroOffset","text":"<pre><code>void mpu_setXGyroOffset (\nint16_t offset\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setxgyrooffsettc","title":"function mpu_setXGyroOffsetTC","text":"<pre><code>void mpu_setXGyroOffsetTC (\nint8_t offset\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setyacceloffset","title":"function mpu_setYAccelOffset","text":"<pre><code>void mpu_setYAccelOffset (\nint16_t offset\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setyfinegain","title":"function mpu_setYFineGain","text":"<pre><code>void mpu_setYFineGain (\nint8_t gain\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setygyrofifoenabled","title":"function mpu_setYGyroFIFOEnabled","text":"<pre><code>void mpu_setYGyroFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set gyroscope Y-axis FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New gyroscope Y-axis FIFO enabled value </li> </ul> <p>See also: getYGyroFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setygyrooffset","title":"function mpu_setYGyroOffset","text":"<pre><code>void mpu_setYGyroOffset (\nint16_t offset\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setygyrooffsettc","title":"function mpu_setYGyroOffsetTC","text":"<pre><code>void mpu_setYGyroOffsetTC (\nint8_t offset\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setzacceloffset","title":"function mpu_setZAccelOffset","text":"<pre><code>void mpu_setZAccelOffset (\nint16_t offset\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setzfinegain","title":"function mpu_setZFineGain","text":"<pre><code>void mpu_setZFineGain (\nint8_t gain\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setzgyrofifoenabled","title":"function mpu_setZGyroFIFOEnabled","text":"<pre><code>void mpu_setZGyroFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set gyroscope Z-axis FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New gyroscope Z-axis FIFO enabled value </li> </ul> <p>See also: getZGyroFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setzgyrooffset","title":"function mpu_setZGyroOffset","text":"<pre><code>void mpu_setZGyroOffset (\nint16_t offset\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setzgyrooffsettc","title":"function mpu_setZGyroOffsetTC","text":"<pre><code>void mpu_setZGyroOffsetTC (\nint8_t offset\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#function-mpu_setzeromotiondetectionduration","title":"function mpu_setZeroMotionDetectionDuration","text":"<pre><code>void mpu_setZeroMotionDetectionDuration (\nuint8_t duration\n) </code></pre> <p>Set zero motion detection event duration threshold. </p> <p>Parameters:</p> <ul> <li><code>duration</code> New zero motion detection duration threshold value (LSB = 1ms) </li> </ul> <p>See also: getZeroMotionDetectionDuration() </p> <p>See also: mpu_RA_ZRMOT_DUR </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_setzeromotiondetectionthreshold","title":"function mpu_setZeroMotionDetectionThreshold","text":"<pre><code>void mpu_setZeroMotionDetectionThreshold (\nuint8_t threshold\n) </code></pre> <p>Set zero motion detection event acceleration threshold. </p> <p>Parameters:</p> <ul> <li><code>threshold</code> New zero motion detection acceleration threshold value (LSB = 2mg) </li> </ul> <p>See also: getZeroMotionDetectionThreshold() </p> <p>See also: mpu_RA_ZRMOT_THR </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_switchspienabled","title":"function mpu_switchSPIEnabled","text":"<pre><code>void mpu_switchSPIEnabled (\nbool enabled\n) </code></pre> <p>Switch from I2C to SPI mode (MPU-6000 only) If this is set, the primary SPI interface will be enabled in place of the disabled primary I2C interface. </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_testconnection","title":"function mpu_testConnection","text":"<pre><code>bool mpu_testConnection () </code></pre> <p>Verify the I2C connection. Make sure the device is connected and responds as expected. </p> <p>Returns:</p> <p>True if connection is valid, false otherwise </p>"},{"location":"stm/MpuController_8hpp/#function-mpu_writememorybyte","title":"function mpu_writeMemoryByte","text":"<pre><code>void mpu_writeMemoryByte (\nuint8_t data\n) </code></pre>"},{"location":"stm/MpuController_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"stm/MpuController_8hpp/#define-mpu_accel_fifo_en_bit","title":"define mpu_ACCEL_FIFO_EN_BIT","text":"<pre><code>#define mpu_ACCEL_FIFO_EN_BIT 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_accel_fs_16","title":"define mpu_ACCEL_FS_16","text":"<pre><code>#define mpu_ACCEL_FS_16 0x03\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_accel_fs_2","title":"define mpu_ACCEL_FS_2","text":"<pre><code>#define mpu_ACCEL_FS_2 0x00\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_accel_fs_4","title":"define mpu_ACCEL_FS_4","text":"<pre><code>#define mpu_ACCEL_FS_4 0x01\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_accel_fs_8","title":"define mpu_ACCEL_FS_8","text":"<pre><code>#define mpu_ACCEL_FS_8 0x02\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_aconfig_accel_hpf_bit","title":"define mpu_ACONFIG_ACCEL_HPF_BIT","text":"<pre><code>#define mpu_ACONFIG_ACCEL_HPF_BIT 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_aconfig_accel_hpf_length","title":"define mpu_ACONFIG_ACCEL_HPF_LENGTH","text":"<pre><code>#define mpu_ACONFIG_ACCEL_HPF_LENGTH 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_aconfig_afs_sel_bit","title":"define mpu_ACONFIG_AFS_SEL_BIT","text":"<pre><code>#define mpu_ACONFIG_AFS_SEL_BIT 4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_aconfig_afs_sel_length","title":"define mpu_ACONFIG_AFS_SEL_LENGTH","text":"<pre><code>#define mpu_ACONFIG_AFS_SEL_LENGTH 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_aconfig_xa_st_bit","title":"define mpu_ACONFIG_XA_ST_BIT","text":"<pre><code>#define mpu_ACONFIG_XA_ST_BIT 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_aconfig_ya_st_bit","title":"define mpu_ACONFIG_YA_ST_BIT","text":"<pre><code>#define mpu_ACONFIG_YA_ST_BIT 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_aconfig_za_st_bit","title":"define mpu_ACONFIG_ZA_ST_BIT","text":"<pre><code>#define mpu_ACONFIG_ZA_ST_BIT 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_address_ad0_high","title":"define mpu_ADDRESS_AD0_HIGH","text":"<pre><code>#define mpu_ADDRESS_AD0_HIGH 0x69\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_address_ad0_low","title":"define mpu_ADDRESS_AD0_LOW","text":"<pre><code>#define mpu_ADDRESS_AD0_LOW 0x68\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_banksel_cfg_user_bank_bit","title":"define mpu_BANKSEL_CFG_USER_BANK_BIT","text":"<pre><code>#define mpu_BANKSEL_CFG_USER_BANK_BIT 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_banksel_mem_sel_bit","title":"define mpu_BANKSEL_MEM_SEL_BIT","text":"<pre><code>#define mpu_BANKSEL_MEM_SEL_BIT 4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_banksel_mem_sel_length","title":"define mpu_BANKSEL_MEM_SEL_LENGTH","text":"<pre><code>#define mpu_BANKSEL_MEM_SEL_LENGTH 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_banksel_prftch_en_bit","title":"define mpu_BANKSEL_PRFTCH_EN_BIT","text":"<pre><code>#define mpu_BANKSEL_PRFTCH_EN_BIT 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_cfg_dlpf_cfg_bit","title":"define mpu_CFG_DLPF_CFG_BIT","text":"<pre><code>#define mpu_CFG_DLPF_CFG_BIT 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_cfg_dlpf_cfg_length","title":"define mpu_CFG_DLPF_CFG_LENGTH","text":"<pre><code>#define mpu_CFG_DLPF_CFG_LENGTH 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_cfg_ext_sync_set_bit","title":"define mpu_CFG_EXT_SYNC_SET_BIT","text":"<pre><code>#define mpu_CFG_EXT_SYNC_SET_BIT 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_cfg_ext_sync_set_length","title":"define mpu_CFG_EXT_SYNC_SET_LENGTH","text":"<pre><code>#define mpu_CFG_EXT_SYNC_SET_LENGTH 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_div_258","title":"define mpu_CLOCK_DIV_258","text":"<pre><code>#define mpu_CLOCK_DIV_258 0x8\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_div_267","title":"define mpu_CLOCK_DIV_267","text":"<pre><code>#define mpu_CLOCK_DIV_267 0x7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_div_276","title":"define mpu_CLOCK_DIV_276","text":"<pre><code>#define mpu_CLOCK_DIV_276 0x6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_div_286","title":"define mpu_CLOCK_DIV_286","text":"<pre><code>#define mpu_CLOCK_DIV_286 0x5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_div_296","title":"define mpu_CLOCK_DIV_296","text":"<pre><code>#define mpu_CLOCK_DIV_296 0x4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_div_308","title":"define mpu_CLOCK_DIV_308","text":"<pre><code>#define mpu_CLOCK_DIV_308 0x3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_div_320","title":"define mpu_CLOCK_DIV_320","text":"<pre><code>#define mpu_CLOCK_DIV_320 0x2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_div_333","title":"define mpu_CLOCK_DIV_333","text":"<pre><code>#define mpu_CLOCK_DIV_333 0x1\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_div_348","title":"define mpu_CLOCK_DIV_348","text":"<pre><code>#define mpu_CLOCK_DIV_348 0x0\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_div_364","title":"define mpu_CLOCK_DIV_364","text":"<pre><code>#define mpu_CLOCK_DIV_364 0xF\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_div_381","title":"define mpu_CLOCK_DIV_381","text":"<pre><code>#define mpu_CLOCK_DIV_381 0xE\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_div_400","title":"define mpu_CLOCK_DIV_400","text":"<pre><code>#define mpu_CLOCK_DIV_400 0xD\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_div_421","title":"define mpu_CLOCK_DIV_421","text":"<pre><code>#define mpu_CLOCK_DIV_421 0xC\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_div_444","title":"define mpu_CLOCK_DIV_444","text":"<pre><code>#define mpu_CLOCK_DIV_444 0xB\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_div_471","title":"define mpu_CLOCK_DIV_471","text":"<pre><code>#define mpu_CLOCK_DIV_471 0xA\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_div_500","title":"define mpu_CLOCK_DIV_500","text":"<pre><code>#define mpu_CLOCK_DIV_500 0x9\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_internal","title":"define mpu_CLOCK_INTERNAL","text":"<pre><code>#define mpu_CLOCK_INTERNAL 0x00\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_keep_reset","title":"define mpu_CLOCK_KEEP_RESET","text":"<pre><code>#define mpu_CLOCK_KEEP_RESET 0x07\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_pll_ext19m","title":"define mpu_CLOCK_PLL_EXT19M","text":"<pre><code>#define mpu_CLOCK_PLL_EXT19M 0x05\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_pll_ext32k","title":"define mpu_CLOCK_PLL_EXT32K","text":"<pre><code>#define mpu_CLOCK_PLL_EXT32K 0x04\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_pll_xgyro","title":"define mpu_CLOCK_PLL_XGYRO","text":"<pre><code>#define mpu_CLOCK_PLL_XGYRO 0x01\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_pll_ygyro","title":"define mpu_CLOCK_PLL_YGYRO","text":"<pre><code>#define mpu_CLOCK_PLL_YGYRO 0x02\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_clock_pll_zgyro","title":"define mpu_CLOCK_PLL_ZGYRO","text":"<pre><code>#define mpu_CLOCK_PLL_ZGYRO 0x03\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_default_address","title":"define mpu_DEFAULT_ADDRESS","text":"<pre><code>#define mpu_DEFAULT_ADDRESS mpu_ADDRESS_AD0_LOW\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_delayctrl_delay_es_shadow_bit","title":"define mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT","text":"<pre><code>#define mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_delayctrl_i2c_slv0_dly_en_bit","title":"define mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT","text":"<pre><code>#define mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT 0\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_delayctrl_i2c_slv1_dly_en_bit","title":"define mpu_DELAYCTRL_I2C_SLV1_DLY_EN_BIT","text":"<pre><code>#define mpu_DELAYCTRL_I2C_SLV1_DLY_EN_BIT 1\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_delayctrl_i2c_slv2_dly_en_bit","title":"define mpu_DELAYCTRL_I2C_SLV2_DLY_EN_BIT","text":"<pre><code>#define mpu_DELAYCTRL_I2C_SLV2_DLY_EN_BIT 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_delayctrl_i2c_slv3_dly_en_bit","title":"define mpu_DELAYCTRL_I2C_SLV3_DLY_EN_BIT","text":"<pre><code>#define mpu_DELAYCTRL_I2C_SLV3_DLY_EN_BIT 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_delayctrl_i2c_slv4_dly_en_bit","title":"define mpu_DELAYCTRL_I2C_SLV4_DLY_EN_BIT","text":"<pre><code>#define mpu_DELAYCTRL_I2C_SLV4_DLY_EN_BIT 4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_detect_accel_on_delay_bit","title":"define mpu_DETECT_ACCEL_ON_DELAY_BIT","text":"<pre><code>#define mpu_DETECT_ACCEL_ON_DELAY_BIT 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_detect_accel_on_delay_length","title":"define mpu_DETECT_ACCEL_ON_DELAY_LENGTH","text":"<pre><code>#define mpu_DETECT_ACCEL_ON_DELAY_LENGTH 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_detect_decrement_1","title":"define mpu_DETECT_DECREMENT_1","text":"<pre><code>#define mpu_DETECT_DECREMENT_1 0x1\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_detect_decrement_2","title":"define mpu_DETECT_DECREMENT_2","text":"<pre><code>#define mpu_DETECT_DECREMENT_2 0x2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_detect_decrement_4","title":"define mpu_DETECT_DECREMENT_4","text":"<pre><code>#define mpu_DETECT_DECREMENT_4 0x3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_detect_decrement_reset","title":"define mpu_DETECT_DECREMENT_RESET","text":"<pre><code>#define mpu_DETECT_DECREMENT_RESET 0x0\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_detect_ff_count_bit","title":"define mpu_DETECT_FF_COUNT_BIT","text":"<pre><code>#define mpu_DETECT_FF_COUNT_BIT 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_detect_ff_count_length","title":"define mpu_DETECT_FF_COUNT_LENGTH","text":"<pre><code>#define mpu_DETECT_FF_COUNT_LENGTH 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_detect_mot_count_bit","title":"define mpu_DETECT_MOT_COUNT_BIT","text":"<pre><code>#define mpu_DETECT_MOT_COUNT_BIT 1\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_detect_mot_count_length","title":"define mpu_DETECT_MOT_COUNT_LENGTH","text":"<pre><code>#define mpu_DETECT_MOT_COUNT_LENGTH 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dhpf_0p63","title":"define mpu_DHPF_0P63","text":"<pre><code>#define mpu_DHPF_0P63 0x04\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dhpf_1p25","title":"define mpu_DHPF_1P25","text":"<pre><code>#define mpu_DHPF_1P25 0x03\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dhpf_2p5","title":"define mpu_DHPF_2P5","text":"<pre><code>#define mpu_DHPF_2P5 0x02\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dhpf_5","title":"define mpu_DHPF_5","text":"<pre><code>#define mpu_DHPF_5 0x01\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dhpf_hold","title":"define mpu_DHPF_HOLD","text":"<pre><code>#define mpu_DHPF_HOLD 0x07\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dhpf_reset","title":"define mpu_DHPF_RESET","text":"<pre><code>#define mpu_DHPF_RESET 0x00\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dlpf_bw_10","title":"define mpu_DLPF_BW_10","text":"<pre><code>#define mpu_DLPF_BW_10 0x05\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dlpf_bw_188","title":"define mpu_DLPF_BW_188","text":"<pre><code>#define mpu_DLPF_BW_188 0x01\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dlpf_bw_20","title":"define mpu_DLPF_BW_20","text":"<pre><code>#define mpu_DLPF_BW_20 0x04\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dlpf_bw_256","title":"define mpu_DLPF_BW_256","text":"<pre><code>#define mpu_DLPF_BW_256 0x00\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dlpf_bw_42","title":"define mpu_DLPF_BW_42","text":"<pre><code>#define mpu_DLPF_BW_42 0x03\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dlpf_bw_5","title":"define mpu_DLPF_BW_5","text":"<pre><code>#define mpu_DLPF_BW_5 0x06\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dlpf_bw_98","title":"define mpu_DLPF_BW_98","text":"<pre><code>#define mpu_DLPF_BW_98 0x02\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dmpint_0_bit","title":"define mpu_DMPINT_0_BIT","text":"<pre><code>#define mpu_DMPINT_0_BIT 0\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dmpint_1_bit","title":"define mpu_DMPINT_1_BIT","text":"<pre><code>#define mpu_DMPINT_1_BIT 1\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dmpint_2_bit","title":"define mpu_DMPINT_2_BIT","text":"<pre><code>#define mpu_DMPINT_2_BIT 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dmpint_3_bit","title":"define mpu_DMPINT_3_BIT","text":"<pre><code>#define mpu_DMPINT_3_BIT 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dmpint_4_bit","title":"define mpu_DMPINT_4_BIT","text":"<pre><code>#define mpu_DMPINT_4_BIT 4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dmpint_5_bit","title":"define mpu_DMPINT_5_BIT","text":"<pre><code>#define mpu_DMPINT_5_BIT 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dmp_memory_banks","title":"define mpu_DMP_MEMORY_BANKS","text":"<pre><code>#define mpu_DMP_MEMORY_BANKS 8\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dmp_memory_bank_size","title":"define mpu_DMP_MEMORY_BANK_SIZE","text":"<pre><code>#define mpu_DMP_MEMORY_BANK_SIZE 256\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_dmp_memory_chunk_size","title":"define mpu_DMP_MEMORY_CHUNK_SIZE","text":"<pre><code>#define mpu_DMP_MEMORY_CHUNK_SIZE 16\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ext_sync_accel_xout_l","title":"define mpu_EXT_SYNC_ACCEL_XOUT_L","text":"<pre><code>#define mpu_EXT_SYNC_ACCEL_XOUT_L 0x5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ext_sync_accel_yout_l","title":"define mpu_EXT_SYNC_ACCEL_YOUT_L","text":"<pre><code>#define mpu_EXT_SYNC_ACCEL_YOUT_L 0x6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ext_sync_accel_zout_l","title":"define mpu_EXT_SYNC_ACCEL_ZOUT_L","text":"<pre><code>#define mpu_EXT_SYNC_ACCEL_ZOUT_L 0x7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ext_sync_disabled","title":"define mpu_EXT_SYNC_DISABLED","text":"<pre><code>#define mpu_EXT_SYNC_DISABLED 0x0\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ext_sync_gyro_xout_l","title":"define mpu_EXT_SYNC_GYRO_XOUT_L","text":"<pre><code>#define mpu_EXT_SYNC_GYRO_XOUT_L 0x2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ext_sync_gyro_yout_l","title":"define mpu_EXT_SYNC_GYRO_YOUT_L","text":"<pre><code>#define mpu_EXT_SYNC_GYRO_YOUT_L 0x3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ext_sync_gyro_zout_l","title":"define mpu_EXT_SYNC_GYRO_ZOUT_L","text":"<pre><code>#define mpu_EXT_SYNC_GYRO_ZOUT_L 0x4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ext_sync_temp_out_l","title":"define mpu_EXT_SYNC_TEMP_OUT_L","text":"<pre><code>#define mpu_EXT_SYNC_TEMP_OUT_L 0x1\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_gconfig_fs_sel_bit","title":"define mpu_GCONFIG_FS_SEL_BIT","text":"<pre><code>#define mpu_GCONFIG_FS_SEL_BIT 4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_gconfig_fs_sel_length","title":"define mpu_GCONFIG_FS_SEL_LENGTH","text":"<pre><code>#define mpu_GCONFIG_FS_SEL_LENGTH 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_gyro_fs_1000","title":"define mpu_GYRO_FS_1000","text":"<pre><code>#define mpu_GYRO_FS_1000 0x02\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_gyro_fs_2000","title":"define mpu_GYRO_FS_2000","text":"<pre><code>#define mpu_GYRO_FS_2000 0x03\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_gyro_fs_250","title":"define mpu_GYRO_FS_250","text":"<pre><code>#define mpu_GYRO_FS_250 0x00\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_gyro_fs_500","title":"define mpu_GYRO_FS_500","text":"<pre><code>#define mpu_GYRO_FS_500 0x01\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_mst_clk_bit","title":"define mpu_I2C_MST_CLK_BIT","text":"<pre><code>#define mpu_I2C_MST_CLK_BIT 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_mst_clk_length","title":"define mpu_I2C_MST_CLK_LENGTH","text":"<pre><code>#define mpu_I2C_MST_CLK_LENGTH 4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_mst_p_nsr_bit","title":"define mpu_I2C_MST_P_NSR_BIT","text":"<pre><code>#define mpu_I2C_MST_P_NSR_BIT 4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv4_addr_bit","title":"define mpu_I2C_SLV4_ADDR_BIT","text":"<pre><code>#define mpu_I2C_SLV4_ADDR_BIT 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv4_addr_length","title":"define mpu_I2C_SLV4_ADDR_LENGTH","text":"<pre><code>#define mpu_I2C_SLV4_ADDR_LENGTH 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv4_en_bit","title":"define mpu_I2C_SLV4_EN_BIT","text":"<pre><code>#define mpu_I2C_SLV4_EN_BIT 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv4_int_en_bit","title":"define mpu_I2C_SLV4_INT_EN_BIT","text":"<pre><code>#define mpu_I2C_SLV4_INT_EN_BIT 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv4_mst_dly_bit","title":"define mpu_I2C_SLV4_MST_DLY_BIT","text":"<pre><code>#define mpu_I2C_SLV4_MST_DLY_BIT 4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv4_mst_dly_length","title":"define mpu_I2C_SLV4_MST_DLY_LENGTH","text":"<pre><code>#define mpu_I2C_SLV4_MST_DLY_LENGTH 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv4_reg_dis_bit","title":"define mpu_I2C_SLV4_REG_DIS_BIT","text":"<pre><code>#define mpu_I2C_SLV4_REG_DIS_BIT 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv4_rw_bit","title":"define mpu_I2C_SLV4_RW_BIT","text":"<pre><code>#define mpu_I2C_SLV4_RW_BIT 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv_addr_bit","title":"define mpu_I2C_SLV_ADDR_BIT","text":"<pre><code>#define mpu_I2C_SLV_ADDR_BIT 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv_addr_length","title":"define mpu_I2C_SLV_ADDR_LENGTH","text":"<pre><code>#define mpu_I2C_SLV_ADDR_LENGTH 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv_byte_sw_bit","title":"define mpu_I2C_SLV_BYTE_SW_BIT","text":"<pre><code>#define mpu_I2C_SLV_BYTE_SW_BIT 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv_en_bit","title":"define mpu_I2C_SLV_EN_BIT","text":"<pre><code>#define mpu_I2C_SLV_EN_BIT 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv_grp_bit","title":"define mpu_I2C_SLV_GRP_BIT","text":"<pre><code>#define mpu_I2C_SLV_GRP_BIT 4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv_len_bit","title":"define mpu_I2C_SLV_LEN_BIT","text":"<pre><code>#define mpu_I2C_SLV_LEN_BIT 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv_len_length","title":"define mpu_I2C_SLV_LEN_LENGTH","text":"<pre><code>#define mpu_I2C_SLV_LEN_LENGTH 4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv_reg_dis_bit","title":"define mpu_I2C_SLV_REG_DIS_BIT","text":"<pre><code>#define mpu_I2C_SLV_REG_DIS_BIT 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_i2c_slv_rw_bit","title":"define mpu_I2C_SLV_RW_BIT","text":"<pre><code>#define mpu_I2C_SLV_RW_BIT 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_intcfg_clkout_en_bit","title":"define mpu_INTCFG_CLKOUT_EN_BIT","text":"<pre><code>#define mpu_INTCFG_CLKOUT_EN_BIT 0\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_intcfg_fsync_int_en_bit","title":"define mpu_INTCFG_FSYNC_INT_EN_BIT","text":"<pre><code>#define mpu_INTCFG_FSYNC_INT_EN_BIT 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_intcfg_fsync_int_level_bit","title":"define mpu_INTCFG_FSYNC_INT_LEVEL_BIT","text":"<pre><code>#define mpu_INTCFG_FSYNC_INT_LEVEL_BIT 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_intcfg_i2c_bypass_en_bit","title":"define mpu_INTCFG_I2C_BYPASS_EN_BIT","text":"<pre><code>#define mpu_INTCFG_I2C_BYPASS_EN_BIT 1\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_intcfg_int_level_bit","title":"define mpu_INTCFG_INT_LEVEL_BIT","text":"<pre><code>#define mpu_INTCFG_INT_LEVEL_BIT 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_intcfg_int_open_bit","title":"define mpu_INTCFG_INT_OPEN_BIT","text":"<pre><code>#define mpu_INTCFG_INT_OPEN_BIT 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_intcfg_int_rd_clear_bit","title":"define mpu_INTCFG_INT_RD_CLEAR_BIT","text":"<pre><code>#define mpu_INTCFG_INT_RD_CLEAR_BIT 4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_intcfg_latch_int_en_bit","title":"define mpu_INTCFG_LATCH_INT_EN_BIT","text":"<pre><code>#define mpu_INTCFG_LATCH_INT_EN_BIT 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_intclear_anyread","title":"define mpu_INTCLEAR_ANYREAD","text":"<pre><code>#define mpu_INTCLEAR_ANYREAD 0x01\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_intclear_statusread","title":"define mpu_INTCLEAR_STATUSREAD","text":"<pre><code>#define mpu_INTCLEAR_STATUSREAD 0x00\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_intdrv_opendrain","title":"define mpu_INTDRV_OPENDRAIN","text":"<pre><code>#define mpu_INTDRV_OPENDRAIN 0x01\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_intdrv_pushpull","title":"define mpu_INTDRV_PUSHPULL","text":"<pre><code>#define mpu_INTDRV_PUSHPULL 0x00\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_interrupt_data_rdy_bit","title":"define mpu_INTERRUPT_DATA_RDY_BIT","text":"<pre><code>#define mpu_INTERRUPT_DATA_RDY_BIT 0\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_interrupt_dmp_int_bit","title":"define mpu_INTERRUPT_DMP_INT_BIT","text":"<pre><code>#define mpu_INTERRUPT_DMP_INT_BIT 1\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_interrupt_ff_bit","title":"define mpu_INTERRUPT_FF_BIT","text":"<pre><code>#define mpu_INTERRUPT_FF_BIT 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_interrupt_fifo_oflow_bit","title":"define mpu_INTERRUPT_FIFO_OFLOW_BIT","text":"<pre><code>#define mpu_INTERRUPT_FIFO_OFLOW_BIT 4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_interrupt_i2c_mst_int_bit","title":"define mpu_INTERRUPT_I2C_MST_INT_BIT","text":"<pre><code>#define mpu_INTERRUPT_I2C_MST_INT_BIT 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_interrupt_mot_bit","title":"define mpu_INTERRUPT_MOT_BIT","text":"<pre><code>#define mpu_INTERRUPT_MOT_BIT 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_interrupt_pll_rdy_int_bit","title":"define mpu_INTERRUPT_PLL_RDY_INT_BIT","text":"<pre><code>#define mpu_INTERRUPT_PLL_RDY_INT_BIT 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_interrupt_zmot_bit","title":"define mpu_INTERRUPT_ZMOT_BIT","text":"<pre><code>#define mpu_INTERRUPT_ZMOT_BIT 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_intlatch_50uspulse","title":"define mpu_INTLATCH_50USPULSE","text":"<pre><code>#define mpu_INTLATCH_50USPULSE 0x00\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_intlatch_waitclear","title":"define mpu_INTLATCH_WAITCLEAR","text":"<pre><code>#define mpu_INTLATCH_WAITCLEAR 0x01\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_intmode_activehigh","title":"define mpu_INTMODE_ACTIVEHIGH","text":"<pre><code>#define mpu_INTMODE_ACTIVEHIGH 0x00\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_intmode_activelow","title":"define mpu_INTMODE_ACTIVELOW","text":"<pre><code>#define mpu_INTMODE_ACTIVELOW 0x01\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_motion_mot_xneg_bit","title":"define mpu_MOTION_MOT_XNEG_BIT","text":"<pre><code>#define mpu_MOTION_MOT_XNEG_BIT 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_motion_mot_xpos_bit","title":"define mpu_MOTION_MOT_XPOS_BIT","text":"<pre><code>#define mpu_MOTION_MOT_XPOS_BIT 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_motion_mot_yneg_bit","title":"define mpu_MOTION_MOT_YNEG_BIT","text":"<pre><code>#define mpu_MOTION_MOT_YNEG_BIT 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_motion_mot_ypos_bit","title":"define mpu_MOTION_MOT_YPOS_BIT","text":"<pre><code>#define mpu_MOTION_MOT_YPOS_BIT 4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_motion_mot_zneg_bit","title":"define mpu_MOTION_MOT_ZNEG_BIT","text":"<pre><code>#define mpu_MOTION_MOT_ZNEG_BIT 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_motion_mot_zpos_bit","title":"define mpu_MOTION_MOT_ZPOS_BIT","text":"<pre><code>#define mpu_MOTION_MOT_ZPOS_BIT 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_motion_mot_zrmot_bit","title":"define mpu_MOTION_MOT_ZRMOT_BIT","text":"<pre><code>#define mpu_MOTION_MOT_ZRMOT_BIT 0\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_mst_i2c_lost_arb_bit","title":"define mpu_MST_I2C_LOST_ARB_BIT","text":"<pre><code>#define mpu_MST_I2C_LOST_ARB_BIT 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_mst_i2c_slv0_nack_bit","title":"define mpu_MST_I2C_SLV0_NACK_BIT","text":"<pre><code>#define mpu_MST_I2C_SLV0_NACK_BIT 0\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_mst_i2c_slv1_nack_bit","title":"define mpu_MST_I2C_SLV1_NACK_BIT","text":"<pre><code>#define mpu_MST_I2C_SLV1_NACK_BIT 1\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_mst_i2c_slv2_nack_bit","title":"define mpu_MST_I2C_SLV2_NACK_BIT","text":"<pre><code>#define mpu_MST_I2C_SLV2_NACK_BIT 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_mst_i2c_slv3_nack_bit","title":"define mpu_MST_I2C_SLV3_NACK_BIT","text":"<pre><code>#define mpu_MST_I2C_SLV3_NACK_BIT 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_mst_i2c_slv4_done_bit","title":"define mpu_MST_I2C_SLV4_DONE_BIT","text":"<pre><code>#define mpu_MST_I2C_SLV4_DONE_BIT 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_mst_i2c_slv4_nack_bit","title":"define mpu_MST_I2C_SLV4_NACK_BIT","text":"<pre><code>#define mpu_MST_I2C_SLV4_NACK_BIT 4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_mst_pass_through_bit","title":"define mpu_MST_PASS_THROUGH_BIT","text":"<pre><code>#define mpu_MST_PASS_THROUGH_BIT 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_mult_mst_en_bit","title":"define mpu_MULT_MST_EN_BIT","text":"<pre><code>#define mpu_MULT_MST_EN_BIT 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pathreset_accel_reset_bit","title":"define mpu_PATHRESET_ACCEL_RESET_BIT","text":"<pre><code>#define mpu_PATHRESET_ACCEL_RESET_BIT 1\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pathreset_gyro_reset_bit","title":"define mpu_PATHRESET_GYRO_RESET_BIT","text":"<pre><code>#define mpu_PATHRESET_GYRO_RESET_BIT 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pathreset_temp_reset_bit","title":"define mpu_PATHRESET_TEMP_RESET_BIT","text":"<pre><code>#define mpu_PATHRESET_TEMP_RESET_BIT 0\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pwr1_clksel_bit","title":"define mpu_PWR1_CLKSEL_BIT","text":"<pre><code>#define mpu_PWR1_CLKSEL_BIT 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pwr1_clksel_length","title":"define mpu_PWR1_CLKSEL_LENGTH","text":"<pre><code>#define mpu_PWR1_CLKSEL_LENGTH 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pwr1_cycle_bit","title":"define mpu_PWR1_CYCLE_BIT","text":"<pre><code>#define mpu_PWR1_CYCLE_BIT 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pwr1_device_reset_bit","title":"define mpu_PWR1_DEVICE_RESET_BIT","text":"<pre><code>#define mpu_PWR1_DEVICE_RESET_BIT 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pwr1_sleep_bit","title":"define mpu_PWR1_SLEEP_BIT","text":"<pre><code>#define mpu_PWR1_SLEEP_BIT 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pwr1_temp_dis_bit","title":"define mpu_PWR1_TEMP_DIS_BIT","text":"<pre><code>#define mpu_PWR1_TEMP_DIS_BIT 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pwr2_lp_wake_ctrl_bit","title":"define mpu_PWR2_LP_WAKE_CTRL_BIT","text":"<pre><code>#define mpu_PWR2_LP_WAKE_CTRL_BIT 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pwr2_lp_wake_ctrl_length","title":"define mpu_PWR2_LP_WAKE_CTRL_LENGTH","text":"<pre><code>#define mpu_PWR2_LP_WAKE_CTRL_LENGTH 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pwr2_stby_xa_bit","title":"define mpu_PWR2_STBY_XA_BIT","text":"<pre><code>#define mpu_PWR2_STBY_XA_BIT 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pwr2_stby_xg_bit","title":"define mpu_PWR2_STBY_XG_BIT","text":"<pre><code>#define mpu_PWR2_STBY_XG_BIT 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pwr2_stby_ya_bit","title":"define mpu_PWR2_STBY_YA_BIT","text":"<pre><code>#define mpu_PWR2_STBY_YA_BIT 4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pwr2_stby_yg_bit","title":"define mpu_PWR2_STBY_YG_BIT","text":"<pre><code>#define mpu_PWR2_STBY_YG_BIT 1\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pwr2_stby_za_bit","title":"define mpu_PWR2_STBY_ZA_BIT","text":"<pre><code>#define mpu_PWR2_STBY_ZA_BIT 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_pwr2_stby_zg_bit","title":"define mpu_PWR2_STBY_ZG_BIT","text":"<pre><code>#define mpu_PWR2_STBY_ZG_BIT 0\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_accel_config","title":"define mpu_RA_ACCEL_CONFIG","text":"<pre><code>#define mpu_RA_ACCEL_CONFIG 0x1C\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_accel_xout_h","title":"define mpu_RA_ACCEL_XOUT_H","text":"<pre><code>#define mpu_RA_ACCEL_XOUT_H 0x3B\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_accel_xout_l","title":"define mpu_RA_ACCEL_XOUT_L","text":"<pre><code>#define mpu_RA_ACCEL_XOUT_L 0x3C\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_accel_yout_h","title":"define mpu_RA_ACCEL_YOUT_H","text":"<pre><code>#define mpu_RA_ACCEL_YOUT_H 0x3D\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_accel_yout_l","title":"define mpu_RA_ACCEL_YOUT_L","text":"<pre><code>#define mpu_RA_ACCEL_YOUT_L 0x3E\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_accel_zout_h","title":"define mpu_RA_ACCEL_ZOUT_H","text":"<pre><code>#define mpu_RA_ACCEL_ZOUT_H 0x3F\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_accel_zout_l","title":"define mpu_RA_ACCEL_ZOUT_L","text":"<pre><code>#define mpu_RA_ACCEL_ZOUT_L 0x40\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_bank_sel","title":"define mpu_RA_BANK_SEL","text":"<pre><code>#define mpu_RA_BANK_SEL 0x6D\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_config","title":"define mpu_RA_CONFIG","text":"<pre><code>#define mpu_RA_CONFIG 0x1A\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_dmp_cfg_1","title":"define mpu_RA_DMP_CFG_1","text":"<pre><code>#define mpu_RA_DMP_CFG_1 0x70\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_dmp_cfg_2","title":"define mpu_RA_DMP_CFG_2","text":"<pre><code>#define mpu_RA_DMP_CFG_2 0x71\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_dmp_int_status","title":"define mpu_RA_DMP_INT_STATUS","text":"<pre><code>#define mpu_RA_DMP_INT_STATUS 0x39\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_00","title":"define mpu_RA_EXT_SENS_DATA_00","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_00 0x49\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_01","title":"define mpu_RA_EXT_SENS_DATA_01","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_01 0x4A\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_02","title":"define mpu_RA_EXT_SENS_DATA_02","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_02 0x4B\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_03","title":"define mpu_RA_EXT_SENS_DATA_03","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_03 0x4C\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_04","title":"define mpu_RA_EXT_SENS_DATA_04","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_04 0x4D\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_05","title":"define mpu_RA_EXT_SENS_DATA_05","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_05 0x4E\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_06","title":"define mpu_RA_EXT_SENS_DATA_06","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_06 0x4F\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_07","title":"define mpu_RA_EXT_SENS_DATA_07","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_07 0x50\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_08","title":"define mpu_RA_EXT_SENS_DATA_08","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_08 0x51\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_09","title":"define mpu_RA_EXT_SENS_DATA_09","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_09 0x52\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_10","title":"define mpu_RA_EXT_SENS_DATA_10","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_10 0x53\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_11","title":"define mpu_RA_EXT_SENS_DATA_11","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_11 0x54\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_12","title":"define mpu_RA_EXT_SENS_DATA_12","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_12 0x55\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_13","title":"define mpu_RA_EXT_SENS_DATA_13","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_13 0x56\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_14","title":"define mpu_RA_EXT_SENS_DATA_14","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_14 0x57\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_15","title":"define mpu_RA_EXT_SENS_DATA_15","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_15 0x58\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_16","title":"define mpu_RA_EXT_SENS_DATA_16","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_16 0x59\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_17","title":"define mpu_RA_EXT_SENS_DATA_17","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_17 0x5A\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_18","title":"define mpu_RA_EXT_SENS_DATA_18","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_18 0x5B\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_19","title":"define mpu_RA_EXT_SENS_DATA_19","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_19 0x5C\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_20","title":"define mpu_RA_EXT_SENS_DATA_20","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_20 0x5D\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_21","title":"define mpu_RA_EXT_SENS_DATA_21","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_21 0x5E\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_22","title":"define mpu_RA_EXT_SENS_DATA_22","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_22 0x5F\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_23","title":"define mpu_RA_EXT_SENS_DATA_23","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_23 0x60\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ff_dur","title":"define mpu_RA_FF_DUR","text":"<pre><code>#define mpu_RA_FF_DUR 0x1E\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ff_thr","title":"define mpu_RA_FF_THR","text":"<pre><code>#define mpu_RA_FF_THR 0x1D\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_fifo_counth","title":"define mpu_RA_FIFO_COUNTH","text":"<pre><code>#define mpu_RA_FIFO_COUNTH 0x72\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_fifo_countl","title":"define mpu_RA_FIFO_COUNTL","text":"<pre><code>#define mpu_RA_FIFO_COUNTL 0x73\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_fifo_en","title":"define mpu_RA_FIFO_EN","text":"<pre><code>#define mpu_RA_FIFO_EN 0x23\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_fifo_r_w","title":"define mpu_RA_FIFO_R_W","text":"<pre><code>#define mpu_RA_FIFO_R_W 0x74\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_gyro_config","title":"define mpu_RA_GYRO_CONFIG","text":"<pre><code>#define mpu_RA_GYRO_CONFIG 0x1B\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_gyro_xout_h","title":"define mpu_RA_GYRO_XOUT_H","text":"<pre><code>#define mpu_RA_GYRO_XOUT_H 0x43\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_gyro_xout_l","title":"define mpu_RA_GYRO_XOUT_L","text":"<pre><code>#define mpu_RA_GYRO_XOUT_L 0x44\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_gyro_yout_h","title":"define mpu_RA_GYRO_YOUT_H","text":"<pre><code>#define mpu_RA_GYRO_YOUT_H 0x45\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_gyro_yout_l","title":"define mpu_RA_GYRO_YOUT_L","text":"<pre><code>#define mpu_RA_GYRO_YOUT_L 0x46\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_gyro_zout_h","title":"define mpu_RA_GYRO_ZOUT_H","text":"<pre><code>#define mpu_RA_GYRO_ZOUT_H 0x47\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_gyro_zout_l","title":"define mpu_RA_GYRO_ZOUT_L","text":"<pre><code>#define mpu_RA_GYRO_ZOUT_L 0x48\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_mst_ctrl","title":"define mpu_RA_I2C_MST_CTRL","text":"<pre><code>#define mpu_RA_I2C_MST_CTRL 0x24\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_mst_delay_ctrl","title":"define mpu_RA_I2C_MST_DELAY_CTRL","text":"<pre><code>#define mpu_RA_I2C_MST_DELAY_CTRL 0x67\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_mst_status","title":"define mpu_RA_I2C_MST_STATUS","text":"<pre><code>#define mpu_RA_I2C_MST_STATUS 0x36\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv0_addr","title":"define mpu_RA_I2C_SLV0_ADDR","text":"<pre><code>#define mpu_RA_I2C_SLV0_ADDR 0x25\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv0_ctrl","title":"define mpu_RA_I2C_SLV0_CTRL","text":"<pre><code>#define mpu_RA_I2C_SLV0_CTRL 0x27\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv0_do","title":"define mpu_RA_I2C_SLV0_DO","text":"<pre><code>#define mpu_RA_I2C_SLV0_DO 0x63\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv0_reg","title":"define mpu_RA_I2C_SLV0_REG","text":"<pre><code>#define mpu_RA_I2C_SLV0_REG 0x26\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv1_addr","title":"define mpu_RA_I2C_SLV1_ADDR","text":"<pre><code>#define mpu_RA_I2C_SLV1_ADDR 0x28\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv1_ctrl","title":"define mpu_RA_I2C_SLV1_CTRL","text":"<pre><code>#define mpu_RA_I2C_SLV1_CTRL 0x2A\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv1_do","title":"define mpu_RA_I2C_SLV1_DO","text":"<pre><code>#define mpu_RA_I2C_SLV1_DO 0x64\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv1_reg","title":"define mpu_RA_I2C_SLV1_REG","text":"<pre><code>#define mpu_RA_I2C_SLV1_REG 0x29\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv2_addr","title":"define mpu_RA_I2C_SLV2_ADDR","text":"<pre><code>#define mpu_RA_I2C_SLV2_ADDR 0x2B\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv2_ctrl","title":"define mpu_RA_I2C_SLV2_CTRL","text":"<pre><code>#define mpu_RA_I2C_SLV2_CTRL 0x2D\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv2_do","title":"define mpu_RA_I2C_SLV2_DO","text":"<pre><code>#define mpu_RA_I2C_SLV2_DO 0x65\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv2_reg","title":"define mpu_RA_I2C_SLV2_REG","text":"<pre><code>#define mpu_RA_I2C_SLV2_REG 0x2C\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv3_addr","title":"define mpu_RA_I2C_SLV3_ADDR","text":"<pre><code>#define mpu_RA_I2C_SLV3_ADDR 0x2E\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv3_ctrl","title":"define mpu_RA_I2C_SLV3_CTRL","text":"<pre><code>#define mpu_RA_I2C_SLV3_CTRL 0x30\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv3_do","title":"define mpu_RA_I2C_SLV3_DO","text":"<pre><code>#define mpu_RA_I2C_SLV3_DO 0x66\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv3_reg","title":"define mpu_RA_I2C_SLV3_REG","text":"<pre><code>#define mpu_RA_I2C_SLV3_REG 0x2F\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv4_addr","title":"define mpu_RA_I2C_SLV4_ADDR","text":"<pre><code>#define mpu_RA_I2C_SLV4_ADDR 0x31\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv4_ctrl","title":"define mpu_RA_I2C_SLV4_CTRL","text":"<pre><code>#define mpu_RA_I2C_SLV4_CTRL 0x34\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv4_di","title":"define mpu_RA_I2C_SLV4_DI","text":"<pre><code>#define mpu_RA_I2C_SLV4_DI 0x35\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv4_do","title":"define mpu_RA_I2C_SLV4_DO","text":"<pre><code>#define mpu_RA_I2C_SLV4_DO 0x33\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_i2c_slv4_reg","title":"define mpu_RA_I2C_SLV4_REG","text":"<pre><code>#define mpu_RA_I2C_SLV4_REG 0x32\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_int_enable","title":"define mpu_RA_INT_ENABLE","text":"<pre><code>#define mpu_RA_INT_ENABLE 0x38\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_int_pin_cfg","title":"define mpu_RA_INT_PIN_CFG","text":"<pre><code>#define mpu_RA_INT_PIN_CFG 0x37\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_int_status","title":"define mpu_RA_INT_STATUS","text":"<pre><code>#define mpu_RA_INT_STATUS 0x3A\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_mem_r_w","title":"define mpu_RA_MEM_R_W","text":"<pre><code>#define mpu_RA_MEM_R_W 0x6F\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_mem_start_addr","title":"define mpu_RA_MEM_START_ADDR","text":"<pre><code>#define mpu_RA_MEM_START_ADDR 0x6E\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_mot_detect_ctrl","title":"define mpu_RA_MOT_DETECT_CTRL","text":"<pre><code>#define mpu_RA_MOT_DETECT_CTRL 0x69\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_mot_detect_status","title":"define mpu_RA_MOT_DETECT_STATUS","text":"<pre><code>#define mpu_RA_MOT_DETECT_STATUS 0x61\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_mot_dur","title":"define mpu_RA_MOT_DUR","text":"<pre><code>#define mpu_RA_MOT_DUR 0x20\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_mot_thr","title":"define mpu_RA_MOT_THR","text":"<pre><code>#define mpu_RA_MOT_THR 0x1F\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_pwr_mgmt_1","title":"define mpu_RA_PWR_MGMT_1","text":"<pre><code>#define mpu_RA_PWR_MGMT_1 0x6B\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_pwr_mgmt_2","title":"define mpu_RA_PWR_MGMT_2","text":"<pre><code>#define mpu_RA_PWR_MGMT_2 0x6C\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_signal_path_reset","title":"define mpu_RA_SIGNAL_PATH_RESET","text":"<pre><code>#define mpu_RA_SIGNAL_PATH_RESET 0x68\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_smplrt_div","title":"define mpu_RA_SMPLRT_DIV","text":"<pre><code>#define mpu_RA_SMPLRT_DIV 0x19\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_temp_out_h","title":"define mpu_RA_TEMP_OUT_H","text":"<pre><code>#define mpu_RA_TEMP_OUT_H 0x41\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_temp_out_l","title":"define mpu_RA_TEMP_OUT_L","text":"<pre><code>#define mpu_RA_TEMP_OUT_L 0x42\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_user_ctrl","title":"define mpu_RA_USER_CTRL","text":"<pre><code>#define mpu_RA_USER_CTRL 0x6A\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_who_am_i","title":"define mpu_RA_WHO_AM_I","text":"<pre><code>#define mpu_RA_WHO_AM_I 0x75\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_xa_offs_h","title":"define mpu_RA_XA_OFFS_H","text":"<pre><code>#define mpu_RA_XA_OFFS_H 0x06\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_xa_offs_l_tc","title":"define mpu_RA_XA_OFFS_L_TC","text":"<pre><code>#define mpu_RA_XA_OFFS_L_TC 0x07\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_xg_offs_tc","title":"define mpu_RA_XG_OFFS_TC","text":"<pre><code>#define mpu_RA_XG_OFFS_TC 0x00\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_xg_offs_usrh","title":"define mpu_RA_XG_OFFS_USRH","text":"<pre><code>#define mpu_RA_XG_OFFS_USRH 0x13\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_xg_offs_usrl","title":"define mpu_RA_XG_OFFS_USRL","text":"<pre><code>#define mpu_RA_XG_OFFS_USRL 0x14\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_x_fine_gain","title":"define mpu_RA_X_FINE_GAIN","text":"<pre><code>#define mpu_RA_X_FINE_GAIN 0x03\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ya_offs_h","title":"define mpu_RA_YA_OFFS_H","text":"<pre><code>#define mpu_RA_YA_OFFS_H 0x08\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_ya_offs_l_tc","title":"define mpu_RA_YA_OFFS_L_TC","text":"<pre><code>#define mpu_RA_YA_OFFS_L_TC 0x09\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_yg_offs_tc","title":"define mpu_RA_YG_OFFS_TC","text":"<pre><code>#define mpu_RA_YG_OFFS_TC 0x01\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_yg_offs_usrh","title":"define mpu_RA_YG_OFFS_USRH","text":"<pre><code>#define mpu_RA_YG_OFFS_USRH 0x15\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_yg_offs_usrl","title":"define mpu_RA_YG_OFFS_USRL","text":"<pre><code>#define mpu_RA_YG_OFFS_USRL 0x16\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_y_fine_gain","title":"define mpu_RA_Y_FINE_GAIN","text":"<pre><code>#define mpu_RA_Y_FINE_GAIN 0x04\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_za_offs_h","title":"define mpu_RA_ZA_OFFS_H","text":"<pre><code>#define mpu_RA_ZA_OFFS_H 0x0A\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_za_offs_l_tc","title":"define mpu_RA_ZA_OFFS_L_TC","text":"<pre><code>#define mpu_RA_ZA_OFFS_L_TC 0x0B\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_zg_offs_tc","title":"define mpu_RA_ZG_OFFS_TC","text":"<pre><code>#define mpu_RA_ZG_OFFS_TC 0x02\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_zg_offs_usrh","title":"define mpu_RA_ZG_OFFS_USRH","text":"<pre><code>#define mpu_RA_ZG_OFFS_USRH 0x17\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_zg_offs_usrl","title":"define mpu_RA_ZG_OFFS_USRL","text":"<pre><code>#define mpu_RA_ZG_OFFS_USRL 0x18\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_zrmot_dur","title":"define mpu_RA_ZRMOT_DUR","text":"<pre><code>#define mpu_RA_ZRMOT_DUR 0x22\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_zrmot_thr","title":"define mpu_RA_ZRMOT_THR","text":"<pre><code>#define mpu_RA_ZRMOT_THR 0x21\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_ra_z_fine_gain","title":"define mpu_RA_Z_FINE_GAIN","text":"<pre><code>#define mpu_RA_Z_FINE_GAIN 0x05\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_slv0_fifo_en_bit","title":"define mpu_SLV0_FIFO_EN_BIT","text":"<pre><code>#define mpu_SLV0_FIFO_EN_BIT 0\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_slv1_fifo_en_bit","title":"define mpu_SLV1_FIFO_EN_BIT","text":"<pre><code>#define mpu_SLV1_FIFO_EN_BIT 1\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_slv2_fifo_en_bit","title":"define mpu_SLV2_FIFO_EN_BIT","text":"<pre><code>#define mpu_SLV2_FIFO_EN_BIT 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_slv_3_fifo_en_bit","title":"define mpu_SLV_3_FIFO_EN_BIT","text":"<pre><code>#define mpu_SLV_3_FIFO_EN_BIT 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_tc_offset_bit","title":"define mpu_TC_OFFSET_BIT","text":"<pre><code>#define mpu_TC_OFFSET_BIT 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_tc_offset_length","title":"define mpu_TC_OFFSET_LENGTH","text":"<pre><code>#define mpu_TC_OFFSET_LENGTH 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_tc_otp_bnk_vld_bit","title":"define mpu_TC_OTP_BNK_VLD_BIT","text":"<pre><code>#define mpu_TC_OTP_BNK_VLD_BIT 0\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_tc_pwr_mode_bit","title":"define mpu_TC_PWR_MODE_BIT","text":"<pre><code>#define mpu_TC_PWR_MODE_BIT 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_temp_fifo_en_bit","title":"define mpu_TEMP_FIFO_EN_BIT","text":"<pre><code>#define mpu_TEMP_FIFO_EN_BIT 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_userctrl_dmp_en_bit","title":"define mpu_USERCTRL_DMP_EN_BIT","text":"<pre><code>#define mpu_USERCTRL_DMP_EN_BIT 7\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_userctrl_dmp_reset_bit","title":"define mpu_USERCTRL_DMP_RESET_BIT","text":"<pre><code>#define mpu_USERCTRL_DMP_RESET_BIT 3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_userctrl_fifo_en_bit","title":"define mpu_USERCTRL_FIFO_EN_BIT","text":"<pre><code>#define mpu_USERCTRL_FIFO_EN_BIT 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_userctrl_fifo_reset_bit","title":"define mpu_USERCTRL_FIFO_RESET_BIT","text":"<pre><code>#define mpu_USERCTRL_FIFO_RESET_BIT 2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_userctrl_i2c_if_dis_bit","title":"define mpu_USERCTRL_I2C_IF_DIS_BIT","text":"<pre><code>#define mpu_USERCTRL_I2C_IF_DIS_BIT 4\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_userctrl_i2c_mst_en_bit","title":"define mpu_USERCTRL_I2C_MST_EN_BIT","text":"<pre><code>#define mpu_USERCTRL_I2C_MST_EN_BIT 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_userctrl_i2c_mst_reset_bit","title":"define mpu_USERCTRL_I2C_MST_RESET_BIT","text":"<pre><code>#define mpu_USERCTRL_I2C_MST_RESET_BIT 1\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_userctrl_sig_cond_reset_bit","title":"define mpu_USERCTRL_SIG_COND_RESET_BIT","text":"<pre><code>#define mpu_USERCTRL_SIG_COND_RESET_BIT 0\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_vddio_level_vdd","title":"define mpu_VDDIO_LEVEL_VDD","text":"<pre><code>#define mpu_VDDIO_LEVEL_VDD 1\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_vddio_level_vlogic","title":"define mpu_VDDIO_LEVEL_VLOGIC","text":"<pre><code>#define mpu_VDDIO_LEVEL_VLOGIC 0\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_wait_for_es_bit","title":"define mpu_WAIT_FOR_ES_BIT","text":"<pre><code>#define mpu_WAIT_FOR_ES_BIT 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_wake_freq_10","title":"define mpu_WAKE_FREQ_10","text":"<pre><code>#define mpu_WAKE_FREQ_10 0x3\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_wake_freq_1p25","title":"define mpu_WAKE_FREQ_1P25","text":"<pre><code>#define mpu_WAKE_FREQ_1P25 0x0\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_wake_freq_2p5","title":"define mpu_WAKE_FREQ_2P5","text":"<pre><code>#define mpu_WAKE_FREQ_2P5 0x1\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_wake_freq_5","title":"define mpu_WAKE_FREQ_5","text":"<pre><code>#define mpu_WAKE_FREQ_5 0x2\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_who_am_i_bit","title":"define mpu_WHO_AM_I_BIT","text":"<pre><code>#define mpu_WHO_AM_I_BIT 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_who_am_i_length","title":"define mpu_WHO_AM_I_LENGTH","text":"<pre><code>#define mpu_WHO_AM_I_LENGTH 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_xg_fifo_en_bit","title":"define mpu_XG_FIFO_EN_BIT","text":"<pre><code>#define mpu_XG_FIFO_EN_BIT 6\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_yg_fifo_en_bit","title":"define mpu_YG_FIFO_EN_BIT","text":"<pre><code>#define mpu_YG_FIFO_EN_BIT 5\n</code></pre>"},{"location":"stm/MpuController_8hpp/#define-mpu_zg_fifo_en_bit","title":"define mpu_ZG_FIFO_EN_BIT","text":"<pre><code>#define mpu_ZG_FIFO_EN_BIT 4\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/MpuController.hpp</code></p>"},{"location":"stm/MpuController_8hpp_source/","title":"File MpuController.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; MpuController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>// I2Cdev library collection - mpu I2C device class\n// Based on InvenSense MPU-6050 register map document rev. 2.0, 5/19/2011 (RM-MPU-6000A-00)\n// 10/3/2011 by Jeff Rowberg &lt;jeff@rowberg.net&gt;\n// 11/28/2014 by Marton Sebok &lt;sebokmarton@gmail.com&gt;\n//\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//     ...        - ongoing debug release\n//     2014-11-28 - ported to PIC18 peripheral library from Arduino code\n//     2017-03-11 - tested basic functions on STM32\n\n// NOTE: THIS IS ONLY A PARIAL RELEASE. THIS DEVICE CLASS IS CURRENTLY UNDERGOING ACTIVE\n// DEVELOPMENT AND IS STILL MISSING SOME IMPORTANT FEATURES. PLEASE KEEP THIS IN MIND IF\n// YOU DECIDE TO USE THIS PARTICULAR CODE FOR ANYTHING.\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2012 Jeff Rowberg\nCopyright (c) 2014 Marton Sebok\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#ifndef _mpu_H_\n#define _mpu_H_\n\n#include \"I2cController.hpp\"\n#include \"rbcx.pb.h\"\n#include &lt;stdbool.h&gt;\n\n#if ((defined mpu_INCLUDE_DMP_MOTIONAPPS20)                                    \\\n    || (defined mpu_INCLUDE_DMP_MOTIONAPPS41))\n#error DMP is not supported yet\n#endif\n\n#define mpu_ADDRESS_AD0_LOW                                                    \\\n    0x68 // address pin low (GND), default for InvenSense evaluation board\n#define mpu_ADDRESS_AD0_HIGH 0x69 // address pin high (VCC)\n#define mpu_DEFAULT_ADDRESS mpu_ADDRESS_AD0_LOW\n\n#define mpu_RA_XG_OFFS_TC 0x00 //[7] PWR_MODE, [6:1] XG_OFFS_TC, [0] OTP_BNK_VLD\n#define mpu_RA_YG_OFFS_TC 0x01 //[7] PWR_MODE, [6:1] YG_OFFS_TC, [0] OTP_BNK_VLD\n#define mpu_RA_ZG_OFFS_TC 0x02 //[7] PWR_MODE, [6:1] ZG_OFFS_TC, [0] OTP_BNK_VLD\n#define mpu_RA_X_FINE_GAIN 0x03 //[7:0] X_FINE_GAIN\n#define mpu_RA_Y_FINE_GAIN 0x04 //[7:0] Y_FINE_GAIN\n#define mpu_RA_Z_FINE_GAIN 0x05 //[7:0] Z_FINE_GAIN\n#define mpu_RA_XA_OFFS_H 0x06 //[15:0] XA_OFFS\n#define mpu_RA_XA_OFFS_L_TC 0x07\n#define mpu_RA_YA_OFFS_H 0x08 //[15:0] YA_OFFS\n#define mpu_RA_YA_OFFS_L_TC 0x09\n#define mpu_RA_ZA_OFFS_H 0x0A //[15:0] ZA_OFFS\n#define mpu_RA_ZA_OFFS_L_TC 0x0B\n#define mpu_RA_XG_OFFS_USRH 0x13 //[15:0] XG_OFFS_USR\n#define mpu_RA_XG_OFFS_USRL 0x14\n#define mpu_RA_YG_OFFS_USRH 0x15 //[15:0] YG_OFFS_USR\n#define mpu_RA_YG_OFFS_USRL 0x16\n#define mpu_RA_ZG_OFFS_USRH 0x17 //[15:0] ZG_OFFS_USR\n#define mpu_RA_ZG_OFFS_USRL 0x18\n#define mpu_RA_SMPLRT_DIV 0x19\n#define mpu_RA_CONFIG 0x1A\n#define mpu_RA_GYRO_CONFIG 0x1B\n#define mpu_RA_ACCEL_CONFIG 0x1C\n#define mpu_RA_FF_THR 0x1D\n#define mpu_RA_FF_DUR 0x1E\n#define mpu_RA_MOT_THR 0x1F\n#define mpu_RA_MOT_DUR 0x20\n#define mpu_RA_ZRMOT_THR 0x21\n#define mpu_RA_ZRMOT_DUR 0x22\n#define mpu_RA_FIFO_EN 0x23\n#define mpu_RA_I2C_MST_CTRL 0x24\n#define mpu_RA_I2C_SLV0_ADDR 0x25\n#define mpu_RA_I2C_SLV0_REG 0x26\n#define mpu_RA_I2C_SLV0_CTRL 0x27\n#define mpu_RA_I2C_SLV1_ADDR 0x28\n#define mpu_RA_I2C_SLV1_REG 0x29\n#define mpu_RA_I2C_SLV1_CTRL 0x2A\n#define mpu_RA_I2C_SLV2_ADDR 0x2B\n#define mpu_RA_I2C_SLV2_REG 0x2C\n#define mpu_RA_I2C_SLV2_CTRL 0x2D\n#define mpu_RA_I2C_SLV3_ADDR 0x2E\n#define mpu_RA_I2C_SLV3_REG 0x2F\n#define mpu_RA_I2C_SLV3_CTRL 0x30\n#define mpu_RA_I2C_SLV4_ADDR 0x31\n#define mpu_RA_I2C_SLV4_REG 0x32\n#define mpu_RA_I2C_SLV4_DO 0x33\n#define mpu_RA_I2C_SLV4_CTRL 0x34\n#define mpu_RA_I2C_SLV4_DI 0x35\n#define mpu_RA_I2C_MST_STATUS 0x36\n#define mpu_RA_INT_PIN_CFG 0x37\n#define mpu_RA_INT_ENABLE 0x38\n#define mpu_RA_DMP_INT_STATUS 0x39\n#define mpu_RA_INT_STATUS 0x3A\n#define mpu_RA_ACCEL_XOUT_H 0x3B\n#define mpu_RA_ACCEL_XOUT_L 0x3C\n#define mpu_RA_ACCEL_YOUT_H 0x3D\n#define mpu_RA_ACCEL_YOUT_L 0x3E\n#define mpu_RA_ACCEL_ZOUT_H 0x3F\n#define mpu_RA_ACCEL_ZOUT_L 0x40\n#define mpu_RA_TEMP_OUT_H 0x41\n#define mpu_RA_TEMP_OUT_L 0x42\n#define mpu_RA_GYRO_XOUT_H 0x43\n#define mpu_RA_GYRO_XOUT_L 0x44\n#define mpu_RA_GYRO_YOUT_H 0x45\n#define mpu_RA_GYRO_YOUT_L 0x46\n#define mpu_RA_GYRO_ZOUT_H 0x47\n#define mpu_RA_GYRO_ZOUT_L 0x48\n#define mpu_RA_EXT_SENS_DATA_00 0x49\n#define mpu_RA_EXT_SENS_DATA_01 0x4A\n#define mpu_RA_EXT_SENS_DATA_02 0x4B\n#define mpu_RA_EXT_SENS_DATA_03 0x4C\n#define mpu_RA_EXT_SENS_DATA_04 0x4D\n#define mpu_RA_EXT_SENS_DATA_05 0x4E\n#define mpu_RA_EXT_SENS_DATA_06 0x4F\n#define mpu_RA_EXT_SENS_DATA_07 0x50\n#define mpu_RA_EXT_SENS_DATA_08 0x51\n#define mpu_RA_EXT_SENS_DATA_09 0x52\n#define mpu_RA_EXT_SENS_DATA_10 0x53\n#define mpu_RA_EXT_SENS_DATA_11 0x54\n#define mpu_RA_EXT_SENS_DATA_12 0x55\n#define mpu_RA_EXT_SENS_DATA_13 0x56\n#define mpu_RA_EXT_SENS_DATA_14 0x57\n#define mpu_RA_EXT_SENS_DATA_15 0x58\n#define mpu_RA_EXT_SENS_DATA_16 0x59\n#define mpu_RA_EXT_SENS_DATA_17 0x5A\n#define mpu_RA_EXT_SENS_DATA_18 0x5B\n#define mpu_RA_EXT_SENS_DATA_19 0x5C\n#define mpu_RA_EXT_SENS_DATA_20 0x5D\n#define mpu_RA_EXT_SENS_DATA_21 0x5E\n#define mpu_RA_EXT_SENS_DATA_22 0x5F\n#define mpu_RA_EXT_SENS_DATA_23 0x60\n#define mpu_RA_MOT_DETECT_STATUS 0x61\n#define mpu_RA_I2C_SLV0_DO 0x63\n#define mpu_RA_I2C_SLV1_DO 0x64\n#define mpu_RA_I2C_SLV2_DO 0x65\n#define mpu_RA_I2C_SLV3_DO 0x66\n#define mpu_RA_I2C_MST_DELAY_CTRL 0x67\n#define mpu_RA_SIGNAL_PATH_RESET 0x68\n#define mpu_RA_MOT_DETECT_CTRL 0x69\n#define mpu_RA_USER_CTRL 0x6A\n#define mpu_RA_PWR_MGMT_1 0x6B\n#define mpu_RA_PWR_MGMT_2 0x6C\n#define mpu_RA_BANK_SEL 0x6D\n#define mpu_RA_MEM_START_ADDR 0x6E\n#define mpu_RA_MEM_R_W 0x6F\n#define mpu_RA_DMP_CFG_1 0x70\n#define mpu_RA_DMP_CFG_2 0x71\n#define mpu_RA_FIFO_COUNTH 0x72\n#define mpu_RA_FIFO_COUNTL 0x73\n#define mpu_RA_FIFO_R_W 0x74\n#define mpu_RA_WHO_AM_I 0x75\n\n#define mpu_TC_PWR_MODE_BIT 7\n#define mpu_TC_OFFSET_BIT 6\n#define mpu_TC_OFFSET_LENGTH 6\n#define mpu_TC_OTP_BNK_VLD_BIT 0\n\n#define mpu_VDDIO_LEVEL_VLOGIC 0\n#define mpu_VDDIO_LEVEL_VDD 1\n\n#define mpu_CFG_EXT_SYNC_SET_BIT 5\n#define mpu_CFG_EXT_SYNC_SET_LENGTH 3\n#define mpu_CFG_DLPF_CFG_BIT 2\n#define mpu_CFG_DLPF_CFG_LENGTH 3\n\n#define mpu_EXT_SYNC_DISABLED 0x0\n#define mpu_EXT_SYNC_TEMP_OUT_L 0x1\n#define mpu_EXT_SYNC_GYRO_XOUT_L 0x2\n#define mpu_EXT_SYNC_GYRO_YOUT_L 0x3\n#define mpu_EXT_SYNC_GYRO_ZOUT_L 0x4\n#define mpu_EXT_SYNC_ACCEL_XOUT_L 0x5\n#define mpu_EXT_SYNC_ACCEL_YOUT_L 0x6\n#define mpu_EXT_SYNC_ACCEL_ZOUT_L 0x7\n\n#define mpu_DLPF_BW_256 0x00\n#define mpu_DLPF_BW_188 0x01\n#define mpu_DLPF_BW_98 0x02\n#define mpu_DLPF_BW_42 0x03\n#define mpu_DLPF_BW_20 0x04\n#define mpu_DLPF_BW_10 0x05\n#define mpu_DLPF_BW_5 0x06\n\n#define mpu_GCONFIG_FS_SEL_BIT 4\n#define mpu_GCONFIG_FS_SEL_LENGTH 2\n\n#define mpu_GYRO_FS_250 0x00\n#define mpu_GYRO_FS_500 0x01\n#define mpu_GYRO_FS_1000 0x02\n#define mpu_GYRO_FS_2000 0x03\n\n#define mpu_ACONFIG_XA_ST_BIT 7\n#define mpu_ACONFIG_YA_ST_BIT 6\n#define mpu_ACONFIG_ZA_ST_BIT 5\n#define mpu_ACONFIG_AFS_SEL_BIT 4\n#define mpu_ACONFIG_AFS_SEL_LENGTH 2\n#define mpu_ACONFIG_ACCEL_HPF_BIT 2\n#define mpu_ACONFIG_ACCEL_HPF_LENGTH 3\n\n#define mpu_ACCEL_FS_2 0x00\n#define mpu_ACCEL_FS_4 0x01\n#define mpu_ACCEL_FS_8 0x02\n#define mpu_ACCEL_FS_16 0x03\n\n#define mpu_DHPF_RESET 0x00\n#define mpu_DHPF_5 0x01\n#define mpu_DHPF_2P5 0x02\n#define mpu_DHPF_1P25 0x03\n#define mpu_DHPF_0P63 0x04\n#define mpu_DHPF_HOLD 0x07\n\n#define mpu_TEMP_FIFO_EN_BIT 7\n#define mpu_XG_FIFO_EN_BIT 6\n#define mpu_YG_FIFO_EN_BIT 5\n#define mpu_ZG_FIFO_EN_BIT 4\n#define mpu_ACCEL_FIFO_EN_BIT 3\n#define mpu_SLV2_FIFO_EN_BIT 2\n#define mpu_SLV1_FIFO_EN_BIT 1\n#define mpu_SLV0_FIFO_EN_BIT 0\n\n#define mpu_MULT_MST_EN_BIT 7\n#define mpu_WAIT_FOR_ES_BIT 6\n#define mpu_SLV_3_FIFO_EN_BIT 5\n#define mpu_I2C_MST_P_NSR_BIT 4\n#define mpu_I2C_MST_CLK_BIT 3\n#define mpu_I2C_MST_CLK_LENGTH 4\n\n#define mpu_CLOCK_DIV_348 0x0\n#define mpu_CLOCK_DIV_333 0x1\n#define mpu_CLOCK_DIV_320 0x2\n#define mpu_CLOCK_DIV_308 0x3\n#define mpu_CLOCK_DIV_296 0x4\n#define mpu_CLOCK_DIV_286 0x5\n#define mpu_CLOCK_DIV_276 0x6\n#define mpu_CLOCK_DIV_267 0x7\n#define mpu_CLOCK_DIV_258 0x8\n#define mpu_CLOCK_DIV_500 0x9\n#define mpu_CLOCK_DIV_471 0xA\n#define mpu_CLOCK_DIV_444 0xB\n#define mpu_CLOCK_DIV_421 0xC\n#define mpu_CLOCK_DIV_400 0xD\n#define mpu_CLOCK_DIV_381 0xE\n#define mpu_CLOCK_DIV_364 0xF\n\n#define mpu_I2C_SLV_RW_BIT 7\n#define mpu_I2C_SLV_ADDR_BIT 6\n#define mpu_I2C_SLV_ADDR_LENGTH 7\n#define mpu_I2C_SLV_EN_BIT 7\n#define mpu_I2C_SLV_BYTE_SW_BIT 6\n#define mpu_I2C_SLV_REG_DIS_BIT 5\n#define mpu_I2C_SLV_GRP_BIT 4\n#define mpu_I2C_SLV_LEN_BIT 3\n#define mpu_I2C_SLV_LEN_LENGTH 4\n\n#define mpu_I2C_SLV4_RW_BIT 7\n#define mpu_I2C_SLV4_ADDR_BIT 6\n#define mpu_I2C_SLV4_ADDR_LENGTH 7\n#define mpu_I2C_SLV4_EN_BIT 7\n#define mpu_I2C_SLV4_INT_EN_BIT 6\n#define mpu_I2C_SLV4_REG_DIS_BIT 5\n#define mpu_I2C_SLV4_MST_DLY_BIT 4\n#define mpu_I2C_SLV4_MST_DLY_LENGTH 5\n\n#define mpu_MST_PASS_THROUGH_BIT 7\n#define mpu_MST_I2C_SLV4_DONE_BIT 6\n#define mpu_MST_I2C_LOST_ARB_BIT 5\n#define mpu_MST_I2C_SLV4_NACK_BIT 4\n#define mpu_MST_I2C_SLV3_NACK_BIT 3\n#define mpu_MST_I2C_SLV2_NACK_BIT 2\n#define mpu_MST_I2C_SLV1_NACK_BIT 1\n#define mpu_MST_I2C_SLV0_NACK_BIT 0\n\n#define mpu_INTCFG_INT_LEVEL_BIT 7\n#define mpu_INTCFG_INT_OPEN_BIT 6\n#define mpu_INTCFG_LATCH_INT_EN_BIT 5\n#define mpu_INTCFG_INT_RD_CLEAR_BIT 4\n#define mpu_INTCFG_FSYNC_INT_LEVEL_BIT 3\n#define mpu_INTCFG_FSYNC_INT_EN_BIT 2\n#define mpu_INTCFG_I2C_BYPASS_EN_BIT 1\n#define mpu_INTCFG_CLKOUT_EN_BIT 0\n\n#define mpu_INTMODE_ACTIVEHIGH 0x00\n#define mpu_INTMODE_ACTIVELOW 0x01\n\n#define mpu_INTDRV_PUSHPULL 0x00\n#define mpu_INTDRV_OPENDRAIN 0x01\n\n#define mpu_INTLATCH_50USPULSE 0x00\n#define mpu_INTLATCH_WAITCLEAR 0x01\n\n#define mpu_INTCLEAR_STATUSREAD 0x00\n#define mpu_INTCLEAR_ANYREAD 0x01\n\n#define mpu_INTERRUPT_FF_BIT 7\n#define mpu_INTERRUPT_MOT_BIT 6\n#define mpu_INTERRUPT_ZMOT_BIT 5\n#define mpu_INTERRUPT_FIFO_OFLOW_BIT 4\n#define mpu_INTERRUPT_I2C_MST_INT_BIT 3\n#define mpu_INTERRUPT_PLL_RDY_INT_BIT 2\n#define mpu_INTERRUPT_DMP_INT_BIT 1\n#define mpu_INTERRUPT_DATA_RDY_BIT 0\n\n// TODO: figure out what these actually do\n// UMPL source code is not very obivous\n#define mpu_DMPINT_5_BIT 5\n#define mpu_DMPINT_4_BIT 4\n#define mpu_DMPINT_3_BIT 3\n#define mpu_DMPINT_2_BIT 2\n#define mpu_DMPINT_1_BIT 1\n#define mpu_DMPINT_0_BIT 0\n\n#define mpu_MOTION_MOT_XNEG_BIT 7\n#define mpu_MOTION_MOT_XPOS_BIT 6\n#define mpu_MOTION_MOT_YNEG_BIT 5\n#define mpu_MOTION_MOT_YPOS_BIT 4\n#define mpu_MOTION_MOT_ZNEG_BIT 3\n#define mpu_MOTION_MOT_ZPOS_BIT 2\n#define mpu_MOTION_MOT_ZRMOT_BIT 0\n\n#define mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT 7\n#define mpu_DELAYCTRL_I2C_SLV4_DLY_EN_BIT 4\n#define mpu_DELAYCTRL_I2C_SLV3_DLY_EN_BIT 3\n#define mpu_DELAYCTRL_I2C_SLV2_DLY_EN_BIT 2\n#define mpu_DELAYCTRL_I2C_SLV1_DLY_EN_BIT 1\n#define mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT 0\n\n#define mpu_PATHRESET_GYRO_RESET_BIT 2\n#define mpu_PATHRESET_ACCEL_RESET_BIT 1\n#define mpu_PATHRESET_TEMP_RESET_BIT 0\n\n#define mpu_DETECT_ACCEL_ON_DELAY_BIT 5\n#define mpu_DETECT_ACCEL_ON_DELAY_LENGTH 2\n#define mpu_DETECT_FF_COUNT_BIT 3\n#define mpu_DETECT_FF_COUNT_LENGTH 2\n#define mpu_DETECT_MOT_COUNT_BIT 1\n#define mpu_DETECT_MOT_COUNT_LENGTH 2\n\n#define mpu_DETECT_DECREMENT_RESET 0x0\n#define mpu_DETECT_DECREMENT_1 0x1\n#define mpu_DETECT_DECREMENT_2 0x2\n#define mpu_DETECT_DECREMENT_4 0x3\n\n#define mpu_USERCTRL_DMP_EN_BIT 7\n#define mpu_USERCTRL_FIFO_EN_BIT 6\n#define mpu_USERCTRL_I2C_MST_EN_BIT 5\n#define mpu_USERCTRL_I2C_IF_DIS_BIT 4\n#define mpu_USERCTRL_DMP_RESET_BIT 3\n#define mpu_USERCTRL_FIFO_RESET_BIT 2\n#define mpu_USERCTRL_I2C_MST_RESET_BIT 1\n#define mpu_USERCTRL_SIG_COND_RESET_BIT 0\n\n#define mpu_PWR1_DEVICE_RESET_BIT 7\n#define mpu_PWR1_SLEEP_BIT 6\n#define mpu_PWR1_CYCLE_BIT 5\n#define mpu_PWR1_TEMP_DIS_BIT 3\n#define mpu_PWR1_CLKSEL_BIT 2\n#define mpu_PWR1_CLKSEL_LENGTH 3\n\n#define mpu_CLOCK_INTERNAL 0x00\n#define mpu_CLOCK_PLL_XGYRO 0x01\n#define mpu_CLOCK_PLL_YGYRO 0x02\n#define mpu_CLOCK_PLL_ZGYRO 0x03\n#define mpu_CLOCK_PLL_EXT32K 0x04\n#define mpu_CLOCK_PLL_EXT19M 0x05\n#define mpu_CLOCK_KEEP_RESET 0x07\n\n#define mpu_PWR2_LP_WAKE_CTRL_BIT 7\n#define mpu_PWR2_LP_WAKE_CTRL_LENGTH 2\n#define mpu_PWR2_STBY_XA_BIT 5\n#define mpu_PWR2_STBY_YA_BIT 4\n#define mpu_PWR2_STBY_ZA_BIT 3\n#define mpu_PWR2_STBY_XG_BIT 2\n#define mpu_PWR2_STBY_YG_BIT 1\n#define mpu_PWR2_STBY_ZG_BIT 0\n\n#define mpu_WAKE_FREQ_1P25 0x0\n#define mpu_WAKE_FREQ_2P5 0x1\n#define mpu_WAKE_FREQ_5 0x2\n#define mpu_WAKE_FREQ_10 0x3\n\n#define mpu_BANKSEL_PRFTCH_EN_BIT 6\n#define mpu_BANKSEL_CFG_USER_BANK_BIT 5\n#define mpu_BANKSEL_MEM_SEL_BIT 4\n#define mpu_BANKSEL_MEM_SEL_LENGTH 5\n\n#define mpu_WHO_AM_I_BIT 6\n#define mpu_WHO_AM_I_LENGTH 6\n\n#define mpu_DMP_MEMORY_BANKS 8\n#define mpu_DMP_MEMORY_BANK_SIZE 256\n#define mpu_DMP_MEMORY_CHUNK_SIZE 16\n\n// note: DMP code memory blocks defined at end of header file\n\n// #define COMPRESS_COEF 4\n\ntypedef struct mpu_t {\nuint8_t devAddr;\nuint8_t buffer[14];\n} mpu_t;\n\nvoid mpuDispatch(const CoprocReq_MpuReq&amp; request);\nvoid mpuTick();\n\nvoid mpuCreate();\nvoid mpuInitialize();\nvoid mpuReset();\nbool mpu_testConnection();\n\n// AUX_VDDIO register\nuint8_t mpu_getAuxVDDIOLevel();\nvoid mpu_setAuxVDDIOLevel(uint8_t level);\n\n// SMPLRT_DIV register\nuint8_t mpu_getRate();\nvoid mpu_setRate(uint8_t rate);\n\n// CONFIG register\nuint8_t mpu_getExternalFrameSync();\nvoid mpu_setExternalFrameSync(uint8_t sync);\nuint8_t mpu_getDLPFMode();\nvoid mpu_setDLPFMode(uint8_t bandwidth);\n\n// GYRO_CONFIG register\nuint8_t mpu_getFullScaleGyroRange();\nvoid mpu_setFullScaleGyroRange(uint8_t range);\n\n// ACCEL_CONFIG register\nbool mpu_getAccelXSelfTest();\nvoid mpu_setAccelXSelfTest(bool enabled);\nbool mpu_getAccelYSelfTest();\nvoid mpu_setAccelYSelfTest(bool enabled);\nbool mpu_getAccelZSelfTest();\nvoid mpu_setAccelZSelfTest(bool enabled);\nuint8_t mpu_getFullScaleAccelRange();\nvoid mpu_setFullScaleAccelRange(uint8_t range);\nuint8_t mpu_getDHPFMode();\nvoid mpu_setDHPFMode(uint8_t mode);\n\n// FF_THR register\nuint8_t mpu_getFreefallDetectionThreshold();\nvoid mpu_setFreefallDetectionThreshold(uint8_t threshold);\n\n// FF_DUR register\nuint8_t mpu_getFreefallDetectionDuration();\nvoid mpu_setFreefallDetectionDuration(uint8_t duration);\n\n// MOT_THR register\nuint8_t mpu_getMotionDetectionThreshold();\nvoid mpu_setMotionDetectionThreshold(uint8_t threshold);\n\n// MOT_DUR register\nuint8_t mpu_getMotionDetectionDuration();\nvoid mpu_setMotionDetectionDuration(uint8_t duration);\n\n// ZRMOT_THR register\nuint8_t mpu_getZeroMotionDetectionThreshold();\nvoid mpu_setZeroMotionDetectionThreshold(uint8_t threshold);\n\n// ZRMOT_DUR register\nuint8_t mpu_getZeroMotionDetectionDuration();\nvoid mpu_setZeroMotionDetectionDuration(uint8_t duration);\n\n// FIFO_EN register\nbool mpu_getTempFIFOEnabled();\nvoid mpu_setTempFIFOEnabled(bool enabled);\nbool mpu_getXGyroFIFOEnabled();\nvoid mpu_setXGyroFIFOEnabled(bool enabled);\nbool mpu_getYGyroFIFOEnabled();\nvoid mpu_setYGyroFIFOEnabled(bool enabled);\nbool mpu_getZGyroFIFOEnabled();\nvoid mpu_setZGyroFIFOEnabled(bool enabled);\nbool mpu_getAccelFIFOEnabled();\nvoid mpu_setAccelFIFOEnabled(bool enabled);\nbool mpu_getSlave2FIFOEnabled();\nvoid mpu_setSlave2FIFOEnabled(bool enabled);\nbool mpu_getSlave1FIFOEnabled();\nvoid mpu_setSlave1FIFOEnabled(bool enabled);\nbool mpu_getSlave0FIFOEnabled();\nvoid mpu_setSlave0FIFOEnabled(bool enabled);\n\n// I2C_MST_CTRL register\nbool mpu_getMultiMasterEnabled();\nvoid mpu_setMultiMasterEnabled(bool enabled);\nbool mpu_getWaitForExternalSensorEnabled();\nvoid mpu_setWaitForExternalSensorEnabled(bool enabled);\nbool mpu_getSlave3FIFOEnabled();\nvoid mpu_setSlave3FIFOEnabled(bool enabled);\nbool mpu_getSlaveReadWriteTransitionEnabled();\nvoid mpu_setSlaveReadWriteTransitionEnabled(bool enabled);\nuint8_t mpu_getMasterClockSpeed();\nvoid mpu_setMasterClockSpeed(uint8_t speed);\n\n// I2C_SLV* registers (Slave 0-3)\nuint8_t mpu_getSlaveAddress(uint8_t num);\nvoid mpu_setSlaveAddress(uint8_t num, uint8_t address);\nuint8_t mpu_getSlaveRegister(uint8_t num);\nvoid mpu_setSlaveRegister(uint8_t num, uint8_t reg);\nbool mpu_getSlaveEnabled(uint8_t num);\nvoid mpu_setSlaveEnabled(uint8_t num, bool enabled);\nbool mpu_getSlaveWordByteSwap(uint8_t num);\nvoid mpu_setSlaveWordByteSwap(uint8_t num, bool enabled);\nbool mpu_getSlaveWriteMode(uint8_t num);\nvoid mpu_setSlaveWriteMode(uint8_t num, bool mode);\nbool mpu_getSlaveWordGroupOffset(uint8_t num);\nvoid mpu_setSlaveWordGroupOffset(uint8_t num, bool enabled);\nuint8_t mpu_getSlaveDataLength(uint8_t num);\nvoid mpu_setSlaveDataLength(uint8_t num, uint8_t length);\n\n// I2C_SLV* registers (Slave 4)\nuint8_t mpu_getSlave4Address();\nvoid mpu_setSlave4Address(uint8_t address);\nuint8_t mpu_getSlave4Register();\nvoid mpu_setSlave4Register(uint8_t reg);\nvoid mpu_setSlave4OutputByte(uint8_t data);\nbool mpu_getSlave4Enabled();\nvoid mpu_setSlave4Enabled(bool enabled);\nbool mpu_getSlave4InterruptEnabled();\nvoid mpu_setSlave4InterruptEnabled(bool enabled);\nbool mpu_getSlave4WriteMode();\nvoid mpu_setSlave4WriteMode(bool mode);\nuint8_t mpu_getSlave4MasterDelay();\nvoid mpu_setSlave4MasterDelay(uint8_t delay);\nuint8_t mpu_getSlate4InputByte();\n\n// I2C_MST_STATUS register\nbool mpu_getPassthroughStatus();\nbool mpu_getSlave4IsDone();\nbool mpu_getLostArbitration();\nbool mpu_getSlave4Nack();\nbool mpu_getSlave3Nack();\nbool mpu_getSlave2Nack();\nbool mpu_getSlave1Nack();\nbool mpu_getSlave0Nack();\n\n// INT_PIN_CFG register\nbool mpu_getInterruptMode();\nvoid mpu_setInterruptMode(bool mode);\nbool mpu_getInterruptDrive();\nvoid mpu_setInterruptDrive(bool drive);\nbool mpu_getInterruptLatch();\nvoid mpu_setInterruptLatch(bool latch);\nbool mpu_getInterruptLatchClear();\nvoid mpu_setInterruptLatchClear(bool clear);\nbool mpu_getFSyncInterruptLevel();\nvoid mpu_setFSyncInterruptLevel(bool level);\nbool mpu_getFSyncInterruptEnabled();\nvoid mpu_setFSyncInterruptEnabled(bool enabled);\nbool mpu_getI2CBypassEnabled();\nvoid mpu_setI2CBypassEnabled(bool enabled);\nbool mpu_getClockOutputEnabled();\nvoid mpu_setClockOutputEnabled(bool enabled);\n\n// INT_ENABLE register\nuint8_t mpu_getIntEnabled();\nvoid mpu_setIntEnabled(uint8_t enabled);\nbool mpu_getIntFreefallEnabled();\nvoid mpu_setIntFreefallEnabled(bool enabled);\nbool mpu_getIntMotionEnabled();\nvoid mpu_setIntMotionEnabled(bool enabled);\nbool mpu_getIntZeroMotionEnabled();\nvoid mpu_setIntZeroMotionEnabled(bool enabled);\nbool mpu_getIntFIFOBufferOverflowEnabled();\nvoid mpu_setIntFIFOBufferOverflowEnabled(bool enabled);\nbool mpu_getIntI2CMasterEnabled();\nvoid mpu_setIntI2CMasterEnabled(bool enabled);\nbool mpu_getIntDataReadyEnabled();\nvoid mpu_setIntDataReadyEnabled(bool enabled);\n\n// INT_STATUS register\nuint8_t mpu_getIntStatus();\nbool mpu_getIntFreefallStatus();\nbool mpu_getIntMotionStatus();\nbool mpu_getIntZeroMotionStatus();\nbool mpu_getIntFIFOBufferOverflowStatus();\nbool mpu_getIntI2CMasterStatus();\nbool mpu_getIntDataReadyStatus();\n\n// ACCEL_*OUT_* registers\nvoid mpu_getMotion9(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx,\nint16_t* gy, int16_t* gz, int16_t* mx, int16_t* my, int16_t* mz);\nvoid mpu_getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx,\nint16_t* gy, int16_t* gz);\nvoid mpu_getAcceleration(int16_t* x, int16_t* y, int16_t* z);\n// void mpu_getAcceleration(int32_t* x, int32_t* y, int32_t* z);\nint16_t mpu_getAccelerationX();\nint16_t mpu_getAccelerationY();\nint16_t mpu_getAccelerationZ();\n\n// TEMP_OUT_* registers\nint16_t mpu_getTemperature();\n\n// GYRO_*OUT_* registers\nvoid mpu_getRotation(int16_t* x, int16_t* y, int16_t* z);\n// void mpu_getRotation(int32_t* x, int32_t* y, int32_t* z);\nint16_t mpu_getRotationX();\nint16_t mpu_getRotationY();\nint16_t mpu_getRotationZ();\n\n// EXT_SENS_DATA_* registers\nuint8_t mpu_getExternalSensorByte(int position);\nuint16_t mpu_getExternalSensorWord(int position);\nuint32_t getExternalSensorDWord(int position);\n\n// MOT_DETECT_STATUS register\nbool mpu_getXNegMotionDetected();\nbool mpu_getXPosMotionDetected();\nbool mpu_getYNegMotionDetected();\nbool mpu_getYPosMotionDetected();\nbool mpu_getZNegMotionDetected();\nbool mpu_getZPosMotionDetected();\nbool mpu_getZeroMotionDetected();\n\n// I2C_SLV*_DO register\nvoid mpu_setSlaveOutputByte(uint8_t num, uint8_t data);\n\n// I2C_MST_DELAY_CTRL register\nbool mpu_getExternalShadowDelayEnabled();\nvoid mpu_setExternalShadowDelayEnabled(bool enabled);\nbool mpu_getSlaveDelayEnabled(uint8_t num);\nvoid mpu_setSlaveDelayEnabled(uint8_t num, bool enabled);\n\n// SIGNAL_PATH_RESET register\nvoid mpu_resetGyroscopePath();\nvoid mpu_resetAccelerometerPath();\nvoid mpu_resetTemperaturePath();\n\n// MOT_DETECT_CTRL register\nuint8_t mpu_getAccelerometerPowerOnDelay();\nvoid mpu_setAccelerometerPowerOnDelay(uint8_t delay);\nuint8_t mpu_getFreefallDetectionCounterDecrement();\nvoid mpu_setFreefallDetectionCounterDecrement(uint8_t decrement);\nuint8_t mpu_getMotionDetectionCounterDecrement();\nvoid mpu_setMotionDetectionCounterDecrement(uint8_t decrement);\n\n// USER_CTRL register\nbool mpu_getFIFOEnabled();\nvoid mpu_setFIFOEnabled(bool enabled);\nbool mpu_getI2CMasterModeEnabled();\nvoid mpu_setI2CMasterModeEnabled(bool enabled);\nvoid mpu_switchSPIEnabled(bool enabled);\nvoid mpu_resetFIFO();\nvoid mpu_resetI2CMaster();\nvoid mpu_resetSensors();\n\n// PWR_MGMT_1 register\nvoid mpu_reset();\nbool mpu_getSleepEnabled();\nvoid mpu_setSleepEnabled(bool enabled);\nbool mpu_getWakeCycleEnabled();\nvoid mpu_setWakeCycleEnabled(bool enabled);\nbool mpu_getTempSensorEnabled();\nvoid mpu_setTempSensorEnabled(bool enabled);\nuint8_t mpu_getClockSource();\nvoid mpu_setClockSource(uint8_t source);\n\n// PWR_MGMT_2 register\nuint8_t mpu_getWakeFrequency();\nvoid mpu_setWakeFrequency(uint8_t frequency);\nbool mpu_getStandbyXAccelEnabled();\nvoid mpu_setStandbyXAccelEnabled(bool enabled);\nbool mpu_getStandbyYAccelEnabled();\nvoid mpu_setStandbyYAccelEnabled(bool enabled);\nbool mpu_getStandbyZAccelEnabled();\nvoid mpu_setStandbyZAccelEnabled(bool enabled);\nbool mpu_getStandbyXGyroEnabled();\nvoid mpu_setStandbyXGyroEnabled(bool enabled);\nbool mpu_getStandbyYGyroEnabled();\nvoid mpu_setStandbyYGyroEnabled(bool enabled);\nbool mpu_getStandbyZGyroEnabled();\nvoid mpu_setStandbyZGyroEnabled(bool enabled);\n\n// FIFO_COUNT_* registers\nuint16_t mpu_getFIFOCount();\n\n// FIFO_R_W register\nuint8_t mpu_getFIFOByte();\nvoid mpu_setFIFOByte(uint8_t data);\nvoid mpu_getFIFOBytes(uint8_t* data, uint8_t length);\n\n// WHO_AM_I register\nuint8_t mpu_getDeviceID();\nvoid mpu_setDeviceID(uint8_t id);\n\n// ======== UNDOCUMENTED/DMP REGISTERS/METHODS ========\n\n// XG_OFFS_TC register\nuint8_t mpu_getOTPBankValid();\nvoid mpu_setOTPBankValid(bool enabled);\nint8_t getXGyroOffsetTC();\nvoid mpu_setXGyroOffsetTC(int8_t offset);\n\n// YG_OFFS_TC register\nint8_t getYGyroOffsetTC();\nvoid mpu_setYGyroOffsetTC(int8_t offset);\n\n// ZG_OFFS_TC register\nint8_t getZGyroOffsetTC();\nvoid mpu_setZGyroOffsetTC(int8_t offset);\n\n// X_FINE_GAIN register\nint8_t getXFineGain();\nvoid mpu_setXFineGain(int8_t gain);\n\n// Y_FINE_GAIN register\nint8_t getYFineGain();\nvoid mpu_setYFineGain(int8_t gain);\n\n// Z_FINE_GAIN register\nint8_t getZFineGain();\nvoid mpu_setZFineGain(int8_t gain);\n\n// XA_OFFS_* registers\nint16_t mpu_getXAccelOffset();\nvoid mpu_setXAccelOffset(int16_t offset);\n\n// YA_OFFS_* register\nint16_t mpu_getYAccelOffset();\nvoid mpu_setYAccelOffset(int16_t offset);\n\n// ZA_OFFS_* register\nint16_t mpu_getZAccelOffset();\nvoid mpu_setZAccelOffset(int16_t offset);\n\n// XG_OFFS_USR* registers\nint16_t mpu_getXGyroOffset();\nvoid mpu_setXGyroOffset(int16_t offset);\n\n// YG_OFFS_USR* register\nint16_t mpu_getYGyroOffset();\nvoid mpu_setYGyroOffset(int16_t offset);\n\n// ZG_OFFS_USR* register\nint16_t mpu_getZGyroOffset();\nvoid mpu_setZGyroOffset(int16_t offset);\n\n// INT_ENABLE register (DMP functions)\nbool mpu_getIntPLLReadyEnabled();\nvoid mpu_setIntPLLReadyEnabled(bool enabled);\nbool mpu_getIntDMPEnabled();\nvoid mpu_setIntDMPEnabled(bool enabled);\n\n// DMP_INT_STATUS\nbool mpu_getDMPInt5Status();\nbool mpu_getDMPInt4Status();\nbool mpu_getDMPInt3Status();\nbool mpu_getDMPInt2Status();\nbool mpu_getDMPInt1Status();\nbool mpu_getDMPInt0Status();\n\n// INT_STATUS register (DMP functions)\nbool mpu_getIntPLLReadyStatus();\nbool mpu_getIntDMPStatus();\n\n// USER_CTRL register (DMP functions)\nbool mpu_getDMPEnabled();\nvoid mpu_setDMPEnabled(bool enabled);\nvoid mpu_resetDMP();\n\n// BANK_SEL register\nvoid mpu_setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank);\n\n// MEM_START_ADDR register\nvoid mpu_setMemoryStartAddress(uint8_t address);\n\n// MEM_R_W register\nuint8_t mpu_readMemoryByte();\nvoid mpu_writeMemoryByte(uint8_t data);\nvoid mpu_readMemoryBlock(\nuint8_t* data, uint16_t dataSize, uint8_t bank, uint8_t address);\n//bool mpu_writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem);\n//bool mpu_writeProgMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify);\n\n//bool mpu_writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize, bool useProgMem);\n//bool mpu_writeProgDMPConfigurationSet(const uint8_t *data, uint16_t dataSize);\n\n// DMP_CFG_1 register\nuint8_t mpu_getDMPConfig1();\nvoid mpu_setDMPConfig1(uint8_t config);\n\n// DMP_CFG_2 register\nuint8_t mpu_getDMPConfig2();\nvoid mpu_setDMPConfig2(uint8_t config);\n\n#endif /* _mpu_H_ */\n</code></pre>"},{"location":"stm/OledController_8hpp/","title":"File OledController.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; OledController.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include \"I2cController.hpp\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> <li><code>#include \"OledController_fonts.hpp\"</code></li> </ul>"},{"location":"stm/OledController_8hpp/#classes","title":"Classes","text":"Type Name struct OLED_VERTEX struct OLED_t"},{"location":"stm/OledController_8hpp/#public-types","title":"Public Types","text":"Type Name enum OLED_COLOR enum OLED_Error_t"},{"location":"stm/OledController_8hpp/#public-functions","title":"Public Functions","text":"Type Name void oledDispatch (const CoprocReq_OledReq &amp; request)  void oledDrawArc (uint8_t x, uint8_t y, uint8_t radius, uint16_t start_angle, uint16_t sweep, OLED_COLOR color)  void oledDrawCircle (uint8_t par_x, uint8_t par_y, uint8_t par_r, OLED_COLOR color)  void oledDrawLine (uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_COLOR color)  void oledDrawPixel (uint8_t x, uint8_t y, OLED_COLOR color)  void oledDrawRectangle (uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_COLOR color)  void oledFill (OLED_COLOR color)  OLED_Error_t oledFillBuffer (uint8_t * buf, uint32_t len)  bool oledGetDisplayOn () Reads DisplayOn state. void oledInit (const CoprocReq_OledInit &amp; init)  void oledInitOld (void)  void oledInitStm ()  void oledPolyline (const OLED_VERTEX * par_vertex, uint16_t par_size, OLED_COLOR color)  void oledSetContrast (const uint8_t value) Sets the contrast of the display. void oledSetCursor (uint8_t x, uint8_t y)  void oledSetDisplayOn (const bool on) Set Display ON/OFF. bool oledTestConnection ()  void oledUpdateScreen (void)  char oledWriteChar (char ch, FontDef Font, OLED_COLOR color)  void oledWriteCommand (uint8_t byte)  void oledWriteData (uint8_t * buffer, size_t buff_size)  char oledWriteString (const char * str, FontDef Font, OLED_COLOR color)"},{"location":"stm/OledController_8hpp/#macros","title":"Macros","text":"Type Name define OLED_BUFFER_SIZE  1024 define OLED_I2C_ADDR  0x3C"},{"location":"stm/OledController_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"stm/OledController_8hpp/#enum-oled_color","title":"enum OLED_COLOR","text":"<pre><code>enum OLED_COLOR {\nBlack = 0x00,\nWhite = 0x01\n};\n</code></pre>"},{"location":"stm/OledController_8hpp/#enum-oled_error_t","title":"enum OLED_Error_t","text":"<pre><code>enum OLED_Error_t {\nOLED_OK = 0x00,\nOLED_ERR = 0x01\n};\n</code></pre>"},{"location":"stm/OledController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/OledController_8hpp/#function-oleddispatch","title":"function oledDispatch","text":"<pre><code>void oledDispatch (\nconst CoprocReq_OledReq &amp; request\n) </code></pre>"},{"location":"stm/OledController_8hpp/#function-oleddrawarc","title":"function oledDrawArc","text":"<pre><code>void oledDrawArc (\nuint8_t x,\nuint8_t y,\nuint8_t radius,\nuint16_t start_angle,\nuint16_t sweep,\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8hpp/#function-oleddrawcircle","title":"function oledDrawCircle","text":"<pre><code>void oledDrawCircle (\nuint8_t par_x,\nuint8_t par_y,\nuint8_t par_r,\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8hpp/#function-oleddrawline","title":"function oledDrawLine","text":"<pre><code>void oledDrawLine (\nuint8_t x1,\nuint8_t y1,\nuint8_t x2,\nuint8_t y2,\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8hpp/#function-oleddrawpixel","title":"function oledDrawPixel","text":"<pre><code>void oledDrawPixel (\nuint8_t x,\nuint8_t y,\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8hpp/#function-oleddrawrectangle","title":"function oledDrawRectangle","text":"<pre><code>void oledDrawRectangle (\nuint8_t x1,\nuint8_t y1,\nuint8_t x2,\nuint8_t y2,\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8hpp/#function-oledfill","title":"function oledFill","text":"<pre><code>void oledFill (\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8hpp/#function-oledfillbuffer","title":"function oledFillBuffer","text":"<pre><code>OLED_Error_t oledFillBuffer (\nuint8_t * buf,\nuint32_t len\n) </code></pre>"},{"location":"stm/OledController_8hpp/#function-oledgetdisplayon","title":"function oledGetDisplayOn","text":"<p>Reads DisplayOn state. <pre><code>bool oledGetDisplayOn () </code></pre></p> <p>Returns:</p> <p>0: OFF. 1: ON. </p>"},{"location":"stm/OledController_8hpp/#function-oledinit","title":"function oledInit","text":"<pre><code>void oledInit (\nconst CoprocReq_OledInit &amp; init\n) </code></pre>"},{"location":"stm/OledController_8hpp/#function-oledinitold","title":"function oledInitOld","text":"<pre><code>void oledInitOld (\nvoid\n) </code></pre>"},{"location":"stm/OledController_8hpp/#function-oledinitstm","title":"function oledInitStm","text":"<pre><code>void oledInitStm () </code></pre>"},{"location":"stm/OledController_8hpp/#function-oledpolyline","title":"function oledPolyline","text":"<pre><code>void oledPolyline (\nconst OLED_VERTEX * par_vertex,\nuint16_t par_size,\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8hpp/#function-oledsetcontrast","title":"function oledSetContrast","text":"<p>Sets the contrast of the display. <pre><code>void oledSetContrast (\nconst uint8_t value\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>value</code> contrast to set. </li> </ul> <p>Note:</p> <p>Contrast increases as the value increases. </p> <p>Note:</p> <p>RESET = 7Fh. </p>"},{"location":"stm/OledController_8hpp/#function-oledsetcursor","title":"function oledSetCursor","text":"<pre><code>void oledSetCursor (\nuint8_t x,\nuint8_t y\n) </code></pre>"},{"location":"stm/OledController_8hpp/#function-oledsetdisplayon","title":"function oledSetDisplayOn","text":"<p>Set Display ON/OFF. <pre><code>void oledSetDisplayOn (\nconst bool on\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>on</code> 0 for OFF, any for ON. </li> </ul>"},{"location":"stm/OledController_8hpp/#function-oledtestconnection","title":"function oledTestConnection","text":"<pre><code>bool oledTestConnection () </code></pre>"},{"location":"stm/OledController_8hpp/#function-oledupdatescreen","title":"function oledUpdateScreen","text":"<pre><code>void oledUpdateScreen (\nvoid\n) </code></pre>"},{"location":"stm/OledController_8hpp/#function-oledwritechar","title":"function oledWriteChar","text":"<pre><code>char oledWriteChar (\nchar ch,\nFontDef Font,\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8hpp/#function-oledwritecommand","title":"function oledWriteCommand","text":"<pre><code>void oledWriteCommand (\nuint8_t byte\n) </code></pre>"},{"location":"stm/OledController_8hpp/#function-oledwritedata","title":"function oledWriteData","text":"<pre><code>void oledWriteData (\nuint8_t * buffer,\nsize_t buff_size\n) </code></pre>"},{"location":"stm/OledController_8hpp/#function-oledwritestring","title":"function oledWriteString","text":"<pre><code>char oledWriteString (\nconst char * str,\nFontDef Font,\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"stm/OledController_8hpp/#define-oled_buffer_size","title":"define OLED_BUFFER_SIZE","text":"<pre><code>#define OLED_BUFFER_SIZE 1024\n</code></pre>"},{"location":"stm/OledController_8hpp/#define-oled_i2c_addr","title":"define OLED_I2C_ADDR","text":"<pre><code>#define OLED_I2C_ADDR 0x3C\n</code></pre> <p>This Library was originally written by Olivier Van den Eede (4ilo) in 2016. Some refactoring was done and SPI support was added by Aleksander Alekseev (afiskon) in 2018.</p> <p>https://github.com/afiskon/stm32-oled </p> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/OledController.hpp</code></p>"},{"location":"stm/OledController_8hpp_source/","title":"File OledController.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; OledController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stddef.h&gt;\n\n#include \"I2cController.hpp\"\n#include \"rbcx.pb.h\"\n\n#include \"OledController_fonts.hpp\"\n\n#define OLED_I2C_ADDR 0x3C\n#define OLED_BUFFER_SIZE 1024\n\n// Enumeration for screen colors\ntypedef enum {\nBlack = 0x00, // Black color, no pixel\nWhite = 0x01 // Pixel is set. Color depends on OLED\n} OLED_COLOR;\n\ntypedef enum {\nOLED_OK = 0x00,\nOLED_ERR = 0x01 // Generic error.\n} OLED_Error_t;\n\n// Struct to store transformations\ntypedef struct {\nuint16_t CurrentX;\nuint16_t CurrentY;\nuint8_t Inverted;\nbool DisplayOn;\n} OLED_t;\ntypedef struct {\nuint8_t x;\nuint8_t y;\n} OLED_VERTEX;\n\nvoid oledDispatch(const CoprocReq_OledReq&amp; request);\n\nbool oledTestConnection();\nvoid oledInitStm();\nvoid oledInit(const CoprocReq_OledInit&amp; init);\n\n// Procedure definitions\nvoid oledInitOld(void);\nvoid oledFill(OLED_COLOR color);\nvoid oledUpdateScreen(void);\nvoid oledDrawPixel(uint8_t x, uint8_t y, OLED_COLOR color);\nchar oledWriteChar(char ch, FontDef Font, OLED_COLOR color);\nchar oledWriteString(const char* str, FontDef Font, OLED_COLOR color);\nvoid oledSetCursor(uint8_t x, uint8_t y);\nvoid oledDrawLine(\nuint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_COLOR color);\nvoid oledDrawArc(uint8_t x, uint8_t y, uint8_t radius, uint16_t start_angle,\nuint16_t sweep, OLED_COLOR color);\nvoid oledDrawCircle(\nuint8_t par_x, uint8_t par_y, uint8_t par_r, OLED_COLOR color);\nvoid oledPolyline(\nconst OLED_VERTEX* par_vertex, uint16_t par_size, OLED_COLOR color);\nvoid oledDrawRectangle(\nuint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_COLOR color);\nvoid oledSetContrast(const uint8_t value);\nvoid oledSetDisplayOn(const bool on);\nbool oledGetDisplayOn();\n\n// Low-level procedures\nvoid oledWriteCommand(uint8_t byte);\nvoid oledWriteData(uint8_t* buffer, size_t buff_size);\nOLED_Error_t oledFillBuffer(uint8_t* buf, uint32_t len);\n</code></pre>"},{"location":"stm/OledController__fonts_8hpp/","title":"File OledController_fonts.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; OledController_fonts.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"stm/OledController__fonts_8hpp/#classes","title":"Classes","text":"Type Name struct FontDef"},{"location":"stm/OledController__fonts_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name FontDef Font_11x18 FontDef Font_16x26 FontDef Font_6x8 FontDef Font_7x10"},{"location":"stm/OledController__fonts_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/OledController__fonts_8hpp/#variable-font_11x18","title":"variable Font_11x18","text":"<pre><code>FontDef Font_11x18;\n</code></pre>"},{"location":"stm/OledController__fonts_8hpp/#variable-font_16x26","title":"variable Font_16x26","text":"<pre><code>FontDef Font_16x26;\n</code></pre>"},{"location":"stm/OledController__fonts_8hpp/#variable-font_6x8","title":"variable Font_6x8","text":"<pre><code>FontDef Font_6x8;\n</code></pre>"},{"location":"stm/OledController__fonts_8hpp/#variable-font_7x10","title":"variable Font_7x10","text":"<pre><code>FontDef Font_7x10;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/OledController_fonts.hpp</code></p>"},{"location":"stm/OledController__fonts_8hpp_source/","title":"File OledController_fonts.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; OledController_fonts.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\ntypedef struct {\nconst uint8_t FontWidth; uint8_t FontHeight; const uint16_t* data; } FontDef;\n\nextern FontDef Font_6x8;\nextern FontDef Font_7x10;\nextern FontDef Font_11x18;\nextern FontDef Font_16x26;\n</code></pre>"},{"location":"stm/Power_8hpp/","title":"File Power.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; Power.hpp</p> <p>Go to the source code of this file.</p>"},{"location":"stm/Power_8hpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint16_t POWER_CALIBRATE_DEFAULT   = = 0 constexpr uint16_t POWER_CALIBRATE_NO_CHANGE   = = 0xFFFF"},{"location":"stm/Power_8hpp/#public-functions","title":"Public Functions","text":"Type Name uint16_t powerBatteryMidMv ()  uint16_t powerBatteryMv ()  void powerCalibrate (uint16_t vccMv, uint16_t bMidMv, uint16_t vref33Mv, uint16_t currentTemperatureC)  void powerInit ()  void powerPoll ()  void powerShutDown ()  uint16_t powerTemperatureC ()  uint16_t powerVrefMv ()"},{"location":"stm/Power_8hpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/Power_8hpp/#variable-power_calibrate_default","title":"variable POWER_CALIBRATE_DEFAULT","text":"<pre><code>constexpr uint16_t POWER_CALIBRATE_DEFAULT;\n</code></pre>"},{"location":"stm/Power_8hpp/#variable-power_calibrate_no_change","title":"variable POWER_CALIBRATE_NO_CHANGE","text":"<pre><code>constexpr uint16_t POWER_CALIBRATE_NO_CHANGE;\n</code></pre>"},{"location":"stm/Power_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/Power_8hpp/#function-powerbatterymidmv","title":"function powerBatteryMidMv","text":"<pre><code>uint16_t powerBatteryMidMv () </code></pre>"},{"location":"stm/Power_8hpp/#function-powerbatterymv","title":"function powerBatteryMv","text":"<pre><code>uint16_t powerBatteryMv () </code></pre>"},{"location":"stm/Power_8hpp/#function-powercalibrate","title":"function powerCalibrate","text":"<pre><code>void powerCalibrate (\nuint16_t vccMv,\nuint16_t bMidMv,\nuint16_t vref33Mv,\nuint16_t currentTemperatureC\n) </code></pre>"},{"location":"stm/Power_8hpp/#function-powerinit","title":"function powerInit","text":"<pre><code>void powerInit () </code></pre>"},{"location":"stm/Power_8hpp/#function-powerpoll","title":"function powerPoll","text":"<pre><code>void powerPoll () </code></pre>"},{"location":"stm/Power_8hpp/#function-powershutdown","title":"function powerShutDown","text":"<pre><code>void powerShutDown () </code></pre>"},{"location":"stm/Power_8hpp/#function-powertemperaturec","title":"function powerTemperatureC","text":"<pre><code>uint16_t powerTemperatureC () </code></pre>"},{"location":"stm/Power_8hpp/#function-powervrefmv","title":"function powerVrefMv","text":"<pre><code>uint16_t powerVrefMv () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/Power.hpp</code></p>"},{"location":"stm/Power_8hpp_source/","title":"File Power.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; Power.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\nvoid powerInit();\nvoid powerPoll();\n\nuint16_t powerBatteryMv();\nuint16_t powerBatteryMidMv();\nuint16_t powerTemperatureC();\nuint16_t powerVrefMv();\n\nstatic constexpr uint16_t POWER_CALIBRATE_DEFAULT = 0;\nstatic constexpr uint16_t POWER_CALIBRATE_NO_CHANGE = 0xFFFF;\nvoid powerCalibrate(uint16_t vccMv, uint16_t bMidMv, uint16_t vref33Mv,\nuint16_t currentTemperatureC);\n\nvoid powerShutDown();\n</code></pre>"},{"location":"stm/StupidServoController_8hpp/","title":"File StupidServoController.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; StupidServoController.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"stm/StupidServoController_8hpp/#public-functions","title":"Public Functions","text":"Type Name void stupidServoDispatch (const CoprocReq_SetStupidServo &amp; request)  void stupidServoInit ()  void stupidServoReset ()"},{"location":"stm/StupidServoController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/StupidServoController_8hpp/#function-stupidservodispatch","title":"function stupidServoDispatch","text":"<pre><code>void stupidServoDispatch (\nconst CoprocReq_SetStupidServo &amp; request\n) </code></pre>"},{"location":"stm/StupidServoController_8hpp/#function-stupidservoinit","title":"function stupidServoInit","text":"<pre><code>void stupidServoInit () </code></pre>"},{"location":"stm/StupidServoController_8hpp/#function-stupidservoreset","title":"function stupidServoReset","text":"<pre><code>void stupidServoReset () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/StupidServoController.hpp</code></p>"},{"location":"stm/StupidServoController_8hpp_source/","title":"File StupidServoController.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; StupidServoController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"rbcx.pb.h\"\n\nvoid stupidServoInit();\nvoid stupidServoDispatch(const CoprocReq_SetStupidServo&amp; request);\nvoid stupidServoReset();\n</code></pre>"},{"location":"stm/UltrasoundController_8hpp/","title":"File UltrasoundController.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; UltrasoundController.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"stm/UltrasoundController_8hpp/#public-functions","title":"Public Functions","text":"Type Name void ultrasoundDispatch (const CoprocReq_UltrasoundReq &amp; request)  void ultrasoundInit ()  void ultrasoundOnEchoEdge ()  void ultrasoundReset ()"},{"location":"stm/UltrasoundController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/UltrasoundController_8hpp/#function-ultrasounddispatch","title":"function ultrasoundDispatch","text":"<pre><code>void ultrasoundDispatch (\nconst CoprocReq_UltrasoundReq &amp; request\n) </code></pre>"},{"location":"stm/UltrasoundController_8hpp/#function-ultrasoundinit","title":"function ultrasoundInit","text":"<pre><code>void ultrasoundInit () </code></pre>"},{"location":"stm/UltrasoundController_8hpp/#function-ultrasoundonechoedge","title":"function ultrasoundOnEchoEdge","text":"<pre><code>void ultrasoundOnEchoEdge () </code></pre>"},{"location":"stm/UltrasoundController_8hpp/#function-ultrasoundreset","title":"function ultrasoundReset","text":"<pre><code>void ultrasoundReset () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/UltrasoundController.hpp</code></p>"},{"location":"stm/UltrasoundController_8hpp_source/","title":"File UltrasoundController.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; UltrasoundController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"rbcx.pb.h\"\n\nvoid ultrasoundInit();\nvoid ultrasoundDispatch(const CoprocReq_UltrasoundReq&amp; request);\nvoid ultrasoundOnEchoEdge();\nvoid ultrasoundReset();\n</code></pre>"},{"location":"stm/UsbCdcLink_8h/","title":"File UsbCdcLink.h","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; UsbCdcLink.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"stm32.h\"</code></li> <li><code>#include \"usb.h\"</code></li> </ul>"},{"location":"stm/UsbCdcLink_8h/#public-attributes","title":"Public Attributes","text":"Type Name usbd_device udev"},{"location":"stm/UsbCdcLink_8h/#public-functions","title":"Public Functions","text":"Type Name void cdcLinkInit ()  bool cdcLinkIsDebugEpEnabled ()"},{"location":"stm/UsbCdcLink_8h/#macros","title":"Macros","text":"Type Name define CDC_DATA_SZ  0x40 define CDC_DEBUG_NTF_EP  0x84 define CDC_DEBUG_RXD_EP  0x02 define CDC_DEBUG_TXD_EP  0x83 define CDC_EP0_SIZE  0x08 define CDC_NTF_SZ  0x08 define CDC_TUNNEL_NTF_EP  0x82 define CDC_TUNNEL_RXD_EP  0x01 define CDC_TUNNEL_TXD_EP  0x81"},{"location":"stm/UsbCdcLink_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/UsbCdcLink_8h/#variable-udev","title":"variable udev","text":"<pre><code>usbd_device udev;\n</code></pre>"},{"location":"stm/UsbCdcLink_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/UsbCdcLink_8h/#function-cdclinkinit","title":"function cdcLinkInit","text":"<pre><code>void cdcLinkInit () </code></pre>"},{"location":"stm/UsbCdcLink_8h/#function-cdclinkisdebugepenabled","title":"function cdcLinkIsDebugEpEnabled","text":"<pre><code>bool cdcLinkIsDebugEpEnabled () </code></pre>"},{"location":"stm/UsbCdcLink_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"stm/UsbCdcLink_8h/#define-cdc_data_sz","title":"define CDC_DATA_SZ","text":"<pre><code>#define CDC_DATA_SZ 0x40\n</code></pre>"},{"location":"stm/UsbCdcLink_8h/#define-cdc_debug_ntf_ep","title":"define CDC_DEBUG_NTF_EP","text":"<pre><code>#define CDC_DEBUG_NTF_EP 0x84\n</code></pre>"},{"location":"stm/UsbCdcLink_8h/#define-cdc_debug_rxd_ep","title":"define CDC_DEBUG_RXD_EP","text":"<pre><code>#define CDC_DEBUG_RXD_EP 0x02\n</code></pre>"},{"location":"stm/UsbCdcLink_8h/#define-cdc_debug_txd_ep","title":"define CDC_DEBUG_TXD_EP","text":"<pre><code>#define CDC_DEBUG_TXD_EP 0x83\n</code></pre>"},{"location":"stm/UsbCdcLink_8h/#define-cdc_ep0_size","title":"define CDC_EP0_SIZE","text":"<pre><code>#define CDC_EP0_SIZE 0x08\n</code></pre>"},{"location":"stm/UsbCdcLink_8h/#define-cdc_ntf_sz","title":"define CDC_NTF_SZ","text":"<pre><code>#define CDC_NTF_SZ 0x08\n</code></pre>"},{"location":"stm/UsbCdcLink_8h/#define-cdc_tunnel_ntf_ep","title":"define CDC_TUNNEL_NTF_EP","text":"<pre><code>#define CDC_TUNNEL_NTF_EP 0x82\n</code></pre>"},{"location":"stm/UsbCdcLink_8h/#define-cdc_tunnel_rxd_ep","title":"define CDC_TUNNEL_RXD_EP","text":"<pre><code>#define CDC_TUNNEL_RXD_EP 0x01\n</code></pre>"},{"location":"stm/UsbCdcLink_8h/#define-cdc_tunnel_txd_ep","title":"define CDC_TUNNEL_TXD_EP","text":"<pre><code>#define CDC_TUNNEL_TXD_EP 0x81\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/UsbCdcLink.h</code></p>"},{"location":"stm/UsbCdcLink_8h_source/","title":"File UsbCdcLink.h","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; UsbCdcLink.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"stm32.h\"\n#include \"usb.h\"\n\n#define CDC_EP0_SIZE 0x08\n#define CDC_TUNNEL_RXD_EP 0x01\n#define CDC_TUNNEL_TXD_EP 0x81\n#define CDC_TUNNEL_NTF_EP 0x82\n#define CDC_DEBUG_RXD_EP 0x02\n#define CDC_DEBUG_TXD_EP 0x83\n#define CDC_DEBUG_NTF_EP 0x84\n\n#define CDC_DATA_SZ 0x40\n#define CDC_NTF_SZ 0x08\n\nextern usbd_device udev;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid cdcLinkInit();\nbool cdcLinkIsDebugEpEnabled();\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>"},{"location":"stm/dir_fefcb77e2df0f839916cd2cdee5c755e/","title":"Dir demo-projets/stm32/include/utils","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; utils</p>"},{"location":"stm/dir_fefcb77e2df0f839916cd2cdee5c755e/#files","title":"Files","text":"Type Name file BasePriorityRaiser.hpp file ByteFifo.hpp file Debug.hpp file Flash.hpp file HalDma.hpp file MessageBufferWrapper.hpp file MutexWrapper.hpp file QueueWrapper.hpp file Regulator.hpp file StreamBufferWrapper.hpp file TaskWrapper.hpp file TickTimer.hpp file XorShift.hpp <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/</code></p>"},{"location":"stm/BasePriorityRaiser_8hpp/","title":"File BasePriorityRaiser.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; BasePriorityRaiser.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"FreeRTOS.h\"</code></li> </ul>"},{"location":"stm/BasePriorityRaiser_8hpp/#classes","title":"Classes","text":"Type Name class BasePriorityRaiser &lt;TargetIrqPriority&gt; <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/BasePriorityRaiser.hpp</code></p>"},{"location":"stm/BasePriorityRaiser_8hpp_source/","title":"File BasePriorityRaiser.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; BasePriorityRaiser.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"FreeRTOS.h\"\n\ntemplate &lt;uint32_t TargetIrqPriority&gt; class BasePriorityRaiser {\nstatic_assert(\nTargetIrqPriority &gt;= configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY,\n\"The TargetIrqPriority is too high, expected \"\n\"configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY and lower.\");\nstatic_assert(TargetIrqPriority &lt; configLIBRARY_LOWEST_INTERRUPT_PRIORITY,\n\"The TargetIrqPriority is too low, expected \"\n\"configLIBRARY_LOWEST_INTERRUPT_PRIORITY and higher.\");\n\npublic:\nBasePriorityRaiser() {}\n~BasePriorityRaiser() {}\n\nvoid lock() {\nvPortSetBASEPRI(TargetIrqPriority &lt;&lt; 4);\n__asm volatile(\"dsb\" ::: \"memory\");\n__asm volatile(\"isb\");\n}\n\nvoid unlock() { vPortSetBASEPRI(0); }\n\nprivate:\nBasePriorityRaiser(const BasePriorityRaiser&amp;) = delete;\n};\n</code></pre>"},{"location":"stm/ByteFifo_8hpp/","title":"File ByteFifo.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; ByteFifo.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"stm/ByteFifo_8hpp/#classes","title":"Classes","text":"Type Name class ByteFifo &lt;Size&gt; <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/ByteFifo.hpp</code></p>"},{"location":"stm/ByteFifo_8hpp_source/","title":"File ByteFifo.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; ByteFifo.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;optional&gt;\n#include &lt;stdint.h&gt;\n\ntemplate &lt;int Size&gt; class ByteFifo {\nstd::array&lt;uint8_t, Size&gt; m_fifo;\nint m_head, m_tail;\n\nint static adjust(int index, int delta) {\nindex += delta;\nif (index &gt;= Size) {\nindex -= Size;\n}\nif (index &lt; 0) {\nindex += Size;\n}\nreturn index;\n}\n\npublic:\nByteFifo()\n: m_head(0)\n, m_tail(0) {}\n\nuint8_t* data() const { return (uint8_t*)m_fifo.data(); }\n\nconstexpr size_t size() const { return m_fifo.size(); }\n\nsize_t available() const {\nif (m_head &gt;= m_tail) {\nreturn m_head - m_tail;\n} else {\nreturn Size - m_tail + m_head;\n}\n}\n\nbool hasData() const { return m_head != m_tail; }\n\nvoid setHead(int newHead) { m_head = newHead; }\n\nvoid clear() { m_tail = m_head; }\n\nvoid writeSpan(uint8_t* data, size_t len) {\nif (len &gt; Size) {\ndata += len - Size;\nlen = Size;\n}\n\nconst size_t chunk = std::min(size_t(Size - m_head), len);\nstd::copy_n(data, chunk, this-&gt;data() + m_head);\nif (len &gt; chunk) {\nstd::copy_n(data + chunk, len - chunk, this-&gt;data());\n}\nnotifyWritten(len);\n}\n\nstd::pair&lt;uint8_t*, size_t&gt; writeableSpan() const {\nint preTail = adjust(m_tail, -1);\nreturn m_head &gt;= preTail\n? std::make_pair(data() + m_head, std::max(0, int(size()) - m_head))\n: std::make_pair(data() + m_head, std::max(0, preTail - m_head));\n}\n\nvoid notifyWritten(size_t len) { m_head = adjust(m_head, len); }\n\nuint8_t pop() {\nauto value = m_fifo[m_tail];\nm_tail = adjust(m_tail, 1);\nreturn value;\n}\n\nvoid push(uint8_t b) {\nm_fifo[m_head] = b;\nnotifyWritten(1);\n}\n\nvoid peekSpan(uint8_t* data, size_t len) {\nconst size_t chunk = std::min(size_t(Size - m_tail), len);\nmemcpy(data, this-&gt;data() + m_tail, chunk);\nif (chunk &lt; len) {\nmemcpy(data + chunk, this-&gt;data(), len - chunk);\n}\n}\n\nstd::pair&lt;uint8_t*, size_t&gt; readableSpan() const {\nreturn m_head &gt;= m_tail\n? std::make_pair(data() + m_tail, m_head - m_tail)\n: std::make_pair(data() + m_tail, int(size()) - m_tail);\n}\n\nvoid notifyRead(size_t len) { m_tail = adjust(m_tail, len); }\n};\n</code></pre>"},{"location":"stm/Debug_8hpp/","title":"File Debug.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; Debug.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> </ul>"},{"location":"stm/Debug_8hpp/#public-functions","title":"Public Functions","text":"Type Name void DEBUG_HEX (const uint8_t * data, size_t len)  bool isInInterrupt ()  void printTaskInfo ()  void rebootToDfu ()"},{"location":"stm/Debug_8hpp/#macros","title":"Macros","text":"Type Name define DEBUG (fmt, ...)  define DEBUGLN (fmt, ...)  define STRINGIFY (x) #x define TOSTRING (x) STRINGIFY(x)"},{"location":"stm/Debug_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/Debug_8hpp/#function-debug_hex","title":"function DEBUG_HEX","text":"<pre><code>inline void DEBUG_HEX (\nconst uint8_t * data,\nsize_t len\n) </code></pre>"},{"location":"stm/Debug_8hpp/#function-isininterrupt","title":"function isInInterrupt","text":"<pre><code>inline bool isInInterrupt () </code></pre>"},{"location":"stm/Debug_8hpp/#function-printtaskinfo","title":"function printTaskInfo","text":"<pre><code>inline void printTaskInfo () </code></pre>"},{"location":"stm/Debug_8hpp/#function-reboottodfu","title":"function rebootToDfu","text":"<pre><code>void rebootToDfu () </code></pre>"},{"location":"stm/Debug_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"stm/Debug_8hpp/#define-debug","title":"define DEBUG","text":"<pre><code>#define DEBUG (\nfmt,\n...\n) printf(\"[%10lu][\" __FILE__ \":\" TOSTRING(__LINE__) \"]: \" fmt,               \\\n        xTaskGetTickCount(), ##__VA_ARGS__)\n</code></pre>"},{"location":"stm/Debug_8hpp/#define-debugln","title":"define DEBUGLN","text":"<pre><code>#define DEBUGLN (\nfmt,\n...\n) DEBUG(fmt, ##__VA_ARGS__);                                                 \\\n    printf(\"\\n\");\n</code></pre>"},{"location":"stm/Debug_8hpp/#define-stringify","title":"define STRINGIFY","text":"<pre><code>#define STRINGIFY (\nx\n) #x\n</code></pre>"},{"location":"stm/Debug_8hpp/#define-tostring","title":"define TOSTRING","text":"<pre><code>#define TOSTRING (\nx\n) STRINGIFY(x)\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/Debug.hpp</code></p>"},{"location":"stm/Debug_8hpp_source/","title":"File Debug.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; Debug.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;array&gt;\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\n#define STRINGIFY(x) #x\n#define TOSTRING(x) STRINGIFY(x)\n\n#ifndef NDEBUG\n\n#define DEBUG(fmt, ...)                                                        \\\n    printf(\"[%10lu][\" __FILE__ \":\" TOSTRING(__LINE__) \"]: \" fmt,               \\\n        xTaskGetTickCount(), ##__VA_ARGS__)\n\ninline void DEBUG_HEX(const uint8_t* data, size_t len) {\nstatic const char* hex = \"0123456789ABCDEF\";\nchar buf[] = { '0', '0', ' ' };\n\nfor (size_t i = 0; i &lt; len; ++i) {\nbuf[0] = hex[data[i] &gt;&gt; 4];\nbuf[1] = hex[data[i] &amp; 0xF];\nfwrite(buf, sizeof(buf), 1, stdout);\n}\nputchar('\\n');\n}\n\n#define DEBUGLN(fmt, ...)                                                      \\\n    DEBUG(fmt, ##__VA_ARGS__);                                                 \\\n    printf(\"\\n\");\n\n#else\n\n#define DEBUG(fmt, ...)                                                        \\\n    do {                                                                       \\\n    } while (0);\n\ninline void DEBUG_HEX(const uint8_t* data, size_t len) {}\n#endif\n\ninline void printTaskInfo() {\nstd::array&lt;TaskStatus_t, 10&gt; statuses;\n\nunsigned taskNum\n= uxTaskGetSystemState(statuses.data(), statuses.size(), nullptr);\n\nprintf(\"Task stacks:\\n\");\nfor (unsigned i = 0; i &lt; taskNum; i++) {\nauto&amp; status = statuses[i];\n\n// Thanks FreeRTOS, because you don't allow reading pxEndOfStack\n// to obtain the total stack size of a task,\n// I have to use your stupid Dummy fields.\nauto stupidTask = (StaticTask_t*)(status.xHandle);\nunsigned bytesTotal\n= uintptr_t(stupidTask-&gt;pxDummy8) - uintptr_t(stupidTask-&gt;pxDummy6);\n\nunsigned bytesFree = status.usStackHighWaterMark * sizeof(StackType_t);\n\nprintf(\"#%d %s: %u bytes untouched (of %u)\\n\", status.xTaskNumber,\nstatus.pcTaskName, bytesFree, bytesTotal);\n}\n}\n\ninline bool isInInterrupt() {\nreturn (SCB-&gt;ICSR &amp; SCB_ICSR_VECTACTIVE_Msk) != 0;\n}\n\nvoid rebootToDfu();\n</code></pre>"},{"location":"stm/Flash_8hpp/","title":"File Flash.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; Flash.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"stm32f1xx_hal_flash.h\"</code></li> </ul>"},{"location":"stm/Flash_8hpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint32_t FLASH_PAGE_POWER_CALIBRATION   = = FLASH_BANK1_END + 1 - FLASH_PAGE_SIZE"},{"location":"stm/Flash_8hpp/#public-functions","title":"Public Functions","text":"Type Name void flashWritePage (uint32_t pageAddress, uint8_t * data, size_t size)"},{"location":"stm/Flash_8hpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/Flash_8hpp/#variable-flash_page_power_calibration","title":"variable FLASH_PAGE_POWER_CALIBRATION","text":"<pre><code>constexpr uint32_t FLASH_PAGE_POWER_CALIBRATION;\n</code></pre>"},{"location":"stm/Flash_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/Flash_8hpp/#function-flashwritepage","title":"function flashWritePage","text":"<pre><code>inline void flashWritePage (\nuint32_t pageAddress,\nuint8_t * data,\nsize_t size\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/Flash.hpp</code></p>"},{"location":"stm/Flash_8hpp_source/","title":"File Flash.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; Flash.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stdlib.h&gt;\n\n#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx_hal_flash.h\"\n\nstatic constexpr uint32_t FLASH_PAGE_POWER_CALIBRATION\n= FLASH_BANK1_END + 1 - FLASH_PAGE_SIZE;\n\ninline void flashWritePage(uint32_t pageAddress, uint8_t* data, size_t size) {\nif (pageAddress % FLASH_PAGE_SIZE != 0 || pageAddress &lt; FLASH_BASE\n|| pageAddress &gt;= FLASH_BANK1_END) {\nabort();\n}\n\nif (size &gt; FLASH_PAGE_SIZE || size % 2 != 0) {\nabort();\n}\n\nif (HAL_FLASH_Unlock() != HAL_OK)\nabort();\n\nFLASH_EraseInitTypeDef eraseCfg = {\n.TypeErase = FLASH_TYPEERASE_PAGES,\n.Banks = FLASH_BANK_1,\n.PageAddress = pageAddress,\n.NbPages = 1,\n};\nuint32_t pageError = 0;\nif (HAL_FLASHEx_Erase(&amp;eraseCfg, &amp;pageError) != HAL_OK)\nabort();\n\nuint32_t address = pageAddress;\nuint8_t* end = data + size;\n\nwhile (end - data &gt;= 8) {\nif (HAL_FLASH_Program(\nFLASH_TYPEPROGRAM_DOUBLEWORD, address, *(uint64_t*)data)\n!= HAL_OK)\nabort();\naddress += 8;\ndata += 8;\n}\n\nwhile (end - data &gt;= 2) {\nif (HAL_FLASH_Program(\nFLASH_TYPEPROGRAM_DOUBLEWORD, address, *(uint16_t*)data)\n!= HAL_OK)\nabort();\naddress += 2;\ndata += 2;\n}\n\nif (HAL_FLASH_Lock() != HAL_OK)\nabort();\n}\n</code></pre>"},{"location":"stm/HalDma_8hpp/","title":"File HalDma.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; HalDma.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"stm32f1xx_hal_dma.h\"</code></li> </ul>"},{"location":"stm/HalDma_8hpp/#public-functions","title":"Public Functions","text":"Type Name HAL_StatusTypeDef HAL_DMA_PollForTransfer_Really (DMA_HandleTypeDef * hdma, uint32_t CompleteLevel, uint32_t Timeout)"},{"location":"stm/HalDma_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/HalDma_8hpp/#function-hal_dma_pollfortransfer_really","title":"function HAL_DMA_PollForTransfer_Really","text":"<pre><code>inline HAL_StatusTypeDef HAL_DMA_PollForTransfer_Really (\nDMA_HandleTypeDef * hdma,\nuint32_t CompleteLevel,\nuint32_t Timeout\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/HalDma.hpp</code></p>"},{"location":"stm/HalDma_8hpp_source/","title":"File HalDma.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; HalDma.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"stm32f1xx_hal_dma.h\"\n\n// HAL_DMA_PollForTransfer, despite its name, can't be used\n// for polling. When it hits timeout (even the 0 one), HAL_DMA_STATE_READY is set\n// into the State member, regardless of whether the transfer is actually done or not.\n// So you can't poll for whether the transfer is done. With the Poll function. What the fuck.\n//\n// This version will never set the State to HAL_DMA_STATE_READY on Timeout,\n// only on error or when it is really done.\n//\n// Countless hours were wasted because of this garbage.\n//\n// Copied from https://github.com/STMicroelectronics/STM32CubeF1/blob/441b2cbdc25aa50437a59c4bffe22b88e78942c9/Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_dma.c\ninline HAL_StatusTypeDef HAL_DMA_PollForTransfer_Really(\nDMA_HandleTypeDef* hdma, uint32_t CompleteLevel, uint32_t Timeout) {\nuint32_t temp;\nuint32_t tickstart = 0U;\n\nif (HAL_DMA_STATE_BUSY != hdma-&gt;State) {\n/* no transfer ongoing */\nhdma-&gt;ErrorCode = HAL_DMA_ERROR_NO_XFER;\n__HAL_UNLOCK(hdma);\nreturn HAL_ERROR;\n}\n\n/* Polling mode not supported in circular mode */\nif (RESET != (hdma-&gt;Instance-&gt;CCR &amp; DMA_CCR_CIRC)) {\nhdma-&gt;ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\nreturn HAL_ERROR;\n}\n\n/* Get the level transfer complete flag */\nif (CompleteLevel == HAL_DMA_FULL_TRANSFER) {\n/* Transfer Complete flag */\ntemp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);\n} else {\n/* Half Transfer Complete flag */\ntemp = __HAL_DMA_GET_HT_FLAG_INDEX(hdma);\n}\n\n/* Get tick */\ntickstart = HAL_GetTick();\n\nwhile (__HAL_DMA_GET_FLAG(hdma, temp) == RESET) {\nif ((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma))\n!= RESET)) {\n/* When a DMA transfer error occurs */\n/* A hardware clear of its EN bits is performed */\n/* Clear all flags */\nhdma-&gt;DmaBaseAddress-&gt;IFCR = (DMA_ISR_GIF1 &lt;&lt; hdma-&gt;ChannelIndex);\n\n/* Update error code */\nSET_BIT(hdma-&gt;ErrorCode, HAL_DMA_ERROR_TE);\n\n/* Change the DMA state */\nhdma-&gt;State = HAL_DMA_STATE_READY;\n\n/* Process Unlocked */\n__HAL_UNLOCK(hdma);\n\nreturn HAL_ERROR;\n}\n/* Check for the Timeout */\nif (Timeout != HAL_MAX_DELAY) {\nif ((Timeout == 0U) || ((HAL_GetTick() - tickstart) &gt; Timeout)) {\n/* Update error code */\nSET_BIT(hdma-&gt;ErrorCode, HAL_DMA_ERROR_TIMEOUT);\n\n/* Change the DMA state */\n// Disabled, because it makes no fucking sense.\n//hdma-&gt;State = HAL_DMA_STATE_READY;\n\n/* Process Unlocked */\n\n// Don't unlock until transfer done.\n//__HAL_UNLOCK(hdma);\n\nreturn HAL_ERROR;\n}\n}\n}\n\nif (CompleteLevel == HAL_DMA_FULL_TRANSFER) {\n/* Clear the transfer complete flag */\n__HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));\n\n/* The selected Channelx EN bit is cleared (DMA is disabled and\n    all transfers are complete) */\nhdma-&gt;State = HAL_DMA_STATE_READY;\n} else {\n/* Clear the half transfer complete flag */\n__HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));\n}\n\n/* Process unlocked */\n__HAL_UNLOCK(hdma);\n\nreturn HAL_OK;\n}\n</code></pre>"},{"location":"stm/MessageBufferWrapper_8hpp/","title":"File MessageBufferWrapper.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; MessageBufferWrapper.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"message_buffer.h\"</code></li> <li><code>#include \"Debug.hpp\"</code></li> </ul>"},{"location":"stm/MessageBufferWrapper_8hpp/#classes","title":"Classes","text":"Type Name class MessageBufferWrapper &lt;SizeInBytes&gt; <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/MessageBufferWrapper.hpp</code></p>"},{"location":"stm/MessageBufferWrapper_8hpp_source/","title":"File MessageBufferWrapper.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; MessageBufferWrapper.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\n#include \"FreeRTOS.h\"\n#include \"message_buffer.h\"\n\n#include \"Debug.hpp\"\n\ntemplate &lt;size_t SizeInBytes&gt; class MessageBufferWrapper {\npublic:\nMessageBufferWrapper()\n: m_handle(nullptr) {}\n\n~MessageBufferWrapper() {\nif (m_handle)\nvMessageBufferDelete(m_handle);\n}\n\nvoid create() {\nif (m_handle)\nabort();\nm_handle = xMessageBufferCreateStatic(\nSizeInBytes, m_buffer, &amp;m_bufferStruct);\n}\n\nMessageBufferHandle_t handle() const { return m_handle; }\n\nbool reset() { return xMessageBufferReset(m_handle) == pdPASS; }\n\nbool push_back(uint8_t* data, size_t len, TickType_t ticks_to_wait,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nsize_t res;\nif (isInInterrupt()) {\nres = xMessageBufferSendFromISR(\nm_handle, (void*)data, len, pxHigherPriorityTaskWoken);\n} else {\nres = xMessageBufferSend(m_handle, (void*)data, len, ticks_to_wait);\n}\nreturn res == len;\n}\n\ntemplate &lt;typename T&gt;\nbool push_back(const T&amp; val, TickType_t ticks_to_wait,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nstatic_assert(std::is_trivial&lt;T&gt;::value);\nreturn push_back((uint8_t*)&amp;val, sizeof(T), ticks_to_wait,\npxHigherPriorityTaskWoken);\n}\n\nsize_t pop_front(uint8_t* dst, size_t maxLen, TickType_t ticks_to_wait,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nsize_t res;\nif (isInInterrupt()) {\nres = xMessageBufferReceiveFromISR(\nm_handle, (void*)dst, maxLen, pxHigherPriorityTaskWoken);\n} else {\nres = xMessageBufferReceive(\nm_handle, (void*)dst, maxLen, ticks_to_wait);\n}\nreturn res;\n}\n\ntemplate &lt;typename T&gt;\nbool pop_front(T&amp; dst, TickType_t ticks_to_wait,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nstatic_assert(std::is_trivial&lt;T&gt;::value);\n\nconst auto res = pop_front(\n(uint8_t*)dst, sizeof(T), ticks_to_wait, pxHigherPriorityTaskWoken);\nif (res &gt; 0 &amp;&amp; res != sizeof(T))\nabort();\nreturn res != 0;\n}\n\nprivate:\nuint8_t m_buffer[SizeInBytes];\nStaticMessageBuffer_t m_bufferStruct;\nMessageBufferHandle_t m_handle;\n};\n</code></pre>"},{"location":"stm/MutexWrapper_8hpp/","title":"File MutexWrapper.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; MutexWrapper.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"semphr.h\"</code></li> </ul>"},{"location":"stm/MutexWrapper_8hpp/#classes","title":"Classes","text":"Type Name class MutexWrapper <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/MutexWrapper.hpp</code></p>"},{"location":"stm/MutexWrapper_8hpp_source/","title":"File MutexWrapper.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; MutexWrapper.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"FreeRTOS.h\"\n#include \"semphr.h\"\n\nclass MutexWrapper {\npublic:\nMutexWrapper()\n: m_handle(nullptr) {}\n\n~MutexWrapper() {\nif (m_handle)\nvSemaphoreDelete(m_handle);\n}\n\nvoid create() {\nif (m_handle)\nabort();\n\nm_handle = xSemaphoreCreateMutexStatic(&amp;m_buffer);\n}\n\nSemaphoreHandle_t native_handle() const { return m_handle; }\n\nvoid lock() { xSemaphoreTake(m_handle, portMAX_DELAY); }\nvoid unlock() { xSemaphoreGive(m_handle); }\n\nprivate:\nSemaphoreHandle_t m_handle;\nStaticSemaphore_t m_buffer;\n};\n</code></pre>"},{"location":"stm/QueueWrapper_8hpp/","title":"File QueueWrapper.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; QueueWrapper.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include \"Debug.hpp\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"queue.h\"</code></li> </ul>"},{"location":"stm/QueueWrapper_8hpp/#classes","title":"Classes","text":"Type Name class QueueWrapper &lt;typename T, Length&gt; <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/QueueWrapper.hpp</code></p>"},{"location":"stm/QueueWrapper_8hpp_source/","title":"File QueueWrapper.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; QueueWrapper.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;type_traits&gt;\n\n#include \"Debug.hpp\"\n#include \"FreeRTOS.h\"\n#include \"queue.h\"\n\ntemplate &lt;typename T, UBaseType_t Length&gt; class QueueWrapper {\nstatic_assert(std::is_trivial&lt;T&gt;::value);\n\npublic:\nQueueWrapper()\n: m_handle(nullptr) {}\n\n~QueueWrapper() {\nif (m_handle)\nvQueueDelete(m_handle);\n}\n\nvoid create() {\nm_handle\n= xQueueCreateStatic(Length, sizeof(T), m_buffer, &amp;m_queueStruct);\n}\n\nQueueHandle_t handle() const { return m_handle; }\n\nvoid reset() { xQueueReset(m_handle); }\n\nbool push_back(const T&amp; val, TickType_t ticks_to_wait = portMAX_DELAY,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nBaseType_t res;\nif (isInInterrupt()) {\nres = xQueueSendToBackFromISR(\nm_handle, &amp;val, pxHigherPriorityTaskWoken);\n} else {\nres = xQueueSendToBack(m_handle, &amp;val, ticks_to_wait);\n}\nreturn res == pdPASS;\n}\n\nbool overwrite(\nconst T&amp; val, BaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nBaseType_t res;\nif (isInInterrupt()) {\nres = xQueueOverwriteFromISR(\nm_handle, &amp;val, pxHigherPriorityTaskWoken);\n} else {\nres = xQueueOverwrite(m_handle, &amp;val);\n}\nreturn res == pdPASS;\n}\n\nbool push_front(const T&amp; val, TickType_t ticks_to_wait = portMAX_DELAY,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nBaseType_t res;\nif (isInInterrupt()) {\nres = xQueueSendToFrontFromISR(\nm_handle, &amp;val, pxHigherPriorityTaskWoken);\n} else {\nres = xQueueSendToFront(m_handle, &amp;val, ticks_to_wait);\n}\nreturn res == pdPASS;\n}\n\nbool pop_front(T&amp; result, TickType_t ticks_to_wait = portMAX_DELAY,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nBaseType_t res;\nif (isInInterrupt()) {\nres = xQueueReceiveFromISR(\nm_handle, &amp;result, pxHigherPriorityTaskWoken);\n} else {\nres = xQueueReceive(m_handle, &amp;result, ticks_to_wait);\n}\nreturn res == pdTRUE;\n}\n\nprivate:\nQueueWrapper(const QueueWrapper&amp;) = delete;\n\nuint8_t m_buffer[sizeof(T) * Length];\nStaticQueue_t m_queueStruct;\nQueueHandle_t m_handle;\n};\n</code></pre>"},{"location":"stm/Regulator_8hpp/","title":"File Regulator.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; Regulator.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"stm/Regulator_8hpp/#classes","title":"Classes","text":"Type Name struct Regulator <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/Regulator.hpp</code></p>"},{"location":"stm/Regulator_8hpp_source/","title":"File Regulator.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; Regulator.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\nstruct Regulator {\ntypedef uint32_t coef_type;\ntypedef int32_t value_type;\n\nconstexpr Regulator&amp; operator=(Regulator&amp;&amp; other) = default;\n\nRegulator() = default;\nRegulator(value_type max_output, coef_type p, coef_type i, coef_type d)\n: m_stop(false)\n, m_p(p)\n, m_i(i)\n, m_d(d)\n, m_e(0)\n, m_le(0)\n, m_de(0)\n, m_output(0)\n, m_integrator(0)\n, m_max_output(max_output) {}\n\nvoid setP(const coef_type&amp; v) { m_p = v; }\ncoef_type P() const { return m_p; }\nvoid setI(const coef_type&amp; v) { m_i = v; }\ncoef_type I() const { return m_i; }\nvoid setD(const coef_type&amp; v) { m_d = v; }\ncoef_type D() const { return m_d; }\nvoid setMaxOutput(value_type max_output) { m_max_output = max_output; }\nvalue_type maxOutput() { return m_max_output; }\n\nvoid stop(bool s = true) {\nm_stop = s;\nm_e = 0;\nm_le = 0;\nm_de = 0;\nm_integrator = 0;\n}\n\nvalue_type process(value_type target, value_type actual) {\nif (m_stop)\nreturn 0;\nm_e = target - actual;\n\nvalue_type integrator = m_integrator;\n\nif (m_i != 0)\nintegrator += m_e;\n\nm_de = m_e - m_le;\n\nvalue_type x = ((value_type(m_p) * m_e) &gt;&gt; 8)\n+ ((value_type(m_d) * m_de) &gt;&gt; 8)\n+ ((value_type(m_i) * integrator) &gt;&gt; 8);\n\nif (x &gt; m_max_output) {\nm_output = m_max_output;\nif (integrator &lt; 0)\nm_integrator = integrator;\n} else if (x &lt; -m_max_output) {\nm_output = -m_max_output;\nif (integrator &gt; 0)\nm_integrator = integrator;\n} else {\nm_output = x;\nm_integrator = integrator;\n}\nm_le = m_e;\nreturn m_output;\n}\n\nvoid clear() {\nm_integrator = 0;\nm_le = m_e;\n}\n\nvalue_type e() const { return m_e; }\nvalue_type de() const { return m_de; }\nvalue_type output() const { return m_output; }\nvalue_type integrator() const { return m_integrator; }\n\nprivate:\nbool m_stop;\ncoef_type m_p;\ncoef_type m_i;\ncoef_type m_d;\nvalue_type m_e;\nvalue_type m_le;\nvalue_type m_de;\nvalue_type m_output;\nvalue_type m_integrator;\nvalue_type m_max_output; //crop output, absolute value\n};\n</code></pre>"},{"location":"stm/StreamBufferWrapper_8hpp/","title":"File StreamBufferWrapper.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; StreamBufferWrapper.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"stream_buffer.h\"</code></li> <li><code>#include \"Debug.hpp\"</code></li> </ul>"},{"location":"stm/StreamBufferWrapper_8hpp/#classes","title":"Classes","text":"Type Name class StreamBufferWrapper &lt;SizeInBytes&gt; <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/StreamBufferWrapper.hpp</code></p>"},{"location":"stm/StreamBufferWrapper_8hpp_source/","title":"File StreamBufferWrapper.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; StreamBufferWrapper.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\n#include \"FreeRTOS.h\"\n#include \"stream_buffer.h\"\n\n#include \"Debug.hpp\"\n\ntemplate &lt;size_t SizeInBytes&gt; class StreamBufferWrapper {\npublic:\nStreamBufferWrapper()\n: m_handle(nullptr) {}\n\n~StreamBufferWrapper() {\nif (m_handle)\nvStreamBufferDelete(m_handle);\n}\n\nvoid create(size_t xTriggerLevelBytes = 1) {\nif (m_handle)\nabort();\nif (xTriggerLevelBytes &gt; SizeInBytes)\nabort();\n\nm_handle = xStreamBufferCreateStatic(\nSizeInBytes, xTriggerLevelBytes, m_buffer, &amp;m_bufferStruct);\n}\n\nStreamBufferHandle_t handle() const { return m_handle; }\n\nbool reset() { return xStreamBufferReset(m_handle) == pdPASS; }\n\nsize_t freeSpace() const { return xStreamBufferSpacesAvailable(m_handle); }\nsize_t available() const { return xStreamBufferBytesAvailable(m_handle); }\n\nsize_t write(const uint8_t* const data, size_t len,\nTickType_t ticks_to_wait,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nsize_t res;\nif (isInInterrupt()) {\nres = xStreamBufferSendFromISR(\nm_handle, (void*)data, len, pxHigherPriorityTaskWoken);\n} else {\nres = xStreamBufferSend(m_handle, (void*)data, len, ticks_to_wait);\n}\nreturn res;\n}\n\nsize_t read(uint8_t* dst, size_t maxLen, TickType_t ticks_to_wait,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nsize_t res;\nif (isInInterrupt()) {\nres = xStreamBufferReceiveFromISR(\nm_handle, (void*)dst, maxLen, pxHigherPriorityTaskWoken);\n} else {\nres = xStreamBufferReceive(\nm_handle, (void*)dst, maxLen, ticks_to_wait);\n}\nreturn res;\n}\n\nprivate:\nuint8_t m_buffer[SizeInBytes];\nStaticStreamBuffer_t m_bufferStruct;\nStreamBufferHandle_t m_handle;\n};\n</code></pre>"},{"location":"stm/TaskWrapper_8hpp/","title":"File TaskWrapper.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; TaskWrapper.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> </ul>"},{"location":"stm/TaskWrapper_8hpp/#classes","title":"Classes","text":"Type Name class TaskWrapper &lt;StackSizeBytes&gt; <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/TaskWrapper.hpp</code></p>"},{"location":"stm/TaskWrapper_8hpp_source/","title":"File TaskWrapper.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; TaskWrapper.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;functional&gt;\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\ntemplate &lt;int StackSizeBytes&gt; class TaskWrapper {\npublic:\nTaskWrapper()\n: m_handle(nullptr) {}\n\n~TaskWrapper() { abort(); }\n\nbool start(\nconst char* name, UBaseType_t priority, std::function&lt;void()&gt;&amp;&amp; func) {\nif (m_handle)\nreturn false;\nm_func = std::move(func);\nm_handle = xTaskCreateStatic(&amp;trampoline, name,\nStackSizeBytes / sizeof(StackType_t), &amp;m_func, priority, m_stack,\n&amp;m_taskStruct);\nreturn m_handle != nullptr;\n}\n\nTaskHandle_t handle() const { return m_handle; }\n\nprivate:\nTaskWrapper(const TaskWrapper&amp;) = delete;\n\nstatic void trampoline(void* arg) {\nconst auto* func = (std::function&lt;void()&gt;*)arg;\n(*func)();\n}\n\nStackType_t m_stack[StackSizeBytes / sizeof(StackType_t)];\nStaticTask_t m_taskStruct;\nstd::function&lt;void()&gt; m_func;\nTaskHandle_t m_handle;\n};\n</code></pre>"},{"location":"stm/TickTimer_8hpp/","title":"File TickTimer.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; TickTimer.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> </ul>"},{"location":"stm/TickTimer_8hpp/#classes","title":"Classes","text":"Type Name class TickTimer <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/TickTimer.hpp</code></p>"},{"location":"stm/TickTimer_8hpp_source/","title":"File TickTimer.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; TickTimer.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n#include &lt;stdlib.h&gt;\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\nclass TickTimer {\nstatic constexpr uint32_t MaxDelay = UINT32_MAX / 2;\n\npublic:\nTickTimer()\n: m_timeoutAt(0) {}\n~TickTimer() {}\n\nbool isActive() const { return m_timeoutAt != 0; }\n\nvoid stop() { m_timeoutAt = 0; }\n\nvoid restart(uint32_t delayMs) {\nif (pdMS_TO_TICKS(delayMs) &gt; MaxDelay) {\nabort();\n}\n\nconst auto now = xTaskGetTickCount();\nm_timeoutAt = now + pdMS_TO_TICKS(delayMs);\nif (m_timeoutAt == 0)\n++m_timeoutAt;\n}\n\nbool poll() {\nif (m_timeoutAt == 0)\nreturn false;\n\nconst uint32_t now = xTaskGetTickCount();\nif (now &lt; m_timeoutAt)\nreturn false;\n\n// m_timeoutAt wrapped around, but xTaskGetTickCount didn't yet\nif (now - m_timeoutAt &gt; MaxDelay)\nreturn false;\nm_timeoutAt = 0;\nreturn true;\n}\n\nprivate:\nuint32_t m_timeoutAt;\n};\n</code></pre>"},{"location":"stm/XorShift_8hpp/","title":"File XorShift.hpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; XorShift.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"stm/XorShift_8hpp/#classes","title":"Classes","text":"Type Name class XorShift Fast deterministic PRNG - https://en.wikipedia.org/wiki/Xorshift . <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/include/utils/XorShift.hpp</code></p>"},{"location":"stm/XorShift_8hpp_source/","title":"File XorShift.hpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; include &gt; utils &gt; XorShift.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\nclass XorShift {\nuint32_t m_state;\n\npublic:\nXorShift(uint32_t seed = 0xb45d9453)\n: m_state(seed) {}\n\nuint32_t next() {\nuint32_t x = m_state;\nx ^= x &lt;&lt; 13;\nx ^= x &gt;&gt; 17;\nx ^= x &lt;&lt; 5;\nreturn m_state = x;\n}\n};\n</code></pre>"},{"location":"stm/dir_d99a4b5e3dbb638c6d22b952f1ff264e/","title":"Dir demo-projets/stm32/src","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src</p>"},{"location":"stm/dir_d99a4b5e3dbb638c6d22b952f1ff264e/#files","title":"Files","text":"Type Name file Bsp.cpp file ButtonController.cpp file CdcUartTunnel.cpp file ControlLink.cpp file DebugLink.cpp file Dispatcher.cpp file Esp32Manager.cpp file FreeRTOSCallbacks.cpp file I2cController.cpp file MotorController.cpp file MpuController.cpp file OledController.cpp file OledController_fonts.cpp file Power.cpp file StupidServoController.cpp file UltrasoundController.cpp file UsbCdcDescriptors.c file UsbCdcLink.cpp file main.cpp"},{"location":"stm/dir_d99a4b5e3dbb638c6d22b952f1ff264e/#directories","title":"Directories","text":"Type Name dir utils <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/</code></p>"},{"location":"stm/Bsp_8cpp/","title":"File Bsp.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; Bsp.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"BuzzerController.hpp\"</code></li> <li><code>#include \"ControlLink.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"Esp32Manager.hpp\"</code></li> <li><code>#include \"I2cController.hpp\"</code></li> <li><code>#include \"MotorController.hpp\"</code></li> <li><code>#include \"MpuController.hpp\"</code></li> <li><code>#include \"StupidServoController.hpp\"</code></li> <li><code>#include \"UltrasoundController.hpp\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/TaskWrapper.hpp\"</code></li> </ul>"},{"location":"stm/Bsp_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name TaskWrapper&lt; 1024 &gt; softResetTask"},{"location":"stm/Bsp_8cpp/#public-functions","title":"Public Functions","text":"Type Name void EXTI4_IRQHandler (void)  void EXTI9_5_IRQHandler (void)  void softReset ()  void softResetInit ()"},{"location":"stm/Bsp_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/Bsp_8cpp/#variable-softresettask","title":"variable softResetTask","text":"<pre><code>TaskWrapper&lt;1024&gt; softResetTask;\n</code></pre>"},{"location":"stm/Bsp_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/Bsp_8cpp/#function-exti4_irqhandler","title":"function EXTI4_IRQHandler","text":"<pre><code>void EXTI4_IRQHandler (\nvoid\n) </code></pre>"},{"location":"stm/Bsp_8cpp/#function-exti9_5_irqhandler","title":"function EXTI9_5_IRQHandler","text":"<pre><code>void EXTI9_5_IRQHandler (\nvoid\n) </code></pre>"},{"location":"stm/Bsp_8cpp/#function-softreset","title":"function softReset","text":"<pre><code>void softReset () </code></pre>"},{"location":"stm/Bsp_8cpp/#function-softresetinit","title":"function softResetInit","text":"<pre><code>void softResetInit () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/Bsp.cpp</code></p>"},{"location":"stm/Bsp_8cpp_source/","title":"File Bsp.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; Bsp.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"Bsp.hpp\"\n#include \"BuzzerController.hpp\"\n#include \"ControlLink.hpp\"\n#include \"Dispatcher.hpp\"\n#include \"Esp32Manager.hpp\"\n#include \"I2cController.hpp\"\n#include \"MotorController.hpp\"\n#include \"MpuController.hpp\"\n#include \"StupidServoController.hpp\"\n#include \"UltrasoundController.hpp\"\n#include \"utils/Debug.hpp\"\n#include \"utils/TaskWrapper.hpp\"\n\nstatic TaskWrapper&lt;1024&gt; softResetTask;\n\nextern \"C\" void EXTI4_IRQHandler(void) {\n// This EXTI vector only serves ESP_EN.\nsEsp32Manager.onEnRisingInIrq();\n__HAL_GPIO_EXTI_CLEAR_IT(espEnPin.second);\n}\n\nextern \"C\" void EXTI9_5_IRQHandler(void) {\n// This EXTI vector only serves the ultrasound ECHO\n// of which only one is listening at a time.\n// We want minimum jitter so avoid the stupid HAL callback scheme.\n\nultrasoundOnEchoEdge();\n__HAL_GPIO_EXTI_CLEAR_IT(uts1EchoPin.second | uts2EchoPin.second\n| uts3EchoPin.second | uts4EchoPin.second);\n}\n\nvoid softResetInit() {\nsoftResetTask.start(\"softrst\", softResetTaskPrio, []() {\nwhile (true) {\nif (xTaskNotifyWait(0, 0, nullptr, portMAX_DELAY) != pdTRUE)\ncontinue;\n\nDEBUG(\"Soft resetting peripherials to default state.\\n\");\n\nsetLeds(0);\nbuzzerSetState(false);\ndispatcherReset();\ncontrolLinkReset();\nstupidServoReset();\nultrasoundReset();\nmotorReset();\ni2cReset();\nmpuReset();\n}\n});\n}\n\nvoid softReset() {\nif (isInInterrupt()) {\nBaseType_t woken = pdFALSE;\nxTaskNotifyFromISR(softResetTask.handle(), 0, eNoAction, &amp;woken);\nportYIELD_FROM_ISR(woken);\n} else {\nxTaskNotify(softResetTask.handle(), 0, eNoAction);\n}\n}\n</code></pre>"},{"location":"stm/ButtonController_8cpp/","title":"File ButtonController.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; ButtonController.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"DebugLink.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"Power.hpp\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> </ul>"},{"location":"stm/ButtonController_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name uint32_t buttonState   = = 0 bool debugStateChanges   = = false uint32_t powerOffAt   = = 0"},{"location":"stm/ButtonController_8cpp/#public-functions","title":"Public Functions","text":"Type Name void buttonControllerPoll ()  void buttonControllerSetDebug (bool debug)"},{"location":"stm/ButtonController_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/ButtonController_8cpp/#variable-buttonstate","title":"variable buttonState","text":"<pre><code>uint32_t buttonState;\n</code></pre>"},{"location":"stm/ButtonController_8cpp/#variable-debugstatechanges","title":"variable debugStateChanges","text":"<pre><code>bool debugStateChanges;\n</code></pre>"},{"location":"stm/ButtonController_8cpp/#variable-poweroffat","title":"variable powerOffAt","text":"<pre><code>uint32_t powerOffAt;\n</code></pre>"},{"location":"stm/ButtonController_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/ButtonController_8cpp/#function-buttoncontrollerpoll","title":"function buttonControllerPoll","text":"<pre><code>void buttonControllerPoll () </code></pre>"},{"location":"stm/ButtonController_8cpp/#function-buttoncontrollersetdebug","title":"function buttonControllerSetDebug","text":"<pre><code>void buttonControllerSetDebug (\nbool debug\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/ButtonController.cpp</code></p>"},{"location":"stm/ButtonController_8cpp_source/","title":"File ButtonController.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; ButtonController.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;stdint.h&gt;\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\n#include \"Bsp.hpp\"\n#include \"DebugLink.hpp\"\n#include \"Dispatcher.hpp\"\n#include \"Power.hpp\"\n#include \"utils/Debug.hpp\"\n\nstatic uint32_t buttonState = 0;\nstatic uint32_t powerOffAt = 0;\n\nstatic bool debugStateChanges = false;\n\nvoid buttonControllerSetDebug(bool debug) { debugStateChanges = debug; }\n\nvoid buttonControllerPoll() {\nif (powerOffAt != 0 &amp;&amp; xTaskGetTickCount() &gt;= powerOffAt) {\npowerShutDown();\npowerOffAt = 0;\n}\n\nconst uint32_t newButtonState = getButtons();\nif (buttonState == newButtonState)\nreturn;\n\nif (debugStateChanges) {\nDEBUG(\"button state change: 0x%04lx -&gt; 0x%04lx\\n\", buttonState,\nnewButtonState);\n}\n\nauto status = CoprocStat();\nstatus.which_payload = CoprocStat_buttonsStat_tag;\nstatus.payload.buttonsStat.buttonsPressed\n= CoprocStat_ButtonsEnum(newButtonState);\n\ndispatcherEnqueueStatus(status);\nbuttonState = newButtonState;\n\nif ((newButtonState &amp; CoprocStat_ButtonsEnum_BOFF) != 0) {\npowerOffAt = xTaskGetTickCount() + pdMS_TO_TICKS(2000);\n} else {\npowerOffAt = 0;\n}\n\nif ((newButtonState &amp; CoprocStat_ButtonsEnum_BON) != 0) {\npinWrite(powerPin, 1);\n}\n}\n</code></pre>"},{"location":"stm/CdcUartTunnel_8cpp/","title":"File CdcUartTunnel.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; CdcUartTunnel.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"stm32f1xx_hal_dma.h\"</code></li> <li><code>#include \"stm32f1xx_ll_rcc.h\"</code></li> <li><code>#include \"stm32f1xx_ll_usart.h\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"CdcUartTunnel.hpp\"</code></li> <li><code>#include \"UsbCdcLink.h\"</code></li> <li><code>#include \"utils/BasePriorityRaiser.hpp\"</code></li> <li><code>#include \"utils/ByteFifo.hpp\"</code></li> <li><code>#include \"utils/HalDma.hpp\"</code></li> </ul>"},{"location":"stm/CdcUartTunnel_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name DMA_HandleTypeDef dmaRxHandle DMA_HandleTypeDef dmaTxHandle ByteFifo&lt; 512 &gt; rxFifo std::array&lt; uint8_t, CDC_DATA_SZ &gt; txBuf BasePriorityRaiser&lt; usbLpIRQnPrio &gt; usbIrqPrioRaise"},{"location":"stm/CdcUartTunnel_8cpp/#public-functions","title":"Public Functions","text":"Type Name bool tunnelOnSetLineCodingInIrq (const usb_cdc_line_coding &amp; old, const usb_cdc_line_coding &amp; current)  void tunnelPoll ()  void tunnelUartInit ()"},{"location":"stm/CdcUartTunnel_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void tunnelDownstreamHandler ()  void tunnelUartRxPoll ()  void tunnelUartTx (uint8_t * data, size_t len)  bool tunnelUartTxReady ()  void tunnelUpstreamHandler ()"},{"location":"stm/CdcUartTunnel_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/CdcUartTunnel_8cpp/#variable-dmarxhandle","title":"variable dmaRxHandle","text":"<pre><code>DMA_HandleTypeDef dmaRxHandle;\n</code></pre> <p>Implements passthrough between the \"tunnel\" UART and USB CDC. \"Tunnel\" UART leads to ESP32 main UART. </p>"},{"location":"stm/CdcUartTunnel_8cpp/#variable-dmatxhandle","title":"variable dmaTxHandle","text":"<pre><code>DMA_HandleTypeDef dmaTxHandle;\n</code></pre>"},{"location":"stm/CdcUartTunnel_8cpp/#variable-rxfifo","title":"variable rxFifo","text":"<pre><code>ByteFifo&lt;512&gt; rxFifo;\n</code></pre>"},{"location":"stm/CdcUartTunnel_8cpp/#variable-txbuf","title":"variable txBuf","text":"<pre><code>std::array&lt;uint8_t, CDC_DATA_SZ&gt; txBuf;\n</code></pre>"},{"location":"stm/CdcUartTunnel_8cpp/#variable-usbirqprioraise","title":"variable usbIrqPrioRaise","text":"<pre><code>BasePriorityRaiser&lt;usbLpIRQnPrio&gt; usbIrqPrioRaise;\n</code></pre>"},{"location":"stm/CdcUartTunnel_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/CdcUartTunnel_8cpp/#function-tunnelonsetlinecodinginirq","title":"function tunnelOnSetLineCodingInIrq","text":"<pre><code>bool tunnelOnSetLineCodingInIrq (\nconst usb_cdc_line_coding &amp; old,\nconst usb_cdc_line_coding &amp; current\n) </code></pre>"},{"location":"stm/CdcUartTunnel_8cpp/#function-tunnelpoll","title":"function tunnelPoll","text":"<pre><code>void tunnelPoll () </code></pre>"},{"location":"stm/CdcUartTunnel_8cpp/#function-tunneluartinit","title":"function tunnelUartInit","text":"<pre><code>void tunnelUartInit () </code></pre>"},{"location":"stm/CdcUartTunnel_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"stm/CdcUartTunnel_8cpp/#function-tunneldownstreamhandler","title":"function tunnelDownstreamHandler","text":"<pre><code>static void tunnelDownstreamHandler () </code></pre>"},{"location":"stm/CdcUartTunnel_8cpp/#function-tunneluartrxpoll","title":"function tunnelUartRxPoll","text":"<pre><code>static void tunnelUartRxPoll () </code></pre>"},{"location":"stm/CdcUartTunnel_8cpp/#function-tunneluarttx","title":"function tunnelUartTx","text":"<pre><code>static void tunnelUartTx (\nuint8_t * data,\nsize_t len\n) </code></pre>"},{"location":"stm/CdcUartTunnel_8cpp/#function-tunneluarttxready","title":"function tunnelUartTxReady","text":"<pre><code>static bool tunnelUartTxReady () </code></pre>"},{"location":"stm/CdcUartTunnel_8cpp/#function-tunnelupstreamhandler","title":"function tunnelUpstreamHandler","text":"<pre><code>static void tunnelUpstreamHandler () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/CdcUartTunnel.cpp</code></p>"},{"location":"stm/CdcUartTunnel_8cpp_source/","title":"File CdcUartTunnel.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; CdcUartTunnel.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx_hal_dma.h\"\n#include \"stm32f1xx_ll_rcc.h\"\n#include \"stm32f1xx_ll_usart.h\"\n\n#include \"FreeRTOS.h\"\n\n#include \"Bsp.hpp\"\n#include \"CdcUartTunnel.hpp\"\n#include \"UsbCdcLink.h\"\n#include \"utils/BasePriorityRaiser.hpp\"\n#include \"utils/ByteFifo.hpp\"\n#include \"utils/HalDma.hpp\"\n\nstatic DMA_HandleTypeDef dmaRxHandle;\nstatic DMA_HandleTypeDef dmaTxHandle;\nstatic ByteFifo&lt;512&gt; rxFifo;\nstatic std::array&lt;uint8_t, CDC_DATA_SZ&gt; txBuf;\nstatic BasePriorityRaiser&lt;usbLpIRQnPrio&gt; usbIrqPrioRaise;\n\nvoid tunnelUartInit() {\nLL_USART_InitTypeDef init;\nLL_USART_StructInit(&amp;init);\ninit.BaudRate = 115200;\ninit.DataWidth = LL_USART_DATAWIDTH_8B;\ninit.HardwareFlowControl = LL_USART_HWCONTROL_NONE;\ninit.Parity = LL_USART_PARITY_NONE;\ninit.StopBits = LL_USART_STOPBITS_1;\ninit.TransferDirection = LL_USART_DIRECTION_TX_RX;\nLL_USART_Init(tunnelUart, &amp;init);\nLL_USART_Enable(tunnelUart);\n\n// UART RX runs indefinitely in circular mode\ndmaRxHandle.Instance = tunnelUartRxDmaChannel;\ndmaRxHandle.Init.Direction = DMA_PERIPH_TO_MEMORY;\ndmaRxHandle.Init.Mode = DMA_CIRCULAR;\ndmaRxHandle.Init.MemInc = DMA_MINC_ENABLE;\ndmaRxHandle.Init.PeriphInc = DMA_PINC_DISABLE;\ndmaRxHandle.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;\ndmaRxHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;\ndmaRxHandle.Init.Priority = DMA_PRIORITY_MEDIUM;\nHAL_DMA_Init(&amp;dmaRxHandle);\nHAL_DMA_Start(&amp;dmaRxHandle, uintptr_t(&amp;(tunnelUart-&gt;DR)),\nuintptr_t(rxFifo.data()), rxFifo.size());\nLL_USART_EnableDMAReq_RX(tunnelUart);\n\n// UART TX burst is started ad hoc each time\ndmaTxHandle.Instance = tunnelUartTxDmaChannel;\ndmaTxHandle.Init.Direction = DMA_MEMORY_TO_PERIPH;\ndmaTxHandle.Init.Mode = DMA_NORMAL;\ndmaTxHandle.Init.MemInc = DMA_MINC_ENABLE;\ndmaTxHandle.Init.PeriphInc = DMA_PINC_DISABLE;\ndmaTxHandle.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;\ndmaTxHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;\ndmaTxHandle.Init.Priority = DMA_PRIORITY_MEDIUM;\nHAL_DMA_Init(&amp;dmaTxHandle);\nLL_USART_EnableDMAReq_TX(tunnelUart);\n\npinInit(\ntunnelUartTxPin, GPIO_MODE_AF_PP, GPIO_PULLUP, GPIO_SPEED_FREQ_HIGH);\npinInit(\ntunnelUartRxPin, GPIO_MODE_AF_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_HIGH);\n}\n\nstatic void tunnelUartRxPoll() {\nint rxHead = rxFifo.size() - __HAL_DMA_GET_COUNTER(&amp;dmaRxHandle);\nrxFifo.setHead(rxHead);\n}\n\nstatic void tunnelUartTx(uint8_t* data, size_t len) {\nHAL_DMA_Start(\n&amp;dmaTxHandle, uintptr_t(data), uintptr_t(&amp;tunnelUart-&gt;DR), len);\n}\n\nstatic bool tunnelUartTxReady() {\nHAL_DMA_PollForTransfer_Really(&amp;dmaTxHandle, HAL_DMA_FULL_TRANSFER, 0);\nreturn dmaTxHandle.State == HAL_DMA_STATE_READY;\n}\n\nstatic void tunnelDownstreamHandler() {\nif (tunnelUartTxReady()) {\nusbIrqPrioRaise.lock();\nconst int transferred = usbd_ep_read(\n&amp;udev, CDC_TUNNEL_RXD_EP, txBuf.data(), txBuf.size());\nusbIrqPrioRaise.unlock();\n\nif (transferred &gt; 0) {\ntunnelUartTx(txBuf.data(), transferred);\n}\n}\n}\n\nstatic void tunnelUpstreamHandler() {\ntunnelUartRxPoll();\nauto readable = rxFifo.readableSpan();\nif (readable.second &gt; 0) {\nusbIrqPrioRaise.lock();\nconst int transferred = usbd_ep_write(&amp;udev, CDC_TUNNEL_TXD_EP,\nreadable.first, std::min(readable.second, size_t(CDC_DATA_SZ)));\nusbIrqPrioRaise.unlock();\n\nif (transferred &gt; 0) {\nrxFifo.notifyRead(transferred);\n}\n}\n}\n\nvoid tunnelPoll() {\ntunnelUpstreamHandler();\ntunnelDownstreamHandler();\n}\n\nbool tunnelOnSetLineCodingInIrq(\nconst usb_cdc_line_coding&amp; old, const usb_cdc_line_coding&amp; current) {\nif (old.dwDTERate != current.dwDTERate) {\n// From inside of LL_USART_Init, wtf is this not exported as some function?\n// https://github.com/STMicroelectronics/STM32CubeF1/blob/master/Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_usart.c\nif (current.dwDTERate &gt; 4500000U) {\nreturn false;\n}\n\nuint32_t periphclk = LL_RCC_PERIPH_FREQUENCY_NO;\nLL_RCC_ClocksTypeDef rcc_clocks;\nLL_RCC_GetSystemClocksFreq(&amp;rcc_clocks);\nif (tunnelUart == USART1) {\nperiphclk = rcc_clocks.PCLK2_Frequency;\n} else if (tunnelUart == USART2) {\nperiphclk = rcc_clocks.PCLK1_Frequency;\n} else if (tunnelUart == USART3) {\nperiphclk = rcc_clocks.PCLK1_Frequency;\n} else if (tunnelUart == UART4) {\nperiphclk = rcc_clocks.PCLK1_Frequency;\n} else if (tunnelUart == UART5) {\nperiphclk = rcc_clocks.PCLK1_Frequency;\n} else {\nabort();\n}\nLL_USART_SetBaudRate(tunnelUart, periphclk, current.dwDTERate);\n}\n\nif (current.bDataBits != 8) {\nreturn false;\n}\n\nif (old.bCharFormat != current.bCharFormat) {\nswitch (current.bCharFormat) {\ncase USB_CDC_1_STOP_BITS:\nLL_USART_SetStopBitsLength(tunnelUart, LL_USART_STOPBITS_1);\nbreak;\ncase USB_CDC_1_5_STOP_BITS:\nLL_USART_SetStopBitsLength(tunnelUart, LL_USART_STOPBITS_1_5);\nbreak;\ncase USB_CDC_2_STOP_BITS:\nLL_USART_SetStopBitsLength(tunnelUart, LL_USART_STOPBITS_2);\nbreak;\ndefault:\nreturn false;\n}\n}\n\nif (old.bParityType != current.bParityType) {\nswitch (current.bParityType) {\ncase USB_CDC_NO_PARITY:\nLL_USART_SetParity(tunnelUart, LL_USART_PARITY_NONE);\nbreak;\ncase USB_CDC_ODD_PARITY:\nLL_USART_SetParity(tunnelUart, LL_USART_PARITY_ODD);\nbreak;\ncase USB_CDC_EVEN_PARITY:\nLL_USART_SetParity(tunnelUart, LL_USART_PARITY_EVEN);\nbreak;\ndefault:\nreturn false;\n}\n}\nreturn true;\n}\n</code></pre>"},{"location":"stm/ControlLink_8cpp/","title":"File ControlLink.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; ControlLink.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"stm32f1xx_hal_dma.h\"</code></li> <li><code>#include \"stm32f1xx_ll_usart.h\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"Esp32Manager.hpp\"</code></li> <li><code>#include \"coproc_codec.h\"</code></li> <li><code>#include \"coproc_link_parser.h\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> <li><code>#include \"utils/ByteFifo.hpp\"</code></li> <li><code>#include \"utils/MessageBufferWrapper.hpp\"</code></li> </ul>"},{"location":"stm/ControlLink_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name rb::CoprocCodec codec DMA_HandleTypeDef dmaRxHandle DMA_HandleTypeDef dmaTxHandle ByteFifo&lt; 512 &gt; rxFifo std::array&lt; uint8_t, codec.MaxFrameSize &gt; txDmaBuf std::array&lt; uint8_t, codec.MaxFrameSize &gt; txEncodeBuf MessageBufferWrapper&lt; 512 &gt; txMessageBuf"},{"location":"stm/ControlLink_8cpp/#public-functions","title":"Public Functions","text":"Type Name void CONTROLUART_TX_DMA_HANDLER ()  void controlLinkReset ()  bool controlLinkRx (CoprocReq &amp; incoming)  void controlLinkTx (const CoprocStat &amp; outgoing)  void controlUartInit ()"},{"location":"stm/ControlLink_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void controlLinkUpdateRxFifo ()  rb::CoprocLinkParser&lt; CoprocReq, &amp;CoprocReq_msg &gt; parser (codec)"},{"location":"stm/ControlLink_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/ControlLink_8cpp/#variable-codec","title":"variable codec","text":"<pre><code>rb::CoprocCodec codec;\n</code></pre>"},{"location":"stm/ControlLink_8cpp/#variable-dmarxhandle","title":"variable dmaRxHandle","text":"<pre><code>DMA_HandleTypeDef dmaRxHandle;\n</code></pre> <p>Implements control frame exchange. Frame byte layout: [0x00 LEN_BYTE COBS_DATA...] COBS is used to avoid having zero bytes present on UART except as packet beginnings. https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing </p>"},{"location":"stm/ControlLink_8cpp/#variable-dmatxhandle","title":"variable dmaTxHandle","text":"<pre><code>DMA_HandleTypeDef dmaTxHandle;\n</code></pre>"},{"location":"stm/ControlLink_8cpp/#variable-rxfifo","title":"variable rxFifo","text":"<pre><code>ByteFifo&lt;512&gt; rxFifo;\n</code></pre>"},{"location":"stm/ControlLink_8cpp/#variable-txdmabuf","title":"variable txDmaBuf","text":"<pre><code>std::array&lt;uint8_t, codec.MaxFrameSize&gt; txDmaBuf;\n</code></pre>"},{"location":"stm/ControlLink_8cpp/#variable-txencodebuf","title":"variable txEncodeBuf","text":"<pre><code>std::array&lt;uint8_t, codec.MaxFrameSize&gt; txEncodeBuf;\n</code></pre>"},{"location":"stm/ControlLink_8cpp/#variable-txmessagebuf","title":"variable txMessageBuf","text":"<pre><code>MessageBufferWrapper&lt;512&gt; txMessageBuf;\n</code></pre>"},{"location":"stm/ControlLink_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/ControlLink_8cpp/#function-controluart_tx_dma_handler","title":"function CONTROLUART_TX_DMA_HANDLER","text":"<pre><code>void CONTROLUART_TX_DMA_HANDLER () </code></pre>"},{"location":"stm/ControlLink_8cpp/#function-controllinkreset","title":"function controlLinkReset","text":"<pre><code>void controlLinkReset () </code></pre>"},{"location":"stm/ControlLink_8cpp/#function-controllinkrx","title":"function controlLinkRx","text":"<pre><code>bool controlLinkRx (\nCoprocReq &amp; incoming\n) </code></pre>"},{"location":"stm/ControlLink_8cpp/#function-controllinktx","title":"function controlLinkTx","text":"<pre><code>void controlLinkTx (\nconst CoprocStat &amp; outgoing\n) </code></pre>"},{"location":"stm/ControlLink_8cpp/#function-controluartinit","title":"function controlUartInit","text":"<pre><code>void controlUartInit () </code></pre>"},{"location":"stm/ControlLink_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"stm/ControlLink_8cpp/#function-controllinkupdaterxfifo","title":"function controlLinkUpdateRxFifo","text":"<pre><code>static void controlLinkUpdateRxFifo () </code></pre>"},{"location":"stm/ControlLink_8cpp/#function-parser","title":"function parser","text":"<pre><code>static rb::CoprocLinkParser&lt; CoprocReq, &amp;CoprocReq_msg &gt; parser (\ncodec\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/ControlLink.cpp</code></p>"},{"location":"stm/ControlLink_8cpp_source/","title":"File ControlLink.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; ControlLink.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;array&gt;\n\n#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx_hal_dma.h\"\n#include \"stm32f1xx_ll_usart.h\"\n\n#include \"Bsp.hpp\"\n#include \"Esp32Manager.hpp\"\n#include \"coproc_codec.h\"\n#include \"coproc_link_parser.h\"\n#include \"rbcx.pb.h\"\n#include \"utils/ByteFifo.hpp\"\n#include \"utils/MessageBufferWrapper.hpp\"\n\nstatic DMA_HandleTypeDef dmaRxHandle;\nstatic DMA_HandleTypeDef dmaTxHandle;\nstatic rb::CoprocCodec codec;\nstatic rb::CoprocLinkParser&lt;CoprocReq, &amp;CoprocReq_msg&gt; parser(codec);\nstatic ByteFifo&lt;512&gt; rxFifo;\n\n// Encode TX frame in txEncodeBuf, push to txMessageBuf, move to txDmaBuf and send via DMA.\nstatic std::array&lt;uint8_t, codec.MaxFrameSize&gt; txEncodeBuf;\nstatic std::array&lt;uint8_t, codec.MaxFrameSize&gt; txDmaBuf;\n\nstatic MessageBufferWrapper&lt;512&gt; txMessageBuf;\n\nvoid controlUartInit() {\ntxMessageBuf.create();\n\nLL_USART_InitTypeDef init;\nLL_USART_StructInit(&amp;init);\ninit.BaudRate = 921600;\ninit.DataWidth = LL_USART_DATAWIDTH_8B;\ninit.HardwareFlowControl = LL_USART_HWCONTROL_NONE;\ninit.Parity = LL_USART_PARITY_NONE;\ninit.StopBits = LL_USART_STOPBITS_1;\ninit.TransferDirection = LL_USART_DIRECTION_TX_RX;\nLL_USART_Init(controlUart, &amp;init);\nLL_USART_Enable(controlUart);\n\n// UART RX runs indefinitely in circular mode\ndmaRxHandle.Instance = controlUartRxDmaChannel;\ndmaRxHandle.Init.Direction = DMA_PERIPH_TO_MEMORY;\ndmaRxHandle.Init.Mode = DMA_CIRCULAR;\ndmaRxHandle.Init.MemInc = DMA_MINC_ENABLE;\ndmaRxHandle.Init.PeriphInc = DMA_PINC_DISABLE;\ndmaRxHandle.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;\ndmaRxHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;\ndmaRxHandle.Init.Priority = DMA_PRIORITY_MEDIUM;\nHAL_DMA_Init(&amp;dmaRxHandle);\nHAL_DMA_Start(&amp;dmaRxHandle, uintptr_t(&amp;(controlUart-&gt;DR)),\nuintptr_t(rxFifo.data()), rxFifo.size());\nLL_USART_EnableDMAReq_RX(controlUart);\n\n// UART TX burst is started ad hoc each time\ndmaTxHandle.Instance = controlUartTxDmaChannel;\ndmaTxHandle.Init.Direction = DMA_MEMORY_TO_PERIPH;\ndmaTxHandle.Init.Mode = DMA_NORMAL;\ndmaTxHandle.Init.MemInc = DMA_MINC_ENABLE;\ndmaTxHandle.Init.PeriphInc = DMA_PINC_DISABLE;\ndmaTxHandle.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;\ndmaTxHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;\ndmaTxHandle.Init.Priority = DMA_PRIORITY_MEDIUM;\nHAL_DMA_Init(&amp;dmaTxHandle);\nHAL_NVIC_SetPriority(controlUartTxDmaIRQn, controlUartTxDmaIRQnPrio, 0);\nHAL_NVIC_EnableIRQ(controlUartTxDmaIRQn);\nLL_USART_EnableDMAReq_TX(controlUart);\n}\n\nstatic void controlLinkUpdateRxFifo() {\nint rxHead = rxFifo.size() - __HAL_DMA_GET_COUNTER(&amp;dmaRxHandle);\nrxFifo.setHead(rxHead);\n}\n\nbool controlLinkRx(CoprocReq&amp; incoming) {\ncontrolLinkUpdateRxFifo();\nwhile (rxFifo.hasData()) {\nif (parser.add(rxFifo.pop())) {\nincoming = parser.lastMessage();\nreturn true;\n}\n}\nreturn false;\n}\n\nvoid controlLinkTx(const CoprocStat&amp; outgoing) {\nauto encodedSize = codec.encodeWithHeader(\n&amp;CoprocStat_msg, &amp;outgoing, txEncodeBuf.data(), txEncodeBuf.size());\n\nif (encodedSize == 0)\nabort();\n\nif (!txMessageBuf.push_back(txEncodeBuf.data(), encodedSize, 0)) {\nDEBUG(\"txMessageBuf overflow\\n\");\nabort();\n}\n\nHAL_NVIC_SetPendingIRQ(controlUartTxDmaIRQn);\n}\n\nvoid controlLinkReset() {\ncontrolLinkUpdateRxFifo();\nrxFifo.clear();\nwhile (!txMessageBuf.reset())\nvTaskDelay(0);\n}\n\nextern \"C\" void CONTROLUART_TX_DMA_HANDLER() {\nHAL_DMA_IRQHandler(&amp;dmaTxHandle);\nif (dmaTxHandle.State == HAL_DMA_STATE_READY) {\nBaseType_t pxHigherPriorityTaskWoken = pdFALSE;\n\nconst auto len = txMessageBuf.pop_front(\ntxDmaBuf.data(), txDmaBuf.size(), 0, &amp;pxHigherPriorityTaskWoken);\nif (len &gt; 0) {\nHAL_DMA_Start_IT(&amp;dmaTxHandle, uintptr_t(txDmaBuf.data()),\nuintptr_t(&amp;controlUart-&gt;DR), len);\n}\nportYIELD_FROM_ISR(pxHigherPriorityTaskWoken);\n}\n}\n</code></pre>"},{"location":"stm/DebugLink_8cpp/","title":"File DebugLink.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; DebugLink.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"stream_buffer.h\"</code></li> <li><code>#include \"task.h\"</code></li> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"stm32f1xx_hal_dma.h\"</code></li> <li><code>#include \"stm32f1xx_ll_usart.h\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"ButtonController.hpp\"</code></li> <li><code>#include \"BuzzerController.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"I2cController.hpp\"</code></li> <li><code>#include \"Mpu6050.hpp\"</code></li> <li><code>#include \"OledController.hpp\"</code></li> <li><code>#include \"MpuController.hpp\"</code></li> <li><code>#include \"Power.hpp\"</code></li> <li><code>#include \"UsbCdcLink.h\"</code></li> <li><code>#include \"coproc_codec.h\"</code></li> <li><code>#include \"coproc_link_parser.h\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> <li><code>#include \"utils/BasePriorityRaiser.hpp\"</code></li> <li><code>#include \"utils/ByteFifo.hpp\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/MessageBufferWrapper.hpp\"</code></li> <li><code>#include \"utils/MutexWrapper.hpp\"</code></li> <li><code>#include \"utils/QueueWrapper.hpp\"</code></li> <li><code>#include \"utils/StreamBufferWrapper.hpp\"</code></li> <li><code>#include \"utils/TickTimer.hpp\"</code></li> </ul>"},{"location":"stm/DebugLink_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr size_t MaxLineLength   = = 128 DMA_HandleTypeDef dmaRxHandle DMA_HandleTypeDef dmaTxHandle MessageBufferWrapper&lt; MaxLineLength+4 &gt; rxLineBuffer std::array&lt; uint8_t, 256 &gt; txDmaBuf StreamBufferWrapper&lt; txDmaBuf.size() *4 &gt; txUartStreamBuf ByteFifo&lt; MaxLineLength &gt; uartRxFifo std::array&lt; uint8_t, CDC_DATA_SZ &gt; usbFrameBuf BasePriorityRaiser&lt; usbLpIRQnPrio &gt; usbIrqPrioRaise ByteFifo&lt; MaxLineLength &gt; usbRxFifo ByteFifo&lt; MaxLineLength *4 &gt; usbTxFifo"},{"location":"stm/DebugLink_8cpp/#public-functions","title":"Public Functions","text":"Type Name void DEBUGUART_HANDLER (void)  void DEBUGUART_TX_DMA_HANDLER ()  int _write (int fd, char * data, int len)  void debugLinkPoll ()  ssize_t debugLinkTx (const uint8_t * data, size_t len)  void debugUartInit ()"},{"location":"stm/DebugLink_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void debugDownstreamHandler ()  void debugLinkHandleCommand (const char * cmd)  void debugUpstreamHandler ()  BaseType_t processRxBuf (ByteFifo&lt; Size &gt; &amp; fifo)"},{"location":"stm/DebugLink_8cpp/#macros","title":"Macros","text":"Type Name define COMMAND (name, ...)"},{"location":"stm/DebugLink_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/DebugLink_8cpp/#variable-maxlinelength","title":"variable MaxLineLength","text":"<pre><code>constexpr size_t MaxLineLength;\n</code></pre>"},{"location":"stm/DebugLink_8cpp/#variable-dmarxhandle","title":"variable dmaRxHandle","text":"<pre><code>DMA_HandleTypeDef dmaRxHandle;\n</code></pre>"},{"location":"stm/DebugLink_8cpp/#variable-dmatxhandle","title":"variable dmaTxHandle","text":"<pre><code>DMA_HandleTypeDef dmaTxHandle;\n</code></pre>"},{"location":"stm/DebugLink_8cpp/#variable-rxlinebuffer","title":"variable rxLineBuffer","text":"<pre><code>MessageBufferWrapper&lt;MaxLineLength + 4&gt; rxLineBuffer;\n</code></pre>"},{"location":"stm/DebugLink_8cpp/#variable-txdmabuf","title":"variable txDmaBuf","text":"<pre><code>std::array&lt;uint8_t, 256&gt; txDmaBuf;\n</code></pre>"},{"location":"stm/DebugLink_8cpp/#variable-txuartstreambuf","title":"variable txUartStreamBuf","text":"<pre><code>StreamBufferWrapper&lt;txDmaBuf.size() * 4&gt; txUartStreamBuf;\n</code></pre>"},{"location":"stm/DebugLink_8cpp/#variable-uartrxfifo","title":"variable uartRxFifo","text":"<pre><code>ByteFifo&lt;MaxLineLength&gt; uartRxFifo;\n</code></pre>"},{"location":"stm/DebugLink_8cpp/#variable-usbframebuf","title":"variable usbFrameBuf","text":"<pre><code>std::array&lt;uint8_t, CDC_DATA_SZ&gt; usbFrameBuf;\n</code></pre>"},{"location":"stm/DebugLink_8cpp/#variable-usbirqprioraise","title":"variable usbIrqPrioRaise","text":"<pre><code>BasePriorityRaiser&lt;usbLpIRQnPrio&gt; usbIrqPrioRaise;\n</code></pre>"},{"location":"stm/DebugLink_8cpp/#variable-usbrxfifo","title":"variable usbRxFifo","text":"<pre><code>ByteFifo&lt;MaxLineLength&gt; usbRxFifo;\n</code></pre>"},{"location":"stm/DebugLink_8cpp/#variable-usbtxfifo","title":"variable usbTxFifo","text":"<pre><code>ByteFifo&lt;MaxLineLength * 4&gt; usbTxFifo;\n</code></pre>"},{"location":"stm/DebugLink_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/DebugLink_8cpp/#function-debuguart_handler","title":"function DEBUGUART_HANDLER","text":"<pre><code>void DEBUGUART_HANDLER (\nvoid\n) </code></pre>"},{"location":"stm/DebugLink_8cpp/#function-debuguart_tx_dma_handler","title":"function DEBUGUART_TX_DMA_HANDLER","text":"<pre><code>void DEBUGUART_TX_DMA_HANDLER () </code></pre>"},{"location":"stm/DebugLink_8cpp/#function-_write","title":"function _write","text":"<pre><code>int _write (\nint fd,\nchar * data,\nint len\n) </code></pre>"},{"location":"stm/DebugLink_8cpp/#function-debuglinkpoll","title":"function debugLinkPoll","text":"<pre><code>void debugLinkPoll () </code></pre>"},{"location":"stm/DebugLink_8cpp/#function-debuglinktx","title":"function debugLinkTx","text":"<pre><code>ssize_t debugLinkTx (\nconst uint8_t * data,\nsize_t len\n) </code></pre>"},{"location":"stm/DebugLink_8cpp/#function-debuguartinit","title":"function debugUartInit","text":"<pre><code>void debugUartInit () </code></pre>"},{"location":"stm/DebugLink_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"stm/DebugLink_8cpp/#function-debugdownstreamhandler","title":"function debugDownstreamHandler","text":"<pre><code>static void debugDownstreamHandler () </code></pre>"},{"location":"stm/DebugLink_8cpp/#function-debuglinkhandlecommand","title":"function debugLinkHandleCommand","text":"<pre><code>static void debugLinkHandleCommand (\nconst char * cmd\n) </code></pre>"},{"location":"stm/DebugLink_8cpp/#function-debugupstreamhandler","title":"function debugUpstreamHandler","text":"<pre><code>static void debugUpstreamHandler () </code></pre>"},{"location":"stm/DebugLink_8cpp/#function-processrxbuf","title":"function processRxBuf","text":"<pre><code>template&lt;int Size&gt;\nstatic BaseType_t processRxBuf (\nByteFifo &lt; Size &gt; &amp; fifo\n) </code></pre>"},{"location":"stm/DebugLink_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"stm/DebugLink_8cpp/#define-command","title":"define COMMAND","text":"<pre><code>#define COMMAND (\nname,\n...\n) if (strncmp(cmd, name \" \", sizeof(name)) == 0) {                           \\\n        cmd += sizeof(name);                                                   \\\n        __VA_ARGS__                                                            \\\n    }\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/DebugLink.cpp</code></p>"},{"location":"stm/DebugLink_8cpp_source/","title":"File DebugLink.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; DebugLink.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;array&gt;\n#include &lt;string.h&gt;\n\n#include \"FreeRTOS.h\"\n#include \"stream_buffer.h\"\n#include \"task.h\"\n\n#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx_hal_dma.h\"\n#include \"stm32f1xx_ll_usart.h\"\n\n#include \"Bsp.hpp\"\n#include \"ButtonController.hpp\"\n#include \"BuzzerController.hpp\"\n#include \"Dispatcher.hpp\"\n#include \"I2cController.hpp\"\n#include \"Mpu6050.hpp\"\n#include \"OledController.hpp\"\n#include \"MpuController.hpp\"\n#include \"Power.hpp\"\n#include \"UsbCdcLink.h\"\n#include \"coproc_codec.h\"\n#include \"coproc_link_parser.h\"\n#include \"rbcx.pb.h\"\n#include \"utils/BasePriorityRaiser.hpp\"\n#include \"utils/ByteFifo.hpp\"\n#include \"utils/Debug.hpp\"\n#include \"utils/MessageBufferWrapper.hpp\"\n#include \"utils/MutexWrapper.hpp\"\n#include \"utils/QueueWrapper.hpp\"\n#include \"utils/StreamBufferWrapper.hpp\"\n#include \"utils/TickTimer.hpp\"\n\n#include \"rbcx.pb.h\"\n\nstatic DMA_HandleTypeDef dmaTxHandle;\nstatic DMA_HandleTypeDef dmaRxHandle;\n\nstatic constexpr size_t MaxLineLength = 128;\n\nstatic std::array&lt;uint8_t, 256&gt; txDmaBuf;\nstatic StreamBufferWrapper&lt;txDmaBuf.size() * 4&gt; txUartStreamBuf;\n\nstatic ByteFifo&lt;MaxLineLength&gt; uartRxFifo;\nstatic MessageBufferWrapper&lt;MaxLineLength + 4&gt; rxLineBuffer;\n\nstatic std::array&lt;uint8_t, CDC_DATA_SZ&gt; usbFrameBuf;\nstatic ByteFifo&lt;MaxLineLength&gt; usbRxFifo;\nstatic ByteFifo&lt;MaxLineLength * 4&gt; usbTxFifo;\nstatic BasePriorityRaiser&lt;usbLpIRQnPrio&gt; usbIrqPrioRaise;\n\nvoid debugUartInit() {\ntxUartStreamBuf.create();\nrxLineBuffer.create();\n\nLL_USART_InitTypeDef init;\nLL_USART_StructInit(&amp;init);\ninit.BaudRate = 115200;\ninit.DataWidth = LL_USART_DATAWIDTH_8B;\ninit.HardwareFlowControl = LL_USART_HWCONTROL_NONE;\ninit.Parity = LL_USART_PARITY_NONE;\ninit.StopBits = LL_USART_STOPBITS_1;\ninit.TransferDirection = LL_USART_DIRECTION_TX_RX;\nif (LL_USART_Init(debugUart, &amp;init) != SUCCESS)\nabort();\nLL_USART_Enable(debugUart);\n\n// UART RX runs indefinitely in circular mode\ndmaRxHandle.Instance = debugUartRxDmaChannel;\ndmaRxHandle.Init.Direction = DMA_PERIPH_TO_MEMORY;\ndmaRxHandle.Init.Mode = DMA_CIRCULAR;\ndmaRxHandle.Init.MemInc = DMA_MINC_ENABLE;\ndmaRxHandle.Init.PeriphInc = DMA_PINC_DISABLE;\ndmaRxHandle.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;\ndmaRxHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;\ndmaRxHandle.Init.Priority = DMA_PRIORITY_MEDIUM;\nHAL_DMA_Init(&amp;dmaRxHandle);\nHAL_DMA_Start(&amp;dmaRxHandle, uintptr_t(&amp;(debugUart-&gt;DR)),\nuintptr_t(uartRxFifo.data()), uartRxFifo.size());\nLL_USART_EnableDMAReq_RX(debugUart);\n\nHAL_NVIC_SetPriority(debugUartIRQn, debugUartIrqPrio, 0);\nHAL_NVIC_EnableIRQ(debugUartIRQn);\nLL_USART_EnableIT_IDLE(debugUart);\n\n// UART TX burst is started ad hoc each time\ndmaTxHandle.Instance = debugUartTxDmaChannel;\ndmaTxHandle.Init.Direction = DMA_MEMORY_TO_PERIPH;\ndmaTxHandle.Init.Mode = DMA_NORMAL;\ndmaTxHandle.Init.MemInc = DMA_MINC_ENABLE;\ndmaTxHandle.Init.PeriphInc = DMA_PINC_DISABLE;\ndmaTxHandle.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;\ndmaTxHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;\ndmaTxHandle.Init.Priority = DMA_PRIORITY_MEDIUM;\nif (HAL_DMA_Init(&amp;dmaTxHandle) != HAL_OK)\nabort();\nHAL_NVIC_SetPriority(debugUartTxDmaIRQn, debugUartTxDmaIrqPrio, 0);\nHAL_NVIC_EnableIRQ(debugUartTxDmaIRQn);\nLL_USART_EnableDMAReq_TX(debugUart);\n\npinInit(debugUartTxPin, GPIO_MODE_AF_PP, GPIO_PULLUP, GPIO_SPEED_FREQ_HIGH);\npinInit(\ndebugUartRxPin, GPIO_MODE_AF_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_HIGH);\n}\n\nssize_t debugLinkTx(const uint8_t* data, size_t len) {\nif ((size_t)len &gt; sizeof(txDmaBuf))\nreturn -1;\n\nsize_t res = 0;\n\nif (isInInterrupt()) {\nBaseType_t woken = pdFALSE;\nconst auto status = taskENTER_CRITICAL_FROM_ISR();\nres = txUartStreamBuf.write((uint8_t*)data, len, 0, &amp;woken);\nusbTxFifo.writeSpan((uint8_t*)data, len);\ntaskEXIT_CRITICAL_FROM_ISR(status);\nportYIELD_FROM_ISR(woken);\n} else {\nwhile (txUartStreamBuf.freeSpace() &lt; len)\nvTaskDelay(0);\ntaskENTER_CRITICAL();\nres = txUartStreamBuf.write((uint8_t*)data, len, 0);\nusbTxFifo.writeSpan((uint8_t*)data, len);\ntaskEXIT_CRITICAL();\n}\n\nif (res == 0)\nreturn -1;\n\nHAL_NVIC_SetPendingIRQ(debugUartTxDmaIRQn);\nreturn res;\n}\n\nextern \"C\" int _write(int fd, char* data, int len) {\nreturn debugLinkTx((uint8_t*)data, len);\n}\n\ntemplate &lt;int Size&gt; static BaseType_t processRxBuf(ByteFifo&lt;Size&gt;&amp; fifo) {\nconst auto fifoAvailable = std::min(MaxLineLength, fifo.available());\n\nchar buf[MaxLineLength];\nfifo.peekSpan((uint8_t*)buf, fifoAvailable);\n\nBaseType_t pxHigherPriorityTaskWoken = pdFALSE;\n\nsize_t remaining = fifoAvailable;\nchar* start = buf;\nwhile (remaining != 0) {\nchar* end = (char*)memchr(start, '\\n', remaining);\nif (!end)\nbreak;\n\n*end = '\\0';\n++end;\n\nconst size_t len = end - start;\n\nif (!rxLineBuffer.push_back(\n(uint8_t*)start, len, 0, &amp;pxHigherPriorityTaskWoken)) {\nprintf(\"Not enough space in line buffer, try sending commands \"\n\"slower.\\n\");\n}\n\nremaining -= len;\nfifo.notifyRead(len);\nstart = end;\n}\nreturn pxHigherPriorityTaskWoken;\n}\n\nextern \"C\" void DEBUGUART_HANDLER(void) {\nint rxHead = uartRxFifo.size() - __HAL_DMA_GET_COUNTER(&amp;dmaRxHandle);\nuartRxFifo.setHead(rxHead);\nLL_USART_ClearFlag_IDLE(debugUart);\nportYIELD_FROM_ISR(processRxBuf(uartRxFifo));\n}\n\nextern \"C\" void DEBUGUART_TX_DMA_HANDLER() {\nHAL_DMA_IRQHandler(&amp;dmaTxHandle);\n\nif (dmaTxHandle.State == HAL_DMA_STATE_READY) {\nBaseType_t pxHigherPriorityTaskWoken = pdFALSE;\nconst auto len = txUartStreamBuf.read(\ntxDmaBuf.data(), txDmaBuf.size(), 0, &amp;pxHigherPriorityTaskWoken);\n\nif (len &gt; 0) {\nHAL_DMA_Start_IT(&amp;dmaTxHandle, uint32_t(txDmaBuf.data()),\nuint32_t(&amp;debugUart-&gt;DR), len);\n}\n\nportYIELD_FROM_ISR(pxHigherPriorityTaskWoken);\n}\n}\n\n#define COMMAND(name, ...)                                                     \\\n    if (strncmp(cmd, name \" \", sizeof(name)) == 0) {                           \\\n        cmd += sizeof(name);                                                   \\\n        __VA_ARGS__                                                            \\\n    }\n\nstatic void debugLinkHandleCommand(const char* cmd) {\nCOMMAND(\"diag\", {\nprintTaskInfo();\nreturn;\n});\n\nCOMMAND(\"power\", {\nCOMMAND(\"calibrate\", {\nCoprocReq req = {\n.which_payload = CoprocReq_calibratePower_tag,\n};\n\nif (sscanf(cmd, \"%lu %lu %lu %lu\",\n&amp;req.payload.calibratePower.vccMv,\n&amp;req.payload.calibratePower.battMidMv,\n&amp;req.payload.calibratePower.vRef33Mv,\n&amp;req.payload.calibratePower.temperatureC)\n!= 4) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\n\ndispatcherEnqueueRequest(req);\nreturn;\n});\n\nCOMMAND(\"info\", {\nprintf(\"Power info: VCC %d mV bMid: %dmV VRef: %d mv Temperature \"\n\"%d C\\n\",\npowerBatteryMv(), powerBatteryMidMv(), powerVrefMv(),\npowerTemperatureC());\nreturn;\n});\n});\n\nCOMMAND(\"motors\", {\nCOMMAND(\"pid\", {\nCoprocReq req = {\n.which_payload = CoprocReq_motorReq_tag,\n};\nreq.payload.motorReq.which_motorCmd\n= CoprocReq_MotorReq_setVelocityRegCoefs_tag;\nauto&amp; c = req.payload.motorReq.motorCmd.setVelocityRegCoefs;\nif (sscanf(cmd, \"%lu %lu %lu\", &amp;c.p, &amp;c.i, &amp;c.d) != 3) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\n\nfor (int m : { 0, 1, 2, 3 }) {\nreq.payload.motorReq.motorIndex = m;\ndispatcherEnqueueRequest(req);\n}\nreturn;\n});\n\nCOMMAND(\"power\", {\nCoprocReq req = {\n.which_payload = CoprocReq_motorReq_tag,\n};\nreq.payload.motorReq.which_motorCmd\n= CoprocReq_MotorReq_setPower_tag;\nauto&amp; c = req.payload.motorReq;\nif (sscanf(cmd, \"%lu %ld\", &amp;c.motorIndex, &amp;c.motorCmd.setPower)\n!= 2) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\n\ndispatcherEnqueueRequest(req);\nreturn;\n});\n\nCOMMAND(\"velocity\", {\nCoprocReq req = {\n.which_payload = CoprocReq_motorReq_tag,\n};\nreq.payload.motorReq.which_motorCmd\n= CoprocReq_MotorReq_setVelocity_tag;\nauto&amp; c = req.payload.motorReq;\nif (sscanf(cmd, \"%lu %ld\", &amp;c.motorIndex, &amp;c.motorCmd.setVelocity)\n!= 2) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\n\ndispatcherEnqueueRequest(req);\nreturn;\n});\n\nCOMMAND(\"position\", {\nCoprocReq req = {\n.which_payload = CoprocReq_motorReq_tag,\n};\nauto&amp; c = req.payload.motorReq;\nc.which_motorCmd = CoprocReq_MotorReq_setPosition_tag;\nif (sscanf(cmd, \"%lu %ld %ld\", &amp;c.motorIndex,\n&amp;c.motorCmd.setPosition.targetPosition,\n&amp;c.motorCmd.setPosition.runningVelocity)\n!= 3) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\n\ndispatcherEnqueueRequest(req);\nreturn;\n});\n});\n\nCOMMAND(\"leds\", {\nCOMMAND(\"set\", {\nuint32_t val = 0;\nif (sscanf(cmd, \"%lu\", &amp;val) != 1) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\nsetLeds(val);\nreturn;\n});\n});\n\nCOMMAND(\"buzzer\", {\nbuzzerSetState(!pinRead(buzzerPin));\nreturn;\n});\n\nCOMMAND(\"buttons\", {\nCOMMAND(\"debug\", {\nbuttonControllerSetDebug(true);\nreturn;\n});\n});\n\nCOMMAND(\"oled\", {\nCOMMAND(\"test\", {\nprintf(\"Oled test: %d\\n\", oledTestConnection());\nreturn;\n});\n\nCOMMAND(\"fill\", {\nCOMMAND(\"white\", {               oledFill(White);\noledUpdateScreen();\nprintf(\"OLED fill white\\n\");\nreturn;\n});\nCOMMAND(\"black\", {\noledFill(Black);\noledUpdateScreen();\nprintf(\"OLED fill black\\n\");\nreturn;\n});\n});\nCOMMAND(\"write\", {\noledSetCursor(0, 0);\noledWriteString(\"AHOJ\", Font_11x18, White);\noledUpdateScreen();\nprintf(\"OLED write\\n\");\nreturn;\n});\nCOMMAND(\"init\", {\nCoprocReq_OledInit req;\nreq.width = 128;\nreq.height = 64;\nreq.rotate = true;\nreq.inverseColor = false;\noledInit(req);\nprintf(\"OLED init\\n\");\nreturn;\n});\n});\n\nCOMMAND(\"mpu\", {\nCOMMAND(\"init\", {\nmpuInitialize();\nprintf(\"MPU init\\n\");\nreturn;\n});\nCOMMAND(\"test\", {\nprintf(\"MPU test: %d\\n\", mpu_testConnection());\nreturn;\n});\nCOMMAND(\"temp\", {\nprintf(\"MPU temp: %d\\n\", mpu_getTemperature());\nreturn;\n});\nCOMMAND(\"acc\", {\nint16_t x, y, z;\n// int32_t x, y, z;\nmpu_getAcceleration(&amp;x, &amp;y, &amp;z);\nprintf(\"MPU acc: x:%d, y:%d, z:%d\\n\", x, y, z);\nreturn;\n});\nCOMMAND(\"gyro\", {\nint16_t x, y, z;\n// int32_t x, y, z;\nmpu_getRotation(&amp;x, &amp;y, &amp;z);\nprintf(\"MPU gyro: x:%d, y:%d, z:%d\\n\", x, y, z);\nreturn;\n});\n});\n\nCOMMAND(\"i2c\", {\nCOMMAND(\"transmit\", {\nunsigned DevAddress;\nuint8_t pData[10];\nunsigned Size;\nif (sscanf(cmd, \"%u %u %u\", &amp;DevAddress, &amp;pData[0], &amp;Size) != 3) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\nprintf(\"I2C tran %d\\n\",\nI2Cdev_Master_Transmit(DevAddress, pData, Size, 0));\nreturn;\n});\n\nCOMMAND(\"receive\", {\nunsigned DevAddress;\nuint8_t pData[10];\nunsigned Size;\nif (sscanf(cmd, \"%u %u\", &amp;DevAddress, &amp;Size) != 2) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\nprintf(\"I2C rec %d; ret: %d\\n\",\nI2Cdev_Master_Receive(DevAddress, pData, Size, 0), pData[0]);\nreturn;\n});\n\nCOMMAND(\"ping\", {\nunsigned DevAddress;\nunsigned Trials;\nif (sscanf(cmd, \"%u %u\", &amp;DevAddress, &amp;Trials) != 2) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\nprintf(\"I2C ping %d\\n\",\nI2Cdev_IsDeviceReady(DevAddress, Trials) == HAL_OK);\nreturn;\n});\n\nCOMMAND(\"scan\", {\nprintf(\"I2C scanner %d\\n\", I2Cdev_scan());\nreturn;\n});\n});\n\nprintf(\"Invalid command.\\n\");\n}\n\nstatic void debugDownstreamHandler() {\nusbIrqPrioRaise.lock();\nconst int transferred = usbd_ep_read(\n&amp;udev, CDC_DEBUG_RXD_EP, usbFrameBuf.data(), usbFrameBuf.size());\nusbIrqPrioRaise.unlock();\n\nif (transferred &gt; 0) {\nusbRxFifo.writeSpan(usbFrameBuf.data(), transferred);\nprocessRxBuf(usbRxFifo);\n}\n}\n\nstatic void debugUpstreamHandler() {\nportDISABLE_INTERRUPTS();\nconst auto chunk = std::min(usbTxFifo.available(), usbFrameBuf.size());\nif (chunk != 0) {\nusbTxFifo.peekSpan(usbFrameBuf.data(), chunk);\nint transferred\n= usbd_ep_write(&amp;udev, CDC_DEBUG_TXD_EP, usbFrameBuf.data(), chunk);\nif (transferred &gt; 0) {\nusbTxFifo.notifyRead(transferred);\n}\n}\nportENABLE_INTERRUPTS();\n}\n\nvoid debugLinkPoll() {\nchar buf[MaxLineLength];\nif (rxLineBuffer.pop_front((uint8_t*)buf, MaxLineLength, 0)) {\ndebugLinkHandleCommand(buf);\n}\n\nif (cdcLinkIsDebugEpEnabled()) {\ndebugDownstreamHandler();\ndebugUpstreamHandler();\n}\n}\n</code></pre>"},{"location":"stm/Dispatcher_8cpp/","title":"File Dispatcher.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; Dispatcher.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"BuzzerController.hpp\"</code></li> <li><code>#include \"ControlLink.hpp\"</code></li> <li><code>#include \"Esp32Manager.hpp\"</code></li> <li><code>#include \"I2cController.hpp\"</code></li> <li><code>#include \"MotorController.hpp\"</code></li> <li><code>#include \"Power.hpp\"</code></li> <li><code>#include \"StupidServoController.hpp\"</code></li> <li><code>#include \"UltrasoundController.hpp\"</code></li> <li><code>#include \"queue.h\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> <li><code>#include \"utils/QueueWrapper.hpp\"</code></li> </ul>"},{"location":"stm/Dispatcher_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name QueueWrapper&lt; CoprocReq, 8 &gt; requestQueue QueueWrapper&lt; CoprocStat, 64 &gt; statusQueue"},{"location":"stm/Dispatcher_8cpp/#public-functions","title":"Public Functions","text":"Type Name bool dispatcherEnqueueRequest (const CoprocReq &amp; request)  bool dispatcherEnqueueStatus (const CoprocStat &amp; status)  void dispatcherInit ()  void dispatcherPoll ()  void dispatcherReset ()"},{"location":"stm/Dispatcher_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void dispatcherProcessReq (const CoprocReq &amp; request)"},{"location":"stm/Dispatcher_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/Dispatcher_8cpp/#variable-requestqueue","title":"variable requestQueue","text":"<pre><code>QueueWrapper&lt;CoprocReq, 8&gt; requestQueue;\n</code></pre>"},{"location":"stm/Dispatcher_8cpp/#variable-statusqueue","title":"variable statusQueue","text":"<pre><code>QueueWrapper&lt;CoprocStat, 64&gt; statusQueue;\n</code></pre>"},{"location":"stm/Dispatcher_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/Dispatcher_8cpp/#function-dispatcherenqueuerequest","title":"function dispatcherEnqueueRequest","text":"<pre><code>bool dispatcherEnqueueRequest (\nconst CoprocReq &amp; request\n) </code></pre>"},{"location":"stm/Dispatcher_8cpp/#function-dispatcherenqueuestatus","title":"function dispatcherEnqueueStatus","text":"<pre><code>bool dispatcherEnqueueStatus (\nconst CoprocStat &amp; status\n) </code></pre>"},{"location":"stm/Dispatcher_8cpp/#function-dispatcherinit","title":"function dispatcherInit","text":"<pre><code>void dispatcherInit () </code></pre>"},{"location":"stm/Dispatcher_8cpp/#function-dispatcherpoll","title":"function dispatcherPoll","text":"<pre><code>void dispatcherPoll () </code></pre>"},{"location":"stm/Dispatcher_8cpp/#function-dispatcherreset","title":"function dispatcherReset","text":"<pre><code>void dispatcherReset () </code></pre>"},{"location":"stm/Dispatcher_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"stm/Dispatcher_8cpp/#function-dispatcherprocessreq","title":"function dispatcherProcessReq","text":"<pre><code>static void dispatcherProcessReq (\nconst CoprocReq &amp; request\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/Dispatcher.cpp</code></p>"},{"location":"stm/Dispatcher_8cpp_source/","title":"File Dispatcher.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; Dispatcher.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"Dispatcher.hpp\"\n#include \"FreeRTOS.h\"\n#include \"utils/Debug.hpp\"\n\n#include \"Bsp.hpp\"\n#include \"BuzzerController.hpp\"\n#include \"ControlLink.hpp\"\n#include \"Esp32Manager.hpp\"\n#include \"I2cController.hpp\"\n#include \"MotorController.hpp\"\n#include \"Power.hpp\"\n#include \"StupidServoController.hpp\"\n#include \"UltrasoundController.hpp\"\n#include \"queue.h\"\n#include \"rbcx.pb.h\"\n#include \"utils/QueueWrapper.hpp\"\n\nstatic QueueWrapper&lt;CoprocStat, 64&gt; statusQueue;\nstatic QueueWrapper&lt;CoprocReq, 8&gt; requestQueue;\n\nvoid dispatcherInit() {\nstatusQueue.create();\nrequestQueue.create();\n}\n\nbool dispatcherEnqueueStatus(const CoprocStat&amp; status) {\nBaseType_t pxHigherPriorityTaskWoken = pdFALSE;\nauto ok = statusQueue.push_back(status, 0, &amp;pxHigherPriorityTaskWoken);\nif (!ok) {\nDEBUG(\"Status queue overflow\\n\");\n}\nportYIELD_FROM_ISR(pxHigherPriorityTaskWoken);\nreturn ok;\n}\n\nbool dispatcherEnqueueRequest(const CoprocReq&amp; request) {\nBaseType_t pxHigherPriorityTaskWoken = pdFALSE;\nauto ok = requestQueue.push_back(request, 0, &amp;pxHigherPriorityTaskWoken);\nif (!ok) {\nDEBUG(\"Request queue overflow\\n\");\n}\nportYIELD_FROM_ISR(pxHigherPriorityTaskWoken);\nreturn ok;\n}\n\nstatic void dispatcherProcessReq(const CoprocReq&amp; request) {\nswitch (request.which_payload) {\ncase CoprocReq_setLeds_tag: {\nsetLeds(request.payload.setLeds.ledsOn);\nconst CoprocStat status = {\n.which_payload = CoprocStat_ledsStat_tag,\n};\ncontrolLinkTx(status);\nbreak;\n}\ncase CoprocReq_getButtons_tag: {\nCoprocStat status = {\n.which_payload = CoprocStat_buttonsStat_tag,\n};\nstatus.payload.buttonsStat.buttonsPressed\n= CoprocStat_ButtonsEnum(getButtons());\ncontrolLinkTx(status);\nbreak;\n}\ncase CoprocReq_setStupidServo_tag:\nstupidServoDispatch(request.payload.setStupidServo);\nbreak;\ncase CoprocReq_ultrasoundReq_tag:\nultrasoundDispatch(request.payload.ultrasoundReq);\nbreak;\ncase CoprocReq_buzzerReq_tag:\nbuzzerSetState(request.payload.buzzerReq.on);\nbuzzerSetState(request.payload.buzzerReq.on);\nbreak;\ncase CoprocReq_versionReq_tag: {\nCoprocStat status = {\n.which_payload = CoprocStat_versionStat_tag,\n};\n\nauto&amp; v = status.payload.versionStat;\n\nstatic_assert(sizeof(v.revision) == 8);\nstatic_assert(sizeof(RBCX_VER_REVISION) == 9); // + NULL byte\nmemcpy(v.revision, RBCX_VER_REVISION, 8);\n\nv.dirty = RBCX_VER_DIRTY;\nv.number = RBCX_VER_NUMBER;\ncontrolLinkTx(status);\nbreak;\n}\ncase CoprocReq_calibratePower_tag: {\nconst auto&amp; c = request.payload.calibratePower;\npowerCalibrate(c.vccMv, c.battMidMv, c.vRef33Mv, c.temperatureC);\nbreak;\n}\ncase CoprocReq_shutdownPower_tag:\npowerShutDown();\nbreak;\ncase CoprocReq_motorReq_tag:\nmotorDispatch(request.payload.motorReq);\nbreak;\ncase CoprocReq_i2cReq_tag:\ni2cDispatch(request.payload.i2cReq);\nbreak;\n}\n}\n\nvoid dispatcherPoll() {\nCoprocReq request;\nCoprocStat status;\n\nif (controlLinkRx(request)) {\nsEsp32Manager.resetWatchdog();\ndispatcherProcessReq(request);\n}\n\nif (requestQueue.pop_front(request, 0)) {\ndispatcherProcessReq(request);\n}\n\nif (statusQueue.pop_front(status, 0)) {\ncontrolLinkTx(status);\n}\n}\n\nvoid dispatcherReset() {\nrequestQueue.reset();\nstatusQueue.reset();\n}\n</code></pre>"},{"location":"stm/Esp32Manager_8cpp/","title":"File Esp32Manager.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; Esp32Manager.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"stm32f1xx_hal_gpio.h\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"Esp32Manager.hpp\"</code></li> </ul>"},{"location":"stm/Esp32Manager_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name Esp32Manager sEsp32Manager"},{"location":"stm/Esp32Manager_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint32_t Esp32WatchdogTimeoutMs   = = 150"},{"location":"stm/Esp32Manager_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/Esp32Manager_8cpp/#variable-sesp32manager","title":"variable sEsp32Manager","text":"<pre><code>Esp32Manager sEsp32Manager;\n</code></pre>"},{"location":"stm/Esp32Manager_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/Esp32Manager_8cpp/#variable-esp32watchdogtimeoutms","title":"variable Esp32WatchdogTimeoutMs","text":"<pre><code>constexpr uint32_t Esp32WatchdogTimeoutMs;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/Esp32Manager.cpp</code></p>"},{"location":"stm/Esp32Manager_8cpp_source/","title":"File Esp32Manager.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; Esp32Manager.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx_hal_gpio.h\"\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\n#include \"Bsp.hpp\"\n#include \"utils/Debug.hpp\"\n\n#include \"Esp32Manager.hpp\"\n\n// https://github.com/espressif/esptool/blob/4a1e87d290e9ba2870b4d092baf7b9ae15e4095d/esptool.py#L469\n\n// Bootloader\n// [   1441314][src/UsbCdcLink.c:205]: CONTROL_LINE_STATE DTR 0 RTS 1 &lt;-- 0\n// [   1441414][src/UsbCdcLink.c:205]: CONTROL_LINE_STATE DTR 1 RTS 1 &lt;-- 1\n// [   1441415][src/UsbCdcLink.c:205]: CONTROL_LINE_STATE DTR 1 RTS 0 &lt;-- 2\n// [   1441465][src/UsbCdcLink.c:205]: CONTROL_LINE_STATE DTR 0 RTS 0\n\n// Reboot\n//                                    (don't care)          DTR 0       &lt;-- 0\n// [    444506][src/UsbCdcLink.cpp:205]: CONTROL_LINE_STATE DTR 0 RTS 1 &lt;-- 1\n// [    444607][src/UsbCdcLink.cpp:205]: CONTROL_LINE_STATE DTR 0 RTS 0 &lt;-- 2\n\nstatic constexpr uint32_t Esp32WatchdogTimeoutMs = 150;\n\nEsp32Manager sEsp32Manager;\n\nEsp32Manager::Esp32Manager()\n: m_enPinHolders {}\n, m_queuedReset(RstNormal)\n, m_previousEnEdge(false)\n, m_inBootloader(false)\n, m_watchdogInhibit(false) {}\n\nEsp32Manager::~Esp32Manager() {}\n\nvoid Esp32Manager::init() {\npinInit(espEnPin, GPIO_MODE_INPUT, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\nm_previousEnEdge = pinRead(espEnPin);\nif (CoreDebug-&gt;DHCSR &amp; CoreDebug_DHCSR_C_DEBUGEN_Msk) {\nDEBUG(\"Watchdog inhibited with debugger attached\\n\");\nm_watchdogInhibit = true;\n}\n}\n\nvoid Esp32Manager::poll() {\nif (m_queuedReset != RstNone) {\nholdReset(EnSwReset);\nreleaseReset(EnSwReset, m_queuedReset == RstBootloader);\nm_queuedReset = RstNone;\n}\n\nif (m_unstrapTimer.poll()) {\nunstrapPins();\n}\n\nif (m_checkBreakTimer.poll()) {\nif (m_lastRts &amp;&amp; !m_lastDtr) {\nholdReset(EnSerialBreaks);\n} else {\nreleaseReset(EnSerialBreaks, m_lastDtr &amp;&amp; !m_lastRts);\n}\n}\n\nif (!m_watchdogInhibit &amp;&amp; m_watchdogTimer.poll() &amp;&amp; !m_inBootloader\n&amp;&amp; m_previousEnEdge &amp;&amp; m_enPinHolders == 0) {\nDEBUG(\"Esp32 watchdog timed out, resetting.\\n\");\nqueueReset();\n}\n}\n\nvoid Esp32Manager::holdReset(EnHolderType typ) {\nif (m_enPinHolders == 0) {\npinInit(espEnPin, GPIO_MODE_OUTPUT_OD, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW,\ntrue);\npinWrite(espEnPin, 0);\nsoftReset();\n}\nm_enPinHolders |= (1 &lt;&lt; typ);\n}\n\nvoid Esp32Manager::releaseReset(EnHolderType typ, bool strapForBootloader) {\nconst uint32_t mask = (1 &lt;&lt; typ);\nif (m_enPinHolders == mask) {\nstrapPins(strapForBootloader);\npinInit(espEnPin, GPIO_MODE_IT_RISING_FALLING, GPIO_NOPULL,\nGPIO_SPEED_FREQ_LOW, true);\nm_unstrapTimer.restart(2);\n}\nm_enPinHolders &amp;= ~mask;\n}\n\nvoid Esp32Manager::queueReset(bool bootloader) {\nm_queuedReset = !bootloader ? RstNormal : RstBootloader;\n}\n\nvoid Esp32Manager::strapPins(bool bootloader) {\n//DEBUG(\"Straping pins, bootloader: %d\\n\", bootloader);\npinInit(esp0Pin, GPIO_MODE_OUTPUT_OD, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\npinInit(esp12Pin, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL,\nGPIO_SPEED_FREQ_LOW); // TODO: set pin 12 to OD on RBCX v1.1, v1.0 has HW bug\npinInit(esp15Pin, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\n\npinWrite(esp12Pin, 0); // 3.3v flash\npinWrite(esp15Pin, 1); // Do not silence bootloader messages\n\nif (!bootloader) {\npinWrite(esp0Pin, 1); // normal\n} else {\npinWrite(esp0Pin, 0); // bootloader\n\npinInit(esp2Pin, GPIO_MODE_OUTPUT_OD, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\npinWrite(esp2Pin, 0); // bootloader confirm\n}\n\nm_inBootloader = bootloader;\n\nif (bootloader) {\nm_watchdogTimer.stop();\n} else {\nm_watchdogTimer.restart(Esp32WatchdogTimeoutMs * 5);\n}\n}\n\nvoid Esp32Manager::unstrapPins() { reinitEspStrappingPins(); }\n\nvoid Esp32Manager::onEnRisingInIrq() {\nconst bool currentEdge = pinRead(espEnPin);\nif (currentEdge &amp;&amp; !m_previousEnEdge &amp;&amp; m_enPinHolders == 0) {\nqueueReset(m_lastDtr &amp;&amp; !m_lastRts);\n} else if (!currentEdge &amp;&amp; m_previousEnEdge) {\nsoftReset();\n}\nm_previousEnEdge = currentEdge;\n}\n\nvoid Esp32Manager::onSerialBreakInIrq(bool dtr, bool rts) {\nm_lastDtr = dtr;\nm_lastRts = rts;\nm_checkBreakTimer.restart(25);\n}\n\nvoid Esp32Manager::resetWatchdog() {\nm_watchdogTimer.restart(Esp32WatchdogTimeoutMs);\n}\n\nvoid Esp32Manager::setWatchdogInhibit(bool inhibit) {\nm_watchdogInhibit = inhibit;\n}\n</code></pre>"},{"location":"stm/FreeRTOSCallbacks_8cpp/","title":"File FreeRTOSCallbacks.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; FreeRTOSCallbacks.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"stm32f1xx_ll_utils.h\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> </ul>"},{"location":"stm/FreeRTOSCallbacks_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name StackType_t idleTaskStack StaticTask_t idleTaskStruct"},{"location":"stm/FreeRTOSCallbacks_8cpp/#public-functions","title":"Public Functions","text":"Type Name void _exit ()  void vApplicationGetIdleTaskMemory (StaticTask_t ** ppxIdleTaskTCBBuffer, StackType_t ** ppxIdleTaskStackBuffer, uint32_t * pulIdleTaskStackSize)  void vApplicationStackOverflowHook (TaskHandle_t xTask, signed char * pcTaskName)  void vApplicationTickHook ()"},{"location":"stm/FreeRTOSCallbacks_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/FreeRTOSCallbacks_8cpp/#variable-idletaskstack","title":"variable idleTaskStack","text":"<pre><code>StackType_t idleTaskStack[configMINIMAL_STACK_SIZE];\n</code></pre>"},{"location":"stm/FreeRTOSCallbacks_8cpp/#variable-idletaskstruct","title":"variable idleTaskStruct","text":"<pre><code>StaticTask_t idleTaskStruct;\n</code></pre>"},{"location":"stm/FreeRTOSCallbacks_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/FreeRTOSCallbacks_8cpp/#function-_exit","title":"function _exit","text":"<pre><code>void _exit () </code></pre>"},{"location":"stm/FreeRTOSCallbacks_8cpp/#function-vapplicationgetidletaskmemory","title":"function vApplicationGetIdleTaskMemory","text":"<pre><code>void vApplicationGetIdleTaskMemory (\nStaticTask_t ** ppxIdleTaskTCBBuffer,\nStackType_t ** ppxIdleTaskStackBuffer,\nuint32_t * pulIdleTaskStackSize\n) </code></pre>"},{"location":"stm/FreeRTOSCallbacks_8cpp/#function-vapplicationstackoverflowhook","title":"function vApplicationStackOverflowHook","text":"<pre><code>void vApplicationStackOverflowHook (\nTaskHandle_t xTask,\nsigned char * pcTaskName\n) </code></pre>"},{"location":"stm/FreeRTOSCallbacks_8cpp/#function-vapplicationtickhook","title":"function vApplicationTickHook","text":"<pre><code>void vApplicationTickHook () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/FreeRTOSCallbacks.cpp</code></p>"},{"location":"stm/FreeRTOSCallbacks_8cpp_source/","title":"File FreeRTOSCallbacks.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; FreeRTOSCallbacks.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx_ll_utils.h\"\n\n#include \"Bsp.hpp\"\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\nstatic StaticTask_t idleTaskStruct;\nstatic StackType_t idleTaskStack[configMINIMAL_STACK_SIZE];\n\n// While timeouts in LL functions rely on having milliseconds in SYSTICK,\n// timeouts in HAL functions require incrementing the uwTick variable:\nextern \"C\" void vApplicationTickHook() { HAL_IncTick(); }\n\nextern \"C\" void vApplicationGetIdleTaskMemory(\nStaticTask_t** ppxIdleTaskTCBBuffer, StackType_t** ppxIdleTaskStackBuffer,\nuint32_t* pulIdleTaskStackSize) {\n*ppxIdleTaskTCBBuffer = &amp;idleTaskStruct;\n*ppxIdleTaskStackBuffer = idleTaskStack;\n*pulIdleTaskStackSize = sizeof(idleTaskStack) / sizeof(StackType_t);\n}\n\n#if configUSE_TIMERS\nstatic StaticTask_t timerTaskStruct;\nstatic StackType_t timerTaskStack[configTIMER_TASK_STACK_DEPTH];\n\nextern \"C\" void vApplicationGetTimerTaskMemory(\nStaticTask_t** ppxIdleTaskTCBBuffer, StackType_t** ppxIdleTaskStackBuffer,\nuint32_t* pulIdleTaskStackSize) {\n*ppxIdleTaskTCBBuffer = &amp;timerTaskStruct;\n*ppxIdleTaskStackBuffer = timerTaskStack;\n*pulIdleTaskStackSize = sizeof(timerTaskStack) / sizeof(StackType_t);\n}\n#endif\n\nextern \"C\" void vApplicationStackOverflowHook(\nTaskHandle_t xTask, signed char* pcTaskName) {\nprintf(\"Stack overflow!\\n\");\nprintf(\"Task: %s\\n\", pcTaskName);\n\nabort();\n}\n\nextern \"C\" void _exit() {\nsoftReset();\n\nLL_mDelay(10);\nputs(\"\\n\\n !!! PROGRAM EXITED, HALTING !!!\\n\\n\");\nLL_mDelay(10);\n\n__disable_irq();\n\nuint32_t on = 0xFFFFFFF;\nwhile (true) {\nsetLeds(on);\non = ~on;\n\n// Triggers when STLink is connected, there doesn't seem to be a way\n// to check if a debugging session is in progress :/\nif (CoreDebug-&gt;DHCSR &amp; CoreDebug_DHCSR_C_DEBUGEN_Msk) {\n__BKPT();\n}\n\nLL_mDelay(200);\n}\n}\n</code></pre>"},{"location":"stm/I2cController_8cpp/","title":"File I2cController.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; I2cController.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"I2cController.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"MpuController.hpp\"</code></li> <li><code>#include \"OledController.hpp\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/MutexWrapper.hpp\"</code></li> <li><code>#include \"utils/QueueWrapper.hpp\"</code></li> <li><code>#include \"utils/TaskWrapper.hpp\"</code></li> <li><code>#include \"timers.h\"</code></li> <li><code>#include &lt;mutex&gt;</code></li> </ul>"},{"location":"stm/I2cController_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name I2C_HandleTypeDef I2Cdev_hi2c uint16_t I2Cdev_readTimeout   = = I2CDEV_DEFAULT_READ_TIMEOUT EventGroupHandle_t i2cEventGroup TaskHandle_t i2cTaskHandle"},{"location":"stm/I2cController_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name xTaskHandle i2cCallingTask StaticEventGroup_t i2cEventBuffer MutexWrapper i2cMutex QueueWrapper&lt; CoprocReq_I2cReq, 16 &gt; i2cQueue TaskWrapper&lt; 1024 &gt; i2cTask"},{"location":"stm/I2cController_8cpp/#public-functions","title":"Public Functions","text":"Type Name __weak void HAL_I2C_ErrorCallback (I2C_HandleTypeDef * hi2c)  __weak void HAL_I2C_MasterRxCpltCallback (I2C_HandleTypeDef * hi2c)  __weak void HAL_I2C_MasterTxCpltCallback (I2C_HandleTypeDef * hi2c)  __weak void HAL_I2C_MemRxCpltCallback (I2C_HandleTypeDef * hi2c)  __weak void HAL_I2C_MemTxCpltCallback (I2C_HandleTypeDef * hi2c)  void I2C1_ER_IRQHandler ()  void I2C1_EV_IRQHandler ()  uint8_t I2Cdev_IsDeviceReady (uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)  uint8_t I2Cdev_Master_Receive (uint16_t DevAddress, uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_Master_Transmit (uint16_t DevAddress, uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_Mem_Read (uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_Mem_Write (uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_init ()  uint8_t I2Cdev_readBit (uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t * data, uint16_t timeout)  uint8_t I2Cdev_readBitW (uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t * data, uint16_t timeout)  uint8_t I2Cdev_readBits (uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t * data, uint16_t timeout)  uint8_t I2Cdev_readBitsW (uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t * data, uint16_t timeout)  uint8_t I2Cdev_readByte (uint8_t devAddr, uint8_t regAddr, uint8_t * data, uint16_t timeout)  uint8_t I2Cdev_readBytes (uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t * data, uint16_t timeout)  uint8_t I2Cdev_readWord (uint8_t devAddr, uint8_t regAddr, uint16_t * data, uint16_t timeout)  uint8_t I2Cdev_readWords (uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t * data, uint16_t timeout)  uint8_t I2Cdev_scan ()  uint16_t I2Cdev_writeBit (uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data)  uint16_t I2Cdev_writeBitW (uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t data)  uint16_t I2Cdev_writeBits (uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data)  uint16_t I2Cdev_writeBitsW (uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t data)  uint16_t I2Cdev_writeByte (uint8_t devAddr, uint8_t regAddr, uint8_t data)  uint16_t I2Cdev_writeBytes (uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t * pData)  uint16_t I2Cdev_writeWord (uint8_t devAddr, uint8_t regAddr, uint16_t data)  uint16_t I2Cdev_writeWords (uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t * data)  void i2cDispatch (const CoprocReq_I2cReq &amp; req)  void i2cNotify ()  void i2cReset ()  uint8_t i2cWait (HAL_StatusTypeDef beginStatus, uint32_t tout)  uint8_t i2cWrap (F fun, uint32_t Timeout)"},{"location":"stm/I2cController_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/I2cController_8cpp/#variable-i2cdev_hi2c","title":"variable I2Cdev_hi2c","text":"<pre><code>I2C_HandleTypeDef I2Cdev_hi2c;\n</code></pre>"},{"location":"stm/I2cController_8cpp/#variable-i2cdev_readtimeout","title":"variable I2Cdev_readTimeout","text":"<pre><code>uint16_t I2Cdev_readTimeout;\n</code></pre> <p>Default timeout value for read operations. Set this to 0 to disable timeout detection. </p>"},{"location":"stm/I2cController_8cpp/#variable-i2ceventgroup","title":"variable i2cEventGroup","text":"<pre><code>EventGroupHandle_t i2cEventGroup;\n</code></pre>"},{"location":"stm/I2cController_8cpp/#variable-i2ctaskhandle","title":"variable i2cTaskHandle","text":"<pre><code>TaskHandle_t i2cTaskHandle;\n</code></pre>"},{"location":"stm/I2cController_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/I2cController_8cpp/#variable-i2ccallingtask","title":"variable i2cCallingTask","text":"<pre><code>xTaskHandle i2cCallingTask;\n</code></pre>"},{"location":"stm/I2cController_8cpp/#variable-i2ceventbuffer","title":"variable i2cEventBuffer","text":"<pre><code>StaticEventGroup_t i2cEventBuffer;\n</code></pre>"},{"location":"stm/I2cController_8cpp/#variable-i2cmutex","title":"variable i2cMutex","text":"<pre><code>MutexWrapper i2cMutex;\n</code></pre>"},{"location":"stm/I2cController_8cpp/#variable-i2cqueue","title":"variable i2cQueue","text":"<pre><code>QueueWrapper&lt;CoprocReq_I2cReq, 16&gt; i2cQueue;\n</code></pre>"},{"location":"stm/I2cController_8cpp/#variable-i2ctask","title":"variable i2cTask","text":"<pre><code>TaskWrapper&lt;1024&gt; i2cTask;\n</code></pre>"},{"location":"stm/I2cController_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/I2cController_8cpp/#function-hal_i2c_errorcallback","title":"function HAL_I2C_ErrorCallback","text":"<pre><code>__weak void HAL_I2C_ErrorCallback (\nI2C_HandleTypeDef * hi2c\n) </code></pre>"},{"location":"stm/I2cController_8cpp/#function-hal_i2c_masterrxcpltcallback","title":"function HAL_I2C_MasterRxCpltCallback","text":"<pre><code>__weak void HAL_I2C_MasterRxCpltCallback (\nI2C_HandleTypeDef * hi2c\n) </code></pre>"},{"location":"stm/I2cController_8cpp/#function-hal_i2c_mastertxcpltcallback","title":"function HAL_I2C_MasterTxCpltCallback","text":"<pre><code>__weak void HAL_I2C_MasterTxCpltCallback (\nI2C_HandleTypeDef * hi2c\n) </code></pre>"},{"location":"stm/I2cController_8cpp/#function-hal_i2c_memrxcpltcallback","title":"function HAL_I2C_MemRxCpltCallback","text":"<pre><code>__weak void HAL_I2C_MemRxCpltCallback (\nI2C_HandleTypeDef * hi2c\n) </code></pre>"},{"location":"stm/I2cController_8cpp/#function-hal_i2c_memtxcpltcallback","title":"function HAL_I2C_MemTxCpltCallback","text":"<pre><code>__weak void HAL_I2C_MemTxCpltCallback (\nI2C_HandleTypeDef * hi2c\n) </code></pre>"},{"location":"stm/I2cController_8cpp/#function-i2c1_er_irqhandler","title":"function I2C1_ER_IRQHandler","text":"<pre><code>void I2C1_ER_IRQHandler () </code></pre>"},{"location":"stm/I2cController_8cpp/#function-i2c1_ev_irqhandler","title":"function I2C1_EV_IRQHandler","text":"<pre><code>void I2C1_EV_IRQHandler () </code></pre>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_isdeviceready","title":"function I2Cdev_IsDeviceReady","text":"<pre><code>uint8_t I2Cdev_IsDeviceReady (\nuint16_t DevAddress,\nuint32_t Trials,\nuint32_t Timeout\n) </code></pre>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_master_receive","title":"function I2Cdev_Master_Receive","text":"<pre><code>uint8_t I2Cdev_Master_Receive (\nuint16_t DevAddress,\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_master_transmit","title":"function I2Cdev_Master_Transmit","text":"<pre><code>uint8_t I2Cdev_Master_Transmit (\nuint16_t DevAddress,\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_mem_read","title":"function I2Cdev_Mem_Read","text":"<pre><code>uint8_t I2Cdev_Mem_Read (\nuint16_t DevAddress,\nuint16_t MemAddress,\nuint16_t MemAddSize,\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_mem_write","title":"function I2Cdev_Mem_Write","text":"<pre><code>uint8_t I2Cdev_Mem_Write (\nuint16_t DevAddress,\nuint16_t MemAddress,\nuint16_t MemAddSize,\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_init","title":"function I2Cdev_init","text":"<pre><code>uint8_t I2Cdev_init () </code></pre>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_readbit","title":"function I2Cdev_readBit","text":"<pre><code>uint8_t I2Cdev_readBit (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitNum,\nuint8_t * data,\nuint16_t timeout\n) </code></pre> <p>Read a single bit from an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>bitNum</code> Bit position to read (0-7) </li> <li><code>data</code> Container for single bit value </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_readbitw","title":"function I2Cdev_readBitW","text":"<pre><code>uint8_t I2Cdev_readBitW (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitNum,\nuint16_t * data,\nuint16_t timeout\n) </code></pre> <p>Read a single bit from a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>bitNum</code> Bit position to read (0-15) </li> <li><code>data</code> Container for single bit value </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_readbits","title":"function I2Cdev_readBits","text":"<pre><code>uint8_t I2Cdev_readBits (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitStart,\nuint8_t length,\nuint8_t * data,\nuint16_t timeout\n) </code></pre> <p>Read multiple bits from an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>bitStart</code> First bit position to read (0-7) </li> <li><code>length</code> Number of bits to read (not more than 8) </li> <li><code>data</code> Container for right-aligned value (i.e. '101' read from any bitStart position will equal 0x05) </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_readbitsw","title":"function I2Cdev_readBitsW","text":"<pre><code>uint8_t I2Cdev_readBitsW (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitStart,\nuint8_t length,\nuint16_t * data,\nuint16_t timeout\n) </code></pre> <p>Read multiple bits from a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>bitStart</code> First bit position to read (0-15) </li> <li><code>length</code> Number of bits to read (not more than 16) </li> <li><code>data</code> Container for right-aligned value (i.e. '101' read from any bitStart position will equal 0x05) </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (1 = success, 0 = failure, -1 = timeout) </p>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_readbyte","title":"function I2Cdev_readByte","text":"<pre><code>uint8_t I2Cdev_readByte (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t * data,\nuint16_t timeout\n) </code></pre> <p>Read single byte from an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>data</code> Container for byte value read from device </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_readbytes","title":"function I2Cdev_readBytes","text":"<pre><code>uint8_t I2Cdev_readBytes (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t length,\nuint8_t * data,\nuint16_t timeout\n) </code></pre> <p>Read multiple bytes from an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> First register regAddr to read from </li> <li><code>length</code> Number of bytes to read </li> <li><code>data</code> Buffer to store read data in </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Number of bytes read (-1 indicates failure) </p>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_readword","title":"function I2Cdev_readWord","text":"<pre><code>uint8_t I2Cdev_readWord (\nuint8_t devAddr,\nuint8_t regAddr,\nuint16_t * data,\nuint16_t timeout\n) </code></pre> <p>Read single word from a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>data</code> Container for word value read from device </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_readwords","title":"function I2Cdev_readWords","text":"<pre><code>uint8_t I2Cdev_readWords (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t length,\nuint16_t * data,\nuint16_t timeout\n) </code></pre> <p>Read multiple words from a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> First register regAddr to read from </li> <li><code>length</code> Number of words to read </li> <li><code>data</code> Buffer to store read data in </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Number of words read (-1 indicates failure) </p>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_scan","title":"function I2Cdev_scan","text":"<pre><code>uint8_t I2Cdev_scan () </code></pre>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_writebit","title":"function I2Cdev_writeBit","text":"<pre><code>uint16_t I2Cdev_writeBit (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitNum,\nuint8_t data\n) </code></pre> <p>write a single bit in an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to write to </li> <li><code>bitNum</code> Bit position to write (0-7) </li> <li><code>value</code> New bit value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_writebitw","title":"function I2Cdev_writeBitW","text":"<pre><code>uint16_t I2Cdev_writeBitW (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitNum,\nuint16_t data\n) </code></pre> <p>write a single bit in a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to write to </li> <li><code>bitNum</code> Bit position to write (0-15) </li> <li><code>value</code> New bit value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_writebits","title":"function I2Cdev_writeBits","text":"<pre><code>uint16_t I2Cdev_writeBits (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitStart,\nuint8_t length,\nuint8_t data\n) </code></pre> <p>Write multiple bits in an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to write to </li> <li><code>bitStart</code> First bit position to write (0-7) </li> <li><code>length</code> Number of bits to write (not more than 8) </li> <li><code>data</code> Right-aligned value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_writebitsw","title":"function I2Cdev_writeBitsW","text":"<pre><code>uint16_t I2Cdev_writeBitsW (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitStart,\nuint8_t length,\nuint16_t data\n) </code></pre> <p>Write multiple bits in a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to write to </li> <li><code>bitStart</code> First bit position to write (0-15) </li> <li><code>length</code> Number of bits to write (not more than 16) </li> <li><code>data</code> Right-aligned value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_writebyte","title":"function I2Cdev_writeByte","text":"<pre><code>uint16_t I2Cdev_writeByte (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t data\n) </code></pre> <p>Write single byte to an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register address to write to </li> <li><code>data</code> New byte value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_writebytes","title":"function I2Cdev_writeBytes","text":"<pre><code>uint16_t I2Cdev_writeBytes (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t length,\nuint8_t * pData\n) </code></pre> <p>Write multiple bytes to an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> First register address to write to </li> <li><code>length</code> Number of bytes to write </li> <li><code>data</code> Buffer to copy new data from </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_writeword","title":"function I2Cdev_writeWord","text":"<pre><code>uint16_t I2Cdev_writeWord (\nuint8_t devAddr,\nuint8_t regAddr,\nuint16_t data\n) </code></pre> <p>Write single word to a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register address to write to </li> <li><code>data</code> New word value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"stm/I2cController_8cpp/#function-i2cdev_writewords","title":"function I2Cdev_writeWords","text":"<pre><code>uint16_t I2Cdev_writeWords (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t length,\nuint16_t * data\n) </code></pre> <p>Write multiple words to a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> First register address to write to </li> <li><code>length</code> Number of words to write </li> <li><code>data</code> Buffer to copy new data from </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"stm/I2cController_8cpp/#function-i2cdispatch","title":"function i2cDispatch","text":"<pre><code>void i2cDispatch (\nconst CoprocReq_I2cReq &amp; req\n) </code></pre>"},{"location":"stm/I2cController_8cpp/#function-i2cnotify","title":"function i2cNotify","text":"<pre><code>void i2cNotify () </code></pre>"},{"location":"stm/I2cController_8cpp/#function-i2creset","title":"function i2cReset","text":"<pre><code>void i2cReset () </code></pre>"},{"location":"stm/I2cController_8cpp/#function-i2cwait","title":"function i2cWait","text":"<pre><code>uint8_t i2cWait (\nHAL_StatusTypeDef beginStatus,\nuint32_t tout\n) </code></pre>"},{"location":"stm/I2cController_8cpp/#function-i2cwrap","title":"function i2cWrap","text":"<pre><code>template&lt;typename F typename F&gt;\nuint8_t i2cWrap (\nF fun,\nuint32_t Timeout\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/I2cController.cpp</code></p>"},{"location":"stm/I2cController_8cpp_source/","title":"File I2cController.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; I2cController.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>// I2Cdev library collection - Main I2C device class header file\n// Abstracts bit and byte I2C R/W functions into a convenient class\n// 6/9/2012 by Jeff Rowberg &lt;jeff@rowberg.net&gt;\n// 6/6/2015 by Andrey Voloshin &lt;voloshin@think.in.ua&gt;\n//\n// Changelog:\n//      2015-06-06 - ported to STM32 HAL library from Arduino code\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2013 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n#include \"I2cController.hpp\"\n#include \"Bsp.hpp\"\n#include \"MpuController.hpp\"\n#include \"OledController.hpp\"\n#include \"utils/Debug.hpp\"\n\n#include \"utils/MutexWrapper.hpp\"\n#include \"utils/QueueWrapper.hpp\"\n#include \"utils/TaskWrapper.hpp\"\n#include \"timers.h\"\n\n// #include \"event_groups.h\"\n#include &lt;mutex&gt;\n\nstatic TaskWrapper&lt;1024&gt; i2cTask;\nTaskHandle_t i2cTaskHandle;\n\nstatic QueueWrapper&lt;CoprocReq_I2cReq, 16&gt; i2cQueue;\nstatic xTaskHandle i2cCallingTask;\nstatic MutexWrapper i2cMutex;\n\nEventGroupHandle_t i2cEventGroup;\nstatic StaticEventGroup_t i2cEventBuffer;\n\n// Hold pointer to inited HAL I2C device\nI2C_HandleTypeDef I2Cdev_hi2c;\n\nvoid i2cDispatch(const CoprocReq_I2cReq&amp; req) {\nif (i2cQueue.push_back(req, 0)) {\nxEventGroupSetBits(i2cEventGroup, I2C_MESSAGE);\n} else {\nDEBUG(\"I2c queue overflow\\n\");\n}\n}\n\nuint16_t I2Cdev_readTimeout = I2CDEV_DEFAULT_READ_TIMEOUT;\n\nuint8_t I2Cdev_init() {\nI2Cdev_hi2c.Instance = I2C1;\nI2Cdev_hi2c.Init.ClockSpeed = 400000;\nI2Cdev_hi2c.Init.DutyCycle = I2C_DUTYCYCLE_2;\nI2Cdev_hi2c.Init.OwnAddress1 = 0;\nI2Cdev_hi2c.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;\nI2Cdev_hi2c.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;\nI2Cdev_hi2c.Init.OwnAddress2 = 0;\nI2Cdev_hi2c.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;\nI2Cdev_hi2c.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;\nauto init = HAL_I2C_Init(&amp;I2Cdev_hi2c);\n\nif (init == HAL_OK) {\ni2cQueue.create();\ni2cMutex.create();\ni2cEventGroup = xEventGroupCreateStatic(&amp;i2cEventBuffer);\n\ni2cTask.start(\"i2c\", i2cPrio, []() {\nwhile (true) {\nCoprocReq_I2cReq req;\n\nEventBits_t eventsBit = I2C_NONE;\neventsBit = xEventGroupWaitBits(\ni2cEventGroup, 0xFF, pdTRUE, 0, portMAX_DELAY);\n\nif (eventsBit &amp; I2C_MPU_TICK) {\nmpuTick();\n// DEBUG(\"SEND MPU\\n\");\n}\n\nwhile (i2cQueue.pop_front(req, 0)) {\nswitch (req.which_payload) {\ncase CoprocReq_I2cReq_oledReq_tag:\noledDispatch(req.payload.oledReq);\nbreak;\ncase CoprocReq_I2cReq_mpuReq_tag:\nmpuDispatch(req.payload.mpuReq);\n// DEBUGLN(\"MPU Req %d\", req.payload.mpuReq.which_mpuCmd);\nbreak;\n}\n}\n// vTaskDelay(pdMS_TO_TICKS(10));\n}\n});\ni2cTaskHandle = i2cTask.handle();\n} else {\nDEBUG(\"Error I2c Init\\n\");\n}\n}\n\nvoid i2cNotify() {\nBaseType_t woken = 0;\nxTaskNotifyFromISR(i2cCallingTask, 0, eNoAction, &amp;woken);\nportYIELD_FROM_ISR(woken);\n}\n\nextern \"C\" void I2C1_EV_IRQHandler() { HAL_I2C_EV_IRQHandler(&amp;I2Cdev_hi2c); }\nextern \"C\" void I2C1_ER_IRQHandler() { HAL_I2C_ER_IRQHandler(&amp;I2Cdev_hi2c); }\n\nextern \"C\" __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef* hi2c) {\ni2cNotify();\n}\n\nextern \"C\" __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef* hi2c) {\ni2cNotify();\n}\n\nextern \"C\" __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef* hi2c) {\ni2cNotify();\n}\n\nextern \"C\" __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef* hi2c) {\ni2cNotify();\n}\n\nextern \"C\" __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef* hi2c) {\ni2cNotify();\n}\n\nuint8_t i2cWait(HAL_StatusTypeDef beginStatus, uint32_t tout) {}\n\ntemplate &lt;typename F&gt; uint8_t i2cWrap(F fun, uint32_t Timeout) {\nuint16_t tout = Timeout &gt; 0 ? Timeout : I2CDEV_DEFAULT_READ_TIMEOUT;\nstd::scoped_lock lock(i2cMutex);\ni2cCallingTask = xTaskGetCurrentTaskHandle();\nauto beginStatus = fun();\n\nif (beginStatus == HAL_OK) {\nauto ok = xTaskNotifyWait(0, ~0, nullptr, pdMS_TO_TICKS(tout));\n\nif (!ok) {\nDEBUG(\"I2C timeout\\n\");\nHAL_I2C_Master_Abort_IT(&amp;I2Cdev_hi2c, 0);\n}\nreturn ok;\n} else {\nHAL_I2C_Master_Abort_IT(&amp;I2Cdev_hi2c, 0);\nreturn 0;\n}\n}\n\nvoid i2cReset() { i2cQueue.reset();        }\n\n/* Rewrited original functions */\nuint8_t I2Cdev_Master_Transmit(\nuint16_t DevAddress, uint8_t* pData, uint16_t Size, uint32_t Timeout) {\nreturn i2cWrap(\n[=]() {\nauto beginStatus = HAL_I2C_Master_Transmit_IT(\n&amp;I2Cdev_hi2c, DevAddress &lt;&lt; 1, pData, Size);\n\nif (beginStatus != HAL_OK) {\nDEBUG(\"I2C ERR - Tx %d bytes, ret: %d\\n\", Size, beginStatus);\n}\nreturn beginStatus;\n},\nTimeout);\n}\n\nuint8_t I2Cdev_Master_Receive(\nuint16_t DevAddress, uint8_t* pData, uint16_t Size, uint32_t Timeout) {\nreturn i2cWrap(\n[=]() {\nauto beginStatus = HAL_I2C_Master_Receive_IT(\n&amp;I2Cdev_hi2c, DevAddress &lt;&lt; 1, pData, Size);\n\nif (beginStatus != HAL_OK) {\nDEBUG(\"I2C ERR - Rx %d bytes, ret: %d\\n\", Size, beginStatus);\n}\nreturn beginStatus;\n},\nTimeout);\n}\n\nuint8_t I2Cdev_Mem_Write(uint16_t DevAddress, uint16_t MemAddress,\nuint16_t MemAddSize, uint8_t* pData, uint16_t Size, uint32_t Timeout) {\nreturn i2cWrap(\n[=]() {\nauto beginStatus = HAL_I2C_Mem_Write_IT(&amp;I2Cdev_hi2c,\nDevAddress &lt;&lt; 1, MemAddress, MemAddSize, pData, Size);\n\nif (beginStatus != HAL_OK) {\nDEBUG(\"I2C ERR - Mem write %d bytes, ret: %d\\n\", Size, beginStatus);\n}\nreturn beginStatus;\n},\nTimeout);\n}\n\nuint8_t I2Cdev_Mem_Read(uint16_t DevAddress, uint16_t MemAddress,\nuint16_t MemAddSize, uint8_t* pData, uint16_t Size, uint32_t Timeout) {\nreturn i2cWrap(\n[=]() {\nauto beginStatus = HAL_I2C_Mem_Read_IT(&amp;I2Cdev_hi2c,\nDevAddress &lt;&lt; 1, MemAddress, MemAddSize, pData, Size);\n\nif (beginStatus != HAL_OK) {\nDEBUG(\"I2C ERR - Mem read %d bytes, ret: %d\\n\", Size, beginStatus);\n}\nreturn beginStatus;\n},\nTimeout);\n}\n\nuint8_t I2Cdev_IsDeviceReady(\nuint16_t DevAddress, uint32_t Trials, uint32_t Timeout) {\nuint16_t tout = Timeout &gt; 0 ? Timeout : I2CDEV_DEFAULT_READ_TIMEOUT;\nreturn HAL_I2C_IsDeviceReady(&amp;I2Cdev_hi2c, DevAddress &lt;&lt; 1, Trials, tout)\n== HAL_OK;\n}\n/* Rewrited original functions */\n\nuint8_t I2Cdev_scan() {\nuint8_t counter = 0;\nfor (int range = 1; range &lt;= 254; range++) {\nif (I2Cdev_IsDeviceReady(range) != 0) {\nDEBUG(\"I2Cdev_scan[%d] ready: %#04x (%d)\\n\", counter, range, range);\ncounter++;\n}\n}\nreturn counter;\n}\n\nuint8_t I2Cdev_readBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum,\nuint8_t* data, uint16_t timeout) {\nuint8_t b;\nuint8_t count = I2Cdev_readByte(devAddr, regAddr, &amp;b, timeout);\n*data = b &amp; (1 &lt;&lt; bitNum);\nreturn count;\n}\n\nuint8_t I2Cdev_readBitW(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum,\nuint16_t* data, uint16_t timeout) {\nuint16_t b;\nuint8_t count = I2Cdev_readWord(devAddr, regAddr, &amp;b, timeout);\n*data = b &amp; (1 &lt;&lt; bitNum);\nreturn count;\n}\n\nuint8_t I2Cdev_readBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart,\nuint8_t length, uint8_t* data, uint16_t timeout) {\n// 01101001 read byte\n// 76543210 bit numbers\n//    xxx   args: bitStart=4, length=3\n//    010   masked\n//   -&gt; 010 shifted\nuint8_t count, b;\nif ((count = I2Cdev_readByte(devAddr, regAddr, &amp;b, timeout)) != 0) {\nuint8_t mask = ((1 &lt;&lt; length) - 1) &lt;&lt; (bitStart - length + 1);\nb &amp;= mask;\nb &gt;&gt;= (bitStart - length + 1);\n*data = b;\n}\nreturn count;\n}\n\nuint8_t I2Cdev_readBitsW(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart,\nuint8_t length, uint16_t* data, uint16_t timeout) {\n// 1101011001101001 read byte\n// fedcba9876543210 bit numbers\n//    xxx           args: bitStart=12, length=3\n//    010           masked\n//           -&gt; 010 shifted\nuint8_t count;\nuint16_t w;\nif ((count = I2Cdev_readWord(devAddr, regAddr, &amp;w, timeout)) != 0) {\nuint16_t mask = ((1 &lt;&lt; length) - 1) &lt;&lt; (bitStart - length + 1);\nw &amp;= mask;\nw &gt;&gt;= (bitStart - length + 1);\n*data = w;\n}\nreturn count;\n}\n\nuint8_t I2Cdev_readByte(\nuint8_t devAddr, uint8_t regAddr, uint8_t* data, uint16_t timeout) {\nreturn I2Cdev_readBytes(devAddr, regAddr, 1, data, timeout);\n}\n\nuint8_t I2Cdev_readWord(\nuint8_t devAddr, uint8_t regAddr, uint16_t* data, uint16_t timeout) {\nreturn I2Cdev_readWords(devAddr, regAddr, 1, data, timeout);\n}\n\nuint8_t I2Cdev_readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length,\nuint8_t* data, uint16_t timeout) {\nuint16_t tout = timeout &gt; 0 ? timeout : I2CDEV_DEFAULT_READ_TIMEOUT;\nI2Cdev_Master_Transmit(devAddr, &amp;regAddr, 1, tout);\nuint8_t ret = I2Cdev_Master_Receive(devAddr, data, length, tout);\nif (ret != 0) {\nreturn length;\n}\nreturn -1;\n}\n\n// uint8_t I2Cdev_readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data, uint16_t timeout)\n// {\n//     uint16_t tout = timeout &gt; 0 ? timeout : I2CDEV_DEFAULT_READ_TIMEOUT;\n\n//     HAL_I2C_Master_Transmit(&amp;I2Cdev_hi2c, devAddr &lt;&lt; 1, &amp;regAddr, 1, tout);\n//     if (HAL_I2C_Master_Receive(&amp;I2Cdev_hi2c, devAddr &lt;&lt; 1, data, length, tout) == HAL_OK) {\n//         DEBUG(\"I2Cdev_readBytes %d\\n\", length);\n//         return length;\n//     }\n//     return -1;\n// }\n\nuint8_t I2Cdev_readWords(uint8_t devAddr, uint8_t regAddr, uint8_t length,\nuint16_t* data, uint16_t timeout) {\nuint16_t tout = timeout &gt; 0 ? timeout : I2CDEV_DEFAULT_READ_TIMEOUT;\n\nI2Cdev_Master_Transmit(devAddr, &amp;regAddr, 1, tout);\nif (I2Cdev_Master_Receive(devAddr, (uint8_t*)data, length * 2, tout) != 0)\nreturn length;\nelse\nreturn -1;\n}\n\n// uint8_t I2Cdev_readWords(uint8_t devAddr, uint8_t regAddr, uint8_t length,\n//     uint16_t* data, uint16_t timeout) {\n//     uint16_t tout = timeout &gt; 0 ? timeout : I2CDEV_DEFAULT_READ_TIMEOUT;\n\n//     HAL_I2C_Master_Transmit(&amp;I2Cdev_hi2c, devAddr &lt;&lt; 1, &amp;regAddr, 1, tout);\n//     if (HAL_I2C_Master_Receive(\n//             &amp;I2Cdev_hi2c, devAddr &lt;&lt; 1, (uint8_t*)data, length * 2, tout)\n//         == HAL_OK)\n//         return length;\n//     else\n//         return -1;\n// }\n\nuint16_t I2Cdev_writeBit(\nuint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {\nuint8_t b;\nI2Cdev_readByte(devAddr, regAddr, &amp;b, I2Cdev_readTimeout);\nb = (data != 0) ? (b | (1 &lt;&lt; bitNum)) : (b &amp; ~(1 &lt;&lt; bitNum));\nreturn I2Cdev_writeByte(devAddr, regAddr, b);\n}\n\nuint16_t I2Cdev_writeBitW(\nuint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t data) {\nuint16_t w;\nI2Cdev_readWord(devAddr, regAddr, &amp;w, 100);\nw = (data != 0) ? (w | (1 &lt;&lt; bitNum)) : (w &amp; ~(1 &lt;&lt; bitNum));\nreturn I2Cdev_writeWord(devAddr, regAddr, w);\n}\n\nuint16_t I2Cdev_writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart,\nuint8_t length, uint8_t data) {\n//      010 value to write\n// 76543210 bit numbers\n//    xxx   args: bitStart=4, length=3\n// 00011100 mask byte\n// 10101111 original value (sample)\n// 10100011 original &amp; ~mask\n// 10101011 masked | value\nuint8_t b;\nif (I2Cdev_readByte(devAddr, regAddr, &amp;b, 100) != 0) {\nuint8_t mask = ((1 &lt;&lt; length) - 1) &lt;&lt; (bitStart - length + 1);\ndata &lt;&lt;= (bitStart - length + 1); // shift data into correct position\ndata &amp;= mask; // zero all non-important bits in data\nb &amp;= ~(mask); // zero all important bits in existing byte\nb |= data; // combine data with existing byte\nreturn I2Cdev_writeByte(devAddr, regAddr, b);\n} else {\nreturn 0;\n}\n}\n\nuint16_t I2Cdev_writeBitsW(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart,\nuint8_t length, uint16_t data) {\n//              010 value to write\n// fedcba9876543210 bit numbers\n//    xxx           args: bitStart=12, length=3\n// 0001110000000000 mask word\n// 1010111110010110 original value (sample)\n// 1010001110010110 original &amp; ~mask\n// 1010101110010110 masked | value\nuint16_t w;\nif (I2Cdev_readWord(devAddr, regAddr, &amp;w, 100) != 0) {\nuint16_t mask = ((1 &lt;&lt; length) - 1) &lt;&lt; (bitStart - length + 1);\ndata &lt;&lt;= (bitStart - length + 1); // shift data into correct position\ndata &amp;= mask; // zero all non-important bits in data\nw &amp;= ~(mask); // zero all important bits in existing word\nw |= data; // combine data with existing word\nreturn I2Cdev_writeWord(devAddr, regAddr, w);\n} else {\nreturn 0;\n}\n}\n\nuint16_t I2Cdev_writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data) {\nreturn I2Cdev_writeBytes(devAddr, regAddr, 1, &amp;data);\n}\n\nuint16_t I2Cdev_writeWord(uint8_t devAddr, uint8_t regAddr, uint16_t data) {\nreturn I2Cdev_writeWords(devAddr, regAddr, 1, &amp;data);\n}\n\nuint16_t I2Cdev_writeBytes(\nuint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* pData) {\n// Creating array to store regAddr + data in one buffer\nuint8_t buffer[length + 1];\nbuffer[0] = regAddr;\n\n// copy array\nmemcpy(buffer + 1, pData, sizeof(uint8_t) * length);\n\nauto ok = I2Cdev_Master_Transmit(devAddr, buffer, length + 1, 1000);\nreturn ok;\n}\n\nuint16_t I2Cdev_writeWords(\nuint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t* data) {\n// Creating array to store regAddr + data in one buffer\nuint8_t buffer[length + 1];\nbuffer[0] = regAddr;\n\n// copy array\nmemcpy(buffer + 1, data, sizeof(uint16_t) * length);\nauto ok = I2Cdev_Master_Transmit(\ndevAddr, buffer, sizeof(uint8_t) + sizeof(uint16_t) * length, 1000);\nreturn ok;\n}\n</code></pre>"},{"location":"stm/MotorController_8cpp/","title":"File MotorController.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; MotorController.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"MotorController.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"ControlLink.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"Motor.hpp\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/MutexWrapper.hpp\"</code></li> <li><code>#include \"utils/TaskWrapper.hpp\"</code></li> <li><code>#include \"stm32f1xx_ll_tim.h\"</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"stm/MotorController_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint32_t encoderFilter   = = LL_TIM_IC_FILTER_FDIV32_N8 constexpr uint16_t maxPwm   = = 2000 std::array&lt; Motor, 4 &gt; motor MutexWrapper motorMut TaskWrapper&lt; 1024 &gt; motorTask"},{"location":"stm/MotorController_8cpp/#public-functions","title":"Public Functions","text":"Type Name void motorDispatch (const CoprocReq_MotorReq &amp; request)  void motorInit ()  void motorReset ()"},{"location":"stm/MotorController_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void setMotorPower (uint8_t motorIndex, int32_t power, bool brake)  void setPwmValue (TIM_TypeDef * timer, uint8_t motorIndex, uint16_t value)  void taskFunc ()"},{"location":"stm/MotorController_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/MotorController_8cpp/#variable-encoderfilter","title":"variable encoderFilter","text":"<pre><code>constexpr uint32_t encoderFilter;\n</code></pre>"},{"location":"stm/MotorController_8cpp/#variable-maxpwm","title":"variable maxPwm","text":"<pre><code>constexpr uint16_t maxPwm;\n</code></pre>"},{"location":"stm/MotorController_8cpp/#variable-motor","title":"variable motor","text":"<pre><code>std::array&lt;Motor, 4&gt; motor;\n</code></pre>"},{"location":"stm/MotorController_8cpp/#variable-motormut","title":"variable motorMut","text":"<pre><code>MutexWrapper motorMut;\n</code></pre>"},{"location":"stm/MotorController_8cpp/#variable-motortask","title":"variable motorTask","text":"<pre><code>TaskWrapper&lt;1024&gt; motorTask;\n</code></pre>"},{"location":"stm/MotorController_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/MotorController_8cpp/#function-motordispatch","title":"function motorDispatch","text":"<pre><code>void motorDispatch (\nconst CoprocReq_MotorReq &amp; request\n) </code></pre>"},{"location":"stm/MotorController_8cpp/#function-motorinit","title":"function motorInit","text":"<pre><code>void motorInit () </code></pre>"},{"location":"stm/MotorController_8cpp/#function-motorreset","title":"function motorReset","text":"<pre><code>void motorReset () </code></pre>"},{"location":"stm/MotorController_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"stm/MotorController_8cpp/#function-setmotorpower","title":"function setMotorPower","text":"<pre><code>static void setMotorPower (\nuint8_t motorIndex,\nint32_t power,\nbool brake\n) </code></pre>"},{"location":"stm/MotorController_8cpp/#function-setpwmvalue","title":"function setPwmValue","text":"<pre><code>static void setPwmValue (\nTIM_TypeDef * timer,\nuint8_t motorIndex,\nuint16_t value\n) </code></pre>"},{"location":"stm/MotorController_8cpp/#function-taskfunc","title":"function taskFunc","text":"<pre><code>static void taskFunc () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/MotorController.cpp</code></p>"},{"location":"stm/MotorController_8cpp_source/","title":"File MotorController.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; MotorController.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"MotorController.hpp\"\n#include \"Bsp.hpp\"\n#include \"ControlLink.hpp\"\n#include \"Dispatcher.hpp\"\n#include \"Motor.hpp\"\n#include \"utils/Debug.hpp\"\n#include \"utils/MutexWrapper.hpp\"\n#include \"utils/TaskWrapper.hpp\"\n\n#include \"stm32f1xx_ll_tim.h\"\n#include &lt;cstdlib&gt;\n#include &lt;mutex&gt;\n#include &lt;stdint.h&gt;\n\nstatic void setPwmValue(TIM_TypeDef* timer, uint8_t motorIndex, uint16_t value);\nstatic void setMotorPower(uint8_t motorIndex, int32_t power, bool brake);\n\n// Debounce ENC signals at ~3.5us (72MHz fDTS)\nstatic constexpr uint32_t encoderFilter = LL_TIM_IC_FILTER_FDIV32_N8;\nstatic constexpr uint16_t maxPwm = 2000;\nstatic std::array&lt;Motor, 4&gt; motor;\nstatic MutexWrapper motorMut;\nstatic TaskWrapper&lt;1024&gt; motorTask;\nstatic void taskFunc();\n\nvoid motorInit() {\nLL_TIM_InitTypeDef pwmInit;\nLL_TIM_StructInit(&amp;pwmInit);\n\npwmInit.Prescaler = 0;\n// this sets interrupts flag when counter reachs TOP:\npwmInit.CounterMode = LL_TIM_COUNTERMODE_CENTER_DOWN;\npwmInit.Autoreload = maxPwm;\npwmInit.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;\npwmInit.RepetitionCounter = 0;\n\nLL_TIM_OC_InitTypeDef ocInit;\nLL_TIM_OC_StructInit(&amp;ocInit);\nocInit.OCMode = LL_TIM_OCMODE_PWM2;\nocInit.OCState = LL_TIM_OCSTATE_ENABLE;\n\nocInit.OCNState = LL_TIM_OCSTATE_ENABLE;\nocInit.CompareValue = 0;\nocInit.OCPolarity = LL_TIM_OCPOLARITY_HIGH;\nocInit.OCNPolarity = LL_TIM_OCPOLARITY_HIGH;\nocInit.OCIdleState = LL_TIM_OCIDLESTATE_HIGH;\nocInit.OCNIdleState = LL_TIM_OCIDLESTATE_HIGH;\n\nLL_TIM_Init(pwmTimer, &amp;pwmInit);\nfor (uint16_t channel = LL_TIM_CHANNEL_CH1; channel != 0; channel &lt;&lt;= 4) {\nLL_TIM_OC_Init(pwmTimer, channel, &amp;ocInit);\nLL_TIM_OC_EnablePreload(pwmTimer, channel);\n}\n\nLL_TIM_SetOffStates(pwmTimer, LL_TIM_OSSI_DISABLE, LL_TIM_OSSR_ENABLE);\nLL_TIM_GenerateEvent_UPDATE(pwmTimer);\nLL_TIM_EnableAllOutputs(pwmTimer);\nLL_TIM_EnableCounter(pwmTimer);\n\nfor (int motorIndex : { 0, 1, 2, 3 }) {\nsetMotorPower(motorIndex, 0, false);\n}\n\nLL_TIM_ENCODER_InitTypeDef encInit;\nencInit.EncoderMode = LL_TIM_ENCODERMODE_X4_TI12;\nencInit.IC1Polarity = LL_TIM_IC_POLARITY_RISING;\nencInit.IC1ActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;\nencInit.IC1Prescaler = LL_TIM_ICPSC_DIV1;\nencInit.IC1Filter = encoderFilter;\nencInit.IC2Polarity = LL_TIM_IC_POLARITY_RISING;\nencInit.IC2ActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;\nencInit.IC2Prescaler = LL_TIM_ICPSC_DIV1;\nencInit.IC2Filter = encoderFilter;\nfor (auto timer : encoderTimer) {\nLL_TIM_ENCODER_Init(timer, &amp;encInit);\nLL_TIM_EnableCounter(timer);\n}\n\nmotorMut.create();\nmotorTask.start(\"motors\", motorTaskPrio, taskFunc);\n}\n\nstatic void taskFunc() {\nwhile (true) {\nauto now = xTaskGetTickCount();\n{\nstd::scoped_lock lock(motorMut);\n\nfor (int m : { 0, 1, 2, 3 }) {\nuint16_t encTicks = LL_TIM_GetCounter(encoderTimer[m]);\nauto&amp; targetMotor = motor[m];\nauto modeBefore = targetMotor.mode();\nauto action = targetMotor.poll(encTicks);\nauto modeAfter = targetMotor.mode();\nsetMotorPower(m, action, modeAfter == MotorMode_BRAKE);\n\nif (modeBefore == MotorMode_POSITION\n&amp;&amp; modeAfter == MotorMode_POSITION_IDLE) {\nCoprocStat stat = {\n.which_payload = CoprocStat_motorStat_tag,\n};\ntargetMotor.reportStat(stat.payload.motorStat);\nstat.payload.motorStat.motorIndex = m;\ndispatcherEnqueueStatus(stat);\n}\n}\n}\nvTaskDelayUntil(&amp;now, pdMS_TO_TICKS(1000 / motorLoopFreq));\n}\n}\n\nvoid motorDispatch(const CoprocReq_MotorReq&amp; request) {\nif (request.motorIndex &gt; 3) {\nreturn;\n}\n\nauto&amp; targetMotor = motor[request.motorIndex];\nstd::scoped_lock lock(motorMut);\n\nswitch (request.which_motorCmd) {\ncase CoprocReq_MotorReq_getState_tag: {\nCoprocStat stat = {\n.which_payload = CoprocStat_motorStat_tag,\n};\ntargetMotor.reportStat(stat.payload.motorStat);\nstat.payload.motorStat.motorIndex = request.motorIndex;\ncontrolLinkTx(stat);\n} break;\ncase CoprocReq_MotorReq_setPower_tag:\ntargetMotor.setTargetPower(request.motorCmd.setPower);\nbreak;\ncase CoprocReq_MotorReq_setBrake_tag:\ntargetMotor.setTargetBrakingPower(request.motorCmd.setBrake);\nbreak;\ncase CoprocReq_MotorReq_setVelocity_tag: {\nauto ticksPerSec = request.motorCmd.setVelocity;\nif (ticksPerSec &gt; INT16_MAX || ticksPerSec &lt; INT16_MIN) {\nDEBUG(\"Motor %d target velocity out of range &lt;-32768; 32767&gt; \"\n\"(%d).\\n\",\nint(request.motorIndex), int(ticksPerSec));\nreturn;\n}\ntargetMotor.setTargetVelocity(ticksPerSec);\n} break;\ncase CoprocReq_MotorReq_homePosition_tag:\ntargetMotor.homePosition(request.motorCmd.homePosition);\nbreak;\ncase CoprocReq_MotorReq_setPosition_tag:\ntargetMotor.setTargetPosition(request.motorCmd.setPosition, false);\nbreak;\ncase CoprocReq_MotorReq_addPosition_tag:\ntargetMotor.setTargetPosition(request.motorCmd.addPosition, true);\nbreak;\ncase CoprocReq_MotorReq_setVelocityRegCoefs_tag:\ntargetMotor.setVelocityPid(request.motorCmd.setVelocityRegCoefs);\nbreak;\ncase CoprocReq_MotorReq_setPositionRegCoefs_tag:\ntargetMotor.setPositionPid(request.motorCmd.setPositionRegCoefs);\nbreak;\ncase CoprocReq_MotorReq_setConfig_tag:\ntargetMotor.setConfig(request.motorCmd.setConfig);\nbreak;\n}\n}\n\nvoid motorReset() {\nstd::scoped_lock lock(motorMut);\n\nfor (int idx : { 0, 1, 2, 3 }) {\nmotor[idx].reset();\nsetMotorPower(idx, 0, false);\n}\n}\n\nstatic void setPwmValue(\nTIM_TypeDef* timer, uint8_t motorIndex, uint16_t value) {\nreinterpret_cast&lt;__IO uint16_t*&gt;(&amp;timer-&gt;CCR1)[motorIndex &lt;&lt; 1] = value;\n}\n\nstatic void setMotorPower(uint8_t motorIndex, int32_t power, bool brake) {\nif (power &gt; SHRT_MAX || power &lt; SHRT_MIN) {\nDEBUG(\"Motor %d power out of range &lt;-32768; 32767&gt; (%d).\\n\",\nint(motorIndex), int(power));\nreturn;\n}\n\nuint16_t pwm = uint32_t(abs(power) * maxPwm) / 32768;\nsetPwmValue(pwmTimer, motorIndex, pwm);\nif (pwm == 0 || brake) {\nswitch (motorIndex) {\ncase 3:\nIN4PORT-&gt;BRR = IN4AMASK | IN4BMASK; // set LOW on IN4A and IN4B\npwmTimer-&gt;CCER |= TIM_CCER_CC4P; // invert channel 4\nbreak;\ndefault:\n// set PWM on both channels and invert positive channel\npwmTimer-&gt;CCER\n= (pwmTimer-&gt;CCER &amp; ~(TIM_CCER_CC1NP &lt;&lt; (motorIndex &lt;&lt; 2)))\n| (TIM_CCER_CC1E &lt;&lt; (motorIndex &lt;&lt; 2))\n| (TIM_CCER_CC1NE &lt;&lt; (motorIndex &lt;&lt; 2))\n| (TIM_CCER_CC1P &lt;&lt; (motorIndex &lt;&lt; 2));\nbreak;\n}\n} else {\nswitch (motorIndex) {\ncase 3:\nIN4PORT-&gt;BSRR = power &lt; 0\n? IN4AMASK | (IN4BMASK &lt;&lt; 16) // pinWrite(in4aPin, power &lt; 0);\n: IN4BMASK | (IN4AMASK &lt;&lt; 16); // pinWrite(in4bPin, power &gt; 0);\npwmTimer-&gt;CCER &amp;= ~TIM_CCER_CC4P; // make channel 4 non-inverted\nbreak;\ndefault:\nif (power &gt; 0) {\n// set HIGH on positive channel and inverted PWM on negative channel\npwmTimer-&gt;CCER\n= (pwmTimer-&gt;CCER\n&amp; ~((TIM_CCER_CC1P &lt;&lt; (motorIndex &lt;&lt; 2))\n| (TIM_CCER_CC1NE &lt;&lt; (motorIndex &lt;&lt; 2))))\n| (TIM_CCER_CC1NP &lt;&lt; (motorIndex &lt;&lt; 2))\n| (TIM_CCER_CC1E &lt;&lt; (motorIndex &lt;&lt; 2));\n} else {\n// set HIGH on negative channel and inverted PWM on positive channel\npwmTimer-&gt;CCER\n= (pwmTimer-&gt;CCER\n&amp; ~((TIM_CCER_CC1E &lt;&lt; (motorIndex &lt;&lt; 2))\n| (TIM_CCER_CC1NP &lt;&lt; (motorIndex &lt;&lt; 2))))\n| (TIM_CCER_CC1NE &lt;&lt; (motorIndex &lt;&lt; 2))\n| (TIM_CCER_CC1P &lt;&lt; (motorIndex &lt;&lt; 2));\n}\nbreak;\n}\n}\n}\n</code></pre>"},{"location":"stm/MpuController_8cpp/","title":"File MpuController.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; MpuController.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"MpuController.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"utils/TickTimer.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"utils/QueueWrapper.hpp\"</code></li> <li><code>#include \"utils/TaskWrapper.hpp\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"timers.h\"</code></li> <li><code>#include \"event_groups.h\"</code></li> </ul>"},{"location":"stm/MpuController_8cpp/#classes","title":"Classes","text":"Type Name struct MpuMotion32 struct MpuMotion6 struct MpuVector struct MpuVector32"},{"location":"stm/MpuController_8cpp/#public-types","title":"Public Types","text":"Type Name typedef struct MpuMotion32 MpuMotion32 typedef struct MpuMotion6 MpuMotion6 typedef struct MpuVector MpuVector typedef struct MpuVector32 MpuVector32"},{"location":"stm/MpuController_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name uint16_t compressCoef   = = 4 mpu_t mpu6050 uint32_t mpuAggrCounter   = = 0 MpuMotion32 mpuAggrData constexpr uint32_t mpuTickPeriodMs   = = 10 StaticTimer_t mpuTimerBuffer TimerHandle_t mpuTimerHandle"},{"location":"stm/MpuController_8cpp/#public-functions","title":"Public Functions","text":"Type Name void mpuCreate ()  void mpuDispatch (const CoprocReq_MpuReq &amp; req)  void mpuInitialize ()  void mpuReset ()  void mpuTick ()  bool mpu_getAccelFIFOEnabled ()  bool mpu_getAccelXSelfTest ()  bool mpu_getAccelYSelfTest ()  bool mpu_getAccelZSelfTest ()  void mpu_getAcceleration (int16_t * x, int16_t * y, int16_t * z)  int16_t mpu_getAccelerationX ()  int16_t mpu_getAccelerationY ()  int16_t mpu_getAccelerationZ ()  uint8_t mpu_getAccelerometerPowerOnDelay ()  uint8_t mpu_getAuxVDDIOLevel ()  bool mpu_getClockOutputEnabled ()  uint8_t mpu_getClockSource ()  uint8_t mpu_getDHPFMode ()  uint8_t mpu_getDLPFMode ()  uint8_t mpu_getExternalFrameSync ()  uint8_t mpu_getExternalSensorByte (int position)  uint32_t mpu_getExternalSensorDWord (int position)  uint16_t mpu_getExternalSensorWord (int position)  bool mpu_getExternalShadowDelayEnabled ()  bool mpu_getFIFOEnabled ()  bool mpu_getFSyncInterruptEnabled ()  bool mpu_getFSyncInterruptLevel ()  uint8_t mpu_getFreefallDetectionCounterDecrement ()  uint8_t mpu_getFreefallDetectionDuration ()  uint8_t mpu_getFreefallDetectionThreshold ()  uint8_t mpu_getFullScaleAccelRange ()  uint8_t mpu_getFullScaleGyroRange ()  bool mpu_getI2CBypassEnabled ()  bool mpu_getI2CMasterModeEnabled ()  bool mpu_getIntDataReadyEnabled ()  bool mpu_getIntDataReadyStatus ()  uint8_t mpu_getIntEnabled ()  bool mpu_getIntFIFOBufferOverflowEnabled ()  bool mpu_getIntFIFOBufferOverflowStatus ()  bool mpu_getIntFreefallEnabled ()  bool mpu_getIntFreefallStatus ()  bool mpu_getIntI2CMasterEnabled ()  bool mpu_getIntI2CMasterStatus ()  bool mpu_getIntMotionEnabled ()  bool mpu_getIntMotionStatus ()  uint8_t mpu_getIntStatus ()  bool mpu_getIntZeroMotionEnabled ()  bool mpu_getIntZeroMotionStatus ()  bool mpu_getInterruptDrive ()  bool mpu_getInterruptLatch ()  bool mpu_getInterruptLatchClear ()  bool mpu_getInterruptMode ()  bool mpu_getLostArbitration ()  uint8_t mpu_getMasterClockSpeed ()  void mpu_getMotion6 (int16_t * ax, int16_t * ay, int16_t * az, int16_t * gx, int16_t * gy, int16_t * gz)  void mpu_getMotion9 (int16_t * ax, int16_t * ay, int16_t * az, int16_t * gx, int16_t * gy, int16_t * gz, int16_t * mx, int16_t * my, int16_t * mz)  uint8_t mpu_getMotionDetectionCounterDecrement ()  uint8_t mpu_getMotionDetectionDuration ()  uint8_t mpu_getMotionDetectionThreshold ()  bool mpu_getMultiMasterEnabled ()  bool mpu_getPassthroughStatus ()  uint8_t mpu_getRate ()  void mpu_getRotation (int16_t * x, int16_t * y, int16_t * z)  int16_t mpu_getRotationX ()  int16_t mpu_getRotationY ()  int16_t mpu_getRotationZ ()  uint8_t mpu_getSlate4InputByte ()  bool mpu_getSlave0FIFOEnabled ()  bool mpu_getSlave0Nack ()  bool mpu_getSlave1FIFOEnabled ()  bool mpu_getSlave1Nack ()  bool mpu_getSlave2FIFOEnabled ()  bool mpu_getSlave2Nack ()  bool mpu_getSlave3FIFOEnabled ()  bool mpu_getSlave3Nack ()  uint8_t mpu_getSlave4Address ()  bool mpu_getSlave4Enabled ()  bool mpu_getSlave4InterruptEnabled ()  bool mpu_getSlave4IsDone ()  uint8_t mpu_getSlave4MasterDelay ()  bool mpu_getSlave4Nack ()  uint8_t mpu_getSlave4Register ()  bool mpu_getSlave4WriteMode ()  uint8_t mpu_getSlaveAddress (uint8_t num)  uint8_t mpu_getSlaveDataLength (uint8_t num)  bool mpu_getSlaveDelayEnabled (uint8_t num)  bool mpu_getSlaveEnabled (uint8_t num)  bool mpu_getSlaveReadWriteTransitionEnabled ()  uint8_t mpu_getSlaveRegister (uint8_t num)  bool mpu_getSlaveWordByteSwap (uint8_t num)  bool mpu_getSlaveWordGroupOffset (uint8_t num)  bool mpu_getSlaveWriteMode (uint8_t num)  bool mpu_getSleepEnabled ()  bool mpu_getTempFIFOEnabled ()  bool mpu_getTempSensorEnabled ()  int16_t mpu_getTemperature ()  bool mpu_getWaitForExternalSensorEnabled ()  bool mpu_getWakeCycleEnabled ()  bool mpu_getXGyroFIFOEnabled ()  bool mpu_getXNegMotionDetected ()  bool mpu_getXPosMotionDetected ()  bool mpu_getYGyroFIFOEnabled ()  bool mpu_getYNegMotionDetected ()  bool mpu_getYPosMotionDetected ()  bool mpu_getZGyroFIFOEnabled ()  bool mpu_getZNegMotionDetected ()  bool mpu_getZPosMotionDetected ()  bool mpu_getZeroMotionDetected ()  uint8_t mpu_getZeroMotionDetectionDuration ()  uint8_t mpu_getZeroMotionDetectionThreshold ()  void mpu_reset ()  void mpu_resetAccelerometerPath ()  void mpu_resetFIFO ()  void mpu_resetGyroscopePath ()  void mpu_resetI2CMaster ()  void mpu_resetSensors ()  void mpu_resetTemperaturePath ()  void mpu_setAccelFIFOEnabled (bool enabled)  void mpu_setAccelXSelfTest (bool enabled)  void mpu_setAccelYSelfTest (bool enabled)  void mpu_setAccelZSelfTest (bool enabled)  void mpu_setAccelerometerPowerOnDelay (uint8_t delay)  void mpu_setAuxVDDIOLevel (uint8_t level)  void mpu_setClockOutputEnabled (bool enabled)  void mpu_setClockSource (uint8_t source)  void mpu_setDHPFMode (uint8_t bandwidth)  void mpu_setDLPFMode (uint8_t mode)  void mpu_setExternalFrameSync (uint8_t sync)  void mpu_setExternalShadowDelayEnabled (bool enabled)  void mpu_setFIFOEnabled (bool enabled)  void mpu_setFSyncInterruptEnabled (bool enabled)  void mpu_setFSyncInterruptLevel (bool level)  void mpu_setFreefallDetectionCounterDecrement (uint8_t decrement)  void mpu_setFreefallDetectionDuration (uint8_t duration)  void mpu_setFreefallDetectionThreshold (uint8_t threshold)  void mpu_setFullScaleAccelRange (uint8_t range)  void mpu_setFullScaleGyroRange (uint8_t range)  void mpu_setI2CBypassEnabled (bool enabled)  void mpu_setI2CMasterModeEnabled (bool enabled)  void mpu_setIntDataReadyEnabled (bool enabled)  void mpu_setIntEnabled (uint8_t enabled)  void mpu_setIntFIFOBufferOverflowEnabled (bool enabled)  void mpu_setIntFreefallEnabled (bool enabled)  void mpu_setIntI2CMasterEnabled (bool enabled)  void mpu_setIntMotionEnabled (bool enabled)  void mpu_setIntZeroMotionEnabled (bool enabled)  void mpu_setInterruptDrive (bool drive)  void mpu_setInterruptLatch (bool latch)  void mpu_setInterruptLatchClear (bool clear)  void mpu_setInterruptMode (bool mode)  void mpu_setMasterClockSpeed (uint8_t speed)  void mpu_setMotionDetectionCounterDecrement (uint8_t decrement)  void mpu_setMotionDetectionDuration (uint8_t duration)  void mpu_setMotionDetectionThreshold (uint8_t threshold)  void mpu_setMultiMasterEnabled (bool enabled)  void mpu_setRate (uint8_t rate)  void mpu_setSlave0FIFOEnabled (bool enabled)  void mpu_setSlave1FIFOEnabled (bool enabled)  void mpu_setSlave2FIFOEnabled (bool enabled)  void mpu_setSlave3FIFOEnabled (bool enabled)  void mpu_setSlave4Address (uint8_t address)  void mpu_setSlave4Enabled (bool enabled)  void mpu_setSlave4InterruptEnabled (bool enabled)  void mpu_setSlave4MasterDelay (uint8_t delay)  void mpu_setSlave4OutputByte (uint8_t data)  void mpu_setSlave4Register (uint8_t reg)  void mpu_setSlave4WriteMode (bool mode)  void mpu_setSlaveAddress (uint8_t num, uint8_t address)  void mpu_setSlaveDataLength (uint8_t num, uint8_t length)  void mpu_setSlaveDelayEnabled (uint8_t num, bool enabled)  void mpu_setSlaveEnabled (uint8_t num, bool enabled)  void mpu_setSlaveOutputByte (uint8_t num, uint8_t data)  void mpu_setSlaveReadWriteTransitionEnabled (bool enabled)  void mpu_setSlaveRegister (uint8_t num, uint8_t reg)  void mpu_setSlaveWordByteSwap (uint8_t num, bool enabled)  void mpu_setSlaveWordGroupOffset (uint8_t num, bool enabled)  void mpu_setSlaveWriteMode (uint8_t num, bool mode)  void mpu_setSleepEnabled (bool enabled)  void mpu_setTempFIFOEnabled (bool enabled)  void mpu_setTempSensorEnabled (bool enabled)  void mpu_setWaitForExternalSensorEnabled (bool enabled)  void mpu_setWakeCycleEnabled (bool enabled)  void mpu_setXGyroFIFOEnabled (bool enabled)  void mpu_setYGyroFIFOEnabled (bool enabled)  void mpu_setZGyroFIFOEnabled (bool enabled)  void mpu_setZeroMotionDetectionDuration (uint8_t duration)  void mpu_setZeroMotionDetectionThreshold (uint8_t threshold)  void mpu_switchSPIEnabled (bool enabled)  bool mpu_testConnection ()"},{"location":"stm/MpuController_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void mpuRead (MpuMotion6 &amp; data)  void mpuSend (const MpuMotion32 &amp; data)  void mpuTickCallback (TimerHandle_t tim)"},{"location":"stm/MpuController_8cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"stm/MpuController_8cpp/#typedef-mpumotion32","title":"typedef MpuMotion32","text":"<pre><code>typedef struct MpuMotion32 MpuMotion32;\n</code></pre>"},{"location":"stm/MpuController_8cpp/#typedef-mpumotion6","title":"typedef MpuMotion6","text":"<pre><code>typedef struct MpuMotion6 MpuMotion6;\n</code></pre>"},{"location":"stm/MpuController_8cpp/#typedef-mpuvector","title":"typedef MpuVector","text":"<pre><code>typedef struct MpuVector MpuVector;\n</code></pre>"},{"location":"stm/MpuController_8cpp/#typedef-mpuvector32","title":"typedef MpuVector32","text":"<pre><code>typedef struct MpuVector32 MpuVector32;\n</code></pre>"},{"location":"stm/MpuController_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/MpuController_8cpp/#variable-compresscoef","title":"variable compressCoef","text":"<pre><code>uint16_t compressCoef;\n</code></pre>"},{"location":"stm/MpuController_8cpp/#variable-mpu6050","title":"variable mpu6050","text":"<pre><code>mpu_t mpu6050;\n</code></pre>"},{"location":"stm/MpuController_8cpp/#variable-mpuaggrcounter","title":"variable mpuAggrCounter","text":"<pre><code>uint32_t mpuAggrCounter;\n</code></pre>"},{"location":"stm/MpuController_8cpp/#variable-mpuaggrdata","title":"variable mpuAggrData","text":"<pre><code>MpuMotion32 mpuAggrData;\n</code></pre>"},{"location":"stm/MpuController_8cpp/#variable-mputickperiodms","title":"variable mpuTickPeriodMs","text":"<pre><code>constexpr uint32_t mpuTickPeriodMs;\n</code></pre>"},{"location":"stm/MpuController_8cpp/#variable-mputimerbuffer","title":"variable mpuTimerBuffer","text":"<pre><code>StaticTimer_t mpuTimerBuffer;\n</code></pre>"},{"location":"stm/MpuController_8cpp/#variable-mputimerhandle","title":"variable mpuTimerHandle","text":"<pre><code>TimerHandle_t mpuTimerHandle;\n</code></pre>"},{"location":"stm/MpuController_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/MpuController_8cpp/#function-mpucreate","title":"function mpuCreate","text":"<pre><code>void mpuCreate () </code></pre>"},{"location":"stm/MpuController_8cpp/#function-mpudispatch","title":"function mpuDispatch","text":"<pre><code>void mpuDispatch (\nconst CoprocReq_MpuReq &amp; req\n) </code></pre>"},{"location":"stm/MpuController_8cpp/#function-mpuinitialize","title":"function mpuInitialize","text":"<pre><code>void mpuInitialize () </code></pre> <p>Power on and prepare for general usage. This will activate the device and take it out of sleep mode (which must be done after start-up). This function also sets both the accelerometer and the gyroscope to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets the clock source to use the X Gyro for reference, which is slightly better than the default internal clock source. </p>"},{"location":"stm/MpuController_8cpp/#function-mpureset","title":"function mpuReset","text":"<pre><code>void mpuReset () </code></pre>"},{"location":"stm/MpuController_8cpp/#function-mputick","title":"function mpuTick","text":"<pre><code>void mpuTick () </code></pre>"},{"location":"stm/MpuController_8cpp/#function-mpu_getaccelfifoenabled","title":"function mpu_getAccelFIFOEnabled","text":"<pre><code>bool mpu_getAccelFIFOEnabled () </code></pre> <p>Get accelerometer FIFO enabled value. When set to 1, this bit enables ACCEL_XOUT_H, ACCEL_XOUT_L, ACCEL_YOUT_H, ACCEL_YOUT_L, ACCEL_ZOUT_H, and ACCEL_ZOUT_L (Registers 59 to 64) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current accelerometer FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getaccelxselftest","title":"function mpu_getAccelXSelfTest","text":"<pre><code>bool mpu_getAccelXSelfTest () </code></pre> <p>Get self-test enabled setting for accelerometer X axis. </p> <p>Returns:</p> <p>Self-test enabled value </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getaccelyselftest","title":"function mpu_getAccelYSelfTest","text":"<pre><code>bool mpu_getAccelYSelfTest () </code></pre> <p>Get self-test enabled value for accelerometer Y axis. </p> <p>Returns:</p> <p>Self-test enabled value </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getaccelzselftest","title":"function mpu_getAccelZSelfTest","text":"<pre><code>bool mpu_getAccelZSelfTest () </code></pre> <p>Get self-test enabled value for accelerometer Z axis. </p> <p>Returns:</p> <p>Self-test enabled value </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getacceleration","title":"function mpu_getAcceleration","text":"<pre><code>void mpu_getAcceleration (\nint16_t * x,\nint16_t * y,\nint16_t * z\n) </code></pre> <p>Get 3-axis accelerometer readings. These registers store the most recent accelerometer measurements. Accelerometer measurements are written to these registers at the Sample Rate as defined in Register 25.</p> <p>The accelerometer measurement registers, along with the temperature measurement registers, gyroscope measurement registers, and external sensor data registers, are composed of two sets of registers: an internal register set and a user-facing read register set.</p> <p>The data within the accelerometer sensors' internal register set is always updated at the Sample Rate. Meanwhile, the user-facing read register set duplicates the internal register set's data values whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.</p> <p>Each 16-bit accelerometer measurement has a full scale defined in ACCEL_FS (Register 28). For each full scale setting, the accelerometers' sensitivity per LSB in ACCEL_xOUT is shown in the table below:</p> <p>Parameters:</p> <ul> <li><code>x</code> 16-bit signed integer container for X-axis acceleration </li> <li><code>y</code> 16-bit signed integer container for Y-axis acceleration </li> <li><code>z</code> 16-bit signed integer container for Z-axis acceleration </li> </ul> <p>See also: mpu_RA_GYRO_XOUT_H </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getaccelerationx","title":"function mpu_getAccelerationX","text":"<pre><code>int16_t mpu_getAccelerationX () </code></pre> <p>Get X-axis accelerometer reading. </p> <p>Returns:</p> <p>X-axis acceleration measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_ACCEL_XOUT_H </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getaccelerationy","title":"function mpu_getAccelerationY","text":"<pre><code>int16_t mpu_getAccelerationY () </code></pre> <p>Get Y-axis accelerometer reading. </p> <p>Returns:</p> <p>Y-axis acceleration measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_ACCEL_YOUT_H </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getaccelerationz","title":"function mpu_getAccelerationZ","text":"<pre><code>int16_t mpu_getAccelerationZ () </code></pre> <p>Get Z-axis accelerometer reading. </p> <p>Returns:</p> <p>Z-axis acceleration measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_ACCEL_ZOUT_H </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getaccelerometerpowerondelay","title":"function mpu_getAccelerometerPowerOnDelay","text":"<pre><code>uint8_t mpu_getAccelerometerPowerOnDelay () </code></pre> <p>Get accelerometer power-on delay. The accelerometer data path provides samples to the sensor registers, Motion detection, Zero Motion detection, and Free Fall detection modules. The signal path contains filters which must be flushed on wake-up with new samples before the detection modules begin operations. The default wake-up delay, of 4ms can be lengthened by up to 3ms. This additional delay is specified in ACCEL_ON_DELAY in units of 1 LSB = 1 ms. The user may select any value above zero unless instructed otherwise by InvenSense. Please refer to Section 8 of the MPU-6000/MPU-6050 Product Specification document for further information regarding the detection modules. </p> <p>Returns:</p> <p>Current accelerometer power-on delay </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_ACCEL_ON_DELAY_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getauxvddiolevel","title":"function mpu_getAuxVDDIOLevel","text":"<pre><code>uint8_t mpu_getAuxVDDIOLevel () </code></pre> <p>Get the auxiliary I2C supply voltage level. When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to the MPU-6000, which does not have a VLOGIC pin. </p> <p>Returns:</p> <p>I2C supply voltage level (0=VLOGIC, 1=VDD) </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getclockoutputenabled","title":"function mpu_getClockOutputEnabled","text":"<pre><code>bool mpu_getClockOutputEnabled () </code></pre> <p>Get reference clock output enabled status. When this bit is equal to 1, a reference clock output is provided at the CLKOUT pin. When this bit is equal to 0, the clock output is disabled. For further information regarding CLKOUT, please refer to the MPU-60X0 Product Specification document. </p> <p>Returns:</p> <p>Current reference clock output enabled status </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_CLKOUT_EN_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getclocksource","title":"function mpu_getClockSource","text":"<pre><code>uint8_t mpu_getClockSource () </code></pre> <p>Get clock source setting. </p> <p>Returns:</p> <p>Current clock source setting </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_CLKSEL_BIT </p> <p>See also: mpu_PWR1_CLKSEL_LENGTH </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getdhpfmode","title":"function mpu_getDHPFMode","text":"<pre><code>uint8_t mpu_getDHPFMode () </code></pre> <p>Get the high-pass filter configuration. The DHPF is a filter module in the path leading to motion detectors (Free Fall, Motion threshold, and Zero Motion). The high pass filter output is not available to the data registers (see Figure in Section 8 of the MPU-6000/ MPU-6050 Product Specification document).</p> <p>The high pass filter has three modes:</p> <p>Returns:</p> <p>Current high-pass filter configuration </p> <p>See also: mpu_DHPF_RESET </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getdlpfmode","title":"function mpu_getDLPFMode","text":"<pre><code>uint8_t mpu_getDLPFMode () </code></pre> <p>Get digital low-pass filter configuration. The DLPF_CFG parameter sets the digital low pass filter configuration. It also determines the internal sampling rate used by the device as shown in the table below.</p> <p>Note: The accelerometer output rate is 1kHz. This means that for a Sample Rate greater than 1kHz, the same accelerometer sample may be output to the FIFO, DMP, and sensor registers more than once.</p> <p>Returns:</p> <p>DLFP configuration </p> <p>See also: mpu_RA_CONFIG </p> <p>See also: mpu_CFG_DLPF_CFG_BIT </p> <p>See also: mpu_CFG_DLPF_CFG_LENGTH </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getexternalframesync","title":"function mpu_getExternalFrameSync","text":"<pre><code>uint8_t mpu_getExternalFrameSync () </code></pre> <p>Get external FSYNC configuration. Configures the external Frame Synchronization (FSYNC) pin sampling. An external signal connected to the FSYNC pin can be sampled by configuring EXT_SYNC_SET. Signal changes to the FSYNC pin are latched so that short strobes may be captured. The latched FSYNC signal will be sampled at the Sampling Rate, as defined in register 25. After sampling, the latch will reset to the current FSYNC signal state.</p> <p>The sampled value will be reported in place of the least significant bit in a sensor data register determined by the value of EXT_SYNC_SET according to the following table.</p> <p>Returns:</p> <p>FSYNC configuration value </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getexternalsensorbyte","title":"function mpu_getExternalSensorByte","text":"<pre><code>uint8_t mpu_getExternalSensorByte (\nint position\n) </code></pre> <p>Read single byte from external sensor data register. These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53).</p> <p>External sensor data is written to these registers at the Sample Rate as defined in Register 25. This access rate can be reduced by using the Slave Delay Enable registers (Register 103).</p> <p>External sensor data registers, along with the gyroscope measurement registers, accelerometer measurement registers, and temperature measurement registers, are composed of two sets of registers: an internal register set and a user-facing read register set.</p> <p>The data within the external sensors' internal register set is always updated at the Sample Rate (or the reduced access rate) whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.</p> <p>Data is placed in these external sensor data registers according to I2C_SLV0_CTRL, I2C_SLV1_CTRL, I2C_SLV2_CTRL, and I2C_SLV3_CTRL (Registers 39, 42, 45, and 48). When more than zero bytes are read (I2C_SLVx_LEN &gt; 0) from an enabled slave (I2C_SLVx_EN = 1), the slave is read at the Sample Rate (as defined in Register 25) or delayed rate (if specified in Register 52 and 103). During each Sample cycle, slave reads are performed in order of Slave number. If all slaves are enabled with more than zero bytes to be read, the order will be Slave 0, followed by Slave 1, Slave 2, and Slave 3.</p> <p>Each enabled slave will have EXT_SENS_DATA registers associated with it by number of bytes read (I2C_SLVx_LEN) in order of slave number, starting from EXT_SENS_DATA_00. Note that this means enabling or disabling a slave may change the higher numbered slaves' associated registers. Furthermore, if fewer total bytes are being read from the external sensors as a result of such a change, then the data remaining in the registers which no longer have an associated slave device (i.e. high numbered registers) will remain in these previously allocated registers unless reset.</p> <p>If the sum of the read lengths of all SLVx transactions exceed the number of available EXT_SENS_DATA registers, the excess bytes will be dropped. There are 24 EXT_SENS_DATA registers and hence the total read lengths between all the slaves cannot be greater than 24 or some bytes will be lost.</p> <p>Note: Slave 4's behavior is distinct from that of Slaves 0-3. For further information regarding the characteristics of Slave 4, please refer to Registers 49 to 53.</p> <p>EXAMPLE: Suppose that Slave 0 is enabled with 4 bytes to be read (I2C_SLV0_EN = 1 and I2C_SLV0_LEN = 4) while Slave 1 is enabled with 2 bytes to be read so that I2C_SLV1_EN = 1 and I2C_SLV1_LEN = 2. In such a situation, EXT_SENS_DATA _00 through _03 will be associated with Slave 0, while EXT_SENS_DATA _04 and 05 will be associated with Slave 1. If Slave 2 is enabled as well, registers starting from EXT_SENS_DATA_06 will be allocated to Slave 2.</p> <p>If Slave 2 is disabled while Slave 3 is enabled in this same situation, then registers starting from EXT_SENS_DATA_06 will be allocated to Slave 3 instead.</p> <p>REGISTER ALLOCATION FOR DYNAMIC DISABLE VS. NORMAL DISABLE: If a slave is disabled at any time, the space initially allocated to the slave in the EXT_SENS_DATA register, will remain associated with that slave. This is to avoid dynamic adjustment of the register allocation.</p> <p>The allocation of the EXT_SENS_DATA registers is recomputed only when (1) all slaves are disabled, or (2) the I2C_MST_RST bit is set (Register 106).</p> <p>This above is also true if one of the slaves gets NACKed and stops functioning.</p> <p>Parameters:</p> <ul> <li><code>position</code> Starting position (0-23) </li> </ul> <p>Returns:</p> <p>Byte read from register </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getexternalsensordword","title":"function mpu_getExternalSensorDWord","text":"<pre><code>uint32_t mpu_getExternalSensorDWord (\nint position\n) </code></pre> <p>Read double word (4 bytes) from external sensor data registers. </p> <p>Parameters:</p> <ul> <li><code>position</code> Starting position (0-20) </li> </ul> <p>Returns:</p> <p>Double word read from registers </p> <p>See also: getExternalSensorByte() </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getexternalsensorword","title":"function mpu_getExternalSensorWord","text":"<pre><code>uint16_t mpu_getExternalSensorWord (\nint position\n) </code></pre> <p>Read word (2 bytes) from external sensor data registers. </p> <p>Parameters:</p> <ul> <li><code>position</code> Starting position (0-21) </li> </ul> <p>Returns:</p> <p>Word read from register </p> <p>See also: getExternalSensorByte() </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getexternalshadowdelayenabled","title":"function mpu_getExternalShadowDelayEnabled","text":"<pre><code>bool mpu_getExternalShadowDelayEnabled () </code></pre> <p>Get external data shadow delay enabled status. This register is used to specify the timing of external sensor data shadowing. When DELAY_ES_SHADOW is set to 1, shadowing of external sensor data is delayed until all data has been received. </p> <p>Returns:</p> <p>Current external data shadow delay enabled status. </p> <p>See also: mpu_RA_I2C_MST_DELAY_CTRL </p> <p>See also: mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getfifoenabled","title":"function mpu_getFIFOEnabled","text":"<pre><code>bool mpu_getFIFOEnabled () </code></pre> <p>Get FIFO enabled status. When this bit is set to 0, the FIFO mpu6050.buffer is disabled. The FIFO mpu6050.buffer cannot be written to or read from while disabled. The FIFO mpu6050.buffer's state does not change unless the MPU-60X0 is power cycled. </p> <p>Returns:</p> <p>Current FIFO enabled status </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_FIFO_EN_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getfsyncinterruptenabled","title":"function mpu_getFSyncInterruptEnabled","text":"<pre><code>bool mpu_getFSyncInterruptEnabled () </code></pre> <p>Get FSYNC pin interrupt enabled setting. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled setting </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_FSYNC_INT_EN_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getfsyncinterruptlevel","title":"function mpu_getFSyncInterruptLevel","text":"<pre><code>bool mpu_getFSyncInterruptLevel () </code></pre> <p>Get FSYNC interrupt logic level mode. </p> <p>Returns:</p> <p>Current FSYNC interrupt mode (0=active-high, 1=active-low) </p> <p>See also: getFSyncInterruptMode() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_FSYNC_INT_LEVEL_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getfreefalldetectioncounterdecrement","title":"function mpu_getFreefallDetectionCounterDecrement","text":"<pre><code>uint8_t mpu_getFreefallDetectionCounterDecrement () </code></pre> <p>Get Free Fall detection counter decrement configuration. Detection is registered by the Free Fall detection module after accelerometer measurements meet their respective threshold conditions over a specified number of samples. When the threshold conditions are met, the corresponding detection counter increments by 1. The user may control the rate at which the detection counter decrements when the threshold condition is not met by configuring FF_COUNT. The decrement rate can be set according to the following table:</p> <p>When FF_COUNT is configured to 0 (reset), any non-qualifying sample will reset the counter to 0. For further information on Free Fall detection, please refer to Registers 29 to 32.</p> <p>Returns:</p> <p>Current decrement configuration </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_FF_COUNT_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getfreefalldetectionduration","title":"function mpu_getFreefallDetectionDuration","text":"<pre><code>uint8_t mpu_getFreefallDetectionDuration () </code></pre> <p>Get free-fall event duration threshold. This register configures the duration counter threshold for Free Fall event detection. The duration counter ticks at 1kHz, therefore FF_DUR has a unit of 1 LSB = 1 ms.</p> <p>The Free Fall duration counter increments while the absolute value of the accelerometer measurements are each less than the detection threshold (Register 29). The Free Fall interrupt is triggered when the Free Fall duration counter reaches the time specified in this register.</p> <p>For more details on the Free Fall detection interrupt, see Section 8.2 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current free-fall duration threshold value (LSB = 1ms) </p> <p>See also: mpu_RA_FF_DUR </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getfreefalldetectionthreshold","title":"function mpu_getFreefallDetectionThreshold","text":"<pre><code>uint8_t mpu_getFreefallDetectionThreshold () </code></pre> <p>Get free-fall event acceleration threshold. This register configures the detection threshold for Free Fall event detection. The unit of FF_THR is 1LSB = 2mg. Free Fall is detected when the absolute value of the accelerometer measurements for the three axes are each less than the detection threshold. This condition increments the Free Fall duration counter (Register 30). The Free Fall interrupt is triggered when the Free Fall duration counter reaches the time specified in FF_DUR.</p> <p>For more details on the Free Fall detection interrupt, see Section 8.2 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current free-fall acceleration threshold value (LSB = 2mg) </p> <p>See also: mpu_RA_FF_THR </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getfullscaleaccelrange","title":"function mpu_getFullScaleAccelRange","text":"<pre><code>uint8_t mpu_getFullScaleAccelRange () </code></pre> <p>Get full-scale accelerometer range. The FS_SEL parameter allows setting the full-scale range of the accelerometer sensors, as described in the table below.</p> <p>Returns:</p> <p>Current full-scale accelerometer range setting </p> <p>See also: mpu_ACCEL_FS_2 </p> <p>See also: mpu_RA_ACCEL_CONFIG </p> <p>See also: mpu_ACONFIG_AFS_SEL_BIT </p> <p>See also: mpu_ACONFIG_AFS_SEL_LENGTH </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getfullscalegyrorange","title":"function mpu_getFullScaleGyroRange","text":"<pre><code>uint8_t mpu_getFullScaleGyroRange () </code></pre> <p>Get full-scale gyroscope range. The FS_SEL parameter allows setting the full-scale range of the gyro sensors, as described in the table below.</p> <p>Returns:</p> <p>Current full-scale gyroscope range setting </p> <p>See also: mpu_GYRO_FS_250 </p> <p>See also: mpu_RA_GYRO_CONFIG </p> <p>See also: mpu_GCONFIG_FS_SEL_BIT </p> <p>See also: mpu_GCONFIG_FS_SEL_LENGTH </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_geti2cbypassenabled","title":"function mpu_getI2CBypassEnabled","text":"<pre><code>bool mpu_getI2CBypassEnabled () </code></pre> <p>Get I2C bypass enabled status. When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to 0, the host application processor will be able to directly access the auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host application processor will not be able to directly access the auxiliary I2C bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106 bit[5]). </p> <p>Returns:</p> <p>Current I2C bypass enabled status </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_I2C_BYPASS_EN_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_geti2cmastermodeenabled","title":"function mpu_getI2CMasterModeEnabled","text":"<pre><code>bool mpu_getI2CMasterModeEnabled () </code></pre> <p>Get I2C Master Mode enabled status. When this mode is enabled, the MPU-60X0 acts as the I2C Master to the external sensor slave devices on the auxiliary I2C bus. When this bit is cleared to 0, the auxiliary I2C bus lines (AUX_DA and AUX_CL) are logically driven by the primary I2C bus (SDA and SCL). This is a precondition to enabling Bypass Mode. For further information regarding Bypass Mode, please refer to Register 55. </p> <p>Returns:</p> <p>Current I2C Master Mode enabled status </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_I2C_MST_EN_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getintdatareadyenabled","title":"function mpu_getIntDataReadyEnabled","text":"<pre><code>bool mpu_getIntDataReadyEnabled () </code></pre> <p>Get Data Ready interrupt enabled setting. This event occurs each time a write operation to all of the sensor registers has been completed. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_DATA_RDY_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getintdatareadystatus","title":"function mpu_getIntDataReadyStatus","text":"<pre><code>bool mpu_getIntDataReadyStatus () </code></pre> <p>Get Data Ready interrupt status. This bit automatically sets to 1 when a Data Ready interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_DATA_RDY_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getintenabled","title":"function mpu_getIntEnabled","text":"<pre><code>uint8_t mpu_getIntEnabled () </code></pre> <p>Get full interrupt enabled status. Full register byte for all interrupts, for quick reading. Each bit will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getintfifobufferoverflowenabled","title":"function mpu_getIntFIFOBufferOverflowEnabled","text":"<pre><code>bool mpu_getIntFIFOBufferOverflowEnabled () </code></pre> <p>Get FIFO Buffer Overflow interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FIFO_OFLOW_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getintfifobufferoverflowstatus","title":"function mpu_getIntFIFOBufferOverflowStatus","text":"<pre><code>bool mpu_getIntFIFOBufferOverflowStatus () </code></pre> <p>Get FIFO Buffer Overflow interrupt status. This bit automatically sets to 1 when a Free Fall interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_FIFO_OFLOW_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getintfreefallenabled","title":"function mpu_getIntFreefallEnabled","text":"<pre><code>bool mpu_getIntFreefallEnabled () </code></pre> <p>Get Free Fall interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getintfreefallstatus","title":"function mpu_getIntFreefallStatus","text":"<pre><code>bool mpu_getIntFreefallStatus () </code></pre> <p>Get Free Fall interrupt status. This bit automatically sets to 1 when a Free Fall interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getinti2cmasterenabled","title":"function mpu_getIntI2CMasterEnabled","text":"<pre><code>bool mpu_getIntI2CMasterEnabled () </code></pre> <p>Get I2C Master interrupt enabled status. This enables any of the I2C Master interrupt sources to generate an interrupt. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_I2C_MST_INT_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getinti2cmasterstatus","title":"function mpu_getIntI2CMasterStatus","text":"<pre><code>bool mpu_getIntI2CMasterStatus () </code></pre> <p>Get I2C Master interrupt status. This bit automatically sets to 1 when an I2C Master interrupt has been generated. For a list of I2C Master interrupts, please refer to Register 54. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_I2C_MST_INT_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getintmotionenabled","title":"function mpu_getIntMotionEnabled","text":"<pre><code>bool mpu_getIntMotionEnabled () </code></pre> <p>Get Motion Detection interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_MOT_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getintmotionstatus","title":"function mpu_getIntMotionStatus","text":"<pre><code>bool mpu_getIntMotionStatus () </code></pre> <p>Get Motion Detection interrupt status. This bit automatically sets to 1 when a Motion Detection interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_MOT_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getintstatus","title":"function mpu_getIntStatus","text":"<pre><code>uint8_t mpu_getIntStatus () </code></pre> <p>Get full set of interrupt status bits. These bits clear to 0 after the register has been read. Very useful for getting multiple INT statuses, since each single bit read clears all of them because it has to read the whole byte. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getintzeromotionenabled","title":"function mpu_getIntZeroMotionEnabled","text":"<pre><code>bool mpu_getIntZeroMotionEnabled () </code></pre> <p>Get Zero Motion Detection interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_ZMOT_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getintzeromotionstatus","title":"function mpu_getIntZeroMotionStatus","text":"<pre><code>bool mpu_getIntZeroMotionStatus () </code></pre> <p>Get Zero Motion Detection interrupt status. This bit automatically sets to 1 when a Zero Motion Detection interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_ZMOT_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getinterruptdrive","title":"function mpu_getInterruptDrive","text":"<pre><code>bool mpu_getInterruptDrive () </code></pre> <p>Get interrupt drive mode. Will be set 0 for push-pull, 1 for open-drain. </p> <p>Returns:</p> <p>Current interrupt drive mode (0=push-pull, 1=open-drain) </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_OPEN_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getinterruptlatch","title":"function mpu_getInterruptLatch","text":"<pre><code>bool mpu_getInterruptLatch () </code></pre> <p>Get interrupt latch mode. Will be set 0 for 50us-pulse, 1 for latch-until-int-cleared. </p> <p>Returns:</p> <p>Current latch mode (0=50us-pulse, 1=latch-until-int-cleared) </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_LATCH_INT_EN_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getinterruptlatchclear","title":"function mpu_getInterruptLatchClear","text":"<pre><code>bool mpu_getInterruptLatchClear () </code></pre> <p>Get interrupt latch clear mode. Will be set 0 for status-read-only, 1 for any-register-read. </p> <p>Returns:</p> <p>Current latch clear mode (0=status-read-only, 1=any-register-read) </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_RD_CLEAR_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getinterruptmode","title":"function mpu_getInterruptMode","text":"<pre><code>bool mpu_getInterruptMode () </code></pre> <p>Get interrupt logic level mode. Will be set 0 for active-high, 1 for active-low. </p> <p>Returns:</p> <p>Current interrupt mode (0=active-high, 1=active-low) </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_LEVEL_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getlostarbitration","title":"function mpu_getLostArbitration","text":"<pre><code>bool mpu_getLostArbitration () </code></pre> <p>Get master arbitration lost status. This bit automatically sets to 1 when the I2C Master has lost arbitration of the auxiliary I2C bus (an error condition). This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Master arbitration lost status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getmasterclockspeed","title":"function mpu_getMasterClockSpeed","text":"<pre><code>uint8_t mpu_getMasterClockSpeed () </code></pre> <p>Get I2C master clock speed. I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:</p> <p>Returns:</p> <p>Current I2C master clock speed </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getmotion6","title":"function mpu_getMotion6","text":"<pre><code>void mpu_getMotion6 (\nint16_t * ax,\nint16_t * ay,\nint16_t * az,\nint16_t * gx,\nint16_t * gy,\nint16_t * gz\n) </code></pre> <p>Get raw 6-axis motion sensor readings (accel/gyro). Retrieves all currently available motion sensor values. </p> <p>Parameters:</p> <ul> <li><code>ax</code> 16-bit signed integer container for accelerometer X-axis value </li> <li><code>ay</code> 16-bit signed integer container for accelerometer Y-axis value </li> <li><code>az</code> 16-bit signed integer container for accelerometer Z-axis value </li> <li><code>gx</code> 16-bit signed integer container for gyroscope X-axis value </li> <li><code>gy</code> 16-bit signed integer container for gyroscope Y-axis value </li> <li><code>gz</code> 16-bit signed integer container for gyroscope Z-axis value </li> </ul> <p>See also: getAcceleration() </p> <p>See also: getRotation() </p> <p>See also: mpu_RA_ACCEL_XOUT_H </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getmotion9","title":"function mpu_getMotion9","text":"<pre><code>void mpu_getMotion9 (\nint16_t * ax,\nint16_t * ay,\nint16_t * az,\nint16_t * gx,\nint16_t * gy,\nint16_t * gz,\nint16_t * mx,\nint16_t * my,\nint16_t * mz\n) </code></pre> <p>Get raw 9-axis motion sensor readings (accel/gyro/compass). FUNCTION NOT FULLY IMPLEMENTED YET. </p> <p>Parameters:</p> <ul> <li><code>ax</code> 16-bit signed integer container for accelerometer X-axis value </li> <li><code>ay</code> 16-bit signed integer container for accelerometer Y-axis value </li> <li><code>az</code> 16-bit signed integer container for accelerometer Z-axis value </li> <li><code>gx</code> 16-bit signed integer container for gyroscope X-axis value </li> <li><code>gy</code> 16-bit signed integer container for gyroscope Y-axis value </li> <li><code>gz</code> 16-bit signed integer container for gyroscope Z-axis value </li> <li><code>mx</code> 16-bit signed integer container for magnetometer X-axis value </li> <li><code>my</code> 16-bit signed integer container for magnetometer Y-axis value </li> <li><code>mz</code> 16-bit signed integer container for magnetometer Z-axis value </li> </ul> <p>See also: getMotion6() </p> <p>See also: getAcceleration() </p> <p>See also: getRotation() </p> <p>See also: mpu_RA_ACCEL_XOUT_H </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getmotiondetectioncounterdecrement","title":"function mpu_getMotionDetectionCounterDecrement","text":"<pre><code>uint8_t mpu_getMotionDetectionCounterDecrement () </code></pre> <p>Get Motion detection counter decrement configuration. Detection is registered by the Motion detection module after accelerometer measurements meet their respective threshold conditions over a specified number of samples. When the threshold conditions are met, the corresponding detection counter increments by 1. The user may control the rate at which the detection counter decrements when the threshold condition is not met by configuring MOT_COUNT. The decrement rate can be set according to the following table:</p> <p>When MOT_COUNT is configured to 0 (reset), any non-qualifying sample will reset the counter to 0. For further information on Motion detection, please refer to Registers 29 to 32. </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getmotiondetectionduration","title":"function mpu_getMotionDetectionDuration","text":"<pre><code>uint8_t mpu_getMotionDetectionDuration () </code></pre> <p>Get motion detection event duration threshold. This register configures the duration counter threshold for Motion interrupt generation. The duration counter ticks at 1 kHz, therefore MOT_DUR has a unit of 1LSB = 1ms. The Motion detection duration counter increments when the absolute value of any of the accelerometer measurements exceeds the Motion detection threshold (Register 31). The Motion detection interrupt is triggered when the Motion detection counter reaches the time count specified in this register.</p> <p>For more details on the Motion detection interrupt, see Section 8.3 of the MPU-6000/MPU-6050 Product Specification document.</p> <p>Returns:</p> <p>Current motion detection duration threshold value (LSB = 1ms) </p> <p>See also: mpu_RA_MOT_DUR </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getmotiondetectionthreshold","title":"function mpu_getMotionDetectionThreshold","text":"<pre><code>uint8_t mpu_getMotionDetectionThreshold () </code></pre> <p>Get motion detection event acceleration threshold. This register configures the detection threshold for Motion interrupt generation. The unit of MOT_THR is 1LSB = 2mg. Motion is detected when the absolute value of any of the accelerometer measurements exceeds this Motion detection threshold. This condition increments the Motion detection duration counter (Register 32). The Motion detection interrupt is triggered when the Motion Detection counter reaches the time count specified in MOT_DUR (Register 32).</p> <p>The Motion interrupt will indicate the axis and polarity of detected motion in MOT_DETECT_STATUS (Register 97).</p> <p>For more details on the Motion detection interrupt, see Section 8.3 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current motion detection acceleration threshold value (LSB = 2mg) </p> <p>See also: mpu_RA_MOT_THR </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getmultimasterenabled","title":"function mpu_getMultiMasterEnabled","text":"<pre><code>bool mpu_getMultiMasterEnabled () </code></pre> <p>Get multi-master enabled value. Multi-master capability allows multiple I2C masters to operate on the same bus. In circuits where multi-master capability is required, set MULT_MST_EN to 1. This will increase current drawn by approximately 30uA.</p> <p>In circuits where multi-master capability is required, the state of the I2C bus must always be monitored by each separate I2C Master. Before an I2C Master can assume arbitration of the bus, it must first confirm that no other I2C Master has arbitration of the bus. When MULT_MST_EN is set to 1, the MPU-60X0's bus arbitration detection logic is turned on, enabling it to detect when the bus is available.</p> <p>Returns:</p> <p>Current multi-master enabled value </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getpassthroughstatus","title":"function mpu_getPassthroughStatus","text":"<pre><code>bool mpu_getPassthroughStatus () </code></pre> <p>Get FSYNC interrupt status. This bit reflects the status of the FSYNC interrupt from an external device into the MPU-60X0. This is used as a way to pass an external interrupt through the MPU-60X0 to the host application processor. When set to 1, this bit will cause an interrupt if FSYNC_INT_EN is asserted in INT_PIN_CFG (Register 55). </p> <p>Returns:</p> <p>FSYNC interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getrate","title":"function mpu_getRate","text":"<pre><code>uint8_t mpu_getRate () </code></pre> <p>Get gyroscope output rate divider. The sensor register output, FIFO output, DMP sampling, Motion detection, Zero Motion detection, and Free Fall detection are all based on the Sample Rate. The Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV:</p> <p>Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)</p> <p>where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or 7), and 1kHz when the DLPF is enabled (see Register 26).</p> <p>Note: The accelerometer output rate is 1kHz. This means that for a Sample Rate greater than 1kHz, the same accelerometer sample may be output to the FIFO, DMP, and sensor registers more than once.</p> <p>For a diagram of the gyroscope and accelerometer signal paths, see Section 8 of the MPU-6000/MPU-6050 Product Specification document.</p> <p>Returns:</p> <p>Current sample rate </p> <p>See also: mpu_RA_SMPLRT_DIV </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getrotation","title":"function mpu_getRotation","text":"<pre><code>void mpu_getRotation (\nint16_t * x,\nint16_t * y,\nint16_t * z\n) </code></pre> <p>Get 3-axis gyroscope readings. These gyroscope measurement registers, along with the accelerometer measurement registers, temperature measurement registers, and external sensor data registers, are composed of two sets of registers: an internal register set and a user-facing read register set. The data within the gyroscope sensors' internal register set is always updated at the Sample Rate. Meanwhile, the user-facing read register set duplicates the internal register set's data values whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.</p> <p>Each 16-bit gyroscope measurement has a full scale defined in FS_SEL (Register 27). For each full scale setting, the gyroscopes' sensitivity per LSB in GYRO_xOUT is shown in the table below:</p> <p>Parameters:</p> <ul> <li><code>x</code> 16-bit signed integer container for X-axis rotation </li> <li><code>y</code> 16-bit signed integer container for Y-axis rotation </li> <li><code>z</code> 16-bit signed integer container for Z-axis rotation </li> </ul> <p>See also: getMotion6() </p> <p>See also: mpu_RA_GYRO_XOUT_H </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getrotationx","title":"function mpu_getRotationX","text":"<pre><code>int16_t mpu_getRotationX () </code></pre> <p>Get X-axis gyroscope reading. </p> <p>Returns:</p> <p>X-axis rotation measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_GYRO_XOUT_H </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getrotationy","title":"function mpu_getRotationY","text":"<pre><code>int16_t mpu_getRotationY () </code></pre> <p>Get Y-axis gyroscope reading. </p> <p>Returns:</p> <p>Y-axis rotation measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_GYRO_YOUT_H </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getrotationz","title":"function mpu_getRotationZ","text":"<pre><code>int16_t mpu_getRotationZ () </code></pre> <p>Get Z-axis gyroscope reading. </p> <p>Returns:</p> <p>Z-axis rotation measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_GYRO_ZOUT_H </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslate4inputbyte","title":"function mpu_getSlate4InputByte","text":"<pre><code>uint8_t mpu_getSlate4InputByte () </code></pre> <p>Get last available byte read from Slave 4. This register stores the data read from Slave 4. This field is populated after a read transaction. </p> <p>Returns:</p> <p>Last available byte read from to Slave 4 </p> <p>See also: mpu_RA_I2C_SLV4_DI </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslave0fifoenabled","title":"function mpu_getSlave0FIFOEnabled","text":"<pre><code>bool mpu_getSlave0FIFOEnabled () </code></pre> <p>Get Slave 0 FIFO enabled value. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 0 to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current Slave 0 FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslave0nack","title":"function mpu_getSlave0Nack","text":"<pre><code>bool mpu_getSlave0Nack () </code></pre> <p>Get Slave 0 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 0. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 0 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslave1fifoenabled","title":"function mpu_getSlave1FIFOEnabled","text":"<pre><code>bool mpu_getSlave1FIFOEnabled () </code></pre> <p>Get Slave 1 FIFO enabled value. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 1 to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current Slave 1 FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslave1nack","title":"function mpu_getSlave1Nack","text":"<pre><code>bool mpu_getSlave1Nack () </code></pre> <p>Get Slave 1 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 1. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 1 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslave2fifoenabled","title":"function mpu_getSlave2FIFOEnabled","text":"<pre><code>bool mpu_getSlave2FIFOEnabled () </code></pre> <p>Get Slave 2 FIFO enabled value. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 2 to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current Slave 2 FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslave2nack","title":"function mpu_getSlave2Nack","text":"<pre><code>bool mpu_getSlave2Nack () </code></pre> <p>Get Slave 2 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 2. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 2 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslave3fifoenabled","title":"function mpu_getSlave3FIFOEnabled","text":"<pre><code>bool mpu_getSlave3FIFOEnabled () </code></pre> <p>Get Slave 3 FIFO enabled value. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 3 to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current Slave 3 FIFO enabled value </p> <p>See also: mpu_RA_MST_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslave3nack","title":"function mpu_getSlave3Nack","text":"<pre><code>bool mpu_getSlave3Nack () </code></pre> <p>Get Slave 3 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 3. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 3 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslave4address","title":"function mpu_getSlave4Address","text":"<pre><code>uint8_t mpu_getSlave4Address () </code></pre> <p>Get the I2C address of Slave 4. Note that Bit 7 (MSB) controls read/write mode. If Bit 7 is set, it's a read operation, and if it is cleared, then it's a write operation. The remaining bits (6-0) are the 7-bit device address of the slave device.</p> <p>Returns:</p> <p>Current address for Slave 4 </p> <p>See also: getSlaveAddress() </p> <p>See also: mpu_RA_I2C_SLV4_ADDR </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslave4enabled","title":"function mpu_getSlave4Enabled","text":"<pre><code>bool mpu_getSlave4Enabled () </code></pre> <p>Get the enabled value for the Slave 4. When set to 1, this bit enables Slave 4 for data transfer operations. When cleared to 0, this bit disables Slave 4 from data transfer operations. </p> <p>Returns:</p> <p>Current enabled value for Slave 4 </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslave4interruptenabled","title":"function mpu_getSlave4InterruptEnabled","text":"<pre><code>bool mpu_getSlave4InterruptEnabled () </code></pre> <p>Get the enabled value for Slave 4 transaction interrupts. When set to 1, this bit enables the generation of an interrupt signal upon completion of a Slave 4 transaction. When cleared to 0, this bit disables the generation of an interrupt signal upon completion of a Slave 4 transaction. The interrupt status can be observed in Register 54.</p> <p>Returns:</p> <p>Current enabled value for Slave 4 transaction interrupts. </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslave4isdone","title":"function mpu_getSlave4IsDone","text":"<pre><code>bool mpu_getSlave4IsDone () </code></pre> <p>Get Slave 4 transaction done status. Automatically sets to 1 when a Slave 4 transaction has completed. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted and if the SLV_4_DONE_INT bit is asserted in the I2C_SLV4_CTRL register (Register 52). </p> <p>Returns:</p> <p>Slave 4 transaction done status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslave4masterdelay","title":"function mpu_getSlave4MasterDelay","text":"<pre><code>uint8_t mpu_getSlave4MasterDelay () </code></pre> <p>Get Slave 4 master delay value. This configures the reduced access rate of I2C slaves relative to the Sample Rate. When a slave's access rate is decreased relative to the Sample Rate, the slave is accessed every:  This base Sample Rate in turn is determined by SMPLRT_DIV (register 25) and DLPF_CFG (register 26). Whether a slave's access rate is reduced relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL (register 103). For further information regarding the Sample Rate, please refer to register 25.</p> <p>Returns:</p> <p>Current Slave 4 master delay value </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslave4nack","title":"function mpu_getSlave4Nack","text":"<pre><code>bool mpu_getSlave4Nack () </code></pre> <p>Get Slave 4 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 4. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 4 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslave4register","title":"function mpu_getSlave4Register","text":"<pre><code>uint8_t mpu_getSlave4Register () </code></pre> <p>Get the active internal register for the Slave 4. Read/write operations for this slave will be done to whatever internal register address is stored in this MPU register.</p> <p>Returns:</p> <p>Current active register for Slave 4 </p> <p>See also: mpu_RA_I2C_SLV4_REG </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslave4writemode","title":"function mpu_getSlave4WriteMode","text":"<pre><code>bool mpu_getSlave4WriteMode () </code></pre> <p>Get write mode for Slave 4. When set to 1, the transaction will read or write data only. When cleared to 0, the transaction will write a register address prior to reading or writing data. This should equal 0 when specifying the register address within the Slave device to/from which the ensuing data transaction will take place.</p> <p>Returns:</p> <p>Current write mode for Slave 4 (0 = register address + data, 1 = data only) </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslaveaddress","title":"function mpu_getSlaveAddress","text":"<pre><code>uint8_t mpu_getSlaveAddress (\nuint8_t num\n) </code></pre> <p>Get the I2C address of the specified slave (0-3). Note that Bit 7 (MSB) controls read/write mode. If Bit 7 is set, it's a read operation, and if it is cleared, then it's a write operation. The remaining bits (6-0) are the 7-bit device address of the slave device.</p> <p>In read mode, the result of the read is placed in the lowest available EXT_SENS_DATA register. For further information regarding the allocation of read results, please refer to the EXT_SENS_DATA register description (Registers 73 - 96).</p> <p>The MPU-6050 supports a total of five slaves, but Slave 4 has unique characteristics, and so it has its own functions (getSlave4* and setSlave4*).</p> <p>I2C data transactions are performed at the Sample Rate, as defined in Register 25. The user is responsible for ensuring that I2C data transactions to and from each enabled Slave can be completed within a single period of the Sample Rate.</p> <p>The I2C slave access rate can be reduced relative to the Sample Rate. This reduced access rate is determined by I2C_MST_DLY (Register 52). Whether a slave's access rate is reduced relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL (Register 103).</p> <p>The processing order for the slaves is fixed. The sequence followed for processing the slaves is Slave 0, Slave 1, Slave 2, Slave 3 and Slave 4. If a particular Slave is disabled it will be skipped.</p> <p>Each slave can either be accessed at the sample rate or at a reduced sample rate. In a case where some slaves are accessed at the Sample Rate and some slaves are accessed at the reduced rate, the sequence of accessing the slaves (Slave 0 to Slave 4) is still followed. However, the reduced rate slaves will be skipped if their access rate dictates that they should not be accessed during that particular cycle. For further information regarding the reduced access rate, please refer to Register 52. Whether a slave is accessed at the Sample Rate or at the reduced rate is determined by the Delay Enable bits in Register 103.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current address for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_ADDR </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslavedatalength","title":"function mpu_getSlaveDataLength","text":"<pre><code>uint8_t mpu_getSlaveDataLength (\nuint8_t num\n) </code></pre> <p>Get number of bytes to read for the specified slave (0-3). Specifies the number of bytes transferred to and from Slave 0. Clearing this bit to 0 is equivalent to disabling the register by writing 0 to I2C_SLV0_EN. </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Number of bytes to read for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslavedelayenabled","title":"function mpu_getSlaveDelayEnabled","text":"<pre><code>bool mpu_getSlaveDelayEnabled (\nuint8_t num\n) </code></pre> <p>Get slave delay enabled status. When a particular slave delay is enabled, the rate of access for the that slave device is reduced. When a slave's access rate is decreased relative to the Sample Rate, the slave is accessed every:  This base Sample Rate in turn is determined by SMPLRT_DIV (register * 25) and DLPF_CFG (register 26).</p> <p>For further information regarding I2C_MST_DLY, please refer to register 52. For further information regarding the Sample Rate, please refer to register 25.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-4) </li> </ul> <p>Returns:</p> <p>Current slave delay enabled status. </p> <p>See also: mpu_RA_I2C_MST_DELAY_CTRL </p> <p>See also: mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslaveenabled","title":"function mpu_getSlaveEnabled","text":"<pre><code>bool mpu_getSlaveEnabled (\nuint8_t num\n) </code></pre> <p>Get the enabled value for the specified slave (0-3). When set to 1, this bit enables Slave 0 for data transfer operations. When cleared to 0, this bit disables Slave 0 from data transfer operations. </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current enabled value for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslavereadwritetransitionenabled","title":"function mpu_getSlaveReadWriteTransitionEnabled","text":"<pre><code>bool mpu_getSlaveReadWriteTransitionEnabled () </code></pre> <p>Get slave read/write transition enabled value. The I2C_MST_P_NSR bit configures the I2C Master's transition from one slave read to the next slave read. If the bit equals 0, there will be a restart between reads. If the bit equals 1, there will be a stop followed by a start of the following read. When a write transaction follows a read transaction, the stop followed by a start of the successive write will be always used.</p> <p>Returns:</p> <p>Current slave read/write transition enabled value </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslaveregister","title":"function mpu_getSlaveRegister","text":"<pre><code>uint8_t mpu_getSlaveRegister (\nuint8_t num\n) </code></pre> <p>Get the active internal register for the specified slave (0-3). Read/write operations for this slave will be done to whatever internal register address is stored in this MPU register.</p> <p>The MPU-6050 supports a total of five slaves, but Slave 4 has unique characteristics, and so it has its own functions.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current active register for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_REG </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslavewordbyteswap","title":"function mpu_getSlaveWordByteSwap","text":"<pre><code>bool mpu_getSlaveWordByteSwap (\nuint8_t num\n) </code></pre> <p>Get word pair byte-swapping enabled for the specified slave (0-3). When set to 1, this bit enables byte swapping. When byte swapping is enabled, the high and low bytes of a word pair are swapped. Please refer to I2C_SLV0_GRP for the pairing convention of the word pairs. When cleared to 0, bytes transferred to and from Slave 0 will be written to EXT_SENS_DATA registers in the order they were transferred.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current word pair byte-swapping enabled value for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslavewordgroupoffset","title":"function mpu_getSlaveWordGroupOffset","text":"<pre><code>bool mpu_getSlaveWordGroupOffset (\nuint8_t num\n) </code></pre> <p>Get word pair grouping order offset for the specified slave (0-3). This sets specifies the grouping order of word pairs received from registers. When cleared to 0, bytes from register addresses 0 and 1, 2 and 3, etc (even, then odd register addresses) are paired to form a word. When set to 1, bytes from register addresses are paired 1 and 2, 3 and 4, etc. (odd, then even register addresses) are paired to form a word.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current word pair grouping order offset for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getslavewritemode","title":"function mpu_getSlaveWriteMode","text":"<pre><code>bool mpu_getSlaveWriteMode (\nuint8_t num\n) </code></pre> <p>Get write mode for the specified slave (0-3). When set to 1, the transaction will read or write data only. When cleared to 0, the transaction will write a register address prior to reading or writing data. This should equal 0 when specifying the register address within the Slave device to/from which the ensuing data transaction will take place.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current write mode for specified slave (0 = register address + data, 1 = data only) </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getsleepenabled","title":"function mpu_getSleepEnabled","text":"<pre><code>bool mpu_getSleepEnabled () </code></pre> <p>Get sleep mode status. Setting the SLEEP bit in the register puts the device into very low power sleep mode. In this mode, only the serial interface and internal registers remain active, allowing for a very low standby current. Clearing this bit puts the device back into normal mode. To save power, the individual standby selections for each of the gyros should be used if any gyro axis is not used by the application. </p> <p>Returns:</p> <p>Current sleep mode enabled status </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_SLEEP_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_gettempfifoenabled","title":"function mpu_getTempFIFOEnabled","text":"<pre><code>bool mpu_getTempFIFOEnabled () </code></pre> <p>Get temperature FIFO enabled value. When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L (Registers 65 and 66) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current temperature FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_gettempsensorenabled","title":"function mpu_getTempSensorEnabled","text":"<pre><code>bool mpu_getTempSensorEnabled () </code></pre> <p>Get temperature sensor enabled status. Control the usage of the internal temperature sensor.</p> <p>Note: this register stores the disabled value, but for consistency with the rest of the code, the function is named and used with standard true/false values to indicate whether the sensor is enabled or disabled, respectively.</p> <p>Returns:</p> <p>Current temperature sensor enabled status </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_TEMP_DIS_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_gettemperature","title":"function mpu_getTemperature","text":"<pre><code>int16_t mpu_getTemperature () </code></pre> <p>Get current internal temperature. </p> <p>Returns:</p> <p>Temperature reading in 16-bit 2's complement format </p> <p>See also: mpu_RA_TEMP_OUT_H </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getwaitforexternalsensorenabled","title":"function mpu_getWaitForExternalSensorEnabled","text":"<pre><code>bool mpu_getWaitForExternalSensorEnabled () </code></pre> <p>Get wait-for-external-sensor-data enabled value. When the WAIT_FOR_ES bit is set to 1, the Data Ready interrupt will be delayed until External Sensor data from the Slave Devices are loaded into the EXT_SENS_DATA registers. This is used to ensure that both the internal sensor data (i.e. from gyro and accel) and external sensor data have been loaded to their respective data registers (i.e. the data is synced) when the Data Ready interrupt is triggered.</p> <p>Returns:</p> <p>Current wait-for-external-sensor-data enabled value </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getwakecycleenabled","title":"function mpu_getWakeCycleEnabled","text":"<pre><code>bool mpu_getWakeCycleEnabled () </code></pre> <p>Get wake cycle enabled status. When this bit is set to 1 and SLEEP is disabled, the MPU-60X0 will cycle between sleep mode and waking up to take a single sample of data from active sensors at a rate determined by LP_WAKE_CTRL (register 108). </p> <p>Returns:</p> <p>Current sleep mode enabled status </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_CYCLE_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getxgyrofifoenabled","title":"function mpu_getXGyroFIFOEnabled","text":"<pre><code>bool mpu_getXGyroFIFOEnabled () </code></pre> <p>Get gyroscope X-axis FIFO enabled value. When set to 1, this bit enables GYRO_XOUT_H and GYRO_XOUT_L (Registers 67 and 68) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current gyroscope X-axis FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getxnegmotiondetected","title":"function mpu_getXNegMotionDetected","text":"<pre><code>bool mpu_getXNegMotionDetected () </code></pre> <p>Get X-axis negative motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_XNEG_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getxposmotiondetected","title":"function mpu_getXPosMotionDetected","text":"<pre><code>bool mpu_getXPosMotionDetected () </code></pre> <p>Get X-axis positive motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_XPOS_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getygyrofifoenabled","title":"function mpu_getYGyroFIFOEnabled","text":"<pre><code>bool mpu_getYGyroFIFOEnabled () </code></pre> <p>Get gyroscope Y-axis FIFO enabled value. When set to 1, this bit enables GYRO_YOUT_H and GYRO_YOUT_L (Registers 69 and 70) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current gyroscope Y-axis FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getynegmotiondetected","title":"function mpu_getYNegMotionDetected","text":"<pre><code>bool mpu_getYNegMotionDetected () </code></pre> <p>Get Y-axis negative motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_YNEG_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getyposmotiondetected","title":"function mpu_getYPosMotionDetected","text":"<pre><code>bool mpu_getYPosMotionDetected () </code></pre> <p>Get Y-axis positive motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_YPOS_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getzgyrofifoenabled","title":"function mpu_getZGyroFIFOEnabled","text":"<pre><code>bool mpu_getZGyroFIFOEnabled () </code></pre> <p>Get gyroscope Z-axis FIFO enabled value. When set to 1, this bit enables GYRO_ZOUT_H and GYRO_ZOUT_L (Registers 71 and 72) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current gyroscope Z-axis FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getznegmotiondetected","title":"function mpu_getZNegMotionDetected","text":"<pre><code>bool mpu_getZNegMotionDetected () </code></pre> <p>Get Z-axis negative motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_ZNEG_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getzposmotiondetected","title":"function mpu_getZPosMotionDetected","text":"<pre><code>bool mpu_getZPosMotionDetected () </code></pre> <p>Get Z-axis positive motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_ZPOS_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getzeromotiondetected","title":"function mpu_getZeroMotionDetected","text":"<pre><code>bool mpu_getZeroMotionDetected () </code></pre> <p>Get zero motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_ZRMOT_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getzeromotiondetectionduration","title":"function mpu_getZeroMotionDetectionDuration","text":"<pre><code>uint8_t mpu_getZeroMotionDetectionDuration () </code></pre> <p>Get zero motion detection event duration threshold. This register configures the duration counter threshold for Zero Motion interrupt generation. The duration counter ticks at 16 Hz, therefore ZRMOT_DUR has a unit of 1 LSB = 64 ms. The Zero Motion duration counter increments while the absolute value of the accelerometer measurements are each less than the detection threshold (Register 33). The Zero Motion interrupt is triggered when the Zero Motion duration counter reaches the time count specified in this register.</p> <p>For more details on the Zero Motion detection interrupt, see Section 8.4 of the MPU-6000/MPU-6050 Product Specification document, as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current zero motion detection duration threshold value (LSB = 64ms) </p> <p>See also: mpu_RA_ZRMOT_DUR </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_getzeromotiondetectionthreshold","title":"function mpu_getZeroMotionDetectionThreshold","text":"<pre><code>uint8_t mpu_getZeroMotionDetectionThreshold () </code></pre> <p>Get zero motion detection event acceleration threshold. This register configures the detection threshold for Zero Motion interrupt generation. The unit of ZRMOT_THR is 1LSB = 2mg. Zero Motion is detected when the absolute value of the accelerometer measurements for the 3 axes are each less than the detection threshold. This condition increments the Zero Motion duration counter (Register 34). The Zero Motion interrupt is triggered when the Zero Motion duration counter reaches the time count specified in ZRMOT_DUR (Register 34).</p> <p>Unlike Free Fall or Motion detection, Zero Motion detection triggers an interrupt both when Zero Motion is first detected and when Zero Motion is no longer detected.</p> <p>When a zero motion event is detected, a Zero Motion Status will be indicated in the MOT_DETECT_STATUS register (Register 97). When a motion-to-zero-motion condition is detected, the status bit is set to 1. When a zero-motion-to- motion condition is detected, the status bit is set to 0.</p> <p>For more details on the Zero Motion detection interrupt, see Section 8.4 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current zero motion detection acceleration threshold value (LSB = 2mg) </p> <p>See also: mpu_RA_ZRMOT_THR </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_reset","title":"function mpu_reset","text":"<pre><code>void mpu_reset () </code></pre> <p>Trigger a full device reset. A small delay of ~50ms may be desirable after triggering a reset. </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_DEVICE_RESET_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_resetaccelerometerpath","title":"function mpu_resetAccelerometerPath","text":"<pre><code>void mpu_resetAccelerometerPath () </code></pre> <p>Reset accelerometer signal path. The reset will revert the signal path analog to digital converters and filters to their power up configurations. </p> <p>See also: mpu_RA_SIGNAL_PATH_RESET </p> <p>See also: mpu_PATHRESET_ACCEL_RESET_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_resetfifo","title":"function mpu_resetFIFO","text":"<pre><code>void mpu_resetFIFO () </code></pre> <p>Reset the FIFO. This bit resets the FIFO mpu6050.buffer when set to 1 while FIFO_EN equals 0. This bit automatically clears to 0 after the reset has been triggered. </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_FIFO_RESET_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_resetgyroscopepath","title":"function mpu_resetGyroscopePath","text":"<pre><code>void mpu_resetGyroscopePath () </code></pre> <p>Reset gyroscope signal path. The reset will revert the signal path analog to digital converters and filters to their power up configurations. </p> <p>See also: mpu_RA_SIGNAL_PATH_RESET </p> <p>See also: mpu_PATHRESET_GYRO_RESET_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_reseti2cmaster","title":"function mpu_resetI2CMaster","text":"<pre><code>void mpu_resetI2CMaster () </code></pre> <p>Reset the I2C Master. This bit resets the I2C Master when set to 1 while I2C_MST_EN equals 0. This bit automatically clears to 0 after the reset has been triggered. </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_I2C_MST_RESET_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_resetsensors","title":"function mpu_resetSensors","text":"<pre><code>void mpu_resetSensors () </code></pre> <p>Reset all sensor registers and signal paths. When set to 1, this bit resets the signal paths for all sensors (gyroscopes, accelerometers, and temperature sensor). This operation will also clear the sensor registers. This bit automatically clears to 0 after the reset has been triggered.</p> <p>When resetting only the signal path (and not the sensor registers), please use Register 104, SIGNAL_PATH_RESET.</p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_SIG_COND_RESET_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_resettemperaturepath","title":"function mpu_resetTemperaturePath","text":"<pre><code>void mpu_resetTemperaturePath () </code></pre> <p>Reset temperature sensor signal path. The reset will revert the signal path analog to digital converters and filters to their power up configurations. </p> <p>See also: mpu_RA_SIGNAL_PATH_RESET </p> <p>See also: mpu_PATHRESET_TEMP_RESET_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setaccelfifoenabled","title":"function mpu_setAccelFIFOEnabled","text":"<pre><code>void mpu_setAccelFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set accelerometer FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New accelerometer FIFO enabled value </li> </ul> <p>See also: getAccelFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setaccelxselftest","title":"function mpu_setAccelXSelfTest","text":"<pre><code>void mpu_setAccelXSelfTest (\nbool enabled\n) </code></pre> <p>Get self-test enabled setting for accelerometer X axis. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> Self-test enabled value </li> </ul> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setaccelyselftest","title":"function mpu_setAccelYSelfTest","text":"<pre><code>void mpu_setAccelYSelfTest (\nbool enabled\n) </code></pre> <p>Get self-test enabled value for accelerometer Y axis. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> Self-test enabled value </li> </ul> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setaccelzselftest","title":"function mpu_setAccelZSelfTest","text":"<pre><code>void mpu_setAccelZSelfTest (\nbool enabled\n) </code></pre> <p>Set self-test enabled value for accelerometer Z axis. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> Self-test enabled value </li> </ul> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setaccelerometerpowerondelay","title":"function mpu_setAccelerometerPowerOnDelay","text":"<pre><code>void mpu_setAccelerometerPowerOnDelay (\nuint8_t delay\n) </code></pre> <p>Set accelerometer power-on delay. </p> <p>Parameters:</p> <ul> <li><code>delay</code> New accelerometer power-on delay (0-3) </li> </ul> <p>See also: getAccelerometerPowerOnDelay() </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_ACCEL_ON_DELAY_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setauxvddiolevel","title":"function mpu_setAuxVDDIOLevel","text":"<pre><code>void mpu_setAuxVDDIOLevel (\nuint8_t level\n) </code></pre> <p>Set the auxiliary I2C supply voltage level. When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to the MPU-6000, which does not have a VLOGIC pin. </p> <p>Parameters:</p> <ul> <li><code>level</code> I2C supply voltage level (0=VLOGIC, 1=VDD) </li> </ul>"},{"location":"stm/MpuController_8cpp/#function-mpu_setclockoutputenabled","title":"function mpu_setClockOutputEnabled","text":"<pre><code>void mpu_setClockOutputEnabled (\nbool enabled\n) </code></pre> <p>Set reference clock output enabled status. When this bit is equal to 1, a reference clock output is provided at the CLKOUT pin. When this bit is equal to 0, the clock output is disabled. For further information regarding CLKOUT, please refer to the MPU-60X0 Product Specification document. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New reference clock output enabled status </li> </ul> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_CLKOUT_EN_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setclocksource","title":"function mpu_setClockSource","text":"<pre><code>void mpu_setClockSource (\nuint8_t source\n) </code></pre> <p>Set clock source setting. An internal 8MHz oscillator, gyroscope based clock, or external sources can be selected as the MPU-60X0 clock source. When the internal 8 MHz oscillator or an external source is chosen as the clock source, the MPU-60X0 can operate in low power modes with the gyroscopes disabled.</p> <p>Upon power up, the MPU-60X0 clock source defaults to the internal oscillator. However, it is highly recommended that the device be configured to use one of the gyroscopes (or an external clock source) as the clock reference for improved stability. The clock source can be selected according to the following table:</p> <p>Parameters:</p> <ul> <li><code>source</code> New clock source setting </li> </ul> <p>See also: getClockSource() </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_CLKSEL_BIT </p> <p>See also: mpu_PWR1_CLKSEL_LENGTH </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setdhpfmode","title":"function mpu_setDHPFMode","text":"<pre><code>void mpu_setDHPFMode (\nuint8_t bandwidth\n) </code></pre> <p>Set the high-pass filter configuration. </p> <p>Parameters:</p> <ul> <li><code>bandwidth</code> New high-pass filter configuration </li> </ul> <p>See also: setDHPFMode() </p> <p>See also: mpu_DHPF_RESET </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setdlpfmode","title":"function mpu_setDLPFMode","text":"<pre><code>void mpu_setDLPFMode (\nuint8_t mode\n) </code></pre> <p>Set digital low-pass filter configuration. </p> <p>Parameters:</p> <ul> <li><code>mode</code> New DLFP configuration setting </li> </ul> <p>See also: getDLPFBandwidth() </p> <p>See also: mpu_DLPF_BW_256 </p> <p>See also: mpu_RA_CONFIG </p> <p>See also: mpu_CFG_DLPF_CFG_BIT </p> <p>See also: mpu_CFG_DLPF_CFG_LENGTH </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setexternalframesync","title":"function mpu_setExternalFrameSync","text":"<pre><code>void mpu_setExternalFrameSync (\nuint8_t sync\n) </code></pre> <p>Set external FSYNC configuration. </p> <p>See also: getExternalFrameSync() </p> <p>See also: mpu_RA_CONFIG </p> <p>Parameters:</p> <ul> <li><code>sync</code> New FSYNC configuration value </li> </ul>"},{"location":"stm/MpuController_8cpp/#function-mpu_setexternalshadowdelayenabled","title":"function mpu_setExternalShadowDelayEnabled","text":"<pre><code>void mpu_setExternalShadowDelayEnabled (\nbool enabled\n) </code></pre> <p>Set external data shadow delay enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New external data shadow delay enabled status. </li> </ul> <p>See also: getExternalShadowDelayEnabled() </p> <p>See also: mpu_RA_I2C_MST_DELAY_CTRL </p> <p>See also: mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setfifoenabled","title":"function mpu_setFIFOEnabled","text":"<pre><code>void mpu_setFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set FIFO enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New FIFO enabled status </li> </ul> <p>See also: getFIFOEnabled() </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_FIFO_EN_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setfsyncinterruptenabled","title":"function mpu_setFSyncInterruptEnabled","text":"<pre><code>void mpu_setFSyncInterruptEnabled (\nbool enabled\n) </code></pre> <p>Set FSYNC pin interrupt enabled setting. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New FSYNC pin interrupt enabled setting </li> </ul> <p>See also: getFSyncInterruptEnabled() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_FSYNC_INT_EN_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setfsyncinterruptlevel","title":"function mpu_setFSyncInterruptLevel","text":"<pre><code>void mpu_setFSyncInterruptLevel (\nbool level\n) </code></pre> <p>Set FSYNC interrupt logic level mode. </p> <p>Parameters:</p> <ul> <li><code>mode</code> New FSYNC interrupt mode (0=active-high, 1=active-low) </li> </ul> <p>See also: getFSyncInterruptMode() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_FSYNC_INT_LEVEL_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setfreefalldetectioncounterdecrement","title":"function mpu_setFreefallDetectionCounterDecrement","text":"<pre><code>void mpu_setFreefallDetectionCounterDecrement (\nuint8_t decrement\n) </code></pre> <p>Set Free Fall detection counter decrement configuration. </p> <p>Parameters:</p> <ul> <li><code>decrement</code> New decrement configuration value </li> </ul> <p>See also: getFreefallDetectionCounterDecrement() </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_FF_COUNT_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setfreefalldetectionduration","title":"function mpu_setFreefallDetectionDuration","text":"<pre><code>void mpu_setFreefallDetectionDuration (\nuint8_t duration\n) </code></pre> <p>Get free-fall event duration threshold. </p> <p>Parameters:</p> <ul> <li><code>duration</code> New free-fall duration threshold value (LSB = 1ms) </li> </ul> <p>See also: getFreefallDetectionDuration() </p> <p>See also: mpu_RA_FF_DUR </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setfreefalldetectionthreshold","title":"function mpu_setFreefallDetectionThreshold","text":"<pre><code>void mpu_setFreefallDetectionThreshold (\nuint8_t threshold\n) </code></pre> <p>Get free-fall event acceleration threshold. </p> <p>Parameters:</p> <ul> <li><code>threshold</code> New free-fall acceleration threshold value (LSB = 2mg) </li> </ul> <p>See also: getFreefallDetectionThreshold() </p> <p>See also: mpu_RA_FF_THR </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setfullscaleaccelrange","title":"function mpu_setFullScaleAccelRange","text":"<pre><code>void mpu_setFullScaleAccelRange (\nuint8_t range\n) </code></pre> <p>Set full-scale accelerometer range. </p> <p>Parameters:</p> <ul> <li><code>range</code> New full-scale accelerometer range setting </li> </ul> <p>See also: getFullScaleAccelRange() </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setfullscalegyrorange","title":"function mpu_setFullScaleGyroRange","text":"<pre><code>void mpu_setFullScaleGyroRange (\nuint8_t range\n) </code></pre> <p>Set full-scale gyroscope range. </p> <p>Parameters:</p> <ul> <li><code>range</code> New full-scale gyroscope range value </li> </ul> <p>See also: getFullScaleRange() </p> <p>See also: mpu_GYRO_FS_250 </p> <p>See also: mpu_RA_GYRO_CONFIG </p> <p>See also: mpu_GCONFIG_FS_SEL_BIT </p> <p>See also: mpu_GCONFIG_FS_SEL_LENGTH </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_seti2cbypassenabled","title":"function mpu_setI2CBypassEnabled","text":"<pre><code>void mpu_setI2CBypassEnabled (\nbool enabled\n) </code></pre> <p>Set I2C bypass enabled status. When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to 0, the host application processor will be able to directly access the auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host application processor will not be able to directly access the auxiliary I2C bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106 bit[5]). </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New I2C bypass enabled status </li> </ul> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_I2C_BYPASS_EN_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_seti2cmastermodeenabled","title":"function mpu_setI2CMasterModeEnabled","text":"<pre><code>void mpu_setI2CMasterModeEnabled (\nbool enabled\n) </code></pre> <p>Set I2C Master Mode enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New I2C Master Mode enabled status </li> </ul> <p>See also: getI2CMasterModeEnabled() </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_I2C_MST_EN_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setintdatareadyenabled","title":"function mpu_setIntDataReadyEnabled","text":"<pre><code>void mpu_setIntDataReadyEnabled (\nbool enabled\n) </code></pre> <p>Set Data Ready interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntDataReadyEnabled() </p> <p>See also: mpu_RA_INT_CFG </p> <p>See also: mpu_INTERRUPT_DATA_RDY_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setintenabled","title":"function mpu_setIntEnabled","text":"<pre><code>void mpu_setIntEnabled (\nuint8_t enabled\n) </code></pre> <p>Set full interrupt enabled status. Full register byte for all interrupts, for quick reading. Each bit should be set 0 for disabled, 1 for enabled. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntFreefallEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setintfifobufferoverflowenabled","title":"function mpu_setIntFIFOBufferOverflowEnabled","text":"<pre><code>void mpu_setIntFIFOBufferOverflowEnabled (\nbool enabled\n) </code></pre> <p>Set FIFO Buffer Overflow interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntFIFOBufferOverflowEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FIFO_OFLOW_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setintfreefallenabled","title":"function mpu_setIntFreefallEnabled","text":"<pre><code>void mpu_setIntFreefallEnabled (\nbool enabled\n) </code></pre> <p>Set Free Fall interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntFreefallEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setinti2cmasterenabled","title":"function mpu_setIntI2CMasterEnabled","text":"<pre><code>void mpu_setIntI2CMasterEnabled (\nbool enabled\n) </code></pre> <p>Set I2C Master interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntI2CMasterEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_I2C_MST_INT_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setintmotionenabled","title":"function mpu_setIntMotionEnabled","text":"<pre><code>void mpu_setIntMotionEnabled (\nbool enabled\n) </code></pre> <p>Set Motion Detection interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntMotionEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_MOT_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setintzeromotionenabled","title":"function mpu_setIntZeroMotionEnabled","text":"<pre><code>void mpu_setIntZeroMotionEnabled (\nbool enabled\n) </code></pre> <p>Set Zero Motion Detection interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntZeroMotionEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_ZMOT_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setinterruptdrive","title":"function mpu_setInterruptDrive","text":"<pre><code>void mpu_setInterruptDrive (\nbool drive\n) </code></pre> <p>Set interrupt drive mode. </p> <p>Parameters:</p> <ul> <li><code>drive</code> New interrupt drive mode (0=push-pull, 1=open-drain) </li> </ul> <p>See also: getInterruptDrive() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_OPEN_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setinterruptlatch","title":"function mpu_setInterruptLatch","text":"<pre><code>void mpu_setInterruptLatch (\nbool latch\n) </code></pre> <p>Set interrupt latch mode. </p> <p>Parameters:</p> <ul> <li><code>latch</code> New latch mode (0=50us-pulse, 1=latch-until-int-cleared) </li> </ul> <p>See also: getInterruptLatch() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_LATCH_INT_EN_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setinterruptlatchclear","title":"function mpu_setInterruptLatchClear","text":"<pre><code>void mpu_setInterruptLatchClear (\nbool clear\n) </code></pre> <p>Set interrupt latch clear mode. </p> <p>Parameters:</p> <ul> <li><code>clear</code> New latch clear mode (0=status-read-only, 1=any-register-read) </li> </ul> <p>See also: getInterruptLatchClear() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_RD_CLEAR_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setinterruptmode","title":"function mpu_setInterruptMode","text":"<pre><code>void mpu_setInterruptMode (\nbool mode\n) </code></pre> <p>Set interrupt logic level mode. </p> <p>Parameters:</p> <ul> <li><code>mode</code> New interrupt mode (0=active-high, 1=active-low) </li> </ul> <p>See also: getInterruptMode() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_LEVEL_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setmasterclockspeed","title":"function mpu_setMasterClockSpeed","text":"<pre><code>void mpu_setMasterClockSpeed (\nuint8_t speed\n) </code></pre> <p>Set I2C master clock speed. @reparam speed Current I2C master clock speed </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setmotiondetectioncounterdecrement","title":"function mpu_setMotionDetectionCounterDecrement","text":"<pre><code>void mpu_setMotionDetectionCounterDecrement (\nuint8_t decrement\n) </code></pre> <p>Set Motion detection counter decrement configuration. </p> <p>Parameters:</p> <ul> <li><code>decrement</code> New decrement configuration value </li> </ul> <p>See also: getMotionDetectionCounterDecrement() </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_MOT_COUNT_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setmotiondetectionduration","title":"function mpu_setMotionDetectionDuration","text":"<pre><code>void mpu_setMotionDetectionDuration (\nuint8_t duration\n) </code></pre> <p>Set motion detection event duration threshold. </p> <p>Parameters:</p> <ul> <li><code>duration</code> New motion detection duration threshold value (LSB = 1ms) </li> </ul> <p>See also: getMotionDetectionDuration() </p> <p>See also: mpu_RA_MOT_DUR </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setmotiondetectionthreshold","title":"function mpu_setMotionDetectionThreshold","text":"<pre><code>void mpu_setMotionDetectionThreshold (\nuint8_t threshold\n) </code></pre> <p>Set free-fall event acceleration threshold. </p> <p>Parameters:</p> <ul> <li><code>threshold</code> New motion detection acceleration threshold value (LSB = 2mg) </li> </ul> <p>See also: getMotionDetectionThreshold() </p> <p>See also: mpu_RA_MOT_THR </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setmultimasterenabled","title":"function mpu_setMultiMasterEnabled","text":"<pre><code>void mpu_setMultiMasterEnabled (\nbool enabled\n) </code></pre> <p>Set multi-master enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New multi-master enabled value </li> </ul> <p>See also: getMultiMasterEnabled() </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setrate","title":"function mpu_setRate","text":"<pre><code>void mpu_setRate (\nuint8_t rate\n) </code></pre> <p>Set gyroscope sample rate divider. </p> <p>Parameters:</p> <ul> <li><code>rate</code> New sample rate divider </li> </ul> <p>See also: getRate() </p> <p>See also: mpu_RA_SMPLRT_DIV </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslave0fifoenabled","title":"function mpu_setSlave0FIFOEnabled","text":"<pre><code>void mpu_setSlave0FIFOEnabled (\nbool enabled\n) </code></pre> <p>Set Slave 0 FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New Slave 0 FIFO enabled value </li> </ul> <p>See also: getSlave0FIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslave1fifoenabled","title":"function mpu_setSlave1FIFOEnabled","text":"<pre><code>void mpu_setSlave1FIFOEnabled (\nbool enabled\n) </code></pre> <p>Set Slave 1 FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New Slave 1 FIFO enabled value </li> </ul> <p>See also: getSlave1FIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslave2fifoenabled","title":"function mpu_setSlave2FIFOEnabled","text":"<pre><code>void mpu_setSlave2FIFOEnabled (\nbool enabled\n) </code></pre> <p>Set Slave 2 FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New Slave 2 FIFO enabled value </li> </ul> <p>See also: getSlave2FIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslave3fifoenabled","title":"function mpu_setSlave3FIFOEnabled","text":"<pre><code>void mpu_setSlave3FIFOEnabled (\nbool enabled\n) </code></pre> <p>Set Slave 3 FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New Slave 3 FIFO enabled value </li> </ul> <p>See also: getSlave3FIFOEnabled() </p> <p>See also: mpu_RA_MST_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslave4address","title":"function mpu_setSlave4Address","text":"<pre><code>void mpu_setSlave4Address (\nuint8_t address\n) </code></pre> <p>Set the I2C address of Slave 4. </p> <p>Parameters:</p> <ul> <li><code>address</code> New address for Slave 4 </li> </ul> <p>See also: getSlave4Address() </p> <p>See also: mpu_RA_I2C_SLV4_ADDR </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslave4enabled","title":"function mpu_setSlave4Enabled","text":"<pre><code>void mpu_setSlave4Enabled (\nbool enabled\n) </code></pre> <p>Set the enabled value for Slave 4. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New enabled value for Slave 4 </li> </ul> <p>See also: getSlave4Enabled() </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslave4interruptenabled","title":"function mpu_setSlave4InterruptEnabled","text":"<pre><code>void mpu_setSlave4InterruptEnabled (\nbool enabled\n) </code></pre> <p>Set the enabled value for Slave 4 transaction interrupts. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New enabled value for Slave 4 transaction interrupts. </li> </ul> <p>See also: getSlave4InterruptEnabled() </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslave4masterdelay","title":"function mpu_setSlave4MasterDelay","text":"<pre><code>void mpu_setSlave4MasterDelay (\nuint8_t delay\n) </code></pre> <p>Set Slave 4 master delay value. </p> <p>Parameters:</p> <ul> <li><code>delay</code> New Slave 4 master delay value </li> </ul> <p>See also: getSlave4MasterDelay() </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslave4outputbyte","title":"function mpu_setSlave4OutputByte","text":"<pre><code>void mpu_setSlave4OutputByte (\nuint8_t data\n) </code></pre> <p>Set new byte to write to Slave 4. This register stores the data to be written into the Slave 4. If I2C_SLV4_RW is set 1 (set to read), this register has no effect. </p> <p>Parameters:</p> <ul> <li><code>data</code> New byte to write to Slave 4 </li> </ul> <p>See also: mpu_RA_I2C_SLV4_DO </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslave4register","title":"function mpu_setSlave4Register","text":"<pre><code>void mpu_setSlave4Register (\nuint8_t reg\n) </code></pre> <p>Set the active internal register for Slave 4. </p> <p>Parameters:</p> <ul> <li><code>reg</code> New active register for Slave 4 </li> </ul> <p>See also: getSlave4Register() </p> <p>See also: mpu_RA_I2C_SLV4_REG </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslave4writemode","title":"function mpu_setSlave4WriteMode","text":"<pre><code>void mpu_setSlave4WriteMode (\nbool mode\n) </code></pre> <p>Set write mode for the Slave 4. </p> <p>Parameters:</p> <ul> <li><code>mode</code> New write mode for Slave 4 (0 = register address + data, 1 = data only) </li> </ul> <p>See also: getSlave4WriteMode() </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslaveaddress","title":"function mpu_setSlaveAddress","text":"<pre><code>void mpu_setSlaveAddress (\nuint8_t num,\nuint8_t address\n) </code></pre> <p>Set the I2C address of the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>address</code> New address for specified slave </li> </ul> <p>See also: getSlaveAddress() </p> <p>See also: mpu_RA_I2C_SLV0_ADDR </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslavedatalength","title":"function mpu_setSlaveDataLength","text":"<pre><code>void mpu_setSlaveDataLength (\nuint8_t num,\nuint8_t length\n) </code></pre> <p>Set number of bytes to read for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>length</code> Number of bytes to read for specified slave </li> </ul> <p>See also: getSlaveDataLength() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslavedelayenabled","title":"function mpu_setSlaveDelayEnabled","text":"<pre><code>void mpu_setSlaveDelayEnabled (\nuint8_t num,\nbool enabled\n) </code></pre> <p>Set slave delay enabled status. </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-4) </li> <li><code>enabled</code> New slave delay enabled status. </li> </ul> <p>See also: mpu_RA_I2C_MST_DELAY_CTRL </p> <p>See also: mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslaveenabled","title":"function mpu_setSlaveEnabled","text":"<pre><code>void mpu_setSlaveEnabled (\nuint8_t num,\nbool enabled\n) </code></pre> <p>Set the enabled value for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>enabled</code> New enabled value for specified slave </li> </ul> <p>See also: getSlaveEnabled() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslaveoutputbyte","title":"function mpu_setSlaveOutputByte","text":"<pre><code>void mpu_setSlaveOutputByte (\nuint8_t num,\nuint8_t data\n) </code></pre> <p>Write byte to Data Output container for specified slave. This register holds the output data written into Slave when Slave is set to write mode. For further information regarding Slave control, please refer to Registers 37 to 39 and immediately following. </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>data</code> Byte to write </li> </ul> <p>See also: mpu_RA_I2C_SLV0_DO </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslavereadwritetransitionenabled","title":"function mpu_setSlaveReadWriteTransitionEnabled","text":"<pre><code>void mpu_setSlaveReadWriteTransitionEnabled (\nbool enabled\n) </code></pre> <p>Set slave read/write transition enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New slave read/write transition enabled value </li> </ul> <p>See also: getSlaveReadWriteTransitionEnabled() </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslaveregister","title":"function mpu_setSlaveRegister","text":"<pre><code>void mpu_setSlaveRegister (\nuint8_t num,\nuint8_t reg\n) </code></pre> <p>Set the active internal register for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>reg</code> New active register for specified slave </li> </ul> <p>See also: getSlaveRegister() </p> <p>See also: mpu_RA_I2C_SLV0_REG </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslavewordbyteswap","title":"function mpu_setSlaveWordByteSwap","text":"<pre><code>void mpu_setSlaveWordByteSwap (\nuint8_t num,\nbool enabled\n) </code></pre> <p>Set word pair byte-swapping enabled for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>enabled</code> New word pair byte-swapping enabled value for specified slave </li> </ul> <p>See also: getSlaveWordByteSwap() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslavewordgroupoffset","title":"function mpu_setSlaveWordGroupOffset","text":"<pre><code>void mpu_setSlaveWordGroupOffset (\nuint8_t num,\nbool enabled\n) </code></pre> <p>Set word pair grouping order offset for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>enabled</code> New word pair grouping order offset for specified slave </li> </ul> <p>See also: getSlaveWordGroupOffset() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setslavewritemode","title":"function mpu_setSlaveWriteMode","text":"<pre><code>void mpu_setSlaveWriteMode (\nuint8_t num,\nbool mode\n) </code></pre> <p>Set write mode for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>mode</code> New write mode for specified slave (0 = register address + data, 1 = data only) </li> </ul> <p>See also: getSlaveWriteMode() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setsleepenabled","title":"function mpu_setSleepEnabled","text":"<pre><code>void mpu_setSleepEnabled (\nbool enabled\n) </code></pre> <p>Set sleep mode status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New sleep mode enabled status </li> </ul> <p>See also: getSleepEnabled() </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_SLEEP_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_settempfifoenabled","title":"function mpu_setTempFIFOEnabled","text":"<pre><code>void mpu_setTempFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set temperature FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New temperature FIFO enabled value </li> </ul> <p>See also: getTempFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_settempsensorenabled","title":"function mpu_setTempSensorEnabled","text":"<pre><code>void mpu_setTempSensorEnabled (\nbool enabled\n) </code></pre> <p>Set temperature sensor enabled status. Note: this register stores the disabled value, but for consistency with the rest of the code, the function is named and used with standard true/false values to indicate whether the sensor is enabled or disabled, respectively.</p> <p>Parameters:</p> <ul> <li><code>enabled</code> New temperature sensor enabled status </li> </ul> <p>See also: getTempSensorEnabled() </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_TEMP_DIS_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setwaitforexternalsensorenabled","title":"function mpu_setWaitForExternalSensorEnabled","text":"<pre><code>void mpu_setWaitForExternalSensorEnabled (\nbool enabled\n) </code></pre> <p>Set wait-for-external-sensor-data enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New wait-for-external-sensor-data enabled value </li> </ul> <p>See also: getWaitForExternalSensorEnabled() </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setwakecycleenabled","title":"function mpu_setWakeCycleEnabled","text":"<pre><code>void mpu_setWakeCycleEnabled (\nbool enabled\n) </code></pre> <p>Set wake cycle enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New sleep mode enabled status </li> </ul> <p>See also: getWakeCycleEnabled() </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_CYCLE_BIT </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setxgyrofifoenabled","title":"function mpu_setXGyroFIFOEnabled","text":"<pre><code>void mpu_setXGyroFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set gyroscope X-axis FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New gyroscope X-axis FIFO enabled value </li> </ul> <p>See also: getXGyroFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setygyrofifoenabled","title":"function mpu_setYGyroFIFOEnabled","text":"<pre><code>void mpu_setYGyroFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set gyroscope Y-axis FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New gyroscope Y-axis FIFO enabled value </li> </ul> <p>See also: getYGyroFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setzgyrofifoenabled","title":"function mpu_setZGyroFIFOEnabled","text":"<pre><code>void mpu_setZGyroFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set gyroscope Z-axis FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New gyroscope Z-axis FIFO enabled value </li> </ul> <p>See also: getZGyroFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setzeromotiondetectionduration","title":"function mpu_setZeroMotionDetectionDuration","text":"<pre><code>void mpu_setZeroMotionDetectionDuration (\nuint8_t duration\n) </code></pre> <p>Set zero motion detection event duration threshold. </p> <p>Parameters:</p> <ul> <li><code>duration</code> New zero motion detection duration threshold value (LSB = 1ms) </li> </ul> <p>See also: getZeroMotionDetectionDuration() </p> <p>See also: mpu_RA_ZRMOT_DUR </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_setzeromotiondetectionthreshold","title":"function mpu_setZeroMotionDetectionThreshold","text":"<pre><code>void mpu_setZeroMotionDetectionThreshold (\nuint8_t threshold\n) </code></pre> <p>Set zero motion detection event acceleration threshold. </p> <p>Parameters:</p> <ul> <li><code>threshold</code> New zero motion detection acceleration threshold value (LSB = 2mg) </li> </ul> <p>See also: getZeroMotionDetectionThreshold() </p> <p>See also: mpu_RA_ZRMOT_THR </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_switchspienabled","title":"function mpu_switchSPIEnabled","text":"<pre><code>void mpu_switchSPIEnabled (\nbool enabled\n) </code></pre> <p>Switch from I2C to SPI mode (MPU-6000 only) If this is set, the primary SPI interface will be enabled in place of the disabled primary I2C interface. </p>"},{"location":"stm/MpuController_8cpp/#function-mpu_testconnection","title":"function mpu_testConnection","text":"<pre><code>bool mpu_testConnection () </code></pre> <p>Verify the I2C connection. Make sure the device is connected and responds as expected. </p> <p>Returns:</p> <p>True if connection is valid, false otherwise </p>"},{"location":"stm/MpuController_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"stm/MpuController_8cpp/#function-mpuread","title":"function mpuRead","text":"<pre><code>static void mpuRead (\nMpuMotion6 &amp; data\n) </code></pre>"},{"location":"stm/MpuController_8cpp/#function-mpusend","title":"function mpuSend","text":"<pre><code>static void mpuSend (\nconst MpuMotion32 &amp; data\n) </code></pre>"},{"location":"stm/MpuController_8cpp/#function-mputickcallback","title":"function mpuTickCallback","text":"<pre><code>static void mpuTickCallback (\nTimerHandle_t tim\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/MpuController.cpp</code></p>"},{"location":"stm/MpuController_8cpp_source/","title":"File MpuController.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; MpuController.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>// I2Cdev library collection - mpu I2C device class\n// Based on InvenSense MPU-6050 register map document rev. 2.0, 5/19/2011 (RM-MPU-6000A-00)\n// 8/24/2011 by Jeff Rowberg &lt;jeff@rowberg.net&gt;\n// 11/28/2014 by Marton Sebok &lt;sebokmarton@gmail.com&gt;\n//\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//     ...        - ongoing debug release\n//     2014-11-28 - ported to PIC18 peripheral library from Arduino code\n//     2017-03-28 - tested basic function on STM32\n\n// NOTE: THIS IS ONLY A PARIAL RELEASE. THIS DEVICE CLASS IS CURRENTLY UNDERGOING ACTIVE\n// DEVELOPMENT AND IS STILL MISSING SOME IMPORTANT FEATURES. PLEASE KEEP THIS IN MIND IF\n// YOU DECIDE TO USE THIS PARTICULAR CODE FOR ANYTHING.\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2012 Jeff Rowberg\nCopyright (c) 2014 Marton Sebok\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include \"MpuController.hpp\"\n#include \"Dispatcher.hpp\"\n#include \"utils/TickTimer.hpp\"\n\n#include \"Bsp.hpp\"\n\n#include \"utils/QueueWrapper.hpp\"\n#include \"utils/TaskWrapper.hpp\"\n\n#include \"FreeRTOS.h\"\n#include \"timers.h\"\n\n#include \"event_groups.h\"\n\ntypedef struct MpuVector {\nint16_t x;\nint16_t y;\nint16_t z;\n} MpuVector;\n\ntypedef struct MpuVector32 {\nint32_t x;\nint32_t y;\nint32_t z;\n} MpuVector32;\n\ntypedef struct MpuMotion6 {\nMpuVector accel;\nMpuVector gyro;\n} MpuMotion6;\n\ntypedef struct MpuMotion32 {\nMpuVector32 accel;\nMpuVector32 gyro;\n} MpuMotion32;\n\nstatic mpu_t mpu6050;\nstatic MpuMotion32 mpuAggrData;\n\nstatic constexpr uint32_t mpuTickPeriodMs = 10;\nstatic uint32_t mpuAggrCounter = 0;\nstatic TimerHandle_t mpuTimerHandle;\nstatic StaticTimer_t mpuTimerBuffer;\nstatic uint16_t compressCoef = 4;\nstatic void mpuTickCallback(TimerHandle_t tim) {\nxEventGroupSetBits(i2cEventGroup, I2C_MPU_TICK);\n}\n\nstatic void mpuRead(MpuMotion6&amp; data) {\nmpu_getMotion6(&amp;data.accel.x, &amp;data.accel.y, &amp;data.accel.z, &amp;data.gyro.x,\n&amp;data.gyro.y, &amp;data.gyro.z);\n}\n\nstatic void mpuSend(const MpuMotion32&amp; data) {\n// DEBUG(\n//     \"DEBUG MPU SEND [%d] acc: x:%d; y:%d; z:%d | gyro: x:%d; y:%d; z:%d\\n\",\n//     mpuAggrCounter, data.accel.x, data.accel.y, data.accel.z, data.gyro.x,\n//     data.gyro.y, data.gyro.z);\n\nCoprocStat status = {\n.which_payload = CoprocStat_mpuStat_tag,\n};\n\nstatus.payload.mpuStat.accel.x = data.accel.x;\nstatus.payload.mpuStat.accel.y = data.accel.y;\nstatus.payload.mpuStat.accel.z = data.accel.z;\nstatus.payload.mpuStat.has_accel = true;\n\nstatus.payload.mpuStat.gyro.x = data.gyro.x;\nstatus.payload.mpuStat.gyro.y = data.gyro.y;\nstatus.payload.mpuStat.gyro.z = data.gyro.z;\nstatus.payload.mpuStat.has_gyro = true;\nstatus.payload.mpuStat.compressCoef = compressCoef;\ndispatcherEnqueueStatus(status);\n}\n\nvoid mpuDispatch(const CoprocReq_MpuReq&amp; req) {\nswitch (req.which_mpuCmd) {\ncase CoprocReq_MpuReq_init_tag:\nmpuInitialize();\nbreak;\ncase CoprocReq_MpuReq_oneSend_tag:\nMpuMotion6 data;\nMpuMotion32 data32;\nmpuRead(data);\ndata32.accel.x = data.accel.x;\ndata32.accel.y = data.accel.y;\ndata32.accel.z = data.accel.z;\ndata32.gyro.x = data.gyro.x;\ndata32.gyro.y = data.gyro.y;\ndata32.gyro.z = data.gyro.z;\nmpuSend(data32);\nbreak;\ncase CoprocReq_MpuReq_startSend_tag: {\nif (xTimerStart(mpuTimerHandle, 0) == pdFALSE) {\nDEBUG(\"MPU6050 timer start failure\\n\");\n}\nmpuAggrCounter = 0;\nbreak;\n}\n\ncase CoprocReq_MpuReq_stopSend_tag: {\nif (xTimerStop(mpuTimerHandle, 0) == pdFALSE) {\nDEBUG(\"MPU6050 timer stop failure\\n\");\n}\nbreak;\n}\n\ncase CoprocReq_MpuReq_setCompressCoef_tag: {\nuint16_t coef = req.mpuCmd.setCompressCoef;\nif (coef &gt; 0 &amp;&amp; coef &lt;= 20) {\ncompressCoef = coef;\nDEBUGLN(\"MPU6050 set new compression coef: %d\", compressCoef);\n}\nbreak;\n}\n\ncase CoprocReq_MpuReq_getCompressCoef_tag: {\nCoprocStat status = {\n.which_payload = CoprocStat_mpuStat_tag,\n.payload = {\n.mpuStat = {\n.compressCoef = compressCoef,\n},\n},\n};\ndispatcherEnqueueStatus(status);\nbreak;\n}\n};\n}\n\nvoid mpuTick() {\nMpuMotion6 data;\nmpuRead(data);\n// DEBUG(\"MPU6050 [%d] acc: x:%d; y:%d; z:%d | gyro: x:%d; y:%d; z:%d\\n\",\n//     mpuAggrCounter, data.accel.x, data.accel.y, data.accel.z, data.gyro.x,\n//     data.gyro.y, data.gyro.z);\n\nmpuAggrData.accel.x += data.accel.x;\nmpuAggrData.accel.y += data.accel.y;\nmpuAggrData.accel.z += data.accel.z;\nmpuAggrData.gyro.x += data.gyro.x;\nmpuAggrData.gyro.y += data.gyro.y;\nmpuAggrData.gyro.z += data.gyro.z;\n\nmpuAggrCounter++;\nif (mpuAggrCounter &gt;= compressCoef) {\nmpuSend(mpuAggrData);\n\nmpuAggrData.accel.x = 0;\nmpuAggrData.accel.y = 0;\nmpuAggrData.accel.z = 0;\nmpuAggrData.gyro.x = 0;\nmpuAggrData.gyro.y = 0;\nmpuAggrData.gyro.z = 0;\nmpuAggrCounter = 0;\n}\n}\n\nvoid mpuCreate() {\nmpu6050.devAddr = mpu_ADDRESS_AD0_HIGH;\nmpuTimerHandle\n= xTimerCreateStatic(\"mpuTimer\", pdMS_TO_TICKS(mpuTickPeriodMs), true,\nnullptr, mpuTickCallback, &amp;mpuTimerBuffer);\n}\n\nvoid mpuInitialize() {\nmpuReset();\n\nif (mpu_testConnection()) {\nmpu_setClockSource(mpu_CLOCK_PLL_XGYRO);\nmpu_setFullScaleGyroRange(mpu_GYRO_FS_250);\nmpu_setFullScaleAccelRange(mpu_ACCEL_FS_2);\nmpu_setSleepEnabled(false);\n} else {\nDEBUG(\"MPU6050 is not connected\\n\");\nCoprocStat status = {\n.which_payload = CoprocStat_faultStat_tag,\n.payload = { .faultStat = {\n.which_fault = CoprocStat_FaultStat_mpuFault_tag,\n},\n},\n};\ndispatcherEnqueueStatus(status);\n}\n}\n\nvoid mpuReset() {\nif (xTimerStop(mpuTimerHandle, 0) == pdFALSE) {\nDEBUG(\"Time queue overflow\\n\");\n}\n}\n\nbool mpu_testConnection() { return mpu_getDeviceID() == 0x34; }\n\n// AUX_VDDIO register (InvenSense demo code calls this RA_*G_OFFS_TC)\n\nuint8_t mpu_getAuxVDDIOLevel() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_YG_OFFS_TC, mpu_TC_PWR_MODE_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setAuxVDDIOLevel(uint8_t level) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_YG_OFFS_TC, mpu_TC_PWR_MODE_BIT, level);\n}\n\n// SMPLRT_DIV register\n\nuint8_t mpu_getRate() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_SMPLRT_DIV, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setRate(uint8_t rate) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_SMPLRT_DIV, rate);\n}\n\n// CONFIG register\n\nuint8_t mpu_getExternalFrameSync() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_CONFIG, mpu_CFG_EXT_SYNC_SET_BIT,\nmpu_CFG_EXT_SYNC_SET_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setExternalFrameSync(uint8_t sync) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_CONFIG, mpu_CFG_EXT_SYNC_SET_BIT,\nmpu_CFG_EXT_SYNC_SET_LENGTH, sync);\n}\nuint8_t mpu_getDLPFMode() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_CONFIG, mpu_CFG_DLPF_CFG_BIT,\nmpu_CFG_DLPF_CFG_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setDLPFMode(uint8_t mode) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_CONFIG, mpu_CFG_DLPF_CFG_BIT,\nmpu_CFG_DLPF_CFG_LENGTH, mode);\n}\n\n// GYRO_CONFIG register\n\nuint8_t mpu_getFullScaleGyroRange() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_GYRO_CONFIG, mpu_GCONFIG_FS_SEL_BIT,\nmpu_GCONFIG_FS_SEL_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setFullScaleGyroRange(uint8_t range) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_GYRO_CONFIG,\nmpu_GCONFIG_FS_SEL_BIT, mpu_GCONFIG_FS_SEL_LENGTH, range);\n}\n\n// ACCEL_CONFIG register\n\nbool mpu_getAccelXSelfTest() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_ACCEL_CONFIG, mpu_ACONFIG_XA_ST_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setAccelXSelfTest(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_ACCEL_CONFIG, mpu_ACONFIG_XA_ST_BIT, enabled);\n}\nbool mpu_getAccelYSelfTest() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_ACCEL_CONFIG, mpu_ACONFIG_YA_ST_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setAccelYSelfTest(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_ACCEL_CONFIG, mpu_ACONFIG_YA_ST_BIT, enabled);\n}\nbool mpu_getAccelZSelfTest() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_ACCEL_CONFIG, mpu_ACONFIG_ZA_ST_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setAccelZSelfTest(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_ACCEL_CONFIG, mpu_ACONFIG_ZA_ST_BIT, enabled);\n}\nuint8_t mpu_getFullScaleAccelRange() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_ACCEL_CONFIG,\nmpu_ACONFIG_AFS_SEL_BIT, mpu_ACONFIG_AFS_SEL_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setFullScaleAccelRange(uint8_t range) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_ACCEL_CONFIG,\nmpu_ACONFIG_AFS_SEL_BIT, mpu_ACONFIG_AFS_SEL_LENGTH, range);\n}\nuint8_t mpu_getDHPFMode() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_ACCEL_CONFIG,\nmpu_ACONFIG_ACCEL_HPF_BIT, mpu_ACONFIG_ACCEL_HPF_LENGTH, mpu6050.buffer,\n0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setDHPFMode(uint8_t bandwidth) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_ACCEL_CONFIG,\nmpu_ACONFIG_ACCEL_HPF_BIT, mpu_ACONFIG_ACCEL_HPF_LENGTH, bandwidth);\n}\n\n// FF_THR register\n\nuint8_t mpu_getFreefallDetectionThreshold() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_FF_THR, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setFreefallDetectionThreshold(uint8_t threshold) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_FF_THR, threshold);\n}\n\n// FF_DUR register\n\nuint8_t mpu_getFreefallDetectionDuration() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_FF_DUR, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setFreefallDetectionDuration(uint8_t duration) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_FF_DUR, duration);\n}\n\n// MOT_THR register\n\nuint8_t mpu_getMotionDetectionThreshold() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_MOT_THR, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setMotionDetectionThreshold(uint8_t threshold) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_MOT_THR, threshold);\n}\n\n// MOT_DUR register\n\nuint8_t mpu_getMotionDetectionDuration() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_MOT_DUR, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setMotionDetectionDuration(uint8_t duration) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_MOT_DUR, duration);\n}\n\n// ZRMOT_THR register\n\nuint8_t mpu_getZeroMotionDetectionThreshold() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_ZRMOT_THR, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setZeroMotionDetectionThreshold(uint8_t threshold) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_ZRMOT_THR, threshold);\n}\n\n// ZRMOT_DUR register\n\nuint8_t mpu_getZeroMotionDetectionDuration() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_ZRMOT_DUR, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setZeroMotionDetectionDuration(uint8_t duration) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_ZRMOT_DUR, duration);\n}\n\n// FIFO_EN register\n\nbool mpu_getTempFIFOEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_FIFO_EN, mpu_TEMP_FIFO_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setTempFIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_TEMP_FIFO_EN_BIT, enabled);\n}\nbool mpu_getXGyroFIFOEnabled() {\nI2Cdev_readBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_XG_FIFO_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setXGyroFIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_XG_FIFO_EN_BIT, enabled);\n}\nbool mpu_getYGyroFIFOEnabled() {\nI2Cdev_readBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_YG_FIFO_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setYGyroFIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_YG_FIFO_EN_BIT, enabled);\n}\nbool mpu_getZGyroFIFOEnabled() {\nI2Cdev_readBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_ZG_FIFO_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setZGyroFIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_ZG_FIFO_EN_BIT, enabled);\n}\nbool mpu_getAccelFIFOEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_FIFO_EN, mpu_ACCEL_FIFO_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setAccelFIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_ACCEL_FIFO_EN_BIT, enabled);\n}\nbool mpu_getSlave2FIFOEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_FIFO_EN, mpu_SLV2_FIFO_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave2FIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_SLV2_FIFO_EN_BIT, enabled);\n}\nbool mpu_getSlave1FIFOEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_FIFO_EN, mpu_SLV1_FIFO_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave1FIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_SLV1_FIFO_EN_BIT, enabled);\n}\nbool mpu_getSlave0FIFOEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_FIFO_EN, mpu_SLV0_FIFO_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave0FIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_SLV0_FIFO_EN_BIT, enabled);\n}\n\n// I2C_MST_CTRL register\n\nbool mpu_getMultiMasterEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_MULT_MST_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setMultiMasterEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_MULT_MST_EN_BIT, enabled);\n}\nbool mpu_getWaitForExternalSensorEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_WAIT_FOR_ES_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setWaitForExternalSensorEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_WAIT_FOR_ES_BIT, enabled);\n}\nbool mpu_getSlave3FIFOEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_SLV_3_FIFO_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave3FIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_SLV_3_FIFO_EN_BIT, enabled);\n}\nbool mpu_getSlaveReadWriteTransitionEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_I2C_MST_P_NSR_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveReadWriteTransitionEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_I2C_MST_P_NSR_BIT, enabled);\n}\nuint8_t mpu_getMasterClockSpeed() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_I2C_MST_CLK_BIT,\nmpu_I2C_MST_CLK_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setMasterClockSpeed(uint8_t speed) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_I2C_MST_CLK_BIT,\nmpu_I2C_MST_CLK_LENGTH, speed);\n}\n\n// I2C_SLV* registers (Slave 0-3)\n\nuint8_t mpu_getSlaveAddress(uint8_t num) {\nif (num &gt; 3)\nreturn 0;\nI2Cdev_readByte(\nmpu6050.devAddr, mpu_RA_I2C_SLV0_ADDR + num * 3, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveAddress(uint8_t num, uint8_t address) {\nif (num &gt; 3)\nreturn;\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_I2C_SLV0_ADDR + num * 3, address);\n}\nuint8_t mpu_getSlaveRegister(uint8_t num) {\nif (num &gt; 3)\nreturn 0;\nI2Cdev_readByte(\nmpu6050.devAddr, mpu_RA_I2C_SLV0_REG + num * 3, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveRegister(uint8_t num, uint8_t reg) {\nif (num &gt; 3)\nreturn;\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_I2C_SLV0_REG + num * 3, reg);\n}\nbool mpu_getSlaveEnabled(uint8_t num) {\nif (num &gt; 3)\nreturn 0;\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveEnabled(uint8_t num, bool enabled) {\nif (num &gt; 3)\nreturn;\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_EN_BIT, enabled);\n}\nbool mpu_getSlaveWordByteSwap(uint8_t num) {\nif (num &gt; 3)\nreturn 0;\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_BYTE_SW_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveWordByteSwap(uint8_t num, bool enabled) {\nif (num &gt; 3)\nreturn;\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_BYTE_SW_BIT, enabled);\n}\nbool mpu_getSlaveWriteMode(uint8_t num) {\nif (num &gt; 3)\nreturn 0;\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_REG_DIS_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveWriteMode(uint8_t num, bool mode) {\nif (num &gt; 3)\nreturn;\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_REG_DIS_BIT, mode);\n}\nbool mpu_getSlaveWordGroupOffset(uint8_t num) {\nif (num &gt; 3)\nreturn 0;\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_GRP_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveWordGroupOffset(uint8_t num, bool enabled) {\nif (num &gt; 3)\nreturn;\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_GRP_BIT, enabled);\n}\nuint8_t mpu_getSlaveDataLength(uint8_t num) {\nif (num &gt; 3)\nreturn 0;\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_LEN_BIT, mpu_I2C_SLV_LEN_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveDataLength(uint8_t num, uint8_t length) {\nif (num &gt; 3)\nreturn;\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_LEN_BIT, mpu_I2C_SLV_LEN_LENGTH, length);\n}\n\n// I2C_SLV* registers (Slave 4)\n\nuint8_t mpu_getSlave4Address() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_I2C_SLV4_ADDR, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave4Address(uint8_t address) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_I2C_SLV4_ADDR, address);\n}\nuint8_t mpu_getSlave4Register() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_I2C_SLV4_REG, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave4Register(uint8_t reg) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_I2C_SLV4_REG, reg);\n}\nvoid mpu_setSlave4OutputByte(uint8_t data) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_I2C_SLV4_DO, data);\n}\nbool mpu_getSlave4Enabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_SLV4_CTRL, mpu_I2C_SLV4_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave4Enabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_I2C_SLV4_CTRL, mpu_I2C_SLV4_EN_BIT, enabled);\n}\nbool mpu_getSlave4InterruptEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_SLV4_CTRL,\nmpu_I2C_SLV4_INT_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave4InterruptEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_I2C_SLV4_CTRL,\nmpu_I2C_SLV4_INT_EN_BIT, enabled);\n}\nbool mpu_getSlave4WriteMode() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_SLV4_CTRL,\nmpu_I2C_SLV4_REG_DIS_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave4WriteMode(bool mode) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_I2C_SLV4_CTRL, mpu_I2C_SLV4_REG_DIS_BIT, mode);\n}\nuint8_t mpu_getSlave4MasterDelay() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_I2C_SLV4_CTRL,\nmpu_I2C_SLV4_MST_DLY_BIT, mpu_I2C_SLV4_MST_DLY_LENGTH, mpu6050.buffer,\n0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave4MasterDelay(uint8_t delay) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_I2C_SLV4_CTRL,\nmpu_I2C_SLV4_MST_DLY_BIT, mpu_I2C_SLV4_MST_DLY_LENGTH, delay);\n}\nuint8_t mpu_getSlate4InputByte() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_I2C_SLV4_DI, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\n\n// I2C_MST_STATUS register\n\nbool mpu_getPassthroughStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_STATUS,\nmpu_MST_PASS_THROUGH_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getSlave4IsDone() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_STATUS,\nmpu_MST_I2C_SLV4_DONE_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getLostArbitration() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_STATUS,\nmpu_MST_I2C_LOST_ARB_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getSlave4Nack() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_STATUS,\nmpu_MST_I2C_SLV4_NACK_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getSlave3Nack() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_STATUS,\nmpu_MST_I2C_SLV3_NACK_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getSlave2Nack() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_STATUS,\nmpu_MST_I2C_SLV2_NACK_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getSlave1Nack() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_STATUS,\nmpu_MST_I2C_SLV1_NACK_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getSlave0Nack() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_STATUS,\nmpu_MST_I2C_SLV0_NACK_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\n\n// INT_PIN_CFG register\n\nbool mpu_getInterruptMode() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_INT_LEVEL_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setInterruptMode(bool mode) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_INT_PIN_CFG, mpu_INTCFG_INT_LEVEL_BIT, mode);\n}\nbool mpu_getInterruptDrive() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG, mpu_INTCFG_INT_OPEN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setInterruptDrive(bool drive) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_INT_PIN_CFG, mpu_INTCFG_INT_OPEN_BIT, drive);\n}\nbool mpu_getInterruptLatch() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_LATCH_INT_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setInterruptLatch(bool latch) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_LATCH_INT_EN_BIT, latch);\n}\nbool mpu_getInterruptLatchClear() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_INT_RD_CLEAR_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setInterruptLatchClear(bool clear) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_INT_RD_CLEAR_BIT, clear);\n}\nbool mpu_getFSyncInterruptLevel() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_FSYNC_INT_LEVEL_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setFSyncInterruptLevel(bool level) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_FSYNC_INT_LEVEL_BIT, level);\n}\nbool mpu_getFSyncInterruptEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_FSYNC_INT_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setFSyncInterruptEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_FSYNC_INT_EN_BIT, enabled);\n}\nbool mpu_getI2CBypassEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_I2C_BYPASS_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setI2CBypassEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_I2C_BYPASS_EN_BIT, enabled);\n}\nbool mpu_getClockOutputEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_CLKOUT_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setClockOutputEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_INT_PIN_CFG, mpu_INTCFG_CLKOUT_EN_BIT, enabled);\n}\n\n// INT_ENABLE register\n\nuint8_t mpu_getIntEnabled() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_INT_ENABLE, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntEnabled(uint8_t enabled) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_INT_ENABLE, enabled);\n}\nbool mpu_getIntFreefallEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_ENABLE, mpu_INTERRUPT_FF_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntFreefallEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_INT_ENABLE, mpu_INTERRUPT_FF_BIT, enabled);\n}\nbool mpu_getIntMotionEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_ENABLE, mpu_INTERRUPT_MOT_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntMotionEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_INT_ENABLE, mpu_INTERRUPT_MOT_BIT, enabled);\n}\nbool mpu_getIntZeroMotionEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_ENABLE, mpu_INTERRUPT_ZMOT_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntZeroMotionEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_INT_ENABLE, mpu_INTERRUPT_ZMOT_BIT, enabled);\n}\nbool mpu_getIntFIFOBufferOverflowEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_FIFO_OFLOW_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntFIFOBufferOverflowEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_FIFO_OFLOW_BIT, enabled);\n}\nbool mpu_getIntI2CMasterEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_I2C_MST_INT_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntI2CMasterEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_I2C_MST_INT_BIT, enabled);\n}\nbool mpu_getIntDataReadyEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_DATA_RDY_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntDataReadyEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_DATA_RDY_BIT, enabled);\n}\n\n// INT_STATUS register\n\nuint8_t mpu_getIntStatus() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_INT_STATUS, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getIntFreefallStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_STATUS, mpu_INTERRUPT_FF_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getIntMotionStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_STATUS, mpu_INTERRUPT_MOT_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getIntZeroMotionStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_STATUS, mpu_INTERRUPT_ZMOT_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getIntFIFOBufferOverflowStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_STATUS,\nmpu_INTERRUPT_FIFO_OFLOW_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getIntI2CMasterStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_STATUS,\nmpu_INTERRUPT_I2C_MST_INT_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getIntDataReadyStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_STATUS,\nmpu_INTERRUPT_DATA_RDY_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\n\n// ACCEL_*OUT_* registers\n\nvoid mpu_getMotion9(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx,\nint16_t* gy, int16_t* gz, int16_t* mx, int16_t* my, int16_t* mz) {\nmpu_getMotion6(ax, ay, az, gx, gy, gz);\n// TODO: magnetometer integration\n}\nvoid mpu_getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx,\nint16_t* gy, int16_t* gz) {\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_ACCEL_XOUT_H, 14, mpu6050.buffer, 0);\n*ax = (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n*ay = (((int16_t)mpu6050.buffer[2]) &lt;&lt; 8) | mpu6050.buffer[3];\n*az = (((int16_t)mpu6050.buffer[4]) &lt;&lt; 8) | mpu6050.buffer[5];\n*gx = (((int16_t)mpu6050.buffer[8]) &lt;&lt; 8) | mpu6050.buffer[9];\n*gy = (((int16_t)mpu6050.buffer[10]) &lt;&lt; 8) | mpu6050.buffer[11];\n*gz = (((int16_t)mpu6050.buffer[12]) &lt;&lt; 8) | mpu6050.buffer[13];\n}\nvoid mpu_getAcceleration(int16_t* x, int16_t* y, int16_t* z) {\n// void mpu_getAcceleration(int32_t* x, int32_t* y, int32_t* z) {\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_ACCEL_XOUT_H, 6, mpu6050.buffer, 0);\n*x = (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n*y = (((int16_t)mpu6050.buffer[2]) &lt;&lt; 8) | mpu6050.buffer[3];\n*z = (((int16_t)mpu6050.buffer[4]) &lt;&lt; 8) | mpu6050.buffer[5];\n}\nint16_t mpu_getAccelerationX() {\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_ACCEL_XOUT_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nint16_t mpu_getAccelerationY() {\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_ACCEL_YOUT_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nint16_t mpu_getAccelerationZ() {\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_ACCEL_ZOUT_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\n\n// TEMP_OUT_* registers\n\nint16_t mpu_getTemperature() {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_TEMP_OUT_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\n\n// GYRO_*OUT_* registers\n\nvoid mpu_getRotation(int16_t* x, int16_t* y, int16_t* z) {\n// void mpu_getRotation(int32_t* x, int32_t* y, int32_t* z) {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_GYRO_XOUT_H, 6, mpu6050.buffer, 0);\n*x = (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n*y = (((int16_t)mpu6050.buffer[2]) &lt;&lt; 8) | mpu6050.buffer[3];\n*z = (((int16_t)mpu6050.buffer[4]) &lt;&lt; 8) | mpu6050.buffer[5];\n}\nint16_t mpu_getRotationX() {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_GYRO_XOUT_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nint16_t mpu_getRotationY() {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_GYRO_YOUT_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nint16_t mpu_getRotationZ() {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_GYRO_ZOUT_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\n\n// EXT_SENS_DATA_* registers\n\nuint8_t mpu_getExternalSensorByte(int position) {\nI2Cdev_readByte(\nmpu6050.devAddr, mpu_RA_EXT_SENS_DATA_00 + position, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nuint16_t mpu_getExternalSensorWord(int position) {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_EXT_SENS_DATA_00 + position, 2,\nmpu6050.buffer, 0);\nreturn (((uint16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nuint32_t mpu_getExternalSensorDWord(int position) {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_EXT_SENS_DATA_00 + position, 4,\nmpu6050.buffer, 0);\nreturn (((uint32_t)mpu6050.buffer[0]) &lt;&lt; 24)\n| (((uint32_t)mpu6050.buffer[1]) &lt;&lt; 16)\n| (((uint16_t)mpu6050.buffer[2]) &lt;&lt; 8) | mpu6050.buffer[3];\n}\n\n// MOT_DETECT_STATUS register\n\nbool mpu_getXNegMotionDetected() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_MOT_DETECT_STATUS,\nmpu_MOTION_MOT_XNEG_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getXPosMotionDetected() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_MOT_DETECT_STATUS,\nmpu_MOTION_MOT_XPOS_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getYNegMotionDetected() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_MOT_DETECT_STATUS,\nmpu_MOTION_MOT_YNEG_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getYPosMotionDetected() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_MOT_DETECT_STATUS,\nmpu_MOTION_MOT_YPOS_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getZNegMotionDetected() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_MOT_DETECT_STATUS,\nmpu_MOTION_MOT_ZNEG_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getZPosMotionDetected() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_MOT_DETECT_STATUS,\nmpu_MOTION_MOT_ZPOS_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getZeroMotionDetected() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_MOT_DETECT_STATUS,\nmpu_MOTION_MOT_ZRMOT_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\n\n// I2C_SLV*_DO register\n\nvoid mpu_setSlaveOutputByte(uint8_t num, uint8_t data) {\nif (num &gt; 3)\nreturn;\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_I2C_SLV0_DO + num, data);\n}\n\n// I2C_MST_DELAY_CTRL register\n\nbool mpu_getExternalShadowDelayEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_DELAY_CTRL,\nmpu_DELAYCTRL_DELAY_ES_SHADOW_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setExternalShadowDelayEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_I2C_MST_DELAY_CTRL,\nmpu_DELAYCTRL_DELAY_ES_SHADOW_BIT, enabled);\n}\nbool mpu_getSlaveDelayEnabled(uint8_t num) {\n// mpu_DELAYCTRL_I2C_SLV4_DLY_EN_BIT is 4, SLV3 is 3, etc.\nif (num &gt; 4)\nreturn 0;\nI2Cdev_readBit(\nmpu6050.devAddr, mpu_RA_I2C_MST_DELAY_CTRL, num, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveDelayEnabled(uint8_t num, bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_I2C_MST_DELAY_CTRL, num, enabled);\n}\n\n// SIGNAL_PATH_RESET register\n\nvoid mpu_resetGyroscopePath() {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_SIGNAL_PATH_RESET,\nmpu_PATHRESET_GYRO_RESET_BIT, true);\n}\nvoid mpu_resetAccelerometerPath() {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_SIGNAL_PATH_RESET,\nmpu_PATHRESET_ACCEL_RESET_BIT, true);\n}\nvoid mpu_resetTemperaturePath() {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_SIGNAL_PATH_RESET,\nmpu_PATHRESET_TEMP_RESET_BIT, true);\n}\n\n// MOT_DETECT_CTRL register\n\nuint8_t mpu_getAccelerometerPowerOnDelay() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_MOT_DETECT_CTRL,\nmpu_DETECT_ACCEL_ON_DELAY_BIT, mpu_DETECT_ACCEL_ON_DELAY_LENGTH,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setAccelerometerPowerOnDelay(uint8_t delay) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_MOT_DETECT_CTRL,\nmpu_DETECT_ACCEL_ON_DELAY_BIT, mpu_DETECT_ACCEL_ON_DELAY_LENGTH, delay);\n}\nuint8_t mpu_getFreefallDetectionCounterDecrement() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_MOT_DETECT_CTRL,\nmpu_DETECT_FF_COUNT_BIT, mpu_DETECT_FF_COUNT_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setFreefallDetectionCounterDecrement(uint8_t decrement) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_MOT_DETECT_CTRL,\nmpu_DETECT_FF_COUNT_BIT, mpu_DETECT_FF_COUNT_LENGTH, decrement);\n}\nuint8_t mpu_getMotionDetectionCounterDecrement() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_MOT_DETECT_CTRL,\nmpu_DETECT_MOT_COUNT_BIT, mpu_DETECT_MOT_COUNT_LENGTH, mpu6050.buffer,\n0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setMotionDetectionCounterDecrement(uint8_t decrement) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_MOT_DETECT_CTRL,\nmpu_DETECT_MOT_COUNT_BIT, mpu_DETECT_MOT_COUNT_LENGTH, decrement);\n}\n\n// USER_CTRL register\n\nbool mpu_getFIFOEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_USER_CTRL, mpu_USERCTRL_FIFO_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setFIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_USER_CTRL, mpu_USERCTRL_FIFO_EN_BIT, enabled);\n}\nbool mpu_getI2CMasterModeEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_USER_CTRL,\nmpu_USERCTRL_I2C_MST_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setI2CMasterModeEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_USER_CTRL,\nmpu_USERCTRL_I2C_MST_EN_BIT, enabled);\n}\nvoid mpu_switchSPIEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_USER_CTRL,\nmpu_USERCTRL_I2C_IF_DIS_BIT, enabled);\n}\nvoid mpu_resetFIFO() {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_USER_CTRL, mpu_USERCTRL_FIFO_RESET_BIT, true);\n}\nvoid mpu_resetI2CMaster() {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_USER_CTRL,\nmpu_USERCTRL_I2C_MST_RESET_BIT, true);\n}\nvoid mpu_resetSensors() {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_USER_CTRL,\nmpu_USERCTRL_SIG_COND_RESET_BIT, true);\n}\n\n// PWR_MGMT_1 register\n\nvoid mpu_reset() {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_DEVICE_RESET_BIT, true);\n}\nbool mpu_getSleepEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_SLEEP_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSleepEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_SLEEP_BIT, enabled);\n}\nbool mpu_getWakeCycleEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_CYCLE_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setWakeCycleEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_CYCLE_BIT, enabled);\n}\nbool mpu_getTempSensorEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_TEMP_DIS_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0] == 0; // 1 is actually disabled here\n}\nvoid mpu_setTempSensorEnabled(bool enabled) {\n// 1 is actually disabled here\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_TEMP_DIS_BIT, !enabled);\n}\nuint8_t mpu_getClockSource() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_CLKSEL_BIT,\nmpu_PWR1_CLKSEL_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setClockSource(uint8_t source) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_CLKSEL_BIT,\nmpu_PWR1_CLKSEL_LENGTH, source);\n}\n\n// PWR_MGMT_2 register\n\nuint8_t mpu_getWakeFrequency() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_PWR_MGMT_2,\nmpu_PWR2_LP_WAKE_CTRL_BIT, mpu_PWR2_LP_WAKE_CTRL_LENGTH, mpu6050.buffer,\n0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setWakeFrequency(uint8_t frequency) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_PWR_MGMT_2,\nmpu_PWR2_LP_WAKE_CTRL_BIT, mpu_PWR2_LP_WAKE_CTRL_LENGTH, frequency);\n}\n\nbool mpu_getStandbyXAccelEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_XA_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setStandbyXAccelEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_XA_BIT, enabled);\n}\nbool mpu_getStandbyYAccelEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_YA_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setStandbyYAccelEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_YA_BIT, enabled);\n}\nbool mpu_getStandbyZAccelEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_ZA_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setStandbyZAccelEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_ZA_BIT, enabled);\n}\nbool mpu_getStandbyXGyroEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_XG_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setStandbyXGyroEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_XG_BIT, enabled);\n}\nbool mpu_getStandbyYGyroEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_YG_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setStandbyYGyroEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_YG_BIT, enabled);\n}\nbool mpu_getStandbyZGyroEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_ZG_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setStandbyZGyroEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_ZG_BIT, enabled);\n}\n\n// FIFO_COUNT* registers\n\nuint16_t mpu_getFIFOCount() {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_FIFO_COUNTH, 2, mpu6050.buffer, 0);\nreturn (((uint16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\n\n// FIFO_R_W register\n\nuint8_t mpu_getFIFOByte() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_FIFO_R_W, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_getFIFOBytes(uint8_t* data, uint8_t length) {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_FIFO_R_W, length, data, 0);\n}\nvoid mpu_setFIFOByte(uint8_t data) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_FIFO_R_W, data);\n}\n\n// WHO_AM_I register\n\nuint8_t mpu_getDeviceID() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_WHO_AM_I, mpu_WHO_AM_I_BIT,\nmpu_WHO_AM_I_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setDeviceID(uint8_t id) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_WHO_AM_I, mpu_WHO_AM_I_BIT,\nmpu_WHO_AM_I_LENGTH, id);\n}\n\n// ======== UNDOCUMENTED/DMP REGISTERS/METHODS ========\n\n// XG_OFFS_TC register\n\nuint8_t mpu_getOTPBankValid() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_XG_OFFS_TC, mpu_TC_OTP_BNK_VLD_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setOTPBankValid(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_XG_OFFS_TC, mpu_TC_OTP_BNK_VLD_BIT, enabled);\n}\nint8_t mpu_getXGyroOffsetTC() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_XG_OFFS_TC, mpu_TC_OFFSET_BIT,\nmpu_TC_OFFSET_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setXGyroOffsetTC(int8_t offset) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_XG_OFFS_TC, mpu_TC_OFFSET_BIT,\nmpu_TC_OFFSET_LENGTH, offset);\n}\n\n// YG_OFFS_TC register\n\nint8_t mpu_getYGyroOffsetTC() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_YG_OFFS_TC, mpu_TC_OFFSET_BIT,\nmpu_TC_OFFSET_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setYGyroOffsetTC(int8_t offset) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_YG_OFFS_TC, mpu_TC_OFFSET_BIT,\nmpu_TC_OFFSET_LENGTH, offset);\n}\n\n// ZG_OFFS_TC register\n\nint8_t mpu_getZGyroOffsetTC() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_ZG_OFFS_TC, mpu_TC_OFFSET_BIT,\nmpu_TC_OFFSET_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setZGyroOffsetTC(int8_t offset) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_ZG_OFFS_TC, mpu_TC_OFFSET_BIT,\nmpu_TC_OFFSET_LENGTH, offset);\n}\n\n// X_FINE_GAIN register\n\nint8_t mpu_getXFineGain() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_X_FINE_GAIN, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setXFineGain(int8_t gain) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_X_FINE_GAIN, gain);\n}\n\n// Y_FINE_GAIN register\n\nint8_t mpu_getYFineGain() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_Y_FINE_GAIN, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setYFineGain(int8_t gain) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_Y_FINE_GAIN, gain);\n}\n\n// Z_FINE_GAIN register\n\nint8_t mpu_getZFineGain() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_Z_FINE_GAIN, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setZFineGain(int8_t gain) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_Z_FINE_GAIN, gain);\n}\n\n// XA_OFFS_* registers\n\nint16_t mpu_getXAccelOffset() {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_XA_OFFS_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nvoid mpu_setXAccelOffset(int16_t offset) {\nI2Cdev_writeWord(mpu6050.devAddr, mpu_RA_XA_OFFS_H, offset);\n}\n\n// YA_OFFS_* register\n\nint16_t mpu_getYAccelOffset() {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_YA_OFFS_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nvoid mpu_setYAccelOffset(int16_t offset) {\nI2Cdev_writeWord(mpu6050.devAddr, mpu_RA_YA_OFFS_H, offset);\n}\n\n// ZA_OFFS_* register\n\nint16_t mpu_getZAccelOffset() {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_ZA_OFFS_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nvoid mpu_setZAccelOffset(int16_t offset) {\nI2Cdev_writeWord(mpu6050.devAddr, mpu_RA_ZA_OFFS_H, offset);\n}\n\n// XG_OFFS_USR* registers\n\nint16_t mpu_getXGyroOffset() {\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_XG_OFFS_USRH, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nvoid mpu_setXGyroOffset(int16_t offset) {\nI2Cdev_writeWord(mpu6050.devAddr, mpu_RA_XG_OFFS_USRH, offset);\n}\n\n// YG_OFFS_USR* register\n\nint16_t mpu_getYGyroOffset() {\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_YG_OFFS_USRH, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nvoid mpu_setYGyroOffset(int16_t offset) {\nI2Cdev_writeWord(mpu6050.devAddr, mpu_RA_YG_OFFS_USRH, offset);\n}\n\n// ZG_OFFS_USR* register\n\nint16_t mpu_getZGyroOffset() {\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_ZG_OFFS_USRH, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nvoid mpu_setZGyroOffset(int16_t offset) {\nI2Cdev_writeWord(mpu6050.devAddr, mpu_RA_ZG_OFFS_USRH, offset);\n}\n\n// INT_ENABLE register (DMP functions)\n\nbool mpu_getIntPLLReadyEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_PLL_RDY_INT_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntPLLReadyEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_PLL_RDY_INT_BIT, enabled);\n}\nbool mpu_getIntDMPEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_DMP_INT_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntDMPEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_INT_ENABLE, mpu_INTERRUPT_DMP_INT_BIT, enabled);\n}\n\n// DMP_INT_STATUS\n\nbool mpu_getDMPInt5Status() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_DMP_INT_STATUS, mpu_DMPINT_5_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getDMPInt4Status() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_DMP_INT_STATUS, mpu_DMPINT_4_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getDMPInt3Status() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_DMP_INT_STATUS, mpu_DMPINT_3_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getDMPInt2Status() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_DMP_INT_STATUS, mpu_DMPINT_2_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getDMPInt1Status() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_DMP_INT_STATUS, mpu_DMPINT_1_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getDMPInt0Status() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_DMP_INT_STATUS, mpu_DMPINT_0_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\n\n// INT_STATUS register (DMP functions)\n\nbool mpu_getIntPLLReadyStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_STATUS,\nmpu_INTERRUPT_PLL_RDY_INT_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getIntDMPStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_STATUS,\nmpu_INTERRUPT_DMP_INT_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\n\n// USER_CTRL register (DMP functions)\n\nbool mpu_getDMPEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_USER_CTRL, mpu_USERCTRL_DMP_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setDMPEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_USER_CTRL, mpu_USERCTRL_DMP_EN_BIT, enabled);\n}\nvoid mpu_resetDMP() {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_USER_CTRL, mpu_USERCTRL_DMP_RESET_BIT, true);\n}\n\n// BANK_SEL register\n\nvoid mpu_setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank) {\nbank &amp;= 0x1F;\nif (userBank)\nbank |= 0x20;\nif (prefetchEnabled)\nbank |= 0x40;\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_BANK_SEL, bank);\n}\n\n// MEM_START_ADDR register\n\nvoid mpu_setMemoryStartAddress(uint8_t address) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_MEM_START_ADDR, address);\n}\n\n// MEM_R_W register\n\nuint8_t mpu_readMemoryByte() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_MEM_R_W, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_writeMemoryByte(uint8_t data) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_MEM_R_W, data);\n}\nvoid mpu_readMemoryBlock(\nuint8_t* data, uint16_t dataSize, uint8_t bank, uint8_t address) {\nmpu_setMemoryBank(bank, false, false);\nmpu_setMemoryStartAddress(address);\nuint8_t chunkSize;\nfor (uint16_t i = 0; i &lt; dataSize;) {\n// determine correct chunk size according to bank position and data size\nchunkSize = mpu_DMP_MEMORY_CHUNK_SIZE;\n\n// make sure we don't go past the data size\nif (i + chunkSize &gt; dataSize)\nchunkSize = dataSize - i;\n\n// make sure this chunk doesn't go past the bank boundary (256 bytes)\nif (chunkSize &gt; 256 - address)\nchunkSize = 256 - address;\n\n// read the chunk of data as specified\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_MEM_R_W, chunkSize, data + i, 0);\n\n// increase byte index by [chunkSize]\ni += chunkSize;\n\n// uint8_t automatically wraps to 0 at 256\naddress += chunkSize;\n\n// if we aren't done, update bank (if necessary) and address\nif (i &lt; dataSize) {\nif (address == 0)\nbank++;\nmpu_setMemoryBank(bank, false, false);\nmpu_setMemoryStartAddress(address);\n}\n}\n}\n/*bool mpu_writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem) {\n    mpu_setMemoryBank(bank, false, false);\n    mpu_setMemoryStartAddress(address);\n    uint8_t chunkSize;\n    uint8_t *verifyBuffer;\n    uint8_t *progBuffer;\n    uint16_t i;\n    uint8_t j;\n    if (verify) verifyBuffer = (uint8_t *)malloc(mpu_DMP_MEMORY_CHUNK_SIZE);\n    if (useProgMem) progBuffer = (uint8_t *)malloc(mpu_DMP_MEMORY_CHUNK_SIZE);\n    for (i = 0; i &lt; dataSize;) {\n        // determine correct chunk size according to bank position and data size\n        chunkSize = mpu_DMP_MEMORY_CHUNK_SIZE;\n\n        // make sure we don't go past the data size\n        if (i + chunkSize &gt; dataSize) chunkSize = dataSize - i;\n\n        // make sure this chunk doesn't go past the bank boundary (256 bytes)\n        if (chunkSize &gt; 256 - address) chunkSize = 256 - address;\n\n        if (useProgMem) {\n            // write the chunk of data as specified\n            for (j = 0; j &lt; chunkSize; j++) progBuffer[j] = pgm_read_byte(data + i + j);\n        } else {\n            // write the chunk of data as specified\n            progBuffer = (uint8_t *)data + i;\n        }\n\n        I2Cdev_writeBytes(mpu6050.devAddr, mpu_RA_MEM_R_W, chunkSize, progBuffer);\n\n        // verify data if needed\n        if (verify &amp;&amp; verifyBuffer) {\n            mpu_setMemoryBank(bank, false, false);\n            mpu_setMemoryStartAddress(address);\n            I2Cdev_readBytes(mpu6050.devAddr, mpu_RA_MEM_R_W, chunkSize, verifyBuffer);\n            if (memcmp(progBuffer, verifyBuffer, chunkSize) != 0) {\n                //Serial.print(\"Block write verification error, bank \");\n                //Serial.print(bank, DEC);\n                //Serial.print(\", address \");\n                //Serial.print(address, DEC);\n                //Serial.print(\"!\\nExpected:\");\n                //for (j = 0; j &lt; chunkSize; j++) {\n                //    Serial.print(\" 0x\");\n                //    if (progBuffer[j] &lt; 16) Serial.print(\"0\");\n                //    Serial.print(progBuffer[j], HEX);\n                //}\n                //Serial.print(\"\\nReceived:\");\n                //for (uint8_t j = 0; j &lt; chunkSize; j++) {\n                //    Serial.print(\" 0x\");\n                //    if (verifyBuffer[i + j] &lt; 16) Serial.print(\"0\");\n                //    Serial.print(verifyBuffer[i + j], HEX);\n                //}\n                Serial.print(\"\\n\");\n                free(verifyBuffer);\n                if (useProgMem) free(progBuffer);\n                return false; // uh oh.\n            }\n        }\n\n        // increase byte index by [chunkSize]\n        i += chunkSize;\n\n        // uint8_t automatically wraps to 0 at 256\n        address += chunkSize;\n\n        // if we aren't done, update bank (if necessary) and address\n        if (i &lt; dataSize) {\n            if (address == 0) bank++;\n            mpu_setMemoryBank(bank, false, false);\n            mpu_setMemoryStartAddress(address);\n        }\n    }\n    if (verify) free(verifyBuffer);\n    if (useProgMem) free(progBuffer);\n    return true;\n}\nbool mpu_writeProgMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify) {\n    return mpu_writeMemoryBlock(data, dataSize, bank, address, verify, true);\n}\nbool mpu_writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize, bool useProgMem) {\n    uint8_t *progBuffer, success, special;\n    uint16_t i, j;\n    if (useProgMem) {\n        progBuffer = (uint8_t *)malloc(8); // assume 8-byte blocks, realloc later if necessary\n    }\n\n    // config set data is a long string of blocks with the following structure:\n    // [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]\n    uint8_t bank, offset, length;\n    for (i = 0; i &lt; dataSize;) {\n        if (useProgMem) {\n            bank = pgm_read_byte(data + i++);\n            offset = pgm_read_byte(data + i++);\n            length = pgm_read_byte(data + i++);\n        } else {\n            bank = data[i++];\n            offset = data[i++];\n            length = data[i++];\n        }\n\n        // write data or perform special action\n        if (length &gt; 0) {\n            // regular block of data to write\n            //Serial.print(\"Writing config block to bank \");\n            //Serial.print(bank);\n            //Serial.print(\", offset \");\n            //Serial.print(offset);\n            //Serial.print(\", length=\");\n            //Serial.println(length);\n            if (useProgMem) {\n                if (sizeof(progBuffer) &lt; length) progBuffer = (uint8_t *)realloc(progBuffer, length);\n                for (j = 0; j &lt; length; j++) progBuffer[j] = pgm_read_byte(data + i + j);\n            } else {\n                progBuffer = (uint8_t *)data + i;\n            }\n            success = mpu_writeMemoryBlock(progBuffer, length, bank, offset, true);\n            i += length;\n        } else {\n            // special instruction\n            // NOTE: this kind of behavior (what and when to do certain things)\n            // is totally undocumented. This code is in here based on observed\n            // behavior only, and exactly why (or even whether) it has to be here\n            // is anybody's guess for now.\n            if (useProgMem) {\n                special = pgm_read_byte(data + i++);\n            } else {\n                special = data[i++];\n            }\n            //Serial.print(\"Special command code \");\n            //Serial.print(special, HEX);\n            //Serial.println(\" found...\");\n            if (special == 0x01) {\n                // enable DMP-related interrupts\n\n                //setIntZeroMotionEnabled(true);\n                //setIntFIFOBufferOverflowEnabled(true);\n                //setIntDMPEnabled(true);\n                I2Cdev_writeByte(mpu6050.devAddr, mpu_RA_INT_ENABLE, 0x32);  // single operation\n\n                success = true;\n            } else {\n                // unknown special command\n                success = false;\n            }\n        }\n\n        if (!success) {\n            if (useProgMem) free(progBuffer);\n            return false; // uh oh\n        }\n    }\n    if (useProgMem) free(progBuffer);\n    return true;\n}\nbool mpu_writeProgDMPConfigurationSet(const uint8_t *data, uint16_t dataSize) {\n    return mpu_writeDMPConfigurationSet(data, dataSize, true);\n}*/\n\n// DMP_CFG_1 register\n\nuint8_t mpu_getDMPConfig1() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_DMP_CFG_1, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setDMPConfig1(uint8_t config) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_DMP_CFG_1, config);\n}\n\n// DMP_CFG_2 register\n\nuint8_t mpu_getDMPConfig2() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_DMP_CFG_2, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setDMPConfig2(uint8_t config) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_DMP_CFG_2, config);\n}\n</code></pre>"},{"location":"stm/OledController_8cpp/","title":"File OledController.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; OledController.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"OledController.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"string.h\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include &lt;math.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> </ul>"},{"location":"stm/OledController_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name OLED_t OLED uint8_t OLED_Buffer uint8_t oled_height   = = 64 uint8_t oled_width   = = 128"},{"location":"stm/OledController_8cpp/#public-functions","title":"Public Functions","text":"Type Name void oledDispatch (const CoprocReq_OledReq &amp; request)  void oledDrawArc (uint8_t x, uint8_t y, uint8_t radius, uint16_t start_angle, uint16_t sweep, OLED_COLOR color)  void oledDrawCircle (uint8_t par_x, uint8_t par_y, uint8_t par_r, OLED_COLOR par_color)  void oledDrawLine (uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_COLOR color)  void oledDrawPixel (uint8_t x, uint8_t y, OLED_COLOR color)  void oledDrawRectangle (uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_COLOR color)  void oledFill (OLED_COLOR color)  OLED_Error_t oledFillBuffer (uint8_t * buf, uint32_t len)  bool oledGetDisplayOn () Reads DisplayOn state. void oledInit (const CoprocReq_OledInit &amp; init)  void oledPolyline (const OLED_VERTEX * par_vertex, uint16_t par_size, OLED_COLOR color)  void oledSetContrast (const uint8_t value) Sets the contrast of the display. void oledSetCursor (uint8_t x, uint8_t y)  void oledSetDisplayOn (const bool on) Set Display ON/OFF. bool oledTestConnection ()  void oledUpdateScreen (void)  char oledWriteChar (char ch, FontDef Font, OLED_COLOR color)  void oledWriteCommand (uint8_t byte)  void oledWriteData (uint8_t * buffer, size_t buff_size)  char oledWriteString (const char * str, FontDef Font, OLED_COLOR color)"},{"location":"stm/OledController_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name float oledDegToRad (float par_deg)  uint16_t oledNormalizeTo0_360 (uint16_t par_deg)"},{"location":"stm/OledController_8cpp/#macros","title":"Macros","text":"Type Name define CIRCLE_APPROXIMATION_SEGMENTS  36"},{"location":"stm/OledController_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/OledController_8cpp/#variable-oled","title":"variable OLED","text":"<pre><code>OLED_t OLED;\n</code></pre>"},{"location":"stm/OledController_8cpp/#variable-oled_buffer","title":"variable OLED_Buffer","text":"<pre><code>uint8_t OLED_Buffer[OLED_BUFFER_SIZE];\n</code></pre>"},{"location":"stm/OledController_8cpp/#variable-oled_height","title":"variable oled_height","text":"<pre><code>uint8_t oled_height;\n</code></pre>"},{"location":"stm/OledController_8cpp/#variable-oled_width","title":"variable oled_width","text":"<pre><code>uint8_t oled_width;\n</code></pre>"},{"location":"stm/OledController_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/OledController_8cpp/#function-oleddispatch","title":"function oledDispatch","text":"<pre><code>void oledDispatch (\nconst CoprocReq_OledReq &amp; request\n) </code></pre>"},{"location":"stm/OledController_8cpp/#function-oleddrawarc","title":"function oledDrawArc","text":"<pre><code>void oledDrawArc (\nuint8_t x,\nuint8_t y,\nuint8_t radius,\nuint16_t start_angle,\nuint16_t sweep,\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8cpp/#function-oleddrawcircle","title":"function oledDrawCircle","text":"<pre><code>void oledDrawCircle (\nuint8_t par_x,\nuint8_t par_y,\nuint8_t par_r,\nOLED_COLOR par_color\n) </code></pre>"},{"location":"stm/OledController_8cpp/#function-oleddrawline","title":"function oledDrawLine","text":"<pre><code>void oledDrawLine (\nuint8_t x1,\nuint8_t y1,\nuint8_t x2,\nuint8_t y2,\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8cpp/#function-oleddrawpixel","title":"function oledDrawPixel","text":"<pre><code>void oledDrawPixel (\nuint8_t x,\nuint8_t y,\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8cpp/#function-oleddrawrectangle","title":"function oledDrawRectangle","text":"<pre><code>void oledDrawRectangle (\nuint8_t x1,\nuint8_t y1,\nuint8_t x2,\nuint8_t y2,\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8cpp/#function-oledfill","title":"function oledFill","text":"<pre><code>void oledFill (\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8cpp/#function-oledfillbuffer","title":"function oledFillBuffer","text":"<pre><code>OLED_Error_t oledFillBuffer (\nuint8_t * buf,\nuint32_t len\n) </code></pre>"},{"location":"stm/OledController_8cpp/#function-oledgetdisplayon","title":"function oledGetDisplayOn","text":"<p>Reads DisplayOn state. <pre><code>bool oledGetDisplayOn () </code></pre></p> <p>Returns:</p> <p>0: OFF. 1: ON. </p>"},{"location":"stm/OledController_8cpp/#function-oledinit","title":"function oledInit","text":"<pre><code>void oledInit (\nconst CoprocReq_OledInit &amp; init\n) </code></pre>"},{"location":"stm/OledController_8cpp/#function-oledpolyline","title":"function oledPolyline","text":"<pre><code>void oledPolyline (\nconst OLED_VERTEX * par_vertex,\nuint16_t par_size,\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8cpp/#function-oledsetcontrast","title":"function oledSetContrast","text":"<p>Sets the contrast of the display. <pre><code>void oledSetContrast (\nconst uint8_t value\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>value</code> contrast to set. </li> </ul> <p>Note:</p> <p>Contrast increases as the value increases. </p> <p>Note:</p> <p>RESET = 7Fh. </p>"},{"location":"stm/OledController_8cpp/#function-oledsetcursor","title":"function oledSetCursor","text":"<pre><code>void oledSetCursor (\nuint8_t x,\nuint8_t y\n) </code></pre>"},{"location":"stm/OledController_8cpp/#function-oledsetdisplayon","title":"function oledSetDisplayOn","text":"<p>Set Display ON/OFF. <pre><code>void oledSetDisplayOn (\nconst bool on\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>on</code> 0 for OFF, any for ON. </li> </ul>"},{"location":"stm/OledController_8cpp/#function-oledtestconnection","title":"function oledTestConnection","text":"<pre><code>bool oledTestConnection () </code></pre>"},{"location":"stm/OledController_8cpp/#function-oledupdatescreen","title":"function oledUpdateScreen","text":"<pre><code>void oledUpdateScreen (\nvoid\n) </code></pre>"},{"location":"stm/OledController_8cpp/#function-oledwritechar","title":"function oledWriteChar","text":"<pre><code>char oledWriteChar (\nchar ch,\nFontDef Font,\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8cpp/#function-oledwritecommand","title":"function oledWriteCommand","text":"<pre><code>void oledWriteCommand (\nuint8_t byte\n) </code></pre>"},{"location":"stm/OledController_8cpp/#function-oledwritedata","title":"function oledWriteData","text":"<pre><code>void oledWriteData (\nuint8_t * buffer,\nsize_t buff_size\n) </code></pre>"},{"location":"stm/OledController_8cpp/#function-oledwritestring","title":"function oledWriteString","text":"<pre><code>char oledWriteString (\nconst char * str,\nFontDef Font,\nOLED_COLOR color\n) </code></pre>"},{"location":"stm/OledController_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"stm/OledController_8cpp/#function-oleddegtorad","title":"function oledDegToRad","text":"<pre><code>static float oledDegToRad (\nfloat par_deg\n) </code></pre>"},{"location":"stm/OledController_8cpp/#function-olednormalizeto0_360","title":"function oledNormalizeTo0_360","text":"<pre><code>static uint16_t oledNormalizeTo0_360 (\nuint16_t par_deg\n) </code></pre>"},{"location":"stm/OledController_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"stm/OledController_8cpp/#define-circle_approximation_segments","title":"define CIRCLE_APPROXIMATION_SEGMENTS","text":"<pre><code>#define CIRCLE_APPROXIMATION_SEGMENTS 36\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/OledController.cpp</code></p>"},{"location":"stm/OledController_8cpp_source/","title":"File OledController.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; OledController.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"OledController.hpp\"\n#include \"Dispatcher.hpp\"\n#include \"string.h\"\n#include \"utils/Debug.hpp\"\n#include &lt;math.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt; // For memcpy\n\n// OLED OLED height in pixels\nstatic uint8_t oled_height = 64;\n\n// OLED width in pixels\nstatic uint8_t oled_width = 128;\n\n// Screenbuffer\nstatic uint8_t OLED_Buffer[OLED_BUFFER_SIZE];\n\n// Screen object\nstatic OLED_t OLED;\n\nvoid oledDispatch(const CoprocReq_OledReq&amp; request) {\nswitch (request.which_oledCmd) {\ncase CoprocReq_OledReq_init_tag:\noledInit(request.oledCmd.init);\nbreak;\n\ncase CoprocReq_OledReq_fill_tag:\noledFill(OLED_COLOR(request.oledCmd.fill));\nbreak;\n\ncase CoprocReq_OledReq_update_tag:\noledUpdateScreen();\nbreak;\n\ncase CoprocReq_OledReq_drawPixel_tag: {\nconst auto&amp; drawPixel = request.oledCmd.drawPixel;\noledDrawPixel(drawPixel.x, drawPixel.y, OLED_COLOR(drawPixel.color));\nbreak;\n}\ncase CoprocReq_OledReq_writeString_tag: {\n\nconst auto&amp; writeString = request.oledCmd.writeString;\nchar text[33];\nstrcpy(text, writeString.text);\nFontDef* font;\nswitch (writeString.font) {\ncase CoprocReq_OledFont_OLED_FONT_6X8:\nfont = &amp;Font_6x8;\nbreak;\ncase CoprocReq_OledFont_OLED_FONT_7X10:\nfont = &amp;Font_7x10;\nbreak;\ncase CoprocReq_OledFont_OLED_FONT_11X18:\nfont = &amp;Font_11x18;\nbreak;\ncase CoprocReq_OledFont_OLED_FONT_16X26:\nfont = &amp;Font_16x26;\nbreak;\ndefault:\nfont = &amp;Font_7x10;\n}\noledWriteString(text, *font, OLED_COLOR(writeString.color));\nbreak;\n}\ncase CoprocReq_OledReq_setCursor_tag: {\nconst auto&amp; setCursor = request.oledCmd.setCursor;\noledSetCursor(setCursor.x, setCursor.y);\nbreak;\n}\n\ncase CoprocReq_OledReq_drawLine_tag: {\nconst auto&amp; drawLine = request.oledCmd.drawLine;\noledDrawLine(drawLine.x1, drawLine.y1, drawLine.x2, drawLine.y2,\nOLED_COLOR(drawLine.color));\nbreak;\n}\n\ncase CoprocReq_OledReq_drawArc_tag: {\nconst auto&amp; drawArc = request.oledCmd.drawArc;\noledDrawArc(drawArc.x, drawArc.y, drawArc.radius, drawArc.start_angle,\ndrawArc.sweep, OLED_COLOR(drawArc.color));\nbreak;\n}\n\ncase CoprocReq_OledReq_drawCircle_tag: {\nconst auto&amp; drawCircle = request.oledCmd.drawCircle;\noledDrawCircle(drawCircle.x, drawCircle.y, drawCircle.radius,\nOLED_COLOR(drawCircle.color));\nbreak;\n}\n\ncase CoprocReq_OledReq_drawRectangle_tag: {\nconst auto&amp; drawRectangle = request.oledCmd.drawRectangle;\noledDrawRectangle(drawRectangle.x1, drawRectangle.y1, drawRectangle.x2,\ndrawRectangle.y2, OLED_COLOR(drawRectangle.color));\nbreak;\n}\n};\n}\n\nbool oledTestConnection() { return I2Cdev_IsDeviceReady(OLED_I2C_ADDR, 1, 10); }\n\n// Initialize the oled screen\nvoid oledInit(const CoprocReq_OledInit&amp; init) {\n\nif (oledTestConnection()) {\n// Init OLED\noledSetDisplayOn(false); //display off\n\noledWriteCommand(0x20); //Set Memory Addressing Mode\noledWriteCommand(\n0x00); // 00b,Horizontal Addressing Mode; 01b,Vertical Addressing Mode;\n// 10b,Page Addressing Mode (RESET); 11b,Invalid\n\noledWriteCommand(\n0xB0); //Set Page Start Address for Page Addressing Mode,0-7\n\nif (init.rotate) {\noledWriteCommand(0xC0); // Mirror vertically\n} else {\noledWriteCommand(0xC8); //Set COM Output Scan Direction\n}\n\noledWriteCommand(0x00); //---set low column address\noledWriteCommand(0x10); //---set high column address\n\noledWriteCommand(0x40); //--set start line address - CHECK\n\noledSetContrast(0xFF);\n\nif (init.rotate) {\noledWriteCommand(0xA0); // Mirror horizontally\n} else {\noledWriteCommand(0xA1); //--set segment re-map 0 to 127 - CHECK\n}\n\nif (init.inverseColor) {\noledWriteCommand(0xA7); //--set inverse color\n} else {\noledWriteCommand(0xA6); //--set normal color\n}\n\noledWriteCommand(0xA8); //--set multiplex ratio(1 to 64) - CHECK\n\nif (init.height == 32) {\noledWriteCommand(0x1F); //\n} else if (init.height == 64) {\noledWriteCommand(0x3F); //\n} else {\n//TO DO warning message\n}\n\noledWriteCommand(\n0xA4); //0xa4,Output follows RAM content;0xa5,Output ignores RAM content\n\noledWriteCommand(0xD3); //-set display offset - CHECK\noledWriteCommand(0x00); //-not offset\n\noledWriteCommand(\n0xD5); //--set display clock divide ratio/oscillator frequency\noledWriteCommand(0xF0); //--set divide ratio\n\noledWriteCommand(0xD9); //--set pre-charge period\noledWriteCommand(0x22); //\n\noledWriteCommand(0xDA); //--set com pins hardware configuration - CHECK\n\nif (init.height == 32) {\noledWriteCommand(0x02);\n} else if (init.height == 64) {\noledWriteCommand(0x12);\n} else {\n//TO DO warning message\n}\n\noledWriteCommand(0xDB); //--set vcomh\noledWriteCommand(0x20); //0x20,0.77xVcc\n\noledWriteCommand(0x8D); //--set DC-DC enable\noledWriteCommand(0x14); //\noledSetDisplayOn(true); //--turn on OLED panel\n\n// Clear screen\noledFill(Black);\n\n// Flush buffer to screen\noledUpdateScreen();\n\n// Set default values for screen object\nOLED.CurrentX = 0;\nOLED.CurrentY = 0;\n\n} else {\nDEBUG(\"Oled not connected-init\\n\");\nCoprocStat status = {\n.which_payload = CoprocStat_faultStat_tag,\n.payload = {\n.faultStat = {\n.which_fault = CoprocStat_FaultStat_oledFault_tag,\n},\n},\n};\ndispatcherEnqueueStatus(status);\n}\n}\n\n// Fill the whole screen with the given color\nvoid oledFill(OLED_COLOR color) {\n/* Set memory */\nuint32_t i;\n\nfor (i = 0; i &lt; sizeof(OLED_Buffer); i++) {\nOLED_Buffer[i] = (color == Black) ? 0x00 : 0xFF;\n}\n}\n\n// Write the screenbuffer with changed to the screen\nvoid oledUpdateScreen(void) {\nif (!oledTestConnection()) {\nDEBUG(\"Oled not connected\\n\");\nCoprocStat status = {\n.which_payload = CoprocStat_faultStat_tag,\n.payload = {\n.faultStat = {\n.which_fault = CoprocStat_FaultStat_oledFault_tag,\n},\n},\n};\ndispatcherEnqueueStatus(status);\n}\n// Write data to each page of RAM. Number of pages\n// depends on the screen height:\n//\n//  * 32px   ==  4 pages\n//  * 64px   ==  8 pages\n//  * 128px  ==  16 pages\nfor (uint8_t i = 0; i &lt; oled_height / 8; i++) {\noledWriteCommand(0xB0 + i); // Set the current RAM page address.\noledWriteCommand(0x00);\noledWriteCommand(0x10);\noledWriteData(&amp;OLED_Buffer[oled_width * i], oled_width);\n}\n}\n\n//    Draw one pixel in the screenbuffer\n//    X =&gt; X Coordinate\n//    Y =&gt; Y Coordinate\n//    color =&gt; Pixel color\nvoid oledDrawPixel(uint8_t x, uint8_t y, OLED_COLOR color) {\nif (x &gt;= oled_width || y &gt;= oled_height) {\n// Don't write outside the buffer\nreturn;\n}\n\n// Check if pixel should be inverted\nif (OLED.Inverted) {\ncolor = (OLED_COLOR)!color;\n}\n\n// Draw in the right color\nif (color == White) {\nOLED_Buffer[x + (y / 8) * oled_width] |= 1 &lt;&lt; (y % 8);\n} else {\nOLED_Buffer[x + (y / 8) * oled_width] &amp;= ~(1 &lt;&lt; (y % 8));\n}\n}\n\n// Draw 1 char to the screen buffer\n// ch       =&gt; char om weg te schrijven\n// Font     =&gt; Font waarmee we gaan schrijven\n// color    =&gt; Black or White\nchar oledWriteChar(char ch, FontDef Font, OLED_COLOR color) {\nuint32_t i, b, j;\n\n// Check if character is valid\nif (ch &lt; 32 || ch &gt; 126)\nreturn 0;\n\n// Check remaining space on current line\nif (oled_width &lt; (OLED.CurrentX + Font.FontWidth)\n|| oled_height &lt; (OLED.CurrentY + Font.FontHeight)) {\n// Not enough space on current line\nreturn 0;\n}\n\n// Use the font to write\nfor (i = 0; i &lt; Font.FontHeight; i++) {\nb = Font.data[(ch - 32) * Font.FontHeight + i];\nfor (j = 0; j &lt; Font.FontWidth; j++) {\nif ((b &lt;&lt; j) &amp; 0x8000) {\noledDrawPixel(\nOLED.CurrentX + j, (OLED.CurrentY + i), (OLED_COLOR)color);\n} else {\noledDrawPixel(\nOLED.CurrentX + j, (OLED.CurrentY + i), (OLED_COLOR)!color);\n}\n}\n}\n\n// The current space is now taken\nOLED.CurrentX += Font.FontWidth;\n\n// Return written char for validation\nreturn ch;\n}\n\n// Write full string to screenbuffer\nchar oledWriteString(const char* str, FontDef Font, OLED_COLOR color) {\n// Write until null-byte\nwhile (*str) {\nif (oledWriteChar(*str, Font, color) != *str) {\n// Char could not be written\nreturn *str;\n}\n\n// Next char\nstr++;\n}\n\n// Everything ok\nreturn *str;\n}\n\n// Position the cursor\nvoid oledSetCursor(uint8_t x, uint8_t y) {\nOLED.CurrentX = x;\nOLED.CurrentY = y;\n}\n\n// Draw line by Bresenhem's algorithm\nvoid oledDrawLine(\nuint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_COLOR color) {\nint32_t deltaX = abs(x2 - x1);\nint32_t deltaY = abs(y2 - y1);\nint32_t signX = ((x1 &lt; x2) ? 1 : -1);\nint32_t signY = ((y1 &lt; y2) ? 1 : -1);\nint32_t error = deltaX - deltaY;\nint32_t error2;\n\noledDrawPixel(x2, y2, color);\nwhile ((x1 != x2) || (y1 != y2)) {\noledDrawPixel(x1, y1, color);\nerror2 = error * 2;\nif (error2 &gt; -deltaY) {\nerror -= deltaY;\nx1 += signX;\n} else {\n/*nothing to do*/\n}\n\nif (error2 &lt; deltaX) {\nerror += deltaX;\ny1 += signY;\n} else {\n/*nothing to do*/\n}\n}\nreturn;\n}\n//Draw polyline\nvoid oledPolyline(\nconst OLED_VERTEX* par_vertex, uint16_t par_size, OLED_COLOR color) {\nuint16_t i;\nif (par_vertex != 0) {\nfor (i = 1; i &lt; par_size; i++) {\noledDrawLine(par_vertex[i - 1].x, par_vertex[i - 1].y,\npar_vertex[i].x, par_vertex[i].y, color);\n}\n} else {\n/*nothing to do*/\n}\nreturn;\n}\n/*Convert Degrees to Radians*/\nstatic float oledDegToRad(float par_deg) { return par_deg * 3.14 / 180.0; }\n/*Normalize degree to [0;360]*/\nstatic uint16_t oledNormalizeTo0_360(uint16_t par_deg) {\nuint16_t loc_angle;\nif (par_deg &lt;= 360) {\nloc_angle = par_deg;\n} else {\nloc_angle = par_deg % 360;\nloc_angle = ((par_deg != 0) ? par_deg : 360);\n}\nreturn loc_angle;\n}\n/*DrawArc. Draw angle is beginning from 4 quart of trigonometric circle (3pi/2)\n * start_angle in degree\n * sweep in degree\n */\nvoid oledDrawArc(uint8_t x, uint8_t y, uint8_t radius, uint16_t start_angle,\nuint16_t sweep, OLED_COLOR color) {\n#define CIRCLE_APPROXIMATION_SEGMENTS 36\nfloat approx_degree;\nuint32_t approx_segments;\nuint8_t xp1, xp2;\nuint8_t yp1, yp2;\nuint32_t count = 0;\nuint32_t loc_sweep = 0;\nfloat rad;\n\nloc_sweep = oledNormalizeTo0_360(sweep);\n\ncount = (oledNormalizeTo0_360(start_angle) * CIRCLE_APPROXIMATION_SEGMENTS)\n/ 360;\napprox_segments = (loc_sweep * CIRCLE_APPROXIMATION_SEGMENTS) / 360;\napprox_degree = loc_sweep / (float)approx_segments;\nwhile (count &lt; approx_segments) {\nrad = oledDegToRad(count * approx_degree);\nxp1 = x + (int8_t)(sin(rad) * radius);\nyp1 = y + (int8_t)(cos(rad) * radius);\ncount++;\nif (count != approx_segments) {\nrad = oledDegToRad(count * approx_degree);\n} else {\nrad = oledDegToRad(loc_sweep);\n}\nxp2 = x + (int8_t)(sin(rad) * radius);\nyp2 = y + (int8_t)(cos(rad) * radius);\noledDrawLine(xp1, yp1, xp2, yp2, color);\n}\n\nreturn;\n}\n//Draw circle by Bresenhem's algorithm\nvoid oledDrawCircle(\nuint8_t par_x, uint8_t par_y, uint8_t par_r, OLED_COLOR par_color) {\nint32_t x = -par_r;\nint32_t y = 0;\nint32_t err = 2 - 2 * par_r;\nint32_t e2;\n\nif (par_x &gt;= oled_width || par_y &gt;= oled_height) {\nreturn;\n}\n\ndo {\noledDrawPixel(par_x - x, par_y + y, par_color);\noledDrawPixel(par_x + x, par_y + y, par_color);\noledDrawPixel(par_x + x, par_y - y, par_color);\noledDrawPixel(par_x - x, par_y - y, par_color);\ne2 = err;\nif (e2 &lt;= y) {\ny++;\nerr = err + (y * 2 + 1);\nif (-x == y &amp;&amp; e2 &lt;= x) {\ne2 = 0;\n} else {\n/*nothing to do*/\n}\n} else {\n/*nothing to do*/\n}\nif (e2 &gt; x) {\nx++;\nerr = err + (x * 2 + 1);\n} else {\n/*nothing to do*/\n}\n} while (x &lt;= 0);\n\nreturn;\n}\n\n//Draw rectangle\nvoid oledDrawRectangle(\nuint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_COLOR color) {\noledDrawLine(x1, y1, x2, y1, color);\noledDrawLine(x2, y1, x2, y2, color);\noledDrawLine(x2, y2, x1, y2, color);\noledDrawLine(x1, y2, x1, y1, color);\n\nreturn;\n}\n\nvoid oledSetContrast(const uint8_t value) {\nconst uint8_t kSetContrastControlRegister = 0x81;\noledWriteCommand(kSetContrastControlRegister);\noledWriteCommand(value);\n}\n\nvoid oledSetDisplayOn(const bool on) {\nuint8_t value;\nif (on) {\nvalue = 0xAF; // Display on\nOLED.DisplayOn = true;\n} else {\nvalue = 0xAE; // Display off\nOLED.DisplayOn = false;\n}\noledWriteCommand(value);\n}\n\nbool oledGetDisplayOn() { return OLED.DisplayOn; }\n\n// Send a byte to the command register\nvoid oledWriteCommand(uint8_t byte) {\nI2Cdev_Mem_Write(OLED_I2C_ADDR, 0x00, 1, &amp;byte, 1, HAL_MAX_DELAY);\n}\n\n// Send data\nvoid oledWriteData(uint8_t* buffer, size_t buff_size) {\nI2Cdev_Mem_Write(OLED_I2C_ADDR, 0x40, 1, buffer, buff_size, HAL_MAX_DELAY);\n}\n\n/* Fills the Screenbuffer with values from a given buffer of a fixed length */\nOLED_Error_t oledFillBuffer(uint8_t* buf, uint32_t len) {\nOLED_Error_t ret = OLED_ERR;\nif (len &lt;= OLED_BUFFER_SIZE) {\nmemcpy(OLED_Buffer, buf, len);\nret = OLED_OK;\n}\nreturn ret;\n}\n</code></pre>"},{"location":"stm/OledController__fonts_8cpp/","title":"File OledController_fonts.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; OledController_fonts.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"OledController_fonts.hpp\"</code></li> </ul>"},{"location":"stm/OledController__fonts_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name FontDef Font_11x18   = = { 11, 18, Font11x18 } FontDef Font_16x26   = = { 16, 26, Font16x26 } FontDef Font_6x8   = = { 6, 8, Font6x8 } FontDef Font_7x10   = = { 7, 10, Font7x10 }"},{"location":"stm/OledController__fonts_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const uint16_t Font11x18 const uint16_t Font16x26 const uint16_t Font6x8 const uint16_t Font7x10"},{"location":"stm/OledController__fonts_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/OledController__fonts_8cpp/#variable-font_11x18","title":"variable Font_11x18","text":"<pre><code>FontDef Font_11x18;\n</code></pre>"},{"location":"stm/OledController__fonts_8cpp/#variable-font_16x26","title":"variable Font_16x26","text":"<pre><code>FontDef Font_16x26;\n</code></pre>"},{"location":"stm/OledController__fonts_8cpp/#variable-font_6x8","title":"variable Font_6x8","text":"<pre><code>FontDef Font_6x8;\n</code></pre>"},{"location":"stm/OledController__fonts_8cpp/#variable-font_7x10","title":"variable Font_7x10","text":"<pre><code>FontDef Font_7x10;\n</code></pre>"},{"location":"stm/OledController__fonts_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/OledController__fonts_8cpp/#variable-font11x18","title":"variable Font11x18","text":"<pre><code>const uint16_t Font11x18[];\n</code></pre>"},{"location":"stm/OledController__fonts_8cpp/#variable-font16x26","title":"variable Font16x26","text":"<pre><code>const uint16_t Font16x26[];\n</code></pre>"},{"location":"stm/OledController__fonts_8cpp/#variable-font6x8","title":"variable Font6x8","text":"<pre><code>const uint16_t Font6x8[];\n</code></pre>"},{"location":"stm/OledController__fonts_8cpp/#variable-font7x10","title":"variable Font7x10","text":"<pre><code>const uint16_t Font7x10[];\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/OledController_fonts.cpp</code></p>"},{"location":"stm/OledController__fonts_8cpp_source/","title":"File OledController_fonts.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; OledController_fonts.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"OledController_fonts.hpp\"\n\nstatic const uint16_t Font7x10[] = {\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // sp\n0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x1000, 0x0000,\n0x0000, // !\n0x2800, 0x2800, 0x2800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // \"\n0x2400, 0x2400, 0x7C00, 0x2400, 0x4800, 0x7C00, 0x4800, 0x4800, 0x0000,\n0x0000, // #\n0x3800, 0x5400, 0x5000, 0x3800, 0x1400, 0x5400, 0x5400, 0x3800, 0x1000,\n0x0000, // $\n0x2000, 0x5400, 0x5800, 0x3000, 0x2800, 0x5400, 0x1400, 0x0800, 0x0000,\n0x0000, // %\n0x1000, 0x2800, 0x2800, 0x1000, 0x3400, 0x4800, 0x4800, 0x3400, 0x0000,\n0x0000, // &amp;\n0x1000, 0x1000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // '\n0x0800, 0x1000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x1000,\n0x0800, // (\n0x2000, 0x1000, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x1000,\n0x2000, // )\n0x1000, 0x3800, 0x1000, 0x2800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // *\n0x0000, 0x0000, 0x1000, 0x1000, 0x7C00, 0x1000, 0x1000, 0x0000, 0x0000,\n0x0000, // +\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x1000,\n0x1000, // ,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3800, 0x0000, 0x0000, 0x0000,\n0x0000, // -\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x0000,\n0x0000, // .\n0x0800, 0x0800, 0x1000, 0x1000, 0x1000, 0x1000, 0x2000, 0x2000, 0x0000,\n0x0000, // /\n0x3800, 0x4400, 0x4400, 0x5400, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000,\n0x0000, // 0\n0x1000, 0x3000, 0x5000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000,\n0x0000, // 1\n0x3800, 0x4400, 0x4400, 0x0400, 0x0800, 0x1000, 0x2000, 0x7C00, 0x0000,\n0x0000, // 2\n0x3800, 0x4400, 0x0400, 0x1800, 0x0400, 0x0400, 0x4400, 0x3800, 0x0000,\n0x0000, // 3\n0x0800, 0x1800, 0x2800, 0x2800, 0x4800, 0x7C00, 0x0800, 0x0800, 0x0000,\n0x0000, // 4\n0x7C00, 0x4000, 0x4000, 0x7800, 0x0400, 0x0400, 0x4400, 0x3800, 0x0000,\n0x0000, // 5\n0x3800, 0x4400, 0x4000, 0x7800, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000,\n0x0000, // 6\n0x7C00, 0x0400, 0x0800, 0x1000, 0x1000, 0x2000, 0x2000, 0x2000, 0x0000,\n0x0000, // 7\n0x3800, 0x4400, 0x4400, 0x3800, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000,\n0x0000, // 8\n0x3800, 0x4400, 0x4400, 0x4400, 0x3C00, 0x0400, 0x4400, 0x3800, 0x0000,\n0x0000, // 9\n0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x0000,\n0x0000, // :\n0x0000, 0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000, 0x1000, 0x1000,\n0x1000, // ;\n0x0000, 0x0000, 0x0C00, 0x3000, 0x4000, 0x3000, 0x0C00, 0x0000, 0x0000,\n0x0000, // &lt;\n0x0000, 0x0000, 0x0000, 0x7C00, 0x0000, 0x7C00, 0x0000, 0x0000, 0x0000,\n0x0000, // =\n0x0000, 0x0000, 0x6000, 0x1800, 0x0400, 0x1800, 0x6000, 0x0000, 0x0000,\n0x0000, // &gt;\n0x3800, 0x4400, 0x0400, 0x0800, 0x1000, 0x1000, 0x0000, 0x1000, 0x0000,\n0x0000, // ?\n0x3800, 0x4400, 0x4C00, 0x5400, 0x5C00, 0x4000, 0x4000, 0x3800, 0x0000,\n0x0000, // @\n0x1000, 0x2800, 0x2800, 0x2800, 0x2800, 0x7C00, 0x4400, 0x4400, 0x0000,\n0x0000, // A\n0x7800, 0x4400, 0x4400, 0x7800, 0x4400, 0x4400, 0x4400, 0x7800, 0x0000,\n0x0000, // B\n0x3800, 0x4400, 0x4000, 0x4000, 0x4000, 0x4000, 0x4400, 0x3800, 0x0000,\n0x0000, // C\n0x7000, 0x4800, 0x4400, 0x4400, 0x4400, 0x4400, 0x4800, 0x7000, 0x0000,\n0x0000, // D\n0x7C00, 0x4000, 0x4000, 0x7C00, 0x4000, 0x4000, 0x4000, 0x7C00, 0x0000,\n0x0000, // E\n0x7C00, 0x4000, 0x4000, 0x7800, 0x4000, 0x4000, 0x4000, 0x4000, 0x0000,\n0x0000, // F\n0x3800, 0x4400, 0x4000, 0x4000, 0x5C00, 0x4400, 0x4400, 0x3800, 0x0000,\n0x0000, // G\n0x4400, 0x4400, 0x4400, 0x7C00, 0x4400, 0x4400, 0x4400, 0x4400, 0x0000,\n0x0000, // H\n0x3800, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x3800, 0x0000,\n0x0000, // I\n0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x4400, 0x3800, 0x0000,\n0x0000, // J\n0x4400, 0x4800, 0x5000, 0x6000, 0x5000, 0x4800, 0x4800, 0x4400, 0x0000,\n0x0000, // K\n0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x7C00, 0x0000,\n0x0000, // L\n0x4400, 0x6C00, 0x6C00, 0x5400, 0x4400, 0x4400, 0x4400, 0x4400, 0x0000,\n0x0000, // M\n0x4400, 0x6400, 0x6400, 0x5400, 0x5400, 0x4C00, 0x4C00, 0x4400, 0x0000,\n0x0000, // N\n0x3800, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000,\n0x0000, // O\n0x7800, 0x4400, 0x4400, 0x4400, 0x7800, 0x4000, 0x4000, 0x4000, 0x0000,\n0x0000, // P\n0x3800, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x5400, 0x3800, 0x0400,\n0x0000, // Q\n0x7800, 0x4400, 0x4400, 0x4400, 0x7800, 0x4800, 0x4800, 0x4400, 0x0000,\n0x0000, // R\n0x3800, 0x4400, 0x4000, 0x3000, 0x0800, 0x0400, 0x4400, 0x3800, 0x0000,\n0x0000, // S\n0x7C00, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000,\n0x0000, // T\n0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000,\n0x0000, // U\n0x4400, 0x4400, 0x4400, 0x2800, 0x2800, 0x2800, 0x1000, 0x1000, 0x0000,\n0x0000, // V\n0x4400, 0x4400, 0x5400, 0x5400, 0x5400, 0x6C00, 0x2800, 0x2800, 0x0000,\n0x0000, // W\n0x4400, 0x2800, 0x2800, 0x1000, 0x1000, 0x2800, 0x2800, 0x4400, 0x0000,\n0x0000, // X\n0x4400, 0x4400, 0x2800, 0x2800, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000,\n0x0000, // Y\n0x7C00, 0x0400, 0x0800, 0x1000, 0x1000, 0x2000, 0x4000, 0x7C00, 0x0000,\n0x0000, // Z\n0x1800, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n0x1800, // [\n0x2000, 0x2000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0800, 0x0800, 0x0000,\n0x0000, /* \\ */\n0x3000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n0x3000, // ]\n0x1000, 0x2800, 0x2800, 0x4400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // ^\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0xFE00, // _\n0x2000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // `\n0x0000, 0x0000, 0x3800, 0x4400, 0x3C00, 0x4400, 0x4C00, 0x3400, 0x0000,\n0x0000, // a\n0x4000, 0x4000, 0x5800, 0x6400, 0x4400, 0x4400, 0x6400, 0x5800, 0x0000,\n0x0000, // b\n0x0000, 0x0000, 0x3800, 0x4400, 0x4000, 0x4000, 0x4400, 0x3800, 0x0000,\n0x0000, // c\n0x0400, 0x0400, 0x3400, 0x4C00, 0x4400, 0x4400, 0x4C00, 0x3400, 0x0000,\n0x0000, // d\n0x0000, 0x0000, 0x3800, 0x4400, 0x7C00, 0x4000, 0x4400, 0x3800, 0x0000,\n0x0000, // e\n0x0C00, 0x1000, 0x7C00, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000,\n0x0000, // f\n0x0000, 0x0000, 0x3400, 0x4C00, 0x4400, 0x4400, 0x4C00, 0x3400, 0x0400,\n0x7800, // g\n0x4000, 0x4000, 0x5800, 0x6400, 0x4400, 0x4400, 0x4400, 0x4400, 0x0000,\n0x0000, // h\n0x1000, 0x0000, 0x7000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000,\n0x0000, // i\n0x1000, 0x0000, 0x7000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n0xE000, // j\n0x4000, 0x4000, 0x4800, 0x5000, 0x6000, 0x5000, 0x4800, 0x4400, 0x0000,\n0x0000, // k\n0x7000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000,\n0x0000, // l\n0x0000, 0x0000, 0x7800, 0x5400, 0x5400, 0x5400, 0x5400, 0x5400, 0x0000,\n0x0000, // m\n0x0000, 0x0000, 0x5800, 0x6400, 0x4400, 0x4400, 0x4400, 0x4400, 0x0000,\n0x0000, // n\n0x0000, 0x0000, 0x3800, 0x4400, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000,\n0x0000, // o\n0x0000, 0x0000, 0x5800, 0x6400, 0x4400, 0x4400, 0x6400, 0x5800, 0x4000,\n0x4000, // p\n0x0000, 0x0000, 0x3400, 0x4C00, 0x4400, 0x4400, 0x4C00, 0x3400, 0x0400,\n0x0400, // q\n0x0000, 0x0000, 0x5800, 0x6400, 0x4000, 0x4000, 0x4000, 0x4000, 0x0000,\n0x0000, // r\n0x0000, 0x0000, 0x3800, 0x4400, 0x3000, 0x0800, 0x4400, 0x3800, 0x0000,\n0x0000, // s\n0x2000, 0x2000, 0x7800, 0x2000, 0x2000, 0x2000, 0x2000, 0x1800, 0x0000,\n0x0000, // t\n0x0000, 0x0000, 0x4400, 0x4400, 0x4400, 0x4400, 0x4C00, 0x3400, 0x0000,\n0x0000, // u\n0x0000, 0x0000, 0x4400, 0x4400, 0x2800, 0x2800, 0x2800, 0x1000, 0x0000,\n0x0000, // v\n0x0000, 0x0000, 0x5400, 0x5400, 0x5400, 0x6C00, 0x2800, 0x2800, 0x0000,\n0x0000, // w\n0x0000, 0x0000, 0x4400, 0x2800, 0x1000, 0x1000, 0x2800, 0x4400, 0x0000,\n0x0000, // x\n0x0000, 0x0000, 0x4400, 0x4400, 0x2800, 0x2800, 0x1000, 0x1000, 0x1000,\n0x6000, // y\n0x0000, 0x0000, 0x7C00, 0x0800, 0x1000, 0x2000, 0x4000, 0x7C00, 0x0000,\n0x0000, // z\n0x1800, 0x1000, 0x1000, 0x1000, 0x2000, 0x2000, 0x1000, 0x1000, 0x1000,\n0x1800, // {\n0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n0x1000, // |\n0x3000, 0x1000, 0x1000, 0x1000, 0x0800, 0x0800, 0x1000, 0x1000, 0x1000,\n0x3000, // }\n0x0000, 0x0000, 0x0000, 0x7400, 0x4C00, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // ~\n};\n\nstatic const uint16_t Font11x18[] = {\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // sp\n0x0000, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00,\n0x0C00, 0x0C00, 0x0C00, 0x0000, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000, // !\n0x0000, 0x1B00, 0x1B00, 0x1B00, 0x1B00, 0x1B00, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // \"\n0x0000, 0x1980, 0x1980, 0x1980, 0x1980, 0x7FC0, 0x7FC0, 0x1980, 0x3300,\n0x7FC0, 0x7FC0, 0x3300, 0x3300, 0x3300, 0x3300, 0x0000, 0x0000, 0x0000, // #\n0x0000, 0x1E00, 0x3F00, 0x7580, 0x6580, 0x7400, 0x3C00, 0x1E00, 0x0700,\n0x0580, 0x6580, 0x6580, 0x7580, 0x3F00, 0x1E00, 0x0400, 0x0400, 0x0000, // $\n0x0000, 0x7000, 0xD800, 0xD840, 0xD8C0, 0xD980, 0x7300, 0x0600, 0x0C00,\n0x1B80, 0x36C0, 0x66C0, 0x46C0, 0x06C0, 0x0380, 0x0000, 0x0000, 0x0000, // %\n0x0000, 0x1E00, 0x3F00, 0x3300, 0x3300, 0x3300, 0x1E00, 0x0C00, 0x3CC0,\n0x66C0, 0x6380, 0x6180, 0x6380, 0x3EC0, 0x1C80, 0x0000, 0x0000, 0x0000, // &amp;\n0x0000, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // '\n0x0080, 0x0100, 0x0300, 0x0600, 0x0600, 0x0400, 0x0C00, 0x0C00, 0x0C00,\n0x0C00, 0x0C00, 0x0C00, 0x0400, 0x0600, 0x0600, 0x0300, 0x0100, 0x0080, // (\n0x2000, 0x1000, 0x1800, 0x0C00, 0x0C00, 0x0400, 0x0600, 0x0600, 0x0600,\n0x0600, 0x0600, 0x0600, 0x0400, 0x0C00, 0x0C00, 0x1800, 0x1000, 0x2000, // )\n0x0000, 0x0C00, 0x2D00, 0x3F00, 0x1E00, 0x3300, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // *\n0x0000, 0x0000, 0x0000, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0xFFC0, 0xFFC0,\n0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // +\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0C00, 0x0C00, 0x0400, 0x0400, 0x0800, // ,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x1E00, 0x1E00, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // -\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000, // .\n0x0000, 0x0300, 0x0300, 0x0300, 0x0600, 0x0600, 0x0600, 0x0600, 0x0C00,\n0x0C00, 0x0C00, 0x0C00, 0x1800, 0x1800, 0x1800, 0x0000, 0x0000, 0x0000, // /\n0x0000, 0x1E00, 0x3F00, 0x3300, 0x6180, 0x6180, 0x6180, 0x6D80, 0x6D80,\n0x6180, 0x6180, 0x6180, 0x3300, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // 0\n0x0000, 0x0600, 0x0E00, 0x1E00, 0x3600, 0x2600, 0x0600, 0x0600, 0x0600,\n0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0000, 0x0000, 0x0000, // 1\n0x0000, 0x1E00, 0x3F00, 0x7380, 0x6180, 0x6180, 0x0180, 0x0300, 0x0600,\n0x0C00, 0x1800, 0x3000, 0x6000, 0x7F80, 0x7F80, 0x0000, 0x0000, 0x0000, // 2\n0x0000, 0x1C00, 0x3E00, 0x6300, 0x6300, 0x0300, 0x0E00, 0x0E00, 0x0300,\n0x0180, 0x0180, 0x6180, 0x7380, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // 3\n0x0000, 0x0600, 0x0E00, 0x0E00, 0x1E00, 0x1E00, 0x1600, 0x3600, 0x3600,\n0x6600, 0x7F80, 0x7F80, 0x0600, 0x0600, 0x0600, 0x0000, 0x0000, 0x0000, // 4\n0x0000, 0x7F00, 0x7F00, 0x6000, 0x6000, 0x6000, 0x6E00, 0x7F00, 0x6380,\n0x0180, 0x0180, 0x6180, 0x7380, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // 5\n0x0000, 0x1E00, 0x3F00, 0x3380, 0x6180, 0x6000, 0x6E00, 0x7F00, 0x7380,\n0x6180, 0x6180, 0x6180, 0x3380, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // 6\n0x0000, 0x7F80, 0x7F80, 0x0180, 0x0300, 0x0300, 0x0600, 0x0600, 0x0C00,\n0x0C00, 0x0C00, 0x0800, 0x1800, 0x1800, 0x1800, 0x0000, 0x0000, 0x0000, // 7\n0x0000, 0x1E00, 0x3F00, 0x6380, 0x6180, 0x6180, 0x2100, 0x1E00, 0x3F00,\n0x6180, 0x6180, 0x6180, 0x6180, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // 8\n0x0000, 0x1E00, 0x3F00, 0x7300, 0x6180, 0x6180, 0x6180, 0x7380, 0x3F80,\n0x1D80, 0x0180, 0x6180, 0x7300, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // 9\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0C00, 0x0C00, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000, // :\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0C00, 0x0C00, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0C00, 0x0C00, 0x0400, 0x0400, 0x0800, // ;\n0x0000, 0x0000, 0x0000, 0x0000, 0x0080, 0x0380, 0x0E00, 0x3800, 0x6000,\n0x3800, 0x0E00, 0x0380, 0x0080, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // &lt;\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x7F80, 0x7F80, 0x0000, 0x0000,\n0x7F80, 0x7F80, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // =\n0x0000, 0x0000, 0x0000, 0x0000, 0x4000, 0x7000, 0x1C00, 0x0700, 0x0180,\n0x0700, 0x1C00, 0x7000, 0x4000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // &gt;\n0x0000, 0x1F00, 0x3F80, 0x71C0, 0x60C0, 0x00C0, 0x01C0, 0x0380, 0x0700,\n0x0E00, 0x0C00, 0x0C00, 0x0000, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000, // ?\n0x0000, 0x1E00, 0x3F00, 0x3180, 0x7180, 0x6380, 0x6F80, 0x6D80, 0x6D80,\n0x6F80, 0x6780, 0x6000, 0x3200, 0x3E00, 0x1C00, 0x0000, 0x0000, 0x0000, // @\n0x0000, 0x0E00, 0x0E00, 0x1B00, 0x1B00, 0x1B00, 0x1B00, 0x3180, 0x3180,\n0x3F80, 0x3F80, 0x3180, 0x60C0, 0x60C0, 0x60C0, 0x0000, 0x0000, 0x0000, // A\n0x0000, 0x7C00, 0x7E00, 0x6300, 0x6300, 0x6300, 0x6300, 0x7E00, 0x7E00,\n0x6300, 0x6180, 0x6180, 0x6380, 0x7F00, 0x7E00, 0x0000, 0x0000, 0x0000, // B\n0x0000, 0x1E00, 0x3F00, 0x3180, 0x6180, 0x6000, 0x6000, 0x6000, 0x6000,\n0x6000, 0x6000, 0x6180, 0x3180, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // C\n0x0000, 0x7C00, 0x7F00, 0x6300, 0x6380, 0x6180, 0x6180, 0x6180, 0x6180,\n0x6180, 0x6180, 0x6300, 0x6300, 0x7E00, 0x7C00, 0x0000, 0x0000, 0x0000, // D\n0x0000, 0x7F80, 0x7F80, 0x6000, 0x6000, 0x6000, 0x6000, 0x7F00, 0x7F00,\n0x6000, 0x6000, 0x6000, 0x6000, 0x7F80, 0x7F80, 0x0000, 0x0000, 0x0000, // E\n0x0000, 0x7F80, 0x7F80, 0x6000, 0x6000, 0x6000, 0x6000, 0x7F00, 0x7F00,\n0x6000, 0x6000, 0x6000, 0x6000, 0x6000, 0x6000, 0x0000, 0x0000, 0x0000, // F\n0x0000, 0x1E00, 0x3F00, 0x3180, 0x6180, 0x6000, 0x6000, 0x6000, 0x6380,\n0x6380, 0x6180, 0x6180, 0x3180, 0x3F80, 0x1E00, 0x0000, 0x0000, 0x0000, // G\n0x0000, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x7F80, 0x7F80,\n0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x0000, 0x0000, 0x0000, // H\n0x0000, 0x3F00, 0x3F00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00,\n0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x3F00, 0x3F00, 0x0000, 0x0000, 0x0000, // I\n0x0000, 0x0180, 0x0180, 0x0180, 0x0180, 0x0180, 0x0180, 0x0180, 0x0180,\n0x0180, 0x6180, 0x6180, 0x7380, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // J\n0x0000, 0x60C0, 0x6180, 0x6300, 0x6600, 0x6600, 0x6C00, 0x7800, 0x7C00,\n0x6600, 0x6600, 0x6300, 0x6180, 0x6180, 0x60C0, 0x0000, 0x0000, 0x0000, // K\n0x0000, 0x6000, 0x6000, 0x6000, 0x6000, 0x6000, 0x6000, 0x6000, 0x6000,\n0x6000, 0x6000, 0x6000, 0x6000, 0x7F80, 0x7F80, 0x0000, 0x0000, 0x0000, // L\n0x0000, 0x71C0, 0x71C0, 0x7BC0, 0x7AC0, 0x6AC0, 0x6AC0, 0x6EC0, 0x64C0,\n0x60C0, 0x60C0, 0x60C0, 0x60C0, 0x60C0, 0x60C0, 0x0000, 0x0000, 0x0000, // M\n0x0000, 0x7180, 0x7180, 0x7980, 0x7980, 0x7980, 0x6D80, 0x6D80, 0x6D80,\n0x6580, 0x6780, 0x6780, 0x6780, 0x6380, 0x6380, 0x0000, 0x0000, 0x0000, // N\n0x0000, 0x1E00, 0x3F00, 0x3300, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180,\n0x6180, 0x6180, 0x6180, 0x3300, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // O\n0x0000, 0x7E00, 0x7F00, 0x6380, 0x6180, 0x6180, 0x6180, 0x6380, 0x7F00,\n0x7E00, 0x6000, 0x6000, 0x6000, 0x6000, 0x6000, 0x0000, 0x0000, 0x0000, // P\n0x0000, 0x1E00, 0x3F00, 0x3300, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180,\n0x6180, 0x6580, 0x6780, 0x3300, 0x3F80, 0x1E40, 0x0000, 0x0000, 0x0000, // Q\n0x0000, 0x7E00, 0x7F00, 0x6380, 0x6180, 0x6180, 0x6380, 0x7F00, 0x7E00,\n0x6600, 0x6300, 0x6300, 0x6180, 0x6180, 0x60C0, 0x0000, 0x0000, 0x0000, // R\n0x0000, 0x0E00, 0x1F00, 0x3180, 0x3180, 0x3000, 0x3800, 0x1E00, 0x0700,\n0x0380, 0x6180, 0x6180, 0x3180, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // S\n0x0000, 0xFFC0, 0xFFC0, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00,\n0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000, // T\n0x0000, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180,\n0x6180, 0x6180, 0x6180, 0x7380, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // U\n0x0000, 0x60C0, 0x60C0, 0x60C0, 0x3180, 0x3180, 0x3180, 0x1B00, 0x1B00,\n0x1B00, 0x1B00, 0x0E00, 0x0E00, 0x0E00, 0x0400, 0x0000, 0x0000, 0x0000, // V\n0x0000, 0xC0C0, 0xC0C0, 0xC0C0, 0xC0C0, 0xC0C0, 0xCCC0, 0x4C80, 0x4C80,\n0x5E80, 0x5280, 0x5280, 0x7380, 0x6180, 0x6180, 0x0000, 0x0000, 0x0000, // W\n0x0000, 0xC0C0, 0x6080, 0x6180, 0x3300, 0x3B00, 0x1E00, 0x0C00, 0x0C00,\n0x1E00, 0x1F00, 0x3B00, 0x7180, 0x6180, 0xC0C0, 0x0000, 0x0000, 0x0000, // X\n0x0000, 0xC0C0, 0x6180, 0x6180, 0x3300, 0x3300, 0x1E00, 0x1E00, 0x0C00,\n0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000, // Y\n0x0000, 0x3F80, 0x3F80, 0x0180, 0x0300, 0x0300, 0x0600, 0x0C00, 0x0C00,\n0x1800, 0x1800, 0x3000, 0x6000, 0x7F80, 0x7F80, 0x0000, 0x0000, 0x0000, // Z\n0x0F00, 0x0F00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00,\n0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0F00, 0x0F00, // [\n0x0000, 0x1800, 0x1800, 0x1800, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0600,\n0x0600, 0x0600, 0x0600, 0x0300, 0x0300, 0x0300, 0x0000, 0x0000,\n0x0000, /* \\ */\n0x1E00, 0x1E00, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600,\n0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x1E00, 0x1E00, // ]\n0x0000, 0x0C00, 0x0C00, 0x1E00, 0x1200, 0x3300, 0x3300, 0x6180, 0x6180,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // ^\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFE0, 0x0000, // _\n0x0000, 0x3800, 0x1800, 0x0C00, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // `\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1F00, 0x3F80, 0x6180, 0x0180,\n0x1F80, 0x3F80, 0x6180, 0x6380, 0x7F80, 0x38C0, 0x0000, 0x0000, 0x0000, // a\n0x0000, 0x6000, 0x6000, 0x6000, 0x6000, 0x6E00, 0x7F00, 0x7380, 0x6180,\n0x6180, 0x6180, 0x6180, 0x7380, 0x7F00, 0x6E00, 0x0000, 0x0000, 0x0000, // b\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1E00, 0x3F00, 0x7380, 0x6180,\n0x6000, 0x6000, 0x6180, 0x7380, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // c\n0x0000, 0x0180, 0x0180, 0x0180, 0x0180, 0x1D80, 0x3F80, 0x7380, 0x6180,\n0x6180, 0x6180, 0x6180, 0x7380, 0x3F80, 0x1D80, 0x0000, 0x0000, 0x0000, // d\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1E00, 0x3F00, 0x7300, 0x6180,\n0x7F80, 0x7F80, 0x6000, 0x7180, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // e\n0x0000, 0x07C0, 0x0FC0, 0x0C00, 0x0C00, 0x7F80, 0x7F80, 0x0C00, 0x0C00,\n0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000, // f\n0x0000, 0x0000, 0x0000, 0x0000, 0x1D80, 0x3F80, 0x7380, 0x6180, 0x6180,\n0x6180, 0x6180, 0x7380, 0x3F80, 0x1D80, 0x0180, 0x6380, 0x7F00, 0x3E00, // g\n0x0000, 0x6000, 0x6000, 0x6000, 0x6000, 0x6F00, 0x7F80, 0x7180, 0x6180,\n0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x0000, 0x0000, 0x0000, // h\n0x0000, 0x0600, 0x0600, 0x0000, 0x0000, 0x3E00, 0x3E00, 0x0600, 0x0600,\n0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0000, 0x0000, 0x0000, // i\n0x0600, 0x0600, 0x0000, 0x0000, 0x3E00, 0x3E00, 0x0600, 0x0600, 0x0600,\n0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x4600, 0x7E00, 0x3C00, // j\n0x0000, 0x6000, 0x6000, 0x6000, 0x6000, 0x6180, 0x6300, 0x6600, 0x6C00,\n0x7C00, 0x7600, 0x6300, 0x6300, 0x6180, 0x60C0, 0x0000, 0x0000, 0x0000, // k\n0x0000, 0x3E00, 0x3E00, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600,\n0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0000, 0x0000, 0x0000, // l\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xDD80, 0xFFC0, 0xCEC0, 0xCCC0,\n0xCCC0, 0xCCC0, 0xCCC0, 0xCCC0, 0xCCC0, 0xCCC0, 0x0000, 0x0000, 0x0000, // m\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x6F00, 0x7F80, 0x7180, 0x6180,\n0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x0000, 0x0000, 0x0000, // n\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1E00, 0x3F00, 0x7380, 0x6180,\n0x6180, 0x6180, 0x6180, 0x7380, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // o\n0x0000, 0x0000, 0x0000, 0x0000, 0x6E00, 0x7F00, 0x7380, 0x6180, 0x6180,\n0x6180, 0x6180, 0x7380, 0x7F00, 0x6E00, 0x6000, 0x6000, 0x6000, 0x6000, // p\n0x0000, 0x0000, 0x0000, 0x0000, 0x1D80, 0x3F80, 0x7380, 0x6180, 0x6180,\n0x6180, 0x6180, 0x7380, 0x3F80, 0x1D80, 0x0180, 0x0180, 0x0180, 0x0180, // q\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x6700, 0x3F80, 0x3900, 0x3000,\n0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 0x0000, 0x0000, 0x0000, // r\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1E00, 0x3F80, 0x6180, 0x6000,\n0x7F00, 0x3F80, 0x0180, 0x6180, 0x7F00, 0x1E00, 0x0000, 0x0000, 0x0000, // s\n0x0000, 0x0000, 0x0800, 0x1800, 0x1800, 0x7F00, 0x7F00, 0x1800, 0x1800,\n0x1800, 0x1800, 0x1800, 0x1800, 0x1F80, 0x0F80, 0x0000, 0x0000, 0x0000, // t\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x6180, 0x6180, 0x6180, 0x6180,\n0x6180, 0x6180, 0x6180, 0x6380, 0x7F80, 0x3D80, 0x0000, 0x0000, 0x0000, // u\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x60C0, 0x3180, 0x3180, 0x3180,\n0x1B00, 0x1B00, 0x1B00, 0x0E00, 0x0E00, 0x0600, 0x0000, 0x0000, 0x0000, // v\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xDD80, 0xDD80, 0xDD80, 0x5500,\n0x5500, 0x5500, 0x7700, 0x7700, 0x2200, 0x2200, 0x0000, 0x0000, 0x0000, // w\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x6180, 0x3300, 0x3300, 0x1E00,\n0x0C00, 0x0C00, 0x1E00, 0x3300, 0x3300, 0x6180, 0x0000, 0x0000, 0x0000, // x\n0x0000, 0x0000, 0x0000, 0x0000, 0x6180, 0x6180, 0x3180, 0x3300, 0x3300,\n0x1B00, 0x1B00, 0x1B00, 0x0E00, 0x0E00, 0x0E00, 0x1C00, 0x7C00, 0x7000, // y\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x7FC0, 0x7FC0, 0x0180, 0x0300,\n0x0600, 0x0C00, 0x1800, 0x3000, 0x7FC0, 0x7FC0, 0x0000, 0x0000, 0x0000, // z\n0x0380, 0x0780, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0E00, 0x1C00,\n0x1C00, 0x0E00, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0780, 0x0380, // {\n0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600,\n0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, // |\n0x3800, 0x3C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0E00, 0x0700,\n0x0700, 0x0E00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x3C00, 0x3800, // }\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3880, 0x7F80,\n0x4700, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // ~\n};\n\nstatic const uint16_t Font16x26[] = {\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [ ]\n0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03C0,\n0x03C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x0000, 0x0000, 0x0000,\n0x03E0, 0x03E0, 0x03E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [!]\n0x1E3C, 0x1E3C, 0x1E3C, 0x1E3C, 0x1E3C, 0x1E3C, 0x1E3C, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [\"]\n0x01CE, 0x03CE, 0x03DE, 0x039E, 0x039C, 0x079C, 0x3FFF, 0x7FFF, 0x0738,\n0x0F38, 0x0F78, 0x0F78, 0x0E78, 0xFFFF, 0xFFFF, 0x1EF0, 0x1CF0, 0x1CE0,\n0x3CE0, 0x3DE0, 0x39E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [#]\n0x03FC, 0x0FFE, 0x1FEE, 0x1EE0, 0x1EE0, 0x1EE0, 0x1EE0, 0x1FE0, 0x0FE0,\n0x07E0, 0x03F0, 0x01FC, 0x01FE, 0x01FE, 0x01FE, 0x01FE, 0x01FE, 0x01FE,\n0x3DFE, 0x3FFC, 0x0FF0, 0x01E0, 0x01E0, 0x0000, 0x0000,\n0x0000, // Ascii = [$]\n0x3E03, 0xF707, 0xE78F, 0xE78E, 0xE39E, 0xE3BC, 0xE7B8, 0xE7F8, 0xF7F0,\n0x3FE0, 0x01C0, 0x03FF, 0x07FF, 0x07F3, 0x0FF3, 0x1EF3, 0x3CF3, 0x38F3,\n0x78F3, 0xF07F, 0xE03F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [%]\n0x07E0, 0x0FF8, 0x0F78, 0x1F78, 0x1F78, 0x1F78, 0x0F78, 0x0FF0, 0x0FE0,\n0x1F80, 0x7FC3, 0xFBC3, 0xF3E7, 0xF1F7, 0xF0F7, 0xF0FF, 0xF07F, 0xF83E,\n0x7C7F, 0x3FFF, 0x1FEF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [&amp;]\n0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03C0, 0x01C0, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [']\n0x003F, 0x007C, 0x01F0, 0x01E0, 0x03C0, 0x07C0, 0x0780, 0x0780, 0x0F80,\n0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F80, 0x0780, 0x0780,\n0x07C0, 0x03C0, 0x01E0, 0x01F0, 0x007C, 0x003F, 0x000F,\n0x0000, // Ascii = [(]\n0x7E00, 0x1F00, 0x07C0, 0x03C0, 0x01E0, 0x01F0, 0x00F0, 0x00F0, 0x00F8,\n0x0078, 0x0078, 0x0078, 0x0078, 0x0078, 0x0078, 0x00F8, 0x00F0, 0x00F0,\n0x01F0, 0x01E0, 0x03C0, 0x07C0, 0x1F00, 0x7E00, 0x7800,\n0x0000, // Ascii = [)]\n0x03E0, 0x03C0, 0x01C0, 0x39CE, 0x3FFF, 0x3F7F, 0x0320, 0x0370, 0x07F8,\n0x0F78, 0x1F3C, 0x0638, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [*]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x01C0, 0x01C0, 0x01C0,\n0x01C0, 0x01C0, 0x01C0, 0x01C0, 0xFFFF, 0xFFFF, 0x01C0, 0x01C0, 0x01C0,\n0x01C0, 0x01C0, 0x01C0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [+]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03E0,\n0x03E0, 0x03E0, 0x03E0, 0x01E0, 0x01E0, 0x01E0, 0x01C0,\n0x0380, // Ascii = [,]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x3FFE, 0x3FFE, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [-]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03E0,\n0x03E0, 0x03E0, 0x03E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [.]\n0x000F, 0x000F, 0x001E, 0x001E, 0x003C, 0x003C, 0x0078, 0x0078, 0x00F0,\n0x00F0, 0x01E0, 0x01E0, 0x03C0, 0x03C0, 0x0780, 0x0780, 0x0F00, 0x0F00,\n0x1E00, 0x1E00, 0x3C00, 0x3C00, 0x7800, 0x7800, 0xF000,\n0x0000, // Ascii = [/]\n0x07F0, 0x0FF8, 0x1F7C, 0x3E3E, 0x3C1E, 0x7C1F, 0x7C1F, 0x780F, 0x780F,\n0x780F, 0x780F, 0x780F, 0x780F, 0x780F, 0x7C1F, 0x7C1F, 0x3C1E, 0x3E3E,\n0x1F7C, 0x0FF8, 0x07F0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [0]\n0x00F0, 0x07F0, 0x3FF0, 0x3FF0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0,\n0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0,\n0x01F0, 0x3FFF, 0x3FFF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [1]\n0x0FE0, 0x3FF8, 0x3C7C, 0x003C, 0x003E, 0x003E, 0x003E, 0x003C, 0x003C,\n0x007C, 0x00F8, 0x01F0, 0x03E0, 0x07C0, 0x0780, 0x0F00, 0x1E00, 0x3E00,\n0x3C00, 0x3FFE, 0x3FFE, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [2]\n0x0FF0, 0x1FF8, 0x1C7C, 0x003E, 0x003E, 0x003E, 0x003C, 0x003C, 0x00F8,\n0x0FF0, 0x0FF8, 0x007C, 0x003E, 0x001E, 0x001E, 0x001E, 0x001E, 0x003E,\n0x1C7C, 0x1FF8, 0x1FE0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [3]\n0x0078, 0x00F8, 0x00F8, 0x01F8, 0x03F8, 0x07F8, 0x07F8, 0x0F78, 0x1E78,\n0x1E78, 0x3C78, 0x7878, 0x7878, 0xFFFF, 0xFFFF, 0x0078, 0x0078, 0x0078,\n0x0078, 0x0078, 0x0078, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [4]\n0x1FFC, 0x1FFC, 0x1FFC, 0x1E00, 0x1E00, 0x1E00, 0x1E00, 0x1E00, 0x1FE0,\n0x1FF8, 0x00FC, 0x007C, 0x003E, 0x003E, 0x001E, 0x003E, 0x003E, 0x003C,\n0x1C7C, 0x1FF8, 0x1FE0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [5]\n0x01FC, 0x07FE, 0x0F8E, 0x1F00, 0x1E00, 0x3E00, 0x3C00, 0x3C00, 0x3DF8,\n0x3FFC, 0x7F3E, 0x7E1F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3E0F, 0x1E1F,\n0x1F3E, 0x0FFC, 0x03F0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [6]\n0x3FFF, 0x3FFF, 0x3FFF, 0x000F, 0x001E, 0x001E, 0x003C, 0x0038, 0x0078,\n0x00F0, 0x00F0, 0x01E0, 0x01E0, 0x03C0, 0x03C0, 0x0780, 0x0F80, 0x0F80,\n0x0F00, 0x1F00, 0x1F00, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [7]\n0x07F8, 0x0FFC, 0x1F3E, 0x1E1E, 0x3E1E, 0x3E1E, 0x1E1E, 0x1F3C, 0x0FF8,\n0x07F0, 0x0FF8, 0x1EFC, 0x3E3E, 0x3C1F, 0x7C1F, 0x7C0F, 0x7C0F, 0x3C1F,\n0x3F3E, 0x1FFC, 0x07F0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [8]\n0x07F0, 0x0FF8, 0x1E7C, 0x3C3E, 0x3C1E, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F,\n0x3C1F, 0x3E3F, 0x1FFF, 0x07EF, 0x001F, 0x001E, 0x001E, 0x003E, 0x003C,\n0x38F8, 0x3FF0, 0x1FE0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [9]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03E0, 0x03E0, 0x03E0,\n0x03E0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03E0,\n0x03E0, 0x03E0, 0x03E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [:]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03E0, 0x03E0, 0x03E0,\n0x03E0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03E0,\n0x03E0, 0x03E0, 0x03E0, 0x01E0, 0x01E0, 0x01E0, 0x03C0,\n0x0380, // Ascii = [;]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0003, 0x000F, 0x003F,\n0x00FC, 0x03F0, 0x0FC0, 0x3F00, 0xFE00, 0x3F00, 0x0FC0, 0x03F0, 0x00FC,\n0x003F, 0x000F, 0x0003, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [&lt;]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [=]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xE000, 0xF800, 0x7E00,\n0x1F80, 0x07E0, 0x01F8, 0x007E, 0x001F, 0x007E, 0x01F8, 0x07E0, 0x1F80,\n0x7E00, 0xF800, 0xE000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [&gt;]\n0x1FF0, 0x3FFC, 0x383E, 0x381F, 0x381F, 0x001E, 0x001E, 0x003C, 0x0078,\n0x00F0, 0x01E0, 0x03C0, 0x03C0, 0x07C0, 0x07C0, 0x0000, 0x0000, 0x0000,\n0x07C0, 0x07C0, 0x07C0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [?]\n0x03F8, 0x0FFE, 0x1F1E, 0x3E0F, 0x3C7F, 0x78FF, 0x79EF, 0x73C7, 0xF3C7,\n0xF38F, 0xF38F, 0xF38F, 0xF39F, 0xF39F, 0x73FF, 0x7BFF, 0x79F7, 0x3C00,\n0x1F1C, 0x0FFC, 0x03F8, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [@]\n0x0000, 0x0000, 0x0000, 0x03E0, 0x03E0, 0x07F0, 0x07F0, 0x07F0, 0x0F78,\n0x0F78, 0x0E7C, 0x1E3C, 0x1E3C, 0x3C3E, 0x3FFE, 0x3FFF, 0x781F, 0x780F,\n0xF00F, 0xF007, 0xF007, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [A]\n0x0000, 0x0000, 0x0000, 0x3FF8, 0x3FFC, 0x3C3E, 0x3C1E, 0x3C1E, 0x3C1E,\n0x3C3E, 0x3C7C, 0x3FF0, 0x3FF8, 0x3C7E, 0x3C1F, 0x3C1F, 0x3C0F, 0x3C0F,\n0x3C1F, 0x3FFE, 0x3FF8, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [B]\n0x0000, 0x0000, 0x0000, 0x01FF, 0x07FF, 0x1F87, 0x3E00, 0x3C00, 0x7C00,\n0x7800, 0x7800, 0x7800, 0x7800, 0x7800, 0x7C00, 0x7C00, 0x3E00, 0x3F00,\n0x1F83, 0x07FF, 0x01FF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [C]\n0x0000, 0x0000, 0x0000, 0x7FF0, 0x7FFC, 0x787E, 0x781F, 0x781F, 0x780F,\n0x780F, 0x780F, 0x780F, 0x780F, 0x780F, 0x780F, 0x780F, 0x781F, 0x781E,\n0x787E, 0x7FF8, 0x7FE0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [D]\n0x0000, 0x0000, 0x0000, 0x3FFF, 0x3FFF, 0x3E00, 0x3E00, 0x3E00, 0x3E00,\n0x3E00, 0x3E00, 0x3FFE, 0x3FFE, 0x3E00, 0x3E00, 0x3E00, 0x3E00, 0x3E00,\n0x3E00, 0x3FFF, 0x3FFF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [E]\n0x0000, 0x0000, 0x0000, 0x1FFF, 0x1FFF, 0x1E00, 0x1E00, 0x1E00, 0x1E00,\n0x1E00, 0x1E00, 0x1FFF, 0x1FFF, 0x1E00, 0x1E00, 0x1E00, 0x1E00, 0x1E00,\n0x1E00, 0x1E00, 0x1E00, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [F]\n0x0000, 0x0000, 0x0000, 0x03FE, 0x0FFF, 0x1F87, 0x3E00, 0x7C00, 0x7C00,\n0x7800, 0xF800, 0xF800, 0xF87F, 0xF87F, 0x780F, 0x7C0F, 0x7C0F, 0x3E0F,\n0x1F8F, 0x0FFF, 0x03FE, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [G]\n0x0000, 0x0000, 0x0000, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F,\n0x7C1F, 0x7C1F, 0x7FFF, 0x7FFF, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F,\n0x7C1F, 0x7C1F, 0x7C1F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [H]\n0x0000, 0x0000, 0x0000, 0x3FFF, 0x3FFF, 0x03E0, 0x03E0, 0x03E0, 0x03E0,\n0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0,\n0x03E0, 0x3FFF, 0x3FFF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [I]\n0x0000, 0x0000, 0x0000, 0x1FFC, 0x1FFC, 0x007C, 0x007C, 0x007C, 0x007C,\n0x007C, 0x007C, 0x007C, 0x007C, 0x007C, 0x007C, 0x007C, 0x0078, 0x0078,\n0x38F8, 0x3FF0, 0x3FC0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [J]\n0x0000, 0x0000, 0x0000, 0x3C1F, 0x3C1E, 0x3C3C, 0x3C78, 0x3CF0, 0x3DE0,\n0x3FE0, 0x3FC0, 0x3F80, 0x3FC0, 0x3FE0, 0x3DF0, 0x3CF0, 0x3C78, 0x3C7C,\n0x3C3E, 0x3C1F, 0x3C0F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [K]\n0x0000, 0x0000, 0x0000, 0x3E00, 0x3E00, 0x3E00, 0x3E00, 0x3E00, 0x3E00,\n0x3E00, 0x3E00, 0x3E00, 0x3E00, 0x3E00, 0x3E00, 0x3E00, 0x3E00, 0x3E00,\n0x3E00, 0x3FFF, 0x3FFF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [L]\n0x0000, 0x0000, 0x0000, 0xF81F, 0xFC1F, 0xFC1F, 0xFE3F, 0xFE3F, 0xFE3F,\n0xFF7F, 0xFF77, 0xFF77, 0xF7F7, 0xF7E7, 0xF3E7, 0xF3E7, 0xF3C7, 0xF007,\n0xF007, 0xF007, 0xF007, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [M]\n0x0000, 0x0000, 0x0000, 0x7C0F, 0x7C0F, 0x7E0F, 0x7F0F, 0x7F0F, 0x7F8F,\n0x7F8F, 0x7FCF, 0x7BEF, 0x79EF, 0x79FF, 0x78FF, 0x78FF, 0x787F, 0x783F,\n0x783F, 0x781F, 0x781F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [N]\n0x0000, 0x0000, 0x0000, 0x07F0, 0x1FFC, 0x3E3E, 0x7C1F, 0x780F, 0x780F,\n0xF80F, 0xF80F, 0xF80F, 0xF80F, 0xF80F, 0xF80F, 0x780F, 0x780F, 0x7C1F,\n0x3E3E, 0x1FFC, 0x07F0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [O]\n0x0000, 0x0000, 0x0000, 0x3FFC, 0x3FFF, 0x3E1F, 0x3E0F, 0x3E0F, 0x3E0F,\n0x3E0F, 0x3E1F, 0x3E3F, 0x3FFC, 0x3FF0, 0x3E00, 0x3E00, 0x3E00, 0x3E00,\n0x3E00, 0x3E00, 0x3E00, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [P]\n0x0000, 0x0000, 0x0000, 0x07F0, 0x1FFC, 0x3E3E, 0x7C1F, 0x780F, 0x780F,\n0xF80F, 0xF80F, 0xF80F, 0xF80F, 0xF80F, 0xF80F, 0x780F, 0x780F, 0x7C1F,\n0x3E3E, 0x1FFC, 0x07F8, 0x007C, 0x003F, 0x000F, 0x0003,\n0x0000, // Ascii = [Q]\n0x0000, 0x0000, 0x0000, 0x3FF0, 0x3FFC, 0x3C7E, 0x3C3E, 0x3C1E, 0x3C1E,\n0x3C3E, 0x3C3C, 0x3CFC, 0x3FF0, 0x3FE0, 0x3DF0, 0x3CF8, 0x3C7C, 0x3C3E,\n0x3C1E, 0x3C1F, 0x3C0F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [R]\n0x0000, 0x0000, 0x0000, 0x07FC, 0x1FFE, 0x3E0E, 0x3C00, 0x3C00, 0x3C00,\n0x3E00, 0x1FC0, 0x0FF8, 0x03FE, 0x007F, 0x001F, 0x000F, 0x000F, 0x201F,\n0x3C3E, 0x3FFC, 0x1FF0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [S]\n0x0000, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0x03E0, 0x03E0, 0x03E0, 0x03E0,\n0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0,\n0x03E0, 0x03E0, 0x03E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [T]\n0x0000, 0x0000, 0x0000, 0x7C0F, 0x7C0F, 0x7C0F, 0x7C0F, 0x7C0F, 0x7C0F,\n0x7C0F, 0x7C0F, 0x7C0F, 0x7C0F, 0x7C0F, 0x7C0F, 0x7C0F, 0x3C1E, 0x3C1E,\n0x3E3E, 0x1FFC, 0x07F0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [U]\n0x0000, 0x0000, 0x0000, 0xF007, 0xF007, 0xF807, 0x780F, 0x7C0F, 0x3C1E,\n0x3C1E, 0x3E1E, 0x1E3C, 0x1F3C, 0x1F78, 0x0F78, 0x0FF8, 0x07F0, 0x07F0,\n0x07F0, 0x03E0, 0x03E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [V]\n0x0000, 0x0000, 0x0000, 0xE003, 0xF003, 0xF003, 0xF007, 0xF3E7, 0xF3E7,\n0xF3E7, 0x73E7, 0x7BF7, 0x7FF7, 0x7FFF, 0x7F7F, 0x7F7F, 0x7F7E, 0x3F7E,\n0x3E3E, 0x3E3E, 0x3E3E, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [W]\n0x0000, 0x0000, 0x0000, 0xF807, 0x7C0F, 0x3E1E, 0x3E3E, 0x1F3C, 0x0FF8,\n0x07F0, 0x07E0, 0x03E0, 0x03E0, 0x07F0, 0x0FF8, 0x0F7C, 0x1E7C, 0x3C3E,\n0x781F, 0x780F, 0xF00F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [X]\n0x0000, 0x0000, 0x0000, 0xF807, 0x7807, 0x7C0F, 0x3C1E, 0x3E1E, 0x1F3C,\n0x0F78, 0x0FF8, 0x07F0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0,\n0x03E0, 0x03E0, 0x03E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [Y]\n0x0000, 0x0000, 0x0000, 0x7FFF, 0x7FFF, 0x000F, 0x001F, 0x003E, 0x007C,\n0x00F8, 0x00F0, 0x01E0, 0x03E0, 0x07C0, 0x0F80, 0x0F00, 0x1E00, 0x3E00,\n0x7C00, 0x7FFF, 0x7FFF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [Z]\n0x07FF, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780,\n0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780,\n0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x07FF, 0x07FF,\n0x0000, // Ascii = [[]\n0x7800, 0x7800, 0x3C00, 0x3C00, 0x1E00, 0x1E00, 0x0F00, 0x0F00, 0x0780,\n0x0780, 0x03C0, 0x03C0, 0x01E0, 0x01E0, 0x00F0, 0x00F0, 0x0078, 0x0078,\n0x003C, 0x003C, 0x001E, 0x001E, 0x000F, 0x000F, 0x0007,\n0x0000, // Ascii = [\\]\n0x7FF0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0,\n0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0,\n0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x7FF0, 0x7FF0,\n0x0000, // Ascii = []]\n0x00C0, 0x01C0, 0x01C0, 0x03E0, 0x03E0, 0x07F0, 0x07F0, 0x0778, 0x0F78,\n0x0F38, 0x1E3C, 0x1E3C, 0x3C1E, 0x3C1E, 0x380F, 0x780F, 0x7807, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [^]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0x0000, 0x0000,\n0x0000, // Ascii = [_]\n0x00F0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [`]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0FF8, 0x3FFC, 0x3C7C,\n0x003E, 0x003E, 0x003E, 0x07FE, 0x1FFE, 0x3E3E, 0x7C3E, 0x783E, 0x7C3E,\n0x7C7E, 0x3FFF, 0x1FCF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [a]\n0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3DF8, 0x3FFE, 0x3F3E,\n0x3E1F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C1F, 0x3C1E,\n0x3F3E, 0x3FFC, 0x3BF0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [b]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03FE, 0x0FFF, 0x1F87,\n0x3E00, 0x3E00, 0x3C00, 0x7C00, 0x7C00, 0x7C00, 0x3C00, 0x3E00, 0x3E00,\n0x1F87, 0x0FFF, 0x03FE, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [c]\n0x001F, 0x001F, 0x001F, 0x001F, 0x001F, 0x001F, 0x07FF, 0x1FFF, 0x3E3F,\n0x3C1F, 0x7C1F, 0x7C1F, 0x7C1F, 0x781F, 0x781F, 0x7C1F, 0x7C1F, 0x3C3F,\n0x3E7F, 0x1FFF, 0x0FDF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [d]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03F8, 0x0FFC, 0x1F3E,\n0x3E1E, 0x3C1F, 0x7C1F, 0x7FFF, 0x7FFF, 0x7C00, 0x7C00, 0x3C00, 0x3E00,\n0x1F07, 0x0FFF, 0x03FE, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [e]\n0x01FF, 0x03E1, 0x03C0, 0x07C0, 0x07C0, 0x07C0, 0x7FFF, 0x7FFF, 0x07C0,\n0x07C0, 0x07C0, 0x07C0, 0x07C0, 0x07C0, 0x07C0, 0x07C0, 0x07C0, 0x07C0,\n0x07C0, 0x07C0, 0x07C0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [f]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x07EF, 0x1FFF, 0x3E7F,\n0x3C1F, 0x7C1F, 0x7C1F, 0x781F, 0x781F, 0x781F, 0x7C1F, 0x7C1F, 0x3C3F,\n0x3E7F, 0x1FFF, 0x0FDF, 0x001E, 0x001E, 0x001E, 0x387C,\n0x3FF8, // Ascii = [g]\n0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3DFC, 0x3FFE, 0x3F9E,\n0x3F1F, 0x3E1F, 0x3C1F, 0x3C1F, 0x3C1F, 0x3C1F, 0x3C1F, 0x3C1F, 0x3C1F,\n0x3C1F, 0x3C1F, 0x3C1F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [h]\n0x01F0, 0x01F0, 0x0000, 0x0000, 0x0000, 0x0000, 0x7FE0, 0x7FE0, 0x01E0,\n0x01E0, 0x01E0, 0x01E0, 0x01E0, 0x01E0, 0x01E0, 0x01E0, 0x01E0, 0x01E0,\n0x01E0, 0x01E0, 0x01E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [i]\n0x00F8, 0x00F8, 0x0000, 0x0000, 0x0000, 0x0000, 0x3FF8, 0x3FF8, 0x00F8,\n0x00F8, 0x00F8, 0x00F8, 0x00F8, 0x00F8, 0x00F8, 0x00F8, 0x00F8, 0x00F8,\n0x00F8, 0x00F8, 0x00F8, 0x00F8, 0x00F8, 0x00F0, 0x71F0,\n0x7FE0, // Ascii = [j]\n0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3C1F, 0x3C3E, 0x3C7C,\n0x3CF8, 0x3DF0, 0x3DE0, 0x3FC0, 0x3FC0, 0x3FE0, 0x3DF0, 0x3CF8, 0x3C7C,\n0x3C3E, 0x3C1F, 0x3C1F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [k]\n0x7FF0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0,\n0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0,\n0x01F0, 0x01F0, 0x01F0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [l]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xF79E, 0xFFFF, 0xFFFF,\n0xFFFF, 0xFBE7, 0xF9E7, 0xF1C7, 0xF1C7, 0xF1C7, 0xF1C7, 0xF1C7, 0xF1C7,\n0xF1C7, 0xF1C7, 0xF1C7, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [m]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3DFC, 0x3FFE, 0x3F9E,\n0x3F1F, 0x3E1F, 0x3C1F, 0x3C1F, 0x3C1F, 0x3C1F, 0x3C1F, 0x3C1F, 0x3C1F,\n0x3C1F, 0x3C1F, 0x3C1F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [n]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x07F0, 0x1FFC, 0x3E3E,\n0x3C1F, 0x7C1F, 0x780F, 0x780F, 0x780F, 0x780F, 0x780F, 0x7C1F, 0x3C1F,\n0x3E3E, 0x1FFC, 0x07F0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [o]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3DF8, 0x3FFE, 0x3F3E,\n0x3E1F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C1F, 0x3E1E,\n0x3F3E, 0x3FFC, 0x3FF8, 0x3C00, 0x3C00, 0x3C00, 0x3C00,\n0x3C00, // Ascii = [p]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x07EE, 0x1FFE, 0x3E7E,\n0x3C1E, 0x7C1E, 0x781E, 0x781E, 0x781E, 0x781E, 0x781E, 0x7C1E, 0x7C3E,\n0x3E7E, 0x1FFE, 0x0FDE, 0x001E, 0x001E, 0x001E, 0x001E,\n0x001E, // Ascii = [q]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1F7F, 0x1FFF, 0x1FE7,\n0x1FC7, 0x1F87, 0x1F00, 0x1F00, 0x1F00, 0x1F00, 0x1F00, 0x1F00, 0x1F00,\n0x1F00, 0x1F00, 0x1F00, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [r]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x07FC, 0x1FFE, 0x1E0E,\n0x3E00, 0x3E00, 0x3F00, 0x1FE0, 0x07FC, 0x00FE, 0x003E, 0x001E, 0x001E,\n0x3C3E, 0x3FFC, 0x1FF0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [s]\n0x0000, 0x0000, 0x0000, 0x0780, 0x0780, 0x0780, 0x7FFF, 0x7FFF, 0x0780,\n0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780,\n0x07C0, 0x03FF, 0x01FF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [t]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3C1E, 0x3C1E, 0x3C1E,\n0x3C1E, 0x3C1E, 0x3C1E, 0x3C1E, 0x3C1E, 0x3C1E, 0x3C1E, 0x3C3E, 0x3C7E,\n0x3EFE, 0x1FFE, 0x0FDE, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [u]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xF007, 0x780F, 0x780F,\n0x3C1E, 0x3C1E, 0x3E1E, 0x1E3C, 0x1E3C, 0x0F78, 0x0F78, 0x0FF0, 0x07F0,\n0x07F0, 0x03E0, 0x03E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [v]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xF003, 0xF1E3, 0xF3E3,\n0xF3E7, 0xF3F7, 0xF3F7, 0x7FF7, 0x7F77, 0x7F7F, 0x7F7F, 0x7F7F, 0x3E3E,\n0x3E3E, 0x3E3E, 0x3E3E, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [w]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x7C0F, 0x3E1E, 0x3E3C,\n0x1F3C, 0x0FF8, 0x07F0, 0x07F0, 0x03E0, 0x07F0, 0x07F8, 0x0FF8, 0x1E7C,\n0x3E3E, 0x3C1F, 0x781F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [x]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xF807, 0x780F, 0x7C0F,\n0x3C1E, 0x3C1E, 0x1E3C, 0x1E3C, 0x1F3C, 0x0F78, 0x0FF8, 0x07F0, 0x07F0,\n0x03E0, 0x03E0, 0x03C0, 0x03C0, 0x03C0, 0x0780, 0x0F80,\n0x7F00, // Ascii = [y]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3FFF, 0x3FFF, 0x001F,\n0x003E, 0x007C, 0x00F8, 0x01F0, 0x03E0, 0x07C0, 0x0F80, 0x1F00, 0x1E00,\n0x3C00, 0x7FFF, 0x7FFF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [z]\n0x01FE, 0x03E0, 0x03C0, 0x03C0, 0x03C0, 0x03C0, 0x01E0, 0x01E0, 0x01E0,\n0x01C0, 0x03C0, 0x3F80, 0x3F80, 0x03C0, 0x01C0, 0x01E0, 0x01E0, 0x01E0,\n0x03C0, 0x03C0, 0x03C0, 0x03C0, 0x03E0, 0x01FE, 0x007E,\n0x0000, // Ascii = [{]\n0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0,\n0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0,\n0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0,\n0x0000, // Ascii = [|]\n0x3FC0, 0x03E0, 0x01E0, 0x01E0, 0x01E0, 0x01E0, 0x01C0, 0x03C0, 0x03C0,\n0x01C0, 0x01E0, 0x00FE, 0x00FE, 0x01E0, 0x01C0, 0x03C0, 0x03C0, 0x01C0,\n0x01E0, 0x01E0, 0x01E0, 0x01E0, 0x03E0, 0x3FC0, 0x3F00,\n0x0000, // Ascii = [}]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x3F07, 0x7FC7, 0x73E7, 0xF1FF, 0xF07E, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [~]\n};\n\nstatic const uint16_t Font6x8[] = {\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // sp\n0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x0000, 0x2000, 0x0000, // !\n0x5000, 0x5000, 0x5000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // \"\n0x5000, 0x5000, 0xf800, 0x5000, 0xf800, 0x5000, 0x5000, 0x0000, // #\n0x2000, 0x7800, 0xa000, 0x7000, 0x2800, 0xf000, 0x2000, 0x0000, // $\n0xc000, 0xc800, 0x1000, 0x2000, 0x4000, 0x9800, 0x1800, 0x0000, // %\n0x4000, 0xa000, 0xa000, 0x4000, 0xa800, 0x9000, 0x6800, 0x0000, // &amp;\n0x3000, 0x3000, 0x2000, 0x4000, 0x0000, 0x0000, 0x0000, 0x0000, // '\n0x1000, 0x2000, 0x4000, 0x4000, 0x4000, 0x2000, 0x1000, 0x0000, // (\n0x4000, 0x2000, 0x1000, 0x1000, 0x1000, 0x2000, 0x4000, 0x0000, // )\n0x2000, 0xa800, 0x7000, 0xf800, 0x7000, 0xa800, 0x2000, 0x0000, // *\n0x0000, 0x2000, 0x2000, 0xf800, 0x2000, 0x2000, 0x0000, 0x0000, // +\n0x0000, 0x0000, 0x0000, 0x0000, 0x3000, 0x3000, 0x2000, 0x0000, // ,\n0x0000, 0x0000, 0x0000, 0xf800, 0x0000, 0x0000, 0x0000, 0x0000, // -\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3000, 0x3000, 0x0000, // .\n0x0000, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000, 0x0000, 0x0000, // /\n0x7000, 0x8800, 0x9800, 0xa800, 0xc800, 0x8800, 0x7000, 0x0000, // 0\n0x2000, 0x6000, 0x2000, 0x2000, 0x2000, 0x2000, 0x7000, 0x0000, // 1\n0x7000, 0x8800, 0x0800, 0x7000, 0x8000, 0x8000, 0xf800, 0x0000, // 2\n0xf800, 0x0800, 0x1000, 0x3000, 0x0800, 0x8800, 0x7000, 0x0000, // 3\n0x1000, 0x3000, 0x5000, 0x9000, 0xf800, 0x1000, 0x1000, 0x0000, // 4\n0xf800, 0x8000, 0xf000, 0x0800, 0x0800, 0x8800, 0x7000, 0x0000, // 5\n0x3800, 0x4000, 0x8000, 0xf000, 0x8800, 0x8800, 0x7000, 0x0000, // 6\n0xf800, 0x0800, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000, 0x0000, // 7\n0x7000, 0x8800, 0x8800, 0x7000, 0x8800, 0x8800, 0x7000, 0x0000, // 8\n0x7000, 0x8800, 0x8800, 0x7800, 0x0800, 0x1000, 0xe000, 0x0000, // 9\n0x0000, 0x0000, 0x2000, 0x0000, 0x2000, 0x0000, 0x0000, 0x0000, // :\n0x0000, 0x0000, 0x2000, 0x0000, 0x2000, 0x2000, 0x4000, 0x0000, // ;\n0x0800, 0x1000, 0x2000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0000, // &lt;\n0x0000, 0x0000, 0xf800, 0x0000, 0xf800, 0x0000, 0x0000, 0x0000, // =\n0x4000, 0x2000, 0x1000, 0x0800, 0x1000, 0x2000, 0x4000, 0x0000, // &gt;\n0x7000, 0x8800, 0x0800, 0x3000, 0x2000, 0x0000, 0x2000, 0x0000, // ?\n0x7000, 0x8800, 0xa800, 0xb800, 0xb000, 0x8000, 0x7800, 0x0000, // @\n0x2000, 0x5000, 0x8800, 0x8800, 0xf800, 0x8800, 0x8800, 0x0000, // A\n0xf000, 0x8800, 0x8800, 0xf000, 0x8800, 0x8800, 0xf000, 0x0000, // B\n0x7000, 0x8800, 0x8000, 0x8000, 0x8000, 0x8800, 0x7000, 0x0000, // C\n0xf000, 0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0xf000, 0x0000, // D\n0xf800, 0x8000, 0x8000, 0xf000, 0x8000, 0x8000, 0xf800, 0x0000, // E\n0xf800, 0x8000, 0x8000, 0xf000, 0x8000, 0x8000, 0x8000, 0x0000, // F\n0x7800, 0x8800, 0x8000, 0x8000, 0x9800, 0x8800, 0x7800, 0x0000, // G\n0x8800, 0x8800, 0x8800, 0xf800, 0x8800, 0x8800, 0x8800, 0x0000, // H\n0x7000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x7000, 0x0000, // I\n0x3800, 0x1000, 0x1000, 0x1000, 0x1000, 0x9000, 0x6000, 0x0000, // J\n0x8800, 0x9000, 0xa000, 0xc000, 0xa000, 0x9000, 0x8800, 0x0000, // K\n0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0xf800, 0x0000, // L\n0x8800, 0xd800, 0xa800, 0xa800, 0xa800, 0x8800, 0x8800, 0x0000, // M\n0x8800, 0x8800, 0xc800, 0xa800, 0x9800, 0x8800, 0x8800, 0x0000, // N\n0x7000, 0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x7000, 0x0000, // O\n0xf000, 0x8800, 0x8800, 0xf000, 0x8000, 0x8000, 0x8000, 0x0000, // P\n0x7000, 0x8800, 0x8800, 0x8800, 0xa800, 0x9000, 0x6800, 0x0000, // Q\n0xf000, 0x8800, 0x8800, 0xf000, 0xa000, 0x9000, 0x8800, 0x0000, // R\n0x7000, 0x8800, 0x8000, 0x7000, 0x0800, 0x8800, 0x7000, 0x0000, // S\n0xf800, 0xa800, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x0000, // T\n0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x7000, 0x0000, // U\n0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x5000, 0x2000, 0x0000, // V\n0x8800, 0x8800, 0x8800, 0xa800, 0xa800, 0xa800, 0x5000, 0x0000, // W\n0x8800, 0x8800, 0x5000, 0x2000, 0x5000, 0x8800, 0x8800, 0x0000, // X\n0x8800, 0x8800, 0x5000, 0x2000, 0x2000, 0x2000, 0x2000, 0x0000, // Y\n0xf800, 0x0800, 0x1000, 0x7000, 0x4000, 0x8000, 0xf800, 0x0000, // Z\n0x7800, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x7800, 0x0000, // [\n0x0000, 0x8000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0000, 0x0000, /* \\ */\n0x7800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x7800, 0x0000, // ]\n0x2000, 0x5000, 0x8800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // ^\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xf800, 0x0000, // _\n0x6000, 0x6000, 0x2000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, // `\n0x0000, 0x0000, 0x6000, 0x1000, 0x7000, 0x9000, 0x7800, 0x0000, // a\n0x8000, 0x8000, 0xb000, 0xc800, 0x8800, 0xc800, 0xb000, 0x0000, // b\n0x0000, 0x0000, 0x7000, 0x8800, 0x8000, 0x8800, 0x7000, 0x0000, // c\n0x0800, 0x0800, 0x6800, 0x9800, 0x8800, 0x9800, 0x6800, 0x0000, // d\n0x0000, 0x0000, 0x7000, 0x8800, 0xf800, 0x8000, 0x7000, 0x0000, // e\n0x1000, 0x2800, 0x2000, 0x7000, 0x2000, 0x2000, 0x2000, 0x0000, // f\n0x0000, 0x0000, 0x7000, 0x9800, 0x9800, 0x6800, 0x0800, 0x0000, // g\n0x8000, 0x8000, 0xb000, 0xc800, 0x8800, 0x8800, 0x8800, 0x0000, // h\n0x2000, 0x0000, 0x6000, 0x2000, 0x2000, 0x2000, 0x7000, 0x0000, // i\n0x1000, 0x0000, 0x1000, 0x1000, 0x1000, 0x9000, 0x6000, 0x0000, // j\n0x8000, 0x8000, 0x9000, 0xa000, 0xc000, 0xa000, 0x9000, 0x0000, // k\n0x6000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x7000, 0x0000, // l\n0x0000, 0x0000, 0xd000, 0xa800, 0xa800, 0xa800, 0xa800, 0x0000, // m\n0x0000, 0x0000, 0xb000, 0xc800, 0x8800, 0x8800, 0x8800, 0x0000, // n\n0x0000, 0x0000, 0x7000, 0x8800, 0x8800, 0x8800, 0x7000, 0x0000, // o\n0x0000, 0x0000, 0xb000, 0xc800, 0xc800, 0xb000, 0x8000, 0x0000, // p\n0x0000, 0x0000, 0x6800, 0x9800, 0x9800, 0x6800, 0x0800, 0x0000, // q\n0x0000, 0x0000, 0xb000, 0xc800, 0x8000, 0x8000, 0x8000, 0x0000, // r\n0x0000, 0x0000, 0x7800, 0x8000, 0x7000, 0x0800, 0xf000, 0x0000, // s\n0x2000, 0x2000, 0xf800, 0x2000, 0x2000, 0x2800, 0x1000, 0x0000, // t\n0x0000, 0x0000, 0x8800, 0x8800, 0x8800, 0x9800, 0x6800, 0x0000, // u\n0x0000, 0x0000, 0x8800, 0x8800, 0x8800, 0x5000, 0x2000, 0x0000, // v\n0x0000, 0x0000, 0x8800, 0x8800, 0xa800, 0xa800, 0x5000, 0x0000, // w\n0x0000, 0x0000, 0x8800, 0x5000, 0x2000, 0x5000, 0x8800, 0x0000, // x\n0x0000, 0x0000, 0x8800, 0x8800, 0x7800, 0x0800, 0x8800, 0x0000, // y\n0x0000, 0x0000, 0xf800, 0x1000, 0x2000, 0x4000, 0xf800, 0x0000, // z\n0x1000, 0x2000, 0x2000, 0x4000, 0x2000, 0x2000, 0x1000, 0x0000, // {\n0x2000, 0x2000, 0x2000, 0x0000, 0x2000, 0x2000, 0x2000, 0x0000, // |\n0x4000, 0x2000, 0x2000, 0x1000, 0x2000, 0x2000, 0x4000, 0x0000, // }\n0x4000, 0xa800, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // ~\n};\n\nFontDef Font_6x8 = { 6, 8, Font6x8 };\nFontDef Font_7x10 = { 7, 10, Font7x10 };\nFontDef Font_11x18 = { 11, 18, Font11x18 };\nFontDef Font_16x26 = { 16, 26, Font16x26 };\n</code></pre>"},{"location":"stm/Power_8cpp/","title":"File Power.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; Power.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"stm32f1xx_ll_adc.h\"</code></li> <li><code>#include \"stm32f1xx_ll_rcc.h\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"BuzzerController.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"Power.hpp\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/Flash.hpp\"</code></li> <li><code>#include \"utils/TaskWrapper.hpp\"</code></li> <li><code>#include \"utils/TickTimer.hpp\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"stm/Power_8cpp/#classes","title":"Classes","text":"Type Name struct CalibrationData"},{"location":"stm/Power_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint16_t ThresholdNoBatteryMv   = = 5000 constexpr uint16_t ThresholdPowerOffMv   = = 6600 CalibrationData calib   = = calibrationDefaults constexpr uint32_t calibrationDataMagic   = = 0x4BCA001 constexpr CalibrationData calibrationDefaults   = = { .magic = calibrationDataMagic, .batteryCoef = 3.4f, .batteryMidCoef = 1.56f, .internalVrefMv = 1200, .tempTypicalMv = 1430, .tempTypicalAtC = 25, } constexpr uint32_t dispatchStatPeriodMs   = = 250 TickTimer dispatchStatTimer uint16_t rawBattery   = = 0 uint16_t rawInternalRef   = = 0 uint16_t rawMidBattery   = = 0 uint16_t rawTemperature   = = 0 constexpr uint16_t tempAvgSlope   = = 4300 int undervoltageCounter   = = 0 constexpr int undervoltageShutdownThreshold   = = 5000 / dispatchStatPeriodMs bool undervoltageWarningOn   = = false uint16_t vrefMv   = = 0"},{"location":"stm/Power_8cpp/#public-functions","title":"Public Functions","text":"Type Name void AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER ()  uint16_t powerBatteryMidMv ()  uint16_t powerBatteryMv ()  void powerCalibrate (uint16_t vccMv, uint16_t bMidMv, uint16_t vref33Mv, uint16_t currentTemperatureC)  void powerInit ()  void powerPoll ()  void powerShutDown ()  uint16_t powerTemperatureC ()  uint16_t powerVrefMv ()"},{"location":"stm/Power_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void adcWait (uint32_t clockCycles)  void checkBatteryVoltage (uint16_t vccMv)  void loadCalibration ()"},{"location":"stm/Power_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/Power_8cpp/#variable-thresholdnobatterymv","title":"variable ThresholdNoBatteryMv","text":"<pre><code>constexpr uint16_t ThresholdNoBatteryMv;\n</code></pre>"},{"location":"stm/Power_8cpp/#variable-thresholdpoweroffmv","title":"variable ThresholdPowerOffMv","text":"<pre><code>constexpr uint16_t ThresholdPowerOffMv;\n</code></pre>"},{"location":"stm/Power_8cpp/#variable-calib","title":"variable calib","text":"<pre><code>CalibrationData calib;\n</code></pre>"},{"location":"stm/Power_8cpp/#variable-calibrationdatamagic","title":"variable calibrationDataMagic","text":"<pre><code>constexpr uint32_t calibrationDataMagic;\n</code></pre>"},{"location":"stm/Power_8cpp/#variable-calibrationdefaults","title":"variable calibrationDefaults","text":"<pre><code>constexpr CalibrationData calibrationDefaults;\n</code></pre>"},{"location":"stm/Power_8cpp/#variable-dispatchstatperiodms","title":"variable dispatchStatPeriodMs","text":"<pre><code>constexpr uint32_t dispatchStatPeriodMs;\n</code></pre>"},{"location":"stm/Power_8cpp/#variable-dispatchstattimer","title":"variable dispatchStatTimer","text":"<pre><code>TickTimer dispatchStatTimer;\n</code></pre>"},{"location":"stm/Power_8cpp/#variable-rawbattery","title":"variable rawBattery","text":"<pre><code>uint16_t rawBattery;\n</code></pre>"},{"location":"stm/Power_8cpp/#variable-rawinternalref","title":"variable rawInternalRef","text":"<pre><code>uint16_t rawInternalRef;\n</code></pre>"},{"location":"stm/Power_8cpp/#variable-rawmidbattery","title":"variable rawMidBattery","text":"<pre><code>uint16_t rawMidBattery;\n</code></pre>"},{"location":"stm/Power_8cpp/#variable-rawtemperature","title":"variable rawTemperature","text":"<pre><code>uint16_t rawTemperature;\n</code></pre>"},{"location":"stm/Power_8cpp/#variable-tempavgslope","title":"variable tempAvgSlope","text":"<pre><code>constexpr uint16_t tempAvgSlope;\n</code></pre>"},{"location":"stm/Power_8cpp/#variable-undervoltagecounter","title":"variable undervoltageCounter","text":"<pre><code>int undervoltageCounter;\n</code></pre>"},{"location":"stm/Power_8cpp/#variable-undervoltageshutdownthreshold","title":"variable undervoltageShutdownThreshold","text":"<pre><code>constexpr int undervoltageShutdownThreshold;\n</code></pre>"},{"location":"stm/Power_8cpp/#variable-undervoltagewarningon","title":"variable undervoltageWarningOn","text":"<pre><code>bool undervoltageWarningOn;\n</code></pre>"},{"location":"stm/Power_8cpp/#variable-vrefmv","title":"variable vrefMv","text":"<pre><code>uint16_t vrefMv;\n</code></pre>"},{"location":"stm/Power_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/Power_8cpp/#function-auxiliary_and_motor_adc_irq_handler","title":"function AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER","text":"<pre><code>void AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER () </code></pre>"},{"location":"stm/Power_8cpp/#function-powerbatterymidmv","title":"function powerBatteryMidMv","text":"<pre><code>uint16_t powerBatteryMidMv () </code></pre>"},{"location":"stm/Power_8cpp/#function-powerbatterymv","title":"function powerBatteryMv","text":"<pre><code>uint16_t powerBatteryMv () </code></pre>"},{"location":"stm/Power_8cpp/#function-powercalibrate","title":"function powerCalibrate","text":"<pre><code>void powerCalibrate (\nuint16_t vccMv,\nuint16_t bMidMv,\nuint16_t vref33Mv,\nuint16_t currentTemperatureC\n) </code></pre>"},{"location":"stm/Power_8cpp/#function-powerinit","title":"function powerInit","text":"<pre><code>void powerInit () </code></pre>"},{"location":"stm/Power_8cpp/#function-powerpoll","title":"function powerPoll","text":"<pre><code>void powerPoll () </code></pre>"},{"location":"stm/Power_8cpp/#function-powershutdown","title":"function powerShutDown","text":"<pre><code>void powerShutDown () </code></pre>"},{"location":"stm/Power_8cpp/#function-powertemperaturec","title":"function powerTemperatureC","text":"<pre><code>uint16_t powerTemperatureC () </code></pre>"},{"location":"stm/Power_8cpp/#function-powervrefmv","title":"function powerVrefMv","text":"<pre><code>uint16_t powerVrefMv () </code></pre>"},{"location":"stm/Power_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"stm/Power_8cpp/#function-adcwait","title":"function adcWait","text":"<pre><code>static void adcWait (\nuint32_t clockCycles\n) </code></pre>"},{"location":"stm/Power_8cpp/#function-checkbatteryvoltage","title":"function checkBatteryVoltage","text":"<pre><code>static void checkBatteryVoltage (\nuint16_t vccMv\n) </code></pre>"},{"location":"stm/Power_8cpp/#function-loadcalibration","title":"function loadCalibration","text":"<pre><code>static void loadCalibration () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/Power.cpp</code></p>"},{"location":"stm/Power_8cpp_source/","title":"File Power.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; Power.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"stm32f1xx_ll_adc.h\"\n#include \"stm32f1xx_ll_rcc.h\"\n\n#include \"Bsp.hpp\"\n#include \"BuzzerController.hpp\"\n#include \"Dispatcher.hpp\"\n#include \"Power.hpp\"\n#include \"utils/Debug.hpp\"\n#include \"utils/Flash.hpp\"\n#include \"utils/TaskWrapper.hpp\"\n#include \"utils/TickTimer.hpp\"\n\n#include \"rbcx.pb.h\"\n\nstatic constexpr uint16_t ThresholdNoBatteryMv = 5000;\nstatic constexpr uint16_t ThresholdPowerOffMv = 6600;\n\nstatic constexpr uint32_t dispatchStatPeriodMs = 250;\nstatic TickTimer dispatchStatTimer;\n\nstatic uint16_t rawBattery = 0;\nstatic uint16_t rawMidBattery = 0;\nstatic uint16_t rawInternalRef = 0;\nstatic uint16_t rawTemperature = 0;\nstatic uint16_t vrefMv = 0;\n\nstatic constexpr int undervoltageShutdownThreshold\n= 5000 / dispatchStatPeriodMs;\nstatic int undervoltageCounter = 0;\nstatic bool undervoltageWarningOn = false;\n\nstatic constexpr uint16_t tempAvgSlope = 4300;\n\n// Make sure to change the magic when CalibrationData changes.\nstatic constexpr uint32_t calibrationDataMagic = 0x4BCA001;\nstruct CalibrationData {\nuint32_t magic;\nfloat batteryCoef;\nfloat batteryMidCoef;\nuint16_t internalVrefMv;\nuint16_t tempTypicalMv;\nuint16_t tempTypicalAtC;\n};\n\nstatic constexpr CalibrationData calibrationDefaults = {\n.magic = calibrationDataMagic,\n.batteryCoef = 3.4f,\n.batteryMidCoef = 1.56f,\n.internalVrefMv = 1200,\n.tempTypicalMv = 1430,\n.tempTypicalAtC = 25,\n};\n\nstatic CalibrationData calib = calibrationDefaults;\n\nstatic void adcWait(uint32_t clockCycles) {\nif (clockCycles == 0)\nreturn;\nuint32_t adcPrescaler = 1;\nconst uint32_t APB2prescaler = LL_RCC_GetAPB2Prescaler();\nif (APB2prescaler != 0)\nadcPrescaler\n&lt;&lt;= ((APB2prescaler - RCC_CFGR_PPRE2_DIV2) &gt;&gt; RCC_CFGR_PPRE2_Pos)\n+ 1;\nadcPrescaler *= 2\n* ((LL_RCC_GetADCClockSource(RCC_CFGR_ADCPRE) &gt;&gt; RCC_CFGR_ADCPRE_Pos)\n+ 1);\nclockCycles *= adcPrescaler;\nwhile (--clockCycles != 0)\n;\n}\n\nstatic void loadCalibration() {\nconst volatile auto* flashData\n= (volatile CalibrationData*)FLASH_PAGE_POWER_CALIBRATION;\n\nswitch (flashData-&gt;magic) {\ncase calibrationDataMagic:\nbreak;\ncase 0xFFFFFFFF:\nDEBUG(\"No calibration data found, using defaults.\\n\");\nreturn;\ndefault:\nDEBUG(\"Calibration data found, but wrong magic: %08lX, using defaults.\",\nflashData-&gt;magic);\nreturn;\n}\n\nmemcpy(&amp;calib, (void*)flashData, sizeof(CalibrationData));\n\nDEBUG(\n\"Loaded calibration data - VCC:%f BMID:%f VREFINT:%dmV temp:%dmV@%dC\\n\",\ncalib.batteryCoef, calib.batteryMidCoef, calib.internalVrefMv,\ncalib.tempTypicalMv, calib.tempTypicalAtC);\n}\n\nvoid powerInit() {\npinInit(\nbatteryVoltagePin, GPIO_MODE_ANALOG, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\npinInit(batteryMiddleVoltagePin, GPIO_MODE_ANALOG, GPIO_NOPULL,\nGPIO_SPEED_FREQ_LOW);\n\nloadCalibration();\n\nLL_ADC_InitTypeDef cfg;\nLL_ADC_StructInit(&amp;cfg);\ncfg.DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;\ncfg.SequencersScanMode = LL_ADC_SEQ_SCAN_ENABLE;\nif (LL_ADC_Init(auxiliaryAdc, &amp;cfg) != SUCCESS)\nabort();\n\nLL_ADC_REG_InitTypeDef cfgReg;\nLL_ADC_REG_StructInit(&amp;cfgReg);\ncfgReg.ContinuousMode = LL_ADC_REG_CONV_CONTINUOUS;\ncfgReg.SequencerLength = LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS;\ncfgReg.TriggerSource = LL_ADC_REG_TRIG_SOFTWARE;\nif (LL_ADC_REG_Init(auxiliaryAdc, &amp;cfgReg) != SUCCESS)\nabort();\n\nLL_ADC_INJ_InitTypeDef cfgInj;\nLL_ADC_INJ_StructInit(&amp;cfgInj);\ncfgInj.TriggerSource = LL_ADC_INJ_TRIG_SOFTWARE;\ncfgInj.TrigAuto = LL_ADC_INJ_TRIG_FROM_GRP_REGULAR;\nif (LL_ADC_INJ_Init(auxiliaryAdc, &amp;cfgInj) != SUCCESS)\nabort();\n\nLL_ADC_SetCommonPathInternalCh(ADC12_COMMON, LL_ADC_PATH_INTERNAL_VREFINT);\n\nLL_ADC_Enable(auxiliaryAdc);\nadcWait(LL_ADC_DELAY_ENABLE_CALIB_ADC_CYCLES);\nLL_ADC_StartCalibration(auxiliaryAdc);\nwhile (LL_ADC_IsCalibrationOnGoing(auxiliaryAdc))\n;\n\nLL_ADC_SetChannelSamplingTimeFix(\nauxiliaryAdc, batteryVoltageAdcChannel, LL_ADC_SAMPLINGTIME_1CYCLE_5);\nLL_ADC_SetChannelSamplingTimeFix(auxiliaryAdc,\nbatteryMiddleVoltageAdcChannel, LL_ADC_SAMPLINGTIME_1CYCLE_5);\nLL_ADC_SetChannelSamplingTimeFix(\nauxiliaryAdc, LL_ADC_CHANNEL_VREFINT, LL_ADC_SAMPLINGTIME_239CYCLES_5);\nLL_ADC_SetChannelSamplingTimeFix(auxiliaryAdc, LL_ADC_CHANNEL_TEMPSENSOR,\nLL_ADC_SAMPLINGTIME_239CYCLES_5);\n\nauxiliaryAdc-&gt;JSQR = ADC_JSQR_JL\n| (batteryVoltageAdcChannel &amp; ADC_JSQR_JSQ1)\n&lt;&lt; (ADC_JSQR_JSQ2_Pos * ((batteryVoltageAdcRank - 1) &amp; 3))\n| (LL_ADC_CHANNEL_VREFINT &amp; ADC_JSQR_JSQ1)\n&lt;&lt; (ADC_JSQR_JSQ2_Pos * ((internalReferenceVoltageAdcRank - 1) &amp; 3))\n| (batteryMiddleVoltageAdcChannel &amp; ADC_JSQR_JSQ1)\n&lt;&lt; (ADC_JSQR_JSQ2_Pos * ((batteryMiddleVoltageAdcRank - 1) &amp; 3))\n| (LL_ADC_CHANNEL_TEMPSENSOR &amp; ADC_JSQR_JSQ1)\n&lt;&lt; (ADC_JSQR_JSQ2_Pos * ((temperatureAdcRank - 1) &amp; 3));\n\nLL_ADC_EnableIT_JEOS(auxiliaryAdc);\nHAL_NVIC_SetPriority(\nauxiliaryAndMotorAdcIRQn, auxiliaryAndMotorAdcIrqPrio, 0);\nHAL_NVIC_EnableIRQ(auxiliaryAndMotorAdcIRQn);\n\nLL_ADC_REG_StartConversionSWStart(auxiliaryAdc);\nLL_ADC_INJ_StartConversionSWStart(auxiliaryAdc);\n\ndispatchStatTimer.restart(dispatchStatPeriodMs);\n}\n\nextern \"C\" void AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER() {\nif (LL_ADC_IsEnabledIT_JEOS(auxiliaryAdc)\n&amp;&amp; LL_ADC_IsActiveFlag_JEOS(auxiliaryAdc)) {\n\nrawBattery = LL_ADC_INJ_ReadConversionData12(\nauxiliaryAdc, batteryVoltageAdcRank);\nrawMidBattery = LL_ADC_INJ_ReadConversionData12(\nauxiliaryAdc, batteryMiddleVoltageAdcRank);\nrawTemperature\n= LL_ADC_INJ_ReadConversionData12(auxiliaryAdc, temperatureAdcRank);\nrawInternalRef = LL_ADC_INJ_ReadConversionData12(\nauxiliaryAdc, internalReferenceVoltageAdcRank);\n\nvrefMv = calib.internalVrefMv\n* __LL_ADC_DIGITAL_SCALE(LL_ADC_RESOLUTION_12B) / rawInternalRef;\n\nLL_ADC_ClearFlag_JEOS(auxiliaryAdc);\n}\nHAL_NVIC_ClearPendingIRQ(auxiliaryAndMotorAdcIRQn);\n}\n\nuint16_t powerBatteryMv() {\nreturn __LL_ADC_CALC_DATA_TO_VOLTAGE(\nvrefMv, rawBattery, LL_ADC_RESOLUTION_12B)\n* calib.batteryCoef;\n}\n\nuint16_t powerBatteryMidMv() {\nreturn __LL_ADC_CALC_DATA_TO_VOLTAGE(\nvrefMv, rawMidBattery, LL_ADC_RESOLUTION_12B)\n* calib.batteryMidCoef;\n}\n\nuint16_t powerTemperatureC() {\nreturn __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS(tempAvgSlope,\ncalib.tempTypicalMv, calib.tempTypicalAtC, vrefMv, rawTemperature,\nLL_ADC_RESOLUTION_12B);\n}\n\nuint16_t powerVrefMv() { return vrefMv; }\n\nvoid powerCalibrate(uint16_t vccMv, uint16_t bMidMv, uint16_t vref33Mv,\nuint16_t currentTemperatureC) {\n\nwhile (vrefMv == 0)\n;\n\nportTICK_TYPE_ENTER_CRITICAL();\n\nif (vref33Mv == POWER_CALIBRATE_DEFAULT) {\ncalib.internalVrefMv = calibrationDefaults.internalVrefMv;\n} else if (vref33Mv != POWER_CALIBRATE_NO_CHANGE) {\nvrefMv = vref33Mv;\ncalib.internalVrefMv = vrefMv * rawInternalRef\n/ __LL_ADC_DIGITAL_SCALE(LL_ADC_RESOLUTION_12B);\n}\n\nif (vccMv == POWER_CALIBRATE_DEFAULT) {\ncalib.batteryCoef = calibrationDefaults.batteryCoef;\n} else if (vccMv != POWER_CALIBRATE_NO_CHANGE) {\ncalib.batteryCoef = float(vccMv)\n/ float(__LL_ADC_CALC_DATA_TO_VOLTAGE(\nvrefMv, rawBattery, LL_ADC_RESOLUTION_12B));\n}\n\nif (bMidMv == POWER_CALIBRATE_DEFAULT) {\ncalib.batteryMidCoef = calibrationDefaults.batteryMidCoef;\n} else if (bMidMv != POWER_CALIBRATE_NO_CHANGE) {\ncalib.batteryMidCoef = float(bMidMv)\n/ float(__LL_ADC_CALC_DATA_TO_VOLTAGE(\nvrefMv, rawMidBattery, LL_ADC_RESOLUTION_12B));\n}\n\nif (currentTemperatureC == POWER_CALIBRATE_DEFAULT) {\ncalib.tempTypicalMv = calibrationDefaults.tempTypicalMv;\ncalib.tempTypicalAtC = calibrationDefaults.tempTypicalAtC;\n} else if (currentTemperatureC != POWER_CALIBRATE_NO_CHANGE) {\ncalib.tempTypicalMv = __LL_ADC_CALC_DATA_TO_VOLTAGE(\nvrefMv, rawTemperature, LL_ADC_RESOLUTION_12B);\ncalib.tempTypicalAtC = currentTemperatureC;\n}\n\nportTICK_TYPE_EXIT_CRITICAL();\n\nflashWritePage(FLASH_PAGE_POWER_CALIBRATION, (uint8_t*)&amp;calib,\nsizeof(CalibrationData));\n\nDEBUG(\"New coefs set, internalRef: %dmv bat: %f mid %f temp %d@%d\\n\",\ncalib.internalVrefMv, calib.batteryCoef, calib.batteryMidCoef,\ncalib.tempTypicalMv, calib.tempTypicalAtC);\n}\n\nvoid powerShutDown() {\nDEBUG(\"Shutting down battery power...\\n\");\n\nif (pinRead(usbBusDetectionPin)) {\npinWrite(powerPin, 0);\nreturn;\n}\n\nvTaskDelay(1);\n\n__disable_irq();\n\npinWrite(powerPin, 0);\n\n// Blink red LED \"pretty fast\"\nuint32_t leds = 0;\nwhile (true) {\nleds ^= CoprocReq_LedsEnum_L3;\nsetLeds(leds);\n\nfor (volatile int i = 0; i &lt; 200000; i++)\n;\n}\n}\n\nstatic void checkBatteryVoltage(uint16_t vccMv) {\nif (vccMv &lt; ThresholdNoBatteryMv) {\nif (undervoltageWarningOn) {\nundervoltageWarningOn = false;\npinWrite(led3Pin, false);\nbuzzerSetState(false);\n}\nreturn;\n}\n\nif (vccMv &lt; ThresholdPowerOffMv &amp;&amp; pinRead(powerPin)) {\n++undervoltageCounter;\nundervoltageWarningOn = !undervoltageWarningOn;\npinWrite(led3Pin, undervoltageWarningOn);\nbuzzerSetState(undervoltageWarningOn);\nDEBUG(\"Battery voltage is low, %dmv.\\n\", vccMv);\n\nif (undervoltageCounter &gt; undervoltageShutdownThreshold) {\nundervoltageCounter = 0;\nDEBUG(\"Battery voltage low, %dmv. Shutting down.\\n\", vccMv);\npowerShutDown();\n}\n} else if (undervoltageCounter &gt; 0) {\n--undervoltageCounter;\nif (undervoltageWarningOn) {\nundervoltageWarningOn = false;\npinWrite(led3Pin, false);\nbuzzerSetState(false);\n}\n}\n}\n\nvoid powerPoll() {\nif (dispatchStatTimer.poll()) {\nconst auto vccMv = powerBatteryMv();\ncheckBatteryVoltage(vccMv);\n\nCoprocStat status = {\n.which_payload = CoprocStat_powerAdcStat_tag,\n};\nstatus.payload.powerAdcStat.vccMv = vccMv;\nstatus.payload.powerAdcStat.battMidMv = powerBatteryMidMv();\nstatus.payload.powerAdcStat.temperatureC = powerTemperatureC();\ndispatcherEnqueueStatus(status);\n\ndispatchStatTimer.restart(dispatchStatPeriodMs);\n}\n}\n</code></pre>"},{"location":"stm/StupidServoController_8cpp/","title":"File StupidServoController.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; StupidServoController.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"StupidServoController.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"ControlLink.hpp\"</code></li> <li><code>#include \"stm32f1xx_hal_rcc.h\"</code></li> <li><code>#include \"stm32f1xx_ll_tim.h\"</code></li> </ul>"},{"location":"stm/StupidServoController_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name uint32_t pwmCenterValue float pwmCoef"},{"location":"stm/StupidServoController_8cpp/#public-functions","title":"Public Functions","text":"Type Name void stupidServoDispatch (const CoprocReq_SetStupidServo &amp; request)  void stupidServoInit ()  void stupidServoReset ()"},{"location":"stm/StupidServoController_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void stupidServoDisable (int servoIndex)  void stupidServoSetPosition (int servoIndex, float position)"},{"location":"stm/StupidServoController_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/StupidServoController_8cpp/#variable-pwmcentervalue","title":"variable pwmCenterValue","text":"<pre><code>uint32_t pwmCenterValue;\n</code></pre>"},{"location":"stm/StupidServoController_8cpp/#variable-pwmcoef","title":"variable pwmCoef","text":"<pre><code>float pwmCoef;\n</code></pre>"},{"location":"stm/StupidServoController_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/StupidServoController_8cpp/#function-stupidservodispatch","title":"function stupidServoDispatch","text":"<pre><code>void stupidServoDispatch (\nconst CoprocReq_SetStupidServo &amp; request\n) </code></pre>"},{"location":"stm/StupidServoController_8cpp/#function-stupidservoinit","title":"function stupidServoInit","text":"<pre><code>void stupidServoInit () </code></pre>"},{"location":"stm/StupidServoController_8cpp/#function-stupidservoreset","title":"function stupidServoReset","text":"<pre><code>void stupidServoReset () </code></pre>"},{"location":"stm/StupidServoController_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"stm/StupidServoController_8cpp/#function-stupidservodisable","title":"function stupidServoDisable","text":"<pre><code>static void stupidServoDisable (\nint servoIndex\n) </code></pre>"},{"location":"stm/StupidServoController_8cpp/#function-stupidservosetposition","title":"function stupidServoSetPosition","text":"<pre><code>static void stupidServoSetPosition (\nint servoIndex,\nfloat position\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/StupidServoController.cpp</code></p>"},{"location":"stm/StupidServoController_8cpp_source/","title":"File StupidServoController.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; StupidServoController.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"StupidServoController.hpp\"\n\n#include \"Bsp.hpp\"\n#include \"ControlLink.hpp\"\n#include \"stm32f1xx_hal_rcc.h\"\n#include \"stm32f1xx_ll_tim.h\"\n\nstatic uint32_t pwmCenterValue;\nstatic float pwmCoef;\n\nvoid stupidServoInit() {\nLL_TIM_InitTypeDef pwmInit;\nLL_TIM_StructInit(&amp;pwmInit);\nauto apb1TimClk = 2 * HAL_RCC_GetPCLK1Freq();\n\n// 1/50 s :\npwmInit.Autoreload = 65535;\npwmInit.Prescaler = (apb1TimClk / 50) / pwmInit.Autoreload;\npwmInit.CounterMode = LL_TIM_COUNTERMODE_UP;\npwmInit.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;\npwmInit.RepetitionCounter = 0;\n\n// Center at 1.5ms within 1/50s\npwmCenterValue = uint32_t(pwmInit.Autoreload * 0.075f);\n// Range +- 0.5ms within 1/50s\npwmCoef = pwmInit.Autoreload * 0.025f;\n\nLL_TIM_OC_InitTypeDef ocInit;\nLL_TIM_OC_StructInit(&amp;ocInit);\nocInit.OCMode = LL_TIM_OCMODE_PWM1;\nocInit.OCState = LL_TIM_OCSTATE_DISABLE;\nocInit.CompareValue = pwmCenterValue;\nocInit.OCPolarity = LL_TIM_OCPOLARITY_HIGH;\nocInit.OCIdleState = LL_TIM_OCIDLESTATE_LOW;\nLL_TIM_Init(servoTimer, &amp;pwmInit);\n\nfor (uint16_t channel = LL_TIM_CHANNEL_CH1; channel != 0; channel &lt;&lt;= 4) {\nLL_TIM_OC_Init(servoTimer, channel, &amp;ocInit);\nLL_TIM_OC_EnablePreload(servoTimer, channel);\n}\nLL_TIM_SetOffStates(servoTimer, LL_TIM_OSSI_DISABLE, LL_TIM_OSSR_ENABLE);\nLL_TIM_GenerateEvent_UPDATE(servoTimer);\nLL_TIM_EnableCounter(servoTimer);\nLL_TIM_EnableAllOutputs(servoTimer);\n}\n\nstatic void stupidServoDisable(int servoIndex) {\nswitch (servoIndex) {\ncase 0:\nLL_TIM_CC_DisableChannel(servoTimer, LL_TIM_CHANNEL_CH1);\nbreak;\ncase 1:\nLL_TIM_CC_DisableChannel(servoTimer, LL_TIM_CHANNEL_CH2);\nbreak;\ncase 2:\nLL_TIM_CC_DisableChannel(servoTimer, LL_TIM_CHANNEL_CH3);\nbreak;\ncase 3:\nLL_TIM_CC_DisableChannel(servoTimer, LL_TIM_CHANNEL_CH4);\nbreak;\n}\n}\n\nstatic void stupidServoSetPosition(int servoIndex, float position) {\nuint32_t value = pwmCenterValue + int32_t(pwmCoef * position);\n\nswitch (servoIndex) {\ncase 0:\nLL_TIM_CC_EnableChannel(servoTimer, LL_TIM_CHANNEL_CH1);\nLL_TIM_OC_SetCompareCH1(servoTimer, value);\nbreak;\ncase 1:\nLL_TIM_CC_EnableChannel(servoTimer, LL_TIM_CHANNEL_CH2);\nLL_TIM_OC_SetCompareCH2(servoTimer, value);\nbreak;\ncase 2:\nLL_TIM_CC_EnableChannel(servoTimer, LL_TIM_CHANNEL_CH3);\nLL_TIM_OC_SetCompareCH3(servoTimer, value);\nbreak;\ncase 3:\nLL_TIM_CC_EnableChannel(servoTimer, LL_TIM_CHANNEL_CH4);\nLL_TIM_OC_SetCompareCH4(servoTimer, value);\nbreak;\n}\n}\n\nvoid stupidServoDispatch(const CoprocReq_SetStupidServo&amp; request) {\nswitch (request.which_servoCmd) {\ncase CoprocReq_SetStupidServo_disable_tag:\nstupidServoDisable(request.servoIndex);\nbreak;\ncase CoprocReq_SetStupidServo_setPosition_tag:\nstupidServoSetPosition(\nrequest.servoIndex, request.servoCmd.setPosition);\nbreak;\n}\n\nCoprocStat status;\nstatus.which_payload = CoprocStat_stupidServoStat_tag;\ncontrolLinkTx(status);\n}\n\nvoid stupidServoReset() {\nfor (int i = 0; i &lt; 4; ++i) {\nstupidServoDisable(i);\n}\n}\n</code></pre>"},{"location":"stm/UltrasoundController_8cpp/","title":"File UltrasoundController.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; UltrasoundController.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"UltrasoundController.hpp\"</code></li> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"stm32f1xx_hal_rcc.h\"</code></li> <li><code>#include \"stm32f1xx_ll_exti.h\"</code></li> <li><code>#include \"stm32f1xx_ll_tim.h\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/QueueWrapper.hpp\"</code></li> <li><code>#include \"utils/TaskWrapper.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> </ul>"},{"location":"stm/UltrasoundController_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const uint16_t echoRestoreTimeoutMs   = = 180 const uint16_t pingTimeoutMs   = = 30 uint32_t risingMicros CoprocStat status QueueWrapper&lt; int, 16 &gt; trigQueue int utsActiveIndex TaskWrapper&lt; 512 &gt; utsTask"},{"location":"stm/UltrasoundController_8cpp/#public-functions","title":"Public Functions","text":"Type Name void ultrasoundDispatch (const CoprocReq_UltrasoundReq &amp; request)  void ultrasoundInit ()  void ultrasoundOnEchoEdge ()  void ultrasoundReset ()"},{"location":"stm/UltrasoundController_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/UltrasoundController_8cpp/#variable-echorestoretimeoutms","title":"variable echoRestoreTimeoutMs","text":"<pre><code>const uint16_t echoRestoreTimeoutMs;\n</code></pre>"},{"location":"stm/UltrasoundController_8cpp/#variable-pingtimeoutms","title":"variable pingTimeoutMs","text":"<pre><code>const uint16_t pingTimeoutMs;\n</code></pre>"},{"location":"stm/UltrasoundController_8cpp/#variable-risingmicros","title":"variable risingMicros","text":"<pre><code>uint32_t risingMicros;\n</code></pre>"},{"location":"stm/UltrasoundController_8cpp/#variable-status","title":"variable status","text":"<pre><code>CoprocStat status;\n</code></pre>"},{"location":"stm/UltrasoundController_8cpp/#variable-trigqueue","title":"variable trigQueue","text":"<pre><code>QueueWrapper&lt;int, 16&gt; trigQueue;\n</code></pre>"},{"location":"stm/UltrasoundController_8cpp/#variable-utsactiveindex","title":"variable utsActiveIndex","text":"<pre><code>int utsActiveIndex;\n</code></pre>"},{"location":"stm/UltrasoundController_8cpp/#variable-utstask","title":"variable utsTask","text":"<pre><code>TaskWrapper&lt;512&gt; utsTask;\n</code></pre>"},{"location":"stm/UltrasoundController_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/UltrasoundController_8cpp/#function-ultrasounddispatch","title":"function ultrasoundDispatch","text":"<pre><code>void ultrasoundDispatch (\nconst CoprocReq_UltrasoundReq &amp; request\n) </code></pre>"},{"location":"stm/UltrasoundController_8cpp/#function-ultrasoundinit","title":"function ultrasoundInit","text":"<pre><code>void ultrasoundInit () </code></pre>"},{"location":"stm/UltrasoundController_8cpp/#function-ultrasoundonechoedge","title":"function ultrasoundOnEchoEdge","text":"<pre><code>void ultrasoundOnEchoEdge () </code></pre>"},{"location":"stm/UltrasoundController_8cpp/#function-ultrasoundreset","title":"function ultrasoundReset","text":"<pre><code>void ultrasoundReset () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/UltrasoundController.cpp</code></p>"},{"location":"stm/UltrasoundController_8cpp_source/","title":"File UltrasoundController.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; UltrasoundController.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"UltrasoundController.hpp\"\n#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx_hal_rcc.h\"\n#include \"stm32f1xx_ll_exti.h\"\n#include \"stm32f1xx_ll_tim.h\"\n#include \"utils/Debug.hpp\"\n#include \"utils/QueueWrapper.hpp\"\n#include \"utils/TaskWrapper.hpp\"\n\n#include \"Bsp.hpp\"\n#include \"Dispatcher.hpp\"\n\nstatic const uint16_t pingTimeoutMs = 30;\nstatic const uint16_t echoRestoreTimeoutMs = 180;\nstatic CoprocStat status;\nstatic int utsActiveIndex;\nstatic uint32_t risingMicros;\nstatic TaskWrapper&lt;512&gt; utsTask;\nstatic QueueWrapper&lt;int, 16&gt; trigQueue;\n\nvoid ultrasoundInit() {\nLL_TIM_InitTypeDef timInit;\nLL_TIM_StructInit(&amp;timInit);\nauto apb1TimClk = 2 * HAL_RCC_GetPCLK1Freq();\n\ntimInit.Autoreload = pingTimeoutMs * 1000;\ntimInit.Prescaler = apb1TimClk / 1'000'000; // 1 us ticks\nLL_TIM_Init(utsTimer, &amp;timInit);\nLL_TIM_SetOnePulseMode(utsTimer, LL_TIM_ONEPULSEMODE_SINGLE);\nLL_TIM_SetUpdateSource(utsTimer, LL_TIM_UPDATESOURCE_COUNTER);\nLL_TIM_ClearFlag_UPDATE(utsTimer);\n\nfor (const auto&amp; p : utsEchoPin) {\nLL_EXTI_DisableIT_0_31(p.second);\n}\n\ntrigQueue.create();\nutsTask.start(\"ultrasound\", ultrasoundTaskPrio, []() {\nwhile (true) {\nint utsIndex;\ntrigQueue.pop_front(utsIndex);\n\n// Wait for potential ECHO high\nauto echoWait = [=]() {\nTickType_t before = xTaskGetTickCount();\nwhile (pinRead(utsEchoPin[utsIndex])) {\nif ((xTaskGetTickCount() - before)\n&gt; pdMS_TO_TICKS(echoRestoreTimeoutMs)) {\nreturn false;\n}\nvTaskDelay(pdMS_TO_TICKS(5));\n}\nreturn true;\n};\nif (!echoWait()) {\nDEBUG(\"Ultrasound ECHO %d hanging high\\n\", utsIndex);\ncontinue;\n}\n\n// Reset timer\nLL_TIM_GenerateEvent_UPDATE(utsTimer);\nLL_TIM_ClearFlag_UPDATE(utsTimer);\n\n// Perform TRIG pulse\ntaskENTER_CRITICAL();\nLL_TIM_EnableCounter(utsTimer);\npinWrite(utsTrigPin[utsIndex], true);\nwhile (LL_TIM_GetCounter(utsTimer) &lt; 10\n&amp;&amp; !LL_TIM_IsActiveFlag_UPDATE(utsTimer)) { // 10 us pulse\n}\npinWrite(utsTrigPin[utsIndex], false);\ntaskEXIT_CRITICAL();\n\n// Wait for ECHO measurement from ISR\nutsActiveIndex = utsIndex;\nxTaskNotifyStateClear(nullptr);\nLL_EXTI_EnableIT_0_31(utsEchoPin[utsIndex].second);\nuint32_t micros = 0;\nauto ok = xTaskNotifyWait(\n0U, ~0U, &amp;micros, pdMS_TO_TICKS(pingTimeoutMs));\nLL_EXTI_DisableIT_0_31(utsEchoPin[utsIndex].second);\n\n// Send measurement\nstatus = CoprocStat_init_default;\nstatus.which_payload = CoprocStat_ultrasoundStat_tag;\nstatus.payload.ultrasoundStat.utsIndex = utsIndex;\nstatus.payload.ultrasoundStat.roundtripMicrosecs = ok ? micros : 0;\ndispatcherEnqueueStatus(status);\n}\n});\n}\n\nvoid ultrasoundDispatch(const CoprocReq_UltrasoundReq&amp; request) {\nif (request.utsIndex &gt; 3) {\nDEBUG(\"Ultrasound index %lu out of range\\n\", request.utsIndex);\nreturn;\n}\n\nswitch (request.which_utsCmd) {\ncase CoprocReq_UltrasoundReq_singlePing_tag:\nif (!trigQueue.push_back(request.utsIndex, 0)) {\nDEBUG(\"Ultrasound TRIG queue overflow\\n\");\n}\nbreak;\n}\n}\n\nvoid ultrasoundOnEchoEdge() {\nauto nowMicros = LL_TIM_GetCounter(utsTimer);\n\nif (pinRead(utsEchoPin[utsActiveIndex])) {\nrisingMicros = nowMicros;\n} else if (risingMicros &gt; 0) {\nuint32_t resultMicros = nowMicros - risingMicros;\nif (nowMicros &lt; risingMicros) {\nresultMicros = 0;\n}\n\nBaseType_t woken = 0;\nxTaskNotifyFromISR(\nutsTask.handle(), resultMicros, eSetValueWithoutOverwrite, &amp;woken);\nportYIELD_FROM_ISR(woken);\n}\n}\n\nvoid ultrasoundReset() { trigQueue.reset(); }\n</code></pre>"},{"location":"stm/UsbCdcDescriptors_8c/","title":"File UsbCdcDescriptors.c","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; UsbCdcDescriptors.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include \"usb.h\"</code></li> </ul>"},{"location":"stm/UsbCdcDescriptors_8c/#public-attributes","title":"Public Attributes","text":"Type Name const struct usb_string_descriptor cdc_iface_desc_en   = = USB_STRING_DESC(\"RBCX ESP32 Tunnel\") const struct usb_string_descriptor debug_iface_desc_en   = = USB_STRING_DESC(\"RBCX Debug UART\") const struct usb_string_descriptor lang_desc   = = USB_ARRAY_DESC(USB_LANGID_ENG_US) const struct usb_string_descriptor manuf_desc_en   = = USB_STRING_DESC(\"robotikabrno.cz\") const struct usb_string_descriptor prod_desc_en   = = USB_STRING_DESC(\"RBCX\") struct usb_string_descriptor serial_number_desc_en   = = USB_STRING_DESC(\"ffffffffffffffffffffffff\")"},{"location":"stm/UsbCdcDescriptors_8c/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/UsbCdcDescriptors_8c/#variable-cdc_iface_desc_en","title":"variable cdc_iface_desc_en","text":"<pre><code>const struct usb_string_descriptor cdc_iface_desc_en;\n</code></pre>"},{"location":"stm/UsbCdcDescriptors_8c/#variable-debug_iface_desc_en","title":"variable debug_iface_desc_en","text":"<pre><code>const struct usb_string_descriptor debug_iface_desc_en;\n</code></pre>"},{"location":"stm/UsbCdcDescriptors_8c/#variable-lang_desc","title":"variable lang_desc","text":"<pre><code>const struct usb_string_descriptor lang_desc;\n</code></pre>"},{"location":"stm/UsbCdcDescriptors_8c/#variable-manuf_desc_en","title":"variable manuf_desc_en","text":"<pre><code>const struct usb_string_descriptor manuf_desc_en;\n</code></pre>"},{"location":"stm/UsbCdcDescriptors_8c/#variable-prod_desc_en","title":"variable prod_desc_en","text":"<pre><code>const struct usb_string_descriptor prod_desc_en;\n</code></pre>"},{"location":"stm/UsbCdcDescriptors_8c/#variable-serial_number_desc_en","title":"variable serial_number_desc_en","text":"<pre><code>struct usb_string_descriptor serial_number_desc_en;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/UsbCdcDescriptors.c</code></p>"},{"location":"stm/UsbCdcDescriptors_8c_source/","title":"File UsbCdcDescriptors.c","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; UsbCdcDescriptors.c</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;stdint.h&gt;\n\n#include \"usb.h\"\n\nconst struct usb_string_descriptor lang_desc\n= USB_ARRAY_DESC(USB_LANGID_ENG_US);\nconst struct usb_string_descriptor manuf_desc_en\n= USB_STRING_DESC(\"robotikabrno.cz\");\nconst struct usb_string_descriptor prod_desc_en = USB_STRING_DESC(\"RBCX\");\nconst struct usb_string_descriptor cdc_iface_desc_en\n= USB_STRING_DESC(\"RBCX ESP32 Tunnel\");\nconst struct usb_string_descriptor debug_iface_desc_en\n= USB_STRING_DESC(\"RBCX Debug UART\");\nstruct usb_string_descriptor serial_number_desc_en\n= USB_STRING_DESC(\"ffffffffffffffffffffffff\");\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/","title":"File UsbCdcLink.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; UsbCdcLink.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdbool.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"CdcUartTunnel.hpp\"</code></li> <li><code>#include \"Esp32Manager.hpp\"</code></li> <li><code>#include \"UsbCdcLink.h\"</code></li> <li><code>#include \"usb_cdc.h\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> </ul>"},{"location":"stm/UsbCdcLink_8cpp/#classes","title":"Classes","text":"Type Name struct __debug_descriptors struct cdc_config"},{"location":"stm/UsbCdcLink_8cpp/#public-types","title":"Public Types","text":"Type Name enum @0 Implements USB CDC using libusb_stm. enum @1"},{"location":"stm/UsbCdcLink_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name const struct usb_string_descriptor cdc_iface_desc_en struct usb_config_descriptor config const struct usb_string_descriptor debug_iface_desc_en const struct usb_string_descriptor lang_desc const struct usb_string_descriptor manuf_desc_en const struct usb_string_descriptor prod_desc_en struct usb_string_descriptor serial_number_desc_en struct usb_cdc_acm_desc tunnel_cdc_acm struct usb_cdc_header_desc tunnel_cdc_hdr struct usb_cdc_call_mgmt_desc tunnel_cdc_mgmt struct usb_cdc_union_desc tunnel_cdc_union struct usb_interface_descriptor tunnel_comm struct usb_endpoint_descriptor tunnel_comm_ep struct usb_iad_descriptor tunnel_comm_iad struct usb_interface_descriptor tunnel_data struct usb_endpoint_descriptor tunnel_data_eprx struct usb_endpoint_descriptor tunnel_data_eptx usbd_device udev"},{"location":"stm/UsbCdcLink_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr size_t DebugDescriptorsSize   = = sizeof(__debug_descriptors) struct usb_cdc_line_coding cdc_line_debug   = = { .dwDTERate = 115200, .bCharFormat = USB_CDC_1_STOP_BITS, .bParityType = USB_CDC_NO_PARITY, .bDataBits = 8, } struct usb_cdc_line_coding cdc_line_tunnel   = = { .dwDTERate = 115200, .bCharFormat = USB_CDC_1_STOP_BITS, .bParityType = USB_CDC_NO_PARITY, .bDataBits = 8, } struct cdc_config config_desc const struct usb_device_descriptor device_desc   = = { .bLength = sizeof(struct usb_device_descriptor), .bDescriptorType = USB_DTYPE_DEVICE, .bcdUSB = VERSION_BCD(2, 0, 0), .bDeviceClass = USB_CLASS_IAD, .bDeviceSubClass = USB_SUBCLASS_IAD, .bDeviceProtocol = USB_PROTO_IAD, .bMaxPacketSize0 = CDC_EP0_SIZE, .idVendor = 0x0483, .idProduct = 0x5740, .bcdDevice = VERSION_BCD(1, 0, 0), .iManufacturer = STRDESC_MANUFACTURER, .iProduct = STRDESC_PRODUCT, .iSerialNumber = STRDESC_SERIAL, .bNumConfigurations = 1, } const struct usb_string_descriptor *const dtable   = = { &amp;lang_desc, &amp;manuf_desc_en, &amp;prod_desc_en, &amp;cdc_iface_desc_en, &amp;debug_iface_desc_en, &amp;serial_number_desc_en, } bool enableDebugEp   = = false uint32_t ubuf"},{"location":"stm/UsbCdcLink_8cpp/#public-functions","title":"Public Functions","text":"Type Name void USB_LP_IRQ_HANDLER (void)  struct __debug_descriptors __attribute__ ((packed))  void cdcLinkInit ()  bool cdcLinkIsDebugEpEnabled ()"},{"location":"stm/UsbCdcLink_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name usbd_respond cdc_control (usbd_device * dev, usbd_ctlreq * req, usbd_rqc_callback * callback)  usbd_respond cdc_control_debug (usbd_device * dev, usbd_ctlreq * req)  usbd_respond cdc_control_tunnel (usbd_device * dev, usbd_ctlreq * req)  usbd_respond cdc_getdesc (usbd_ctlreq * req, void ** address, uint16_t * length)  usbd_respond cdc_setconf (usbd_device * dev, uint8_t cfg)  void tunnel_check_for_dfu_request (const struct usb_cdc_line_coding * coding)"},{"location":"stm/UsbCdcLink_8cpp/#macros","title":"Macros","text":"Type Name define DEBUG_DESCRIPTORS"},{"location":"stm/UsbCdcLink_8cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"stm/UsbCdcLink_8cpp/#enum-0","title":"enum @0","text":"<pre><code>enum @0 {\nSTRDESC_LANG,\nSTRDESC_MANUFACTURER,\nSTRDESC_PRODUCT,\nSTRDESC_CDC_IFACE,\nSTRDESC_DEBUG_IFACE,\nSTRDESC_SERIAL,\nSTRDESC_MAX\n};\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#enum-1","title":"enum @1","text":"<pre><code>enum @1 {\nINTERFACE_TUNNEL_COMM,\nINTERFACE_TUNNEL_DATA,\nINTERFACE_DEBUG_COMM,\nINTERFACE_DEBUG_DATA,\nINTERFACE_COUNT_ALL,\nINTERFACE_COUNT_NODEBUG = INTERFACE_DEBUG_COMM\n};\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"stm/UsbCdcLink_8cpp/#variable-cdc_iface_desc_en","title":"variable cdc_iface_desc_en","text":"<pre><code>const struct usb_string_descriptor cdc_iface_desc_en;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-config","title":"variable config","text":"<pre><code>struct usb_config_descriptor config;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-debug_iface_desc_en","title":"variable debug_iface_desc_en","text":"<pre><code>const struct usb_string_descriptor debug_iface_desc_en;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-lang_desc","title":"variable lang_desc","text":"<pre><code>const struct usb_string_descriptor lang_desc;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-manuf_desc_en","title":"variable manuf_desc_en","text":"<pre><code>const struct usb_string_descriptor manuf_desc_en;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-prod_desc_en","title":"variable prod_desc_en","text":"<pre><code>const struct usb_string_descriptor prod_desc_en;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-serial_number_desc_en","title":"variable serial_number_desc_en","text":"<pre><code>struct usb_string_descriptor serial_number_desc_en;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-tunnel_cdc_acm","title":"variable tunnel_cdc_acm","text":"<pre><code>struct usb_cdc_acm_desc tunnel_cdc_acm;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-tunnel_cdc_hdr","title":"variable tunnel_cdc_hdr","text":"<pre><code>struct usb_cdc_header_desc tunnel_cdc_hdr;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-tunnel_cdc_mgmt","title":"variable tunnel_cdc_mgmt","text":"<pre><code>struct usb_cdc_call_mgmt_desc tunnel_cdc_mgmt;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-tunnel_cdc_union","title":"variable tunnel_cdc_union","text":"<pre><code>struct usb_cdc_union_desc tunnel_cdc_union;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-tunnel_comm","title":"variable tunnel_comm","text":"<pre><code>struct usb_interface_descriptor tunnel_comm;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-tunnel_comm_ep","title":"variable tunnel_comm_ep","text":"<pre><code>struct usb_endpoint_descriptor tunnel_comm_ep;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-tunnel_comm_iad","title":"variable tunnel_comm_iad","text":"<pre><code>struct usb_iad_descriptor tunnel_comm_iad;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-tunnel_data","title":"variable tunnel_data","text":"<pre><code>struct usb_interface_descriptor tunnel_data;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-tunnel_data_eprx","title":"variable tunnel_data_eprx","text":"<pre><code>struct usb_endpoint_descriptor tunnel_data_eprx;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-tunnel_data_eptx","title":"variable tunnel_data_eptx","text":"<pre><code>struct usb_endpoint_descriptor tunnel_data_eptx;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-udev","title":"variable udev","text":"<pre><code>usbd_device udev;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/UsbCdcLink_8cpp/#variable-debugdescriptorssize","title":"variable DebugDescriptorsSize","text":"<pre><code>constexpr size_t DebugDescriptorsSize;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-cdc_line_debug","title":"variable cdc_line_debug","text":"<pre><code>struct usb_cdc_line_coding cdc_line_debug;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-cdc_line_tunnel","title":"variable cdc_line_tunnel","text":"<pre><code>struct usb_cdc_line_coding cdc_line_tunnel;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-config_desc","title":"variable config_desc","text":"<pre><code>struct cdc_config config_desc;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-device_desc","title":"variable device_desc","text":"<pre><code>const struct usb_device_descriptor device_desc;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-dtable","title":"variable dtable","text":"<pre><code>const struct usb_string_descriptor* const dtable[STRDESC_MAX];\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-enabledebugep","title":"variable enableDebugEp","text":"<pre><code>bool enableDebugEp;\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#variable-ubuf","title":"variable ubuf","text":"<pre><code>uint32_t ubuf[0x20];\n</code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/UsbCdcLink_8cpp/#function-usb_lp_irq_handler","title":"function USB_LP_IRQ_HANDLER","text":"<pre><code>void USB_LP_IRQ_HANDLER (\nvoid\n) </code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#function-__attribute__","title":"function __attribute__","text":"<pre><code>struct __debug_descriptors __attribute__ (\n(packed)\n) </code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#function-cdclinkinit","title":"function cdcLinkInit","text":"<pre><code>void cdcLinkInit () </code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#function-cdclinkisdebugepenabled","title":"function cdcLinkIsDebugEpEnabled","text":"<pre><code>bool cdcLinkIsDebugEpEnabled () </code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"stm/UsbCdcLink_8cpp/#function-cdc_control","title":"function cdc_control","text":"<pre><code>static usbd_respond cdc_control (\nusbd_device * dev,\nusbd_ctlreq * req,\nusbd_rqc_callback * callback\n) </code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#function-cdc_control_debug","title":"function cdc_control_debug","text":"<pre><code>static usbd_respond cdc_control_debug (\nusbd_device * dev,\nusbd_ctlreq * req\n) </code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#function-cdc_control_tunnel","title":"function cdc_control_tunnel","text":"<pre><code>static usbd_respond cdc_control_tunnel (\nusbd_device * dev,\nusbd_ctlreq * req\n) </code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#function-cdc_getdesc","title":"function cdc_getdesc","text":"<pre><code>static usbd_respond cdc_getdesc (\nusbd_ctlreq * req,\nvoid ** address,\nuint16_t * length\n) </code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#function-cdc_setconf","title":"function cdc_setconf","text":"<pre><code>static usbd_respond cdc_setconf (\nusbd_device * dev,\nuint8_t cfg\n) </code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#function-tunnel_check_for_dfu_request","title":"function tunnel_check_for_dfu_request","text":"<pre><code>static void tunnel_check_for_dfu_request (\nconst struct usb_cdc_line_coding * coding\n) </code></pre>"},{"location":"stm/UsbCdcLink_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"stm/UsbCdcLink_8cpp/#define-debug_descriptors","title":"define DEBUG_DESCRIPTORS","text":"<pre><code>#define DEBUG_DESCRIPTORS struct usb_iad_descriptor debug_comm_iad;                                  \\\n    struct usb_interface_descriptor debug_comm;                                \\\n    struct usb_cdc_header_desc debug_cdc_hdr;                                  \\\n    struct usb_cdc_call_mgmt_desc debug_cdc_mgmt;                              \\\n    struct usb_cdc_acm_desc debug_cdc_acm;                                     \\\n    struct usb_cdc_union_desc debug_cdc_union;                                 \\\n    struct usb_endpoint_descriptor debug_comm_ep;                              \\\n    struct usb_interface_descriptor debug_data;                                \\\n    struct usb_endpoint_descriptor debug_data_eprx;                            \\\n    struct usb_endpoint_descriptor debug_data_eptx;\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/UsbCdcLink.cpp</code></p>"},{"location":"stm/UsbCdcLink_8cpp_source/","title":"File UsbCdcLink.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; UsbCdcLink.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;stdbool.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include \"Bsp.hpp\"\n#include \"CdcUartTunnel.hpp\"\n#include \"Esp32Manager.hpp\"\n#include \"UsbCdcLink.h\"\n#include \"usb_cdc.h\"\n#include \"utils/Debug.hpp\"\n\nenum {\nSTRDESC_LANG,\nSTRDESC_MANUFACTURER,\nSTRDESC_PRODUCT,\nSTRDESC_CDC_IFACE,\nSTRDESC_DEBUG_IFACE,\nSTRDESC_SERIAL,\n\nSTRDESC_MAX,\n};\n\nenum {\nINTERFACE_TUNNEL_COMM,\nINTERFACE_TUNNEL_DATA,\nINTERFACE_DEBUG_COMM,\nINTERFACE_DEBUG_DATA,\n\nINTERFACE_COUNT_ALL,\nINTERFACE_COUNT_NODEBUG = INTERFACE_DEBUG_COMM,\n};\n\nextern \"C\" {\nextern const struct usb_string_descriptor lang_desc;\nextern const struct usb_string_descriptor manuf_desc_en;\nextern const struct usb_string_descriptor prod_desc_en;\nextern const struct usb_string_descriptor cdc_iface_desc_en;\nextern const struct usb_string_descriptor debug_iface_desc_en;\nextern struct usb_string_descriptor serial_number_desc_en;\n};\n\nstatic const struct usb_string_descriptor* const dtable[STRDESC_MAX] = {\n&amp;lang_desc,\n&amp;manuf_desc_en,\n&amp;prod_desc_en,\n&amp;cdc_iface_desc_en,\n&amp;debug_iface_desc_en,\n&amp;serial_number_desc_en,\n};\n\n#define DEBUG_DESCRIPTORS                                                      \\\n    struct usb_iad_descriptor debug_comm_iad;                                  \\\n    struct usb_interface_descriptor debug_comm;                                \\\n    struct usb_cdc_header_desc debug_cdc_hdr;                                  \\\n    struct usb_cdc_call_mgmt_desc debug_cdc_mgmt;                              \\\n    struct usb_cdc_acm_desc debug_cdc_acm;                                     \\\n    struct usb_cdc_union_desc debug_cdc_union;                                 \\\n    struct usb_endpoint_descriptor debug_comm_ep;                              \\\n    struct usb_interface_descriptor debug_data;                                \\\n    struct usb_endpoint_descriptor debug_data_eprx;                            \\\n    struct usb_endpoint_descriptor debug_data_eptx;\n\nstruct __debug_descriptors {\nDEBUG_DESCRIPTORS\n} __attribute__((packed));\n\nstatic constexpr size_t DebugDescriptorsSize = sizeof(__debug_descriptors);\n\nstruct cdc_config {\nstruct usb_config_descriptor config;\n\nstruct usb_iad_descriptor tunnel_comm_iad;\nstruct usb_interface_descriptor tunnel_comm;\nstruct usb_cdc_header_desc tunnel_cdc_hdr;\nstruct usb_cdc_call_mgmt_desc tunnel_cdc_mgmt;\nstruct usb_cdc_acm_desc tunnel_cdc_acm;\nstruct usb_cdc_union_desc tunnel_cdc_union;\nstruct usb_endpoint_descriptor tunnel_comm_ep;\nstruct usb_interface_descriptor tunnel_data;\nstruct usb_endpoint_descriptor tunnel_data_eprx;\nstruct usb_endpoint_descriptor tunnel_data_eptx;\n\nDEBUG_DESCRIPTORS\n} __attribute__((packed));\n\nstatic const struct usb_device_descriptor device_desc = {\n.bLength = sizeof(struct usb_device_descriptor),\n.bDescriptorType = USB_DTYPE_DEVICE,\n.bcdUSB = VERSION_BCD(2, 0, 0),\n.bDeviceClass = USB_CLASS_IAD,\n.bDeviceSubClass = USB_SUBCLASS_IAD,\n.bDeviceProtocol = USB_PROTO_IAD,\n.bMaxPacketSize0 = CDC_EP0_SIZE,\n.idVendor = 0x0483,\n.idProduct = 0x5740,\n.bcdDevice = VERSION_BCD(1, 0, 0),\n.iManufacturer = STRDESC_MANUFACTURER,\n.iProduct = STRDESC_PRODUCT,\n.iSerialNumber = STRDESC_SERIAL,\n.bNumConfigurations = 1,\n};\n\nstatic struct cdc_config config_desc = {\n.config = {\n.bLength = sizeof(struct usb_config_descriptor),\n.bDescriptorType = USB_DTYPE_CONFIGURATION,\n.wTotalLength = sizeof(struct cdc_config),\n.bNumInterfaces = INTERFACE_COUNT_ALL,\n.bConfigurationValue = 1,\n.iConfiguration = NO_DESCRIPTOR,\n.bmAttributes = USB_CFG_ATTR_RESERVED | USB_CFG_ATTR_SELFPOWERED,\n.bMaxPower = USB_CFG_POWER_MA(100),\n},\n\n.tunnel_comm_iad = {\n.bLength = sizeof(struct usb_iad_descriptor),\n.bDescriptorType = USB_DTYPE_INTERFASEASSOC,\n.bFirstInterface = INTERFACE_TUNNEL_COMM,\n.bInterfaceCount = 2,\n.bFunctionClass = USB_CLASS_CDC,\n.bFunctionSubClass = USB_CDC_SUBCLASS_ACM,\n.bFunctionProtocol = USB_PROTO_NONE,\n.iFunction = NO_DESCRIPTOR,\n},\n.tunnel_comm = {\n.bLength = sizeof(struct usb_interface_descriptor),\n.bDescriptorType = USB_DTYPE_INTERFACE,\n.bInterfaceNumber = INTERFACE_TUNNEL_COMM,\n.bAlternateSetting = 0,\n.bNumEndpoints = 1,\n.bInterfaceClass = USB_CLASS_CDC,\n.bInterfaceSubClass = USB_CDC_SUBCLASS_ACM,\n.bInterfaceProtocol = USB_PROTO_NONE,\n.iInterface = NO_DESCRIPTOR,\n},\n.tunnel_cdc_hdr = {\n.bFunctionLength = sizeof(struct usb_cdc_header_desc),\n.bDescriptorType = USB_DTYPE_CS_INTERFACE,\n.bDescriptorSubType = USB_DTYPE_CDC_HEADER,\n.bcdCDC = VERSION_BCD(1, 1, 0),\n},\n.tunnel_cdc_mgmt = {\n.bFunctionLength = sizeof(struct usb_cdc_call_mgmt_desc),\n.bDescriptorType = USB_DTYPE_CS_INTERFACE,\n.bDescriptorSubType = USB_DTYPE_CDC_CALL_MANAGEMENT,\n.bmCapabilities = 0,\n.bDataInterface = INTERFACE_TUNNEL_DATA,\n},\n.tunnel_cdc_acm = {\n.bFunctionLength = sizeof(struct usb_cdc_acm_desc),\n.bDescriptorType = USB_DTYPE_CS_INTERFACE,\n.bDescriptorSubType = USB_DTYPE_CDC_ACM,\n.bmCapabilities = 0,\n},\n.tunnel_cdc_union = {\n.bFunctionLength = sizeof(struct usb_cdc_union_desc),\n.bDescriptorType = USB_DTYPE_CS_INTERFACE,\n.bDescriptorSubType = USB_DTYPE_CDC_UNION,\n.bMasterInterface0 = INTERFACE_TUNNEL_COMM,\n.bSlaveInterface0 = INTERFACE_TUNNEL_DATA,\n},\n.tunnel_comm_ep = {\n.bLength = sizeof(struct usb_endpoint_descriptor),\n.bDescriptorType = USB_DTYPE_ENDPOINT,\n.bEndpointAddress = CDC_TUNNEL_NTF_EP,\n.bmAttributes = USB_EPTYPE_INTERRUPT,\n.wMaxPacketSize = CDC_NTF_SZ,\n.bInterval = 0xFF,\n},\n.tunnel_data = {\n.bLength = sizeof(struct usb_interface_descriptor),\n.bDescriptorType = USB_DTYPE_INTERFACE,\n.bInterfaceNumber = INTERFACE_TUNNEL_DATA,\n.bAlternateSetting = 0,\n.bNumEndpoints = 2,\n.bInterfaceClass = USB_CLASS_CDC_DATA,\n.bInterfaceSubClass = USB_SUBCLASS_NONE,\n.bInterfaceProtocol = USB_PROTO_NONE,\n.iInterface = STRDESC_CDC_IFACE,\n},\n.tunnel_data_eprx = {\n.bLength = sizeof(struct usb_endpoint_descriptor),\n.bDescriptorType = USB_DTYPE_ENDPOINT,\n.bEndpointAddress = CDC_TUNNEL_RXD_EP,\n.bmAttributes = USB_EPTYPE_BULK,\n.wMaxPacketSize = CDC_DATA_SZ,\n.bInterval = 0x01,\n},\n.tunnel_data_eptx = {\n.bLength = sizeof(struct usb_endpoint_descriptor),\n.bDescriptorType = USB_DTYPE_ENDPOINT,\n.bEndpointAddress = CDC_TUNNEL_TXD_EP,\n.bmAttributes = USB_EPTYPE_BULK,\n.wMaxPacketSize = CDC_DATA_SZ,\n.bInterval = 0x01,\n},\n\n\n.debug_comm_iad = {\n.bLength = sizeof(struct usb_iad_descriptor),\n.bDescriptorType = USB_DTYPE_INTERFASEASSOC,\n.bFirstInterface = INTERFACE_DEBUG_COMM,\n.bInterfaceCount = 2,\n.bFunctionClass = USB_CLASS_CDC,\n.bFunctionSubClass = USB_CDC_SUBCLASS_ACM,\n.bFunctionProtocol = USB_PROTO_NONE,\n.iFunction = NO_DESCRIPTOR,\n},\n.debug_comm = {\n.bLength = sizeof(struct usb_interface_descriptor),\n.bDescriptorType = USB_DTYPE_INTERFACE,\n.bInterfaceNumber = INTERFACE_DEBUG_COMM,\n.bAlternateSetting = 0,\n.bNumEndpoints = 1,\n.bInterfaceClass = USB_CLASS_CDC,\n.bInterfaceSubClass = USB_CDC_SUBCLASS_ACM,\n.bInterfaceProtocol = USB_PROTO_NONE,\n.iInterface = NO_DESCRIPTOR,\n},\n.debug_cdc_hdr = {\n.bFunctionLength = sizeof(struct usb_cdc_header_desc),\n.bDescriptorType = USB_DTYPE_CS_INTERFACE,\n.bDescriptorSubType = USB_DTYPE_CDC_HEADER,\n.bcdCDC = VERSION_BCD(1, 1, 0),\n},\n.debug_cdc_mgmt = {\n.bFunctionLength = sizeof(struct usb_cdc_call_mgmt_desc),\n.bDescriptorType = USB_DTYPE_CS_INTERFACE,\n.bDescriptorSubType = USB_DTYPE_CDC_CALL_MANAGEMENT,\n.bmCapabilities = 0,\n.bDataInterface = INTERFACE_DEBUG_DATA,\n},\n.debug_cdc_acm = {\n.bFunctionLength = sizeof(struct usb_cdc_acm_desc),\n.bDescriptorType = USB_DTYPE_CS_INTERFACE,\n.bDescriptorSubType = USB_DTYPE_CDC_ACM,\n.bmCapabilities = 0,\n},\n.debug_cdc_union = {\n.bFunctionLength = sizeof(struct usb_cdc_union_desc),\n.bDescriptorType = USB_DTYPE_CS_INTERFACE,\n.bDescriptorSubType = USB_DTYPE_CDC_UNION,\n.bMasterInterface0 = INTERFACE_DEBUG_COMM,\n.bSlaveInterface0 = INTERFACE_DEBUG_DATA,\n},\n.debug_comm_ep = {\n.bLength = sizeof(struct usb_endpoint_descriptor),\n.bDescriptorType = USB_DTYPE_ENDPOINT,\n.bEndpointAddress = CDC_DEBUG_NTF_EP,\n.bmAttributes = USB_EPTYPE_INTERRUPT,\n.wMaxPacketSize = CDC_NTF_SZ,\n.bInterval = 0xFF,\n},\n.debug_data = {\n.bLength = sizeof(struct usb_interface_descriptor),\n.bDescriptorType = USB_DTYPE_INTERFACE,\n.bInterfaceNumber = INTERFACE_DEBUG_DATA,\n.bAlternateSetting = 0,\n.bNumEndpoints = 2,\n.bInterfaceClass = USB_CLASS_CDC_DATA,\n.bInterfaceSubClass = USB_SUBCLASS_NONE,\n.bInterfaceProtocol = USB_PROTO_NONE,\n.iInterface = STRDESC_DEBUG_IFACE,\n},\n.debug_data_eprx = {\n.bLength = sizeof(struct usb_endpoint_descriptor),\n.bDescriptorType = USB_DTYPE_ENDPOINT,\n.bEndpointAddress = CDC_DEBUG_RXD_EP,\n.bmAttributes = USB_EPTYPE_BULK,\n.wMaxPacketSize = CDC_DATA_SZ,\n.bInterval = 0x01,\n},\n.debug_data_eptx = {\n.bLength = sizeof(struct usb_endpoint_descriptor),\n.bDescriptorType = USB_DTYPE_ENDPOINT,\n.bEndpointAddress = CDC_DEBUG_TXD_EP,\n.bmAttributes = USB_EPTYPE_BULK,\n.wMaxPacketSize = CDC_DATA_SZ,\n.bInterval = 0x01,\n},\n};\n\nusbd_device udev;\nstatic uint32_t ubuf[0x20];\nstatic bool enableDebugEp = false;\n\nstatic struct usb_cdc_line_coding cdc_line_tunnel = {\n.dwDTERate = 115200,\n.bCharFormat = USB_CDC_1_STOP_BITS,\n.bParityType = USB_CDC_NO_PARITY,\n.bDataBits = 8,\n};\n\nstatic struct usb_cdc_line_coding cdc_line_debug = {\n.dwDTERate = 115200,\n.bCharFormat = USB_CDC_1_STOP_BITS,\n.bParityType = USB_CDC_NO_PARITY,\n.bDataBits = 8,\n};\n\nstatic usbd_respond cdc_getdesc(\nusbd_ctlreq* req, void** address, uint16_t* length) {\nconst uint8_t dtype = req-&gt;wValue &gt;&gt; 8;\nconst uint8_t dnumber = req-&gt;wValue &amp; 0xFF;\nconst void* desc;\nuint16_t len = 0;\nswitch (dtype) {\ncase USB_DTYPE_DEVICE:\ndesc = &amp;device_desc;\nbreak;\ncase USB_DTYPE_CONFIGURATION:\ndesc = &amp;config_desc;\nlen = config_desc.config.wTotalLength;\nbreak;\ncase USB_DTYPE_STRING:\nif (dnumber &lt; STRDESC_MAX) {\ndesc = dtable[dnumber];\n} else {\nreturn usbd_fail;\n}\nbreak;\ndefault:\nreturn usbd_fail;\n}\nif (len == 0) {\nlen = ((struct usb_header_descriptor*)desc)-&gt;bLength;\n}\n*address = (void*)desc;\n*length = len;\nreturn usbd_ack;\n};\n\nstatic void tunnel_check_for_dfu_request(\nconst struct usb_cdc_line_coding* coding) {\n#ifdef RBCX_SBOOT\nif (coding-&gt;dwDTERate == 12345 &amp;&amp; coding-&gt;bParityType == USB_CDC_EVEN_PARITY\n&amp;&amp; coding-&gt;bCharFormat == USB_CDC_2_STOP_BITS) {\nrebootToDfu();\n}\n#endif\n}\n\nstatic usbd_respond cdc_control_tunnel(usbd_device* dev, usbd_ctlreq* req) {\nswitch (req-&gt;bRequest) {\ncase USB_CDC_SET_CONTROL_LINE_STATE: {\nconst bool dtr = req-&gt;wValue &amp; 0x01;\nconst bool rts = req-&gt;wValue &amp; 0x02;\n//DEBUG(\"CONTROL_LINE_STATE DTR %d RTS %d\\n\", (int)dtr, (int)rts);\nsEsp32Manager.onSerialBreakInIrq(dtr, rts);\nreturn usbd_ack;\n}\ncase USB_CDC_SET_LINE_CODING: {\nif (req-&gt;wLength &lt; sizeof(cdc_line_tunnel))\nreturn usbd_fail;\n\nauto* newCoding = (struct usb_cdc_line_coding*)req-&gt;data;\n\ntunnel_check_for_dfu_request(newCoding);\n\nif (!tunnelOnSetLineCodingInIrq(cdc_line_tunnel, *newCoding))\nreturn usbd_fail;\n\nmemcpy(&amp;cdc_line_tunnel, req-&gt;data, sizeof(cdc_line_tunnel));\n/*DEBUG(\"USB_CDC_SET_LINE_CODING %d %d %d %d\\n\",\n            cdc_line_tunnel.dwDTERate, cdc_line_tunnel.bCharFormat,\n            cdc_line_tunnel.bDataBits, cdc_line_tunnel.bParityType);*/\nreturn usbd_ack;\n}\ncase USB_CDC_GET_LINE_CODING:\ndev-&gt;status.data_ptr = &amp;cdc_line_tunnel;\ndev-&gt;status.data_count = sizeof(cdc_line_tunnel);\nreturn usbd_ack;\ndefault:\nreturn usbd_fail;\n}\n}\n\nstatic usbd_respond cdc_control_debug(usbd_device* dev, usbd_ctlreq* req) {\nswitch (req-&gt;bRequest) {\ncase USB_CDC_SET_CONTROL_LINE_STATE: {\nreturn usbd_ack;\n}\ncase USB_CDC_SET_LINE_CODING: {\nif (req-&gt;wLength &lt; sizeof(cdc_line_debug))\nreturn usbd_fail;\nmemcpy(&amp;cdc_line_debug, req-&gt;data, sizeof(cdc_line_debug));\n//DEBUG(\"USB_CDC_SET_LINE_CODING %d %d %d %d\\n\", cdc_line.dwDTERate,\n//  cdc_line.bCharFormat, cdc_line.bDataBits, cdc_line.bParityType);\nreturn usbd_ack;\n}\ncase USB_CDC_GET_LINE_CODING:\ndev-&gt;status.data_ptr = &amp;cdc_line_debug;\ndev-&gt;status.data_count = sizeof(cdc_line_debug);\nreturn usbd_ack;\ndefault:\nreturn usbd_fail;\n}\n}\n\nstatic usbd_respond cdc_control(\nusbd_device* dev, usbd_ctlreq* req, usbd_rqc_callback* callback) {\nif (((USB_REQ_RECIPIENT | USB_REQ_TYPE) &amp; req-&gt;bmRequestType)\n== (USB_REQ_INTERFACE | USB_REQ_CLASS)) {\nswitch (req-&gt;wIndex) {\ncase INTERFACE_TUNNEL_COMM:\nreturn cdc_control_tunnel(dev, req);\ncase INTERFACE_DEBUG_COMM:\nreturn cdc_control_debug(dev, req);\n}\n}\nreturn usbd_fail;\n}\n\nstatic usbd_respond cdc_setconf(usbd_device* dev, uint8_t cfg) {\nswitch (cfg) {\ncase 0:\n/* deconfiguring device */\nusbd_ep_deconfig(dev, CDC_TUNNEL_NTF_EP);\nusbd_ep_deconfig(dev, CDC_TUNNEL_TXD_EP);\nusbd_ep_deconfig(dev, CDC_TUNNEL_RXD_EP);\nif (enableDebugEp) {\nusbd_ep_deconfig(dev, CDC_DEBUG_NTF_EP);\nusbd_ep_deconfig(dev, CDC_DEBUG_TXD_EP);\nusbd_ep_deconfig(dev, CDC_DEBUG_RXD_EP);\n}\nreturn usbd_ack;\ncase 1:\n/* configuring device */\nusbd_ep_config(dev, CDC_TUNNEL_RXD_EP,\nUSB_EPTYPE_BULK /*| USB_EPTYPE_DBLBUF*/, CDC_DATA_SZ);\nusbd_ep_config(dev, CDC_TUNNEL_TXD_EP,\nUSB_EPTYPE_BULK /*| USB_EPTYPE_DBLBUF*/, CDC_DATA_SZ);\nusbd_ep_config(\ndev, CDC_TUNNEL_NTF_EP, USB_EPTYPE_INTERRUPT, CDC_NTF_SZ);\n\nif (enableDebugEp) {\nusbd_ep_config(dev, CDC_DEBUG_RXD_EP,\nUSB_EPTYPE_BULK /*| USB_EPTYPE_DBLBUF*/, CDC_DATA_SZ);\nusbd_ep_config(dev, CDC_DEBUG_TXD_EP,\nUSB_EPTYPE_BULK /*| USB_EPTYPE_DBLBUF*/, CDC_DATA_SZ);\nusbd_ep_config(\ndev, CDC_DEBUG_NTF_EP, USB_EPTYPE_INTERRUPT, CDC_NTF_SZ);\n}\nreturn usbd_ack;\ndefault:\nreturn usbd_fail;\n}\n}\n\nvoid cdcLinkInit() {\n__HAL_RCC_USB_CLK_ENABLE();\n\n// quickly charge Button capacitor\npinInit(button3Pin, GPIO_MODE_OUTPUT_PP, GPIO_PULLUP, GPIO_SPEED_FREQ_HIGH,\ntrue);\npinWrite(button3Pin, 1);\n\nstd::array&lt;uint32_t, 3&gt; uid;\nHAL_GetUID(uid.data());\n\nchar buf[9];\nsize_t sn_off = 0;\nfor (auto u : uid) {\nsnprintf(buf, sizeof(buf), \"%08lx\", u);\nfor (int i = 0; i &lt; 8; ++i) {\nserial_number_desc_en.wString[sn_off++] = buf[i];\n}\n}\n\n// reinit button and check\nfor (volatile int i = 0; i &lt; 5000; ++i)\n;\npinInit(\nbutton3Pin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_LOW, true);\nenableDebugEp = !pinRead(button3Pin)\n|| (CoreDebug-&gt;DHCSR &amp; CoreDebug_DHCSR_C_DEBUGEN_Msk);\n\nif (enableDebugEp) {\nconfig_desc.config.bNumInterfaces = INTERFACE_COUNT_ALL;\nconfig_desc.config.wTotalLength = sizeof(config_desc);\n} else {\nconfig_desc.config.bNumInterfaces = INTERFACE_COUNT_NODEBUG;\nconfig_desc.config.wTotalLength\n= sizeof(config_desc) - DebugDescriptorsSize;\n}\n\nusbd_init(&amp;udev, &amp;usbd_hw, CDC_EP0_SIZE, ubuf, sizeof(ubuf));\nusbd_reg_config(&amp;udev, cdc_setconf);\nusbd_reg_control(&amp;udev, cdc_control);\nusbd_reg_descr(&amp;udev, cdc_getdesc);\n\nHAL_NVIC_SetPriority(usbLpIRQn, usbLpIRQnPrio, 0);\nHAL_NVIC_EnableIRQ(usbLpIRQn);\n\nusbd_enable(&amp;udev, true);\nusbd_connect(&amp;udev, true);\n}\n\nbool cdcLinkIsDebugEpEnabled() { return enableDebugEp; }\n\nextern \"C\" void USB_LP_IRQ_HANDLER(void) { usbd_poll(&amp;udev); }\n</code></pre>"},{"location":"stm/dir_2664a5dd552ae2f985361b9f9bb51ff0/","title":"Dir demo-projets/stm32/src/utils","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; utils</p>"},{"location":"stm/dir_2664a5dd552ae2f985361b9f9bb51ff0/#files","title":"Files","text":"Type Name file Debug.cpp <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/utils/</code></p>"},{"location":"stm/Debug_8cpp/","title":"File Debug.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; utils &gt; Debug.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"UsbCdcLink.h\"</code></li> </ul>"},{"location":"stm/Debug_8cpp/#public-functions","title":"Public Functions","text":"Type Name void rebootToDfu ()"},{"location":"stm/Debug_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/Debug_8cpp/#function-reboottodfu","title":"function rebootToDfu","text":"<pre><code>void rebootToDfu () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/utils/Debug.cpp</code></p>"},{"location":"stm/Debug_8cpp_source/","title":"File Debug.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; utils &gt; Debug.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"utils/Debug.hpp\"\n#include \"Bsp.hpp\"\n#include \"UsbCdcLink.h\"\n\nvoid rebootToDfu() {\n#ifdef RBCX_SBOOT\n__disable_irq();\n\nusbd_connect(&amp;udev, false);\n\nvolatile uint32_t* st = (uint32_t*)0x02000bffc; // __stack\n*st = 0x157F32D4; // DFU_BOOTKEY\n\nNVIC_SystemReset();\n#else\nabort();\n#endif\n}\n</code></pre>"},{"location":"stm/main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; demo-projets &gt; stm32 &gt; src &gt; main.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/TaskWrapper.hpp\"</code></li> <li><code>#include \"ButtonController.hpp\"</code></li> <li><code>#include \"I2cController.hpp\"</code></li> <li><code>#include \"MotorController.hpp\"</code></li> <li><code>#include \"MpuController.hpp\"</code></li> <li><code>#include \"OledController.hpp\"</code></li> <li><code>#include \"StupidServoController.hpp\"</code></li> <li><code>#include \"UltrasoundController.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"CdcUartTunnel.hpp\"</code></li> <li><code>#include \"ControlLink.hpp\"</code></li> <li><code>#include \"DebugLink.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"Esp32Manager.hpp\"</code></li> <li><code>#include \"Power.hpp\"</code></li> <li><code>#include \"UsbCdcLink.h\"</code></li> </ul>"},{"location":"stm/main_8cpp/#public-types","title":"Public Types","text":"Type Name typedef int _myint"},{"location":"stm/main_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name TaskWrapper&lt; 3072 &gt; mainTask"},{"location":"stm/main_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main ()  _myint testInt ()"},{"location":"stm/main_8cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"stm/main_8cpp/#typedef-_myint","title":"typedef _myint","text":"<pre><code>typedef int _myint;\n</code></pre>"},{"location":"stm/main_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"stm/main_8cpp/#variable-maintask","title":"variable mainTask","text":"<pre><code>TaskWrapper&lt;3072&gt; mainTask;\n</code></pre>"},{"location":"stm/main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"stm/main_8cpp/#function-main","title":"function main","text":"<pre><code>int main () </code></pre>"},{"location":"stm/main_8cpp/#function-testint","title":"function testInt","text":"<pre><code>_myint testInt () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/stm32/src/main.cpp</code></p>"},{"location":"stm/main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; demo-projets &gt; stm32 &gt; src &gt; main.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;array&gt;\n\n#include \"stm32f1xx_hal.h\"\n\n#include \"utils/Debug.hpp\"\n#include \"utils/TaskWrapper.hpp\"\n\n#include \"ButtonController.hpp\"\n#include \"I2cController.hpp\"\n#include \"MotorController.hpp\"\n#include \"MpuController.hpp\"\n#include \"OledController.hpp\"\n#include \"StupidServoController.hpp\"\n#include \"UltrasoundController.hpp\"\n\n#include \"Bsp.hpp\"\n#include \"CdcUartTunnel.hpp\"\n#include \"ControlLink.hpp\"\n#include \"DebugLink.hpp\"\n#include \"Dispatcher.hpp\"\n#include \"Esp32Manager.hpp\"\n#include \"Power.hpp\"\n#include \"UsbCdcLink.h\"\n\nstatic TaskWrapper&lt;3072&gt; mainTask;\n\ntypedef int _myint;\n\n_myint testInt() {}\n\nint main() {\nclocksInit();\nHAL_Init();\n\n#ifdef RBCX_VECT_TAB_OFFSET\nSCB-&gt;VTOR = FLASH_BASE | RBCX_VECT_TAB_OFFSET;\n#endif\n\npinsInit();\n\nmainTask.start(\"main\", mainTaskPrio, []() {\ndebugUartInit();\nsoftResetInit();\npowerInit();\ndispatcherInit();\ntunnelUartInit();\ncontrolUartInit();\ncdcLinkInit();\nI2Cdev_init();\nstupidServoInit();\nultrasoundInit();\nmpuCreate();\nsEsp32Manager.init();\nmotorInit();\n\nDEBUG(\"STM32 Coprocessor initialized, v%06x \" RBCX_VER_REVISION\nRBCX_VER_DIRTY_STR \"\\n\",\nRBCX_VER_NUMBER);\nwhile (true) {\nvTaskDelay(pdMS_TO_TICKS(1));\ndebugLinkPoll();\npowerPoll();\ndispatcherPoll();\ntunnelPoll();\nbuttonControllerPoll();\nsEsp32Manager.poll();\n}\n});\n\nvTaskStartScheduler();\nabort();\n}\n</code></pre>"},{"location":"stm/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"stm/classes/","title":"Class Index","text":""},{"location":"stm/classes/#b","title":"b","text":"<ul> <li>BasePriorityRaiser</li> <li>ByteFifo</li> </ul>"},{"location":"stm/classes/#c","title":"c","text":"<ul> <li>CalibrationData</li> <li>cdc_config</li> </ul>"},{"location":"stm/classes/#e","title":"e","text":"<ul> <li>Esp32Manager</li> </ul>"},{"location":"stm/classes/#f","title":"f","text":"<ul> <li>FontDef</li> </ul>"},{"location":"stm/classes/#m","title":"m","text":"<ul> <li>MessageBufferWrapper</li> <li>Motor</li> <li>MutexWrapper</li> <li>MPU6050_t</li> <li>MpuMotion32</li> <li>MpuMotion6</li> <li>MpuVector</li> <li>MpuVector32</li> <li>mpu_t</li> </ul>"},{"location":"stm/classes/#o","title":"o","text":"<ul> <li>OLED_VERTEX</li> <li>OLED_t</li> </ul>"},{"location":"stm/classes/#q","title":"q","text":"<ul> <li>QueueWrapper</li> </ul>"},{"location":"stm/classes/#r","title":"r","text":"<ul> <li>Regulator</li> </ul>"},{"location":"stm/classes/#s","title":"s","text":"<ul> <li>StreamBufferWrapper</li> </ul>"},{"location":"stm/classes/#t","title":"t","text":"<ul> <li>TaskWrapper</li> <li>TickTimer</li> </ul>"},{"location":"stm/classes/#x","title":"x","text":"<ul> <li>XorShift</li> </ul> <p>## \\</p> <ul> <li>__debug_descriptors</li> </ul>"},{"location":"stm/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class BasePriorityRaiser </li> <li>class ByteFifo </li> <li>class Esp32Manager </li> <li>class MessageBufferWrapper </li> <li>class Motor </li> <li>class MutexWrapper </li> <li>class QueueWrapper </li> <li>class StreamBufferWrapper </li> <li>class TaskWrapper </li> <li>class TickTimer </li> <li>class XorShift Fast deterministic PRNG - https://en.wikipedia.org/wiki/Xorshift .</li> <li>struct CalibrationData </li> <li>struct FontDef </li> <li>struct MPU6050_t </li> <li>struct MpuMotion32 </li> <li>struct MpuMotion6 </li> <li>struct MpuVector </li> <li>struct MpuVector32 </li> <li>struct OLED_VERTEX </li> <li>struct OLED_t </li> <li>struct Regulator </li> <li>struct __debug_descriptors </li> <li>struct cdc_config </li> <li>struct mpu_t </li> </ul>"},{"location":"stm/modules/","title":"Modules","text":"<p>Here is a list of all modules:</p>"},{"location":"stm/md_demo_projets_stm32_Readme/","title":"Source","text":"<p>Code is from RB3204-RBCX.</p> <p>It is main board for Robotka robot.</p> <p></p>"},{"location":"stm/pages/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p>"},{"location":"stm/class_members/","title":"Class Members","text":""},{"location":"stm/class_members/#a","title":"a","text":"<ul> <li>adjust (ByteFifo)</li> <li>available (ByteFifo, StreamBufferWrapper)</li> <li>atStandstill (Motor)</li> <li>atTargetPosition (Motor)</li> <li>accel (MpuMotion32, MpuMotion6)</li> </ul>"},{"location":"stm/class_members/#b","title":"b","text":"<ul> <li>BasePriorityRaiser (BasePriorityRaiser)</li> <li>ByteFifo (ByteFifo)</li> <li>batteryCoef (CalibrationData)</li> <li>batteryMidCoef (CalibrationData)</li> <li>buffer (MPU6050_t, mpu_t)</li> </ul>"},{"location":"stm/class_members/#c","title":"c","text":"<ul> <li>clear (ByteFifo, Regulator)</li> <li>create (MessageBufferWrapper, MutexWrapper, QueueWrapper, StreamBufferWrapper)</li> <li>CurrentX (OLED_t)</li> <li>CurrentY (OLED_t)</li> <li>coef_type (Regulator)</li> <li>config (cdc_config)</li> </ul>"},{"location":"stm/class_members/#d","title":"d","text":"<ul> <li>data (ByteFifo, FontDef)</li> <li>devAddr (MPU6050_t, mpu_t)</li> <li>DisplayOn (OLED_t)</li> <li>D (Regulator)</li> <li>de (Regulator)</li> </ul>"},{"location":"stm/class_members/#e","title":"e","text":"<ul> <li>EnHolderType (Esp32Manager)</li> <li>Esp32Manager (Esp32Manager)</li> <li>e (Regulator)</li> </ul>"},{"location":"stm/class_members/#f","title":"f","text":"<ul> <li>FontHeight (FontDef)</li> <li>FontWidth (FontDef)</li> <li>freeSpace (StreamBufferWrapper)</li> </ul>"},{"location":"stm/class_members/#g","title":"g","text":"<ul> <li>gyro (MpuMotion32, MpuMotion6)</li> </ul>"},{"location":"stm/class_members/#h","title":"h","text":"<ul> <li>hasData (ByteFifo)</li> <li>holdReset (Esp32Manager)</li> <li>handle (MessageBufferWrapper, QueueWrapper, StreamBufferWrapper, TaskWrapper)</li> <li>homePosition (Motor)</li> </ul>"},{"location":"stm/class_members/#i","title":"i","text":"<ul> <li>internalVrefMv (CalibrationData)</li> <li>init (Esp32Manager)</li> <li>isInBootloader (Esp32Manager)</li> <li>Inverted (OLED_t)</li> <li>I (Regulator)</li> <li>integrator (Regulator)</li> <li>isActive (TickTimer)</li> </ul>"},{"location":"stm/class_members/#l","title":"l","text":"<ul> <li>lock (BasePriorityRaiser, MutexWrapper)</li> </ul>"},{"location":"stm/class_members/#m","title":"m","text":"<ul> <li>m_fifo (ByteFifo)</li> <li>m_head (ByteFifo)</li> <li>m_tail (ByteFifo)</li> <li>magic (CalibrationData)</li> <li>m_checkBreakTimer (Esp32Manager)</li> <li>m_enPinHolders (Esp32Manager)</li> <li>m_inBootloader (Esp32Manager)</li> <li>m_lastDtr (Esp32Manager)</li> <li>m_lastRts (Esp32Manager)</li> <li>m_previousEnEdge (Esp32Manager)</li> <li>m_queuedReset (Esp32Manager)</li> <li>m_unstrapTimer (Esp32Manager)</li> <li>m_watchdogInhibit (Esp32Manager)</li> <li>m_watchdogTimer (Esp32Manager)</li> <li>MessageBufferWrapper (MessageBufferWrapper)</li> <li>m_buffer (MessageBufferWrapper, MutexWrapper, QueueWrapper, StreamBufferWrapper)</li> <li>m_bufferStruct (MessageBufferWrapper, StreamBufferWrapper)</li> <li>m_handle (MessageBufferWrapper, MutexWrapper, QueueWrapper, StreamBufferWrapper, TaskWrapper)</li> <li>Motor (Motor)</li> <li>m_actualPosition (Motor)</li> <li>m_actualPower (Motor)</li> <li>m_actualTicksPerLoop (Motor)</li> <li>m_dither (Motor)</li> <li>m_lastEncTicks (Motor)</li> <li>m_maxAccel (Motor)</li> <li>m_mode (Motor)</li> <li>m_posEpsilon (Motor)</li> <li>m_positionReg (Motor)</li> <li>m_targetPosition (Motor)</li> <li>m_targetVelocity (Motor)</li> <li>m_velEpsilon (Motor)</li> <li>m_velocityReg (Motor)</li> <li>mode (Motor)</li> <li>modeChange (Motor)</li> <li>MutexWrapper (MutexWrapper)</li> <li>m_queueStruct (QueueWrapper)</li> <li>m_d (Regulator)</li> <li>m_de (Regulator)</li> <li>m_e (Regulator)</li> <li>m_i (Regulator)</li> <li>m_integrator (Regulator)</li> <li>m_le (Regulator)</li> <li>m_max_output (Regulator)</li> <li>m_output (Regulator)</li> <li>m_p (Regulator)</li> <li>m_stop (Regulator)</li> <li>maxOutput (Regulator)</li> <li>m_func (TaskWrapper)</li> <li>m_stack (TaskWrapper)</li> <li>m_taskStruct (TaskWrapper)</li> <li>MaxDelay (TickTimer)</li> <li>m_timeoutAt (TickTimer)</li> <li>m_state (XorShift)</li> </ul>"},{"location":"stm/class_members/#n","title":"n","text":"<ul> <li>notifyRead (ByteFifo)</li> <li>notifyWritten (ByteFifo)</li> <li>native_handle (MutexWrapper)</li> <li>next (XorShift)</li> </ul>"},{"location":"stm/class_members/#o","title":"o","text":"<ul> <li>onEnRisingInIrq (Esp32Manager)</li> <li>onSerialBreakInIrq (Esp32Manager)</li> <li>overwrite (QueueWrapper)</li> <li>operator= (Regulator)</li> <li>output (Regulator)</li> </ul>"},{"location":"stm/class_members/#p","title":"p","text":"<ul> <li>peekSpan (ByteFifo)</li> <li>pop (ByteFifo)</li> <li>push (ByteFifo)</li> <li>poll (Esp32Manager, Motor, TickTimer)</li> <li>pop_front (MessageBufferWrapper, QueueWrapper)</li> <li>push_back (MessageBufferWrapper, QueueWrapper)</li> <li>push_front (QueueWrapper)</li> <li>P (Regulator)</li> <li>process (Regulator)</li> </ul>"},{"location":"stm/class_members/#q","title":"q","text":"<ul> <li>QueuedReset (Esp32Manager)</li> <li>queueReset (Esp32Manager)</li> <li>QueueWrapper (QueueWrapper)</li> </ul>"},{"location":"stm/class_members/#r","title":"r","text":"<ul> <li>readableSpan (ByteFifo)</li> <li>releaseReset (Esp32Manager)</li> <li>resetWatchdog (Esp32Manager)</li> <li>reset (MessageBufferWrapper, Motor, QueueWrapper, StreamBufferWrapper)</li> <li>reportStat (Motor)</li> <li>Regulator (Regulator)</li> <li>read (StreamBufferWrapper)</li> <li>restart (TickTimer)</li> </ul>"},{"location":"stm/class_members/#s","title":"s","text":"<ul> <li>setHead (ByteFifo)</li> <li>size (ByteFifo)</li> <li>setWatchdogInhibit (Esp32Manager)</li> <li>strapPins (Esp32Manager)</li> <li>setConfig (Motor)</li> <li>setPositionPid (Motor)</li> <li>setTargetBrakingPower (Motor)</li> <li>setTargetPosition (Motor)</li> <li>setTargetPower (Motor)</li> <li>setTargetVelocity (Motor)</li> <li>setVelocityPid (Motor)</li> <li>setD (Regulator)</li> <li>setI (Regulator)</li> <li>setMaxOutput (Regulator)</li> <li>setP (Regulator)</li> <li>stop (Regulator, TickTimer)</li> <li>StreamBufferWrapper (StreamBufferWrapper)</li> <li>start (TaskWrapper)</li> </ul>"},{"location":"stm/class_members/#t","title":"t","text":"<ul> <li>tempTypicalAtC (CalibrationData)</li> <li>tempTypicalMv (CalibrationData)</li> <li>TaskWrapper (TaskWrapper)</li> <li>trampoline (TaskWrapper)</li> <li>TickTimer (TickTimer)</li> <li>tunnel_cdc_acm (cdc_config)</li> <li>tunnel_cdc_hdr (cdc_config)</li> <li>tunnel_cdc_mgmt (cdc_config)</li> <li>tunnel_cdc_union (cdc_config)</li> <li>tunnel_comm (cdc_config)</li> <li>tunnel_comm_ep (cdc_config)</li> <li>tunnel_comm_iad (cdc_config)</li> <li>tunnel_data (cdc_config)</li> <li>tunnel_data_eprx (cdc_config)</li> <li>tunnel_data_eptx (cdc_config)</li> </ul>"},{"location":"stm/class_members/#u","title":"u","text":"<ul> <li>unlock (BasePriorityRaiser, MutexWrapper)</li> <li>unstrapPins (Esp32Manager)</li> </ul>"},{"location":"stm/class_members/#v","title":"v","text":"<ul> <li>value_type (Regulator)</li> </ul>"},{"location":"stm/class_members/#w","title":"w","text":"<ul> <li>writeSpan (ByteFifo)</li> <li>writeableSpan (ByteFifo)</li> <li>write (StreamBufferWrapper)</li> </ul>"},{"location":"stm/class_members/#x","title":"x","text":"<ul> <li>x (MpuVector, MpuVector32, OLED_VERTEX)</li> <li>XorShift (XorShift)</li> </ul>"},{"location":"stm/class_members/#y","title":"y","text":"<ul> <li>y (MpuVector, MpuVector32, OLED_VERTEX)</li> </ul>"},{"location":"stm/class_members/#z","title":"z","text":"<ul> <li>z (MpuVector, MpuVector32)</li> </ul>"},{"location":"stm/class_members/#_1","title":"~","text":"<ul> <li>~BasePriorityRaiser (BasePriorityRaiser)</li> <li>~Esp32Manager (Esp32Manager)</li> <li>~MessageBufferWrapper (MessageBufferWrapper)</li> <li>~MutexWrapper (MutexWrapper)</li> <li>~QueueWrapper (QueueWrapper)</li> <li>~StreamBufferWrapper (StreamBufferWrapper)</li> <li>~TaskWrapper (TaskWrapper)</li> <li>~TickTimer (TickTimer)</li> </ul>"},{"location":"stm/class_member_functions/","title":"Class Member Functions","text":""},{"location":"stm/class_member_functions/#a","title":"a","text":"<ul> <li>adjust (ByteFifo)</li> <li>available (ByteFifo, StreamBufferWrapper)</li> <li>atStandstill (Motor)</li> <li>atTargetPosition (Motor)</li> </ul>"},{"location":"stm/class_member_functions/#b","title":"b","text":"<ul> <li>BasePriorityRaiser (BasePriorityRaiser)</li> <li>ByteFifo (ByteFifo)</li> </ul>"},{"location":"stm/class_member_functions/#c","title":"c","text":"<ul> <li>clear (ByteFifo, Regulator)</li> <li>create (MessageBufferWrapper, MutexWrapper, QueueWrapper, StreamBufferWrapper)</li> </ul>"},{"location":"stm/class_member_functions/#d","title":"d","text":"<ul> <li>data (ByteFifo)</li> <li>D (Regulator)</li> <li>de (Regulator)</li> </ul>"},{"location":"stm/class_member_functions/#e","title":"e","text":"<ul> <li>Esp32Manager (Esp32Manager)</li> <li>e (Regulator)</li> </ul>"},{"location":"stm/class_member_functions/#f","title":"f","text":"<ul> <li>freeSpace (StreamBufferWrapper)</li> </ul>"},{"location":"stm/class_member_functions/#h","title":"h","text":"<ul> <li>hasData (ByteFifo)</li> <li>holdReset (Esp32Manager)</li> <li>handle (MessageBufferWrapper, QueueWrapper, StreamBufferWrapper, TaskWrapper)</li> <li>homePosition (Motor)</li> </ul>"},{"location":"stm/class_member_functions/#i","title":"i","text":"<ul> <li>init (Esp32Manager)</li> <li>isInBootloader (Esp32Manager)</li> <li>I (Regulator)</li> <li>integrator (Regulator)</li> <li>isActive (TickTimer)</li> </ul>"},{"location":"stm/class_member_functions/#l","title":"l","text":"<ul> <li>lock (BasePriorityRaiser, MutexWrapper)</li> </ul>"},{"location":"stm/class_member_functions/#m","title":"m","text":"<ul> <li>MessageBufferWrapper (MessageBufferWrapper)</li> <li>Motor (Motor)</li> <li>mode (Motor)</li> <li>modeChange (Motor)</li> <li>MutexWrapper (MutexWrapper)</li> <li>maxOutput (Regulator)</li> </ul>"},{"location":"stm/class_member_functions/#n","title":"n","text":"<ul> <li>notifyRead (ByteFifo)</li> <li>notifyWritten (ByteFifo)</li> <li>native_handle (MutexWrapper)</li> <li>next (XorShift)</li> </ul>"},{"location":"stm/class_member_functions/#o","title":"o","text":"<ul> <li>onEnRisingInIrq (Esp32Manager)</li> <li>onSerialBreakInIrq (Esp32Manager)</li> <li>overwrite (QueueWrapper)</li> <li>operator= (Regulator)</li> <li>output (Regulator)</li> </ul>"},{"location":"stm/class_member_functions/#p","title":"p","text":"<ul> <li>peekSpan (ByteFifo)</li> <li>pop (ByteFifo)</li> <li>push (ByteFifo)</li> <li>poll (Esp32Manager, Motor, TickTimer)</li> <li>pop_front (MessageBufferWrapper, QueueWrapper)</li> <li>push_back (MessageBufferWrapper, QueueWrapper)</li> <li>push_front (QueueWrapper)</li> <li>P (Regulator)</li> <li>process (Regulator)</li> </ul>"},{"location":"stm/class_member_functions/#q","title":"q","text":"<ul> <li>queueReset (Esp32Manager)</li> <li>QueueWrapper (QueueWrapper)</li> </ul>"},{"location":"stm/class_member_functions/#r","title":"r","text":"<ul> <li>readableSpan (ByteFifo)</li> <li>releaseReset (Esp32Manager)</li> <li>resetWatchdog (Esp32Manager)</li> <li>reset (MessageBufferWrapper, Motor, QueueWrapper, StreamBufferWrapper)</li> <li>reportStat (Motor)</li> <li>Regulator (Regulator)</li> <li>read (StreamBufferWrapper)</li> <li>restart (TickTimer)</li> </ul>"},{"location":"stm/class_member_functions/#s","title":"s","text":"<ul> <li>setHead (ByteFifo)</li> <li>size (ByteFifo)</li> <li>setWatchdogInhibit (Esp32Manager)</li> <li>strapPins (Esp32Manager)</li> <li>setConfig (Motor)</li> <li>setPositionPid (Motor)</li> <li>setTargetBrakingPower (Motor)</li> <li>setTargetPosition (Motor)</li> <li>setTargetPower (Motor)</li> <li>setTargetVelocity (Motor)</li> <li>setVelocityPid (Motor)</li> <li>setD (Regulator)</li> <li>setI (Regulator)</li> <li>setMaxOutput (Regulator)</li> <li>setP (Regulator)</li> <li>stop (Regulator, TickTimer)</li> <li>StreamBufferWrapper (StreamBufferWrapper)</li> <li>start (TaskWrapper)</li> </ul>"},{"location":"stm/class_member_functions/#t","title":"t","text":"<ul> <li>TaskWrapper (TaskWrapper)</li> <li>trampoline (TaskWrapper)</li> <li>TickTimer (TickTimer)</li> </ul>"},{"location":"stm/class_member_functions/#u","title":"u","text":"<ul> <li>unlock (BasePriorityRaiser, MutexWrapper)</li> <li>unstrapPins (Esp32Manager)</li> </ul>"},{"location":"stm/class_member_functions/#w","title":"w","text":"<ul> <li>writeSpan (ByteFifo)</li> <li>writeableSpan (ByteFifo)</li> <li>write (StreamBufferWrapper)</li> </ul>"},{"location":"stm/class_member_functions/#x","title":"x","text":"<ul> <li>XorShift (XorShift)</li> </ul>"},{"location":"stm/class_member_functions/#_1","title":"~","text":"<ul> <li>~BasePriorityRaiser (BasePriorityRaiser)</li> <li>~Esp32Manager (Esp32Manager)</li> <li>~MessageBufferWrapper (MessageBufferWrapper)</li> <li>~MutexWrapper (MutexWrapper)</li> <li>~QueueWrapper (QueueWrapper)</li> <li>~StreamBufferWrapper (StreamBufferWrapper)</li> <li>~TaskWrapper (TaskWrapper)</li> <li>~TickTimer (TickTimer)</li> </ul>"},{"location":"stm/class_member_variables/","title":"Class Member Variables","text":""},{"location":"stm/class_member_variables/#a","title":"a","text":"<ul> <li>accel (MpuMotion32, MpuMotion6)</li> </ul>"},{"location":"stm/class_member_variables/#b","title":"b","text":"<ul> <li>batteryCoef (CalibrationData)</li> <li>batteryMidCoef (CalibrationData)</li> <li>buffer (MPU6050_t, mpu_t)</li> </ul>"},{"location":"stm/class_member_variables/#c","title":"c","text":"<ul> <li>CurrentX (OLED_t)</li> <li>CurrentY (OLED_t)</li> <li>config (cdc_config)</li> </ul>"},{"location":"stm/class_member_variables/#d","title":"d","text":"<ul> <li>data (FontDef)</li> <li>devAddr (MPU6050_t, mpu_t)</li> <li>DisplayOn (OLED_t)</li> </ul>"},{"location":"stm/class_member_variables/#f","title":"f","text":"<ul> <li>FontHeight (FontDef)</li> <li>FontWidth (FontDef)</li> </ul>"},{"location":"stm/class_member_variables/#g","title":"g","text":"<ul> <li>gyro (MpuMotion32, MpuMotion6)</li> </ul>"},{"location":"stm/class_member_variables/#i","title":"i","text":"<ul> <li>internalVrefMv (CalibrationData)</li> <li>Inverted (OLED_t)</li> </ul>"},{"location":"stm/class_member_variables/#m","title":"m","text":"<ul> <li>m_fifo (ByteFifo)</li> <li>m_head (ByteFifo)</li> <li>m_tail (ByteFifo)</li> <li>magic (CalibrationData)</li> <li>m_checkBreakTimer (Esp32Manager)</li> <li>m_enPinHolders (Esp32Manager)</li> <li>m_inBootloader (Esp32Manager)</li> <li>m_lastDtr (Esp32Manager)</li> <li>m_lastRts (Esp32Manager)</li> <li>m_previousEnEdge (Esp32Manager)</li> <li>m_queuedReset (Esp32Manager)</li> <li>m_unstrapTimer (Esp32Manager)</li> <li>m_watchdogInhibit (Esp32Manager)</li> <li>m_watchdogTimer (Esp32Manager)</li> <li>m_buffer (MessageBufferWrapper, MutexWrapper, QueueWrapper, StreamBufferWrapper)</li> <li>m_bufferStruct (MessageBufferWrapper, StreamBufferWrapper)</li> <li>m_handle (MessageBufferWrapper, MutexWrapper, QueueWrapper, StreamBufferWrapper, TaskWrapper)</li> <li>m_actualPosition (Motor)</li> <li>m_actualPower (Motor)</li> <li>m_actualTicksPerLoop (Motor)</li> <li>m_dither (Motor)</li> <li>m_lastEncTicks (Motor)</li> <li>m_maxAccel (Motor)</li> <li>m_mode (Motor)</li> <li>m_posEpsilon (Motor)</li> <li>m_positionReg (Motor)</li> <li>m_targetPosition (Motor)</li> <li>m_targetVelocity (Motor)</li> <li>m_velEpsilon (Motor)</li> <li>m_velocityReg (Motor)</li> <li>m_queueStruct (QueueWrapper)</li> <li>m_d (Regulator)</li> <li>m_de (Regulator)</li> <li>m_e (Regulator)</li> <li>m_i (Regulator)</li> <li>m_integrator (Regulator)</li> <li>m_le (Regulator)</li> <li>m_max_output (Regulator)</li> <li>m_output (Regulator)</li> <li>m_p (Regulator)</li> <li>m_stop (Regulator)</li> <li>m_func (TaskWrapper)</li> <li>m_stack (TaskWrapper)</li> <li>m_taskStruct (TaskWrapper)</li> <li>MaxDelay (TickTimer)</li> <li>m_timeoutAt (TickTimer)</li> <li>m_state (XorShift)</li> </ul>"},{"location":"stm/class_member_variables/#t","title":"t","text":"<ul> <li>tempTypicalAtC (CalibrationData)</li> <li>tempTypicalMv (CalibrationData)</li> <li>tunnel_cdc_acm (cdc_config)</li> <li>tunnel_cdc_hdr (cdc_config)</li> <li>tunnel_cdc_mgmt (cdc_config)</li> <li>tunnel_cdc_union (cdc_config)</li> <li>tunnel_comm (cdc_config)</li> <li>tunnel_comm_ep (cdc_config)</li> <li>tunnel_comm_iad (cdc_config)</li> <li>tunnel_data (cdc_config)</li> <li>tunnel_data_eprx (cdc_config)</li> <li>tunnel_data_eptx (cdc_config)</li> </ul>"},{"location":"stm/class_member_variables/#x","title":"x","text":"<ul> <li>x (MpuVector, MpuVector32, OLED_VERTEX)</li> </ul>"},{"location":"stm/class_member_variables/#y","title":"y","text":"<ul> <li>y (MpuVector, MpuVector32, OLED_VERTEX)</li> </ul>"},{"location":"stm/class_member_variables/#z","title":"z","text":"<ul> <li>z (MpuVector, MpuVector32)</li> </ul>"},{"location":"stm/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"stm/class_member_typedefs/#c","title":"c","text":"<ul> <li>coef_type (Regulator)</li> </ul>"},{"location":"stm/class_member_typedefs/#v","title":"v","text":"<ul> <li>value_type (Regulator)</li> </ul>"},{"location":"stm/class_member_enums/","title":"Class Member Enums","text":""},{"location":"stm/class_member_enums/#e","title":"e","text":"<ul> <li>EnHolderType (Esp32Manager)</li> </ul>"},{"location":"stm/class_member_enums/#q","title":"q","text":"<ul> <li>QueuedReset (Esp32Manager)</li> </ul>"},{"location":"stm/namespace_members/","title":"Namespace Members","text":""},{"location":"stm/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"stm/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"stm/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"stm/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"stm/functions/","title":"Functions","text":""},{"location":"stm/functions/#a","title":"a","text":"<ul> <li>AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER (Power.cpp)</li> <li>adcWait (Power.cpp)</li> </ul>"},{"location":"stm/functions/#b","title":"b","text":"<ul> <li>buttonControllerPoll (ButtonController.hpp, ButtonController.cpp)</li> <li>buttonControllerSetDebug (ButtonController.hpp, ButtonController.cpp)</li> <li>buzzerSetState (BuzzerController.hpp)</li> </ul>"},{"location":"stm/functions/#c","title":"c","text":"<ul> <li>clocksInit (Bsp.hpp)</li> <li>controlLinkReset (ControlLink.hpp, ControlLink.cpp)</li> <li>controlLinkRx (ControlLink.hpp, ControlLink.cpp)</li> <li>controlLinkTx (ControlLink.hpp, ControlLink.cpp)</li> <li>controlUartInit (ControlLink.hpp, ControlLink.cpp)</li> <li>cdcLinkInit (UsbCdcLink.h, UsbCdcLink.cpp)</li> <li>cdcLinkIsDebugEpEnabled (UsbCdcLink.h, UsbCdcLink.cpp)</li> <li>CONTROLUART_TX_DMA_HANDLER (ControlLink.cpp)</li> <li>controlLinkUpdateRxFifo (ControlLink.cpp)</li> <li>checkBatteryVoltage (Power.cpp)</li> <li>cdc_control (UsbCdcLink.cpp)</li> <li>cdc_control_debug (UsbCdcLink.cpp)</li> <li>cdc_control_tunnel (UsbCdcLink.cpp)</li> <li>cdc_getdesc (UsbCdcLink.cpp)</li> <li>cdc_setconf (UsbCdcLink.cpp)</li> </ul>"},{"location":"stm/functions/#d","title":"d","text":"<ul> <li>debugLinkPoll (DebugLink.hpp, DebugLink.cpp)</li> <li>debugLinkTx (DebugLink.hpp, DebugLink.cpp)</li> <li>debugUartInit (DebugLink.hpp, DebugLink.cpp)</li> <li>dispatcherEnqueueRequest (Dispatcher.hpp, Dispatcher.cpp)</li> <li>dispatcherEnqueueStatus (Dispatcher.hpp, Dispatcher.cpp)</li> <li>dispatcherInit (Dispatcher.hpp, Dispatcher.cpp)</li> <li>dispatcherPoll (Dispatcher.hpp, Dispatcher.cpp)</li> <li>dispatcherReset (Dispatcher.hpp, Dispatcher.cpp)</li> <li>DEBUG_HEX (Debug.hpp)</li> <li>DEBUGUART_HANDLER (DebugLink.cpp)</li> <li>DEBUGUART_TX_DMA_HANDLER (DebugLink.cpp)</li> <li>debugDownstreamHandler (DebugLink.cpp)</li> <li>debugLinkHandleCommand (DebugLink.cpp)</li> <li>debugUpstreamHandler (DebugLink.cpp)</li> <li>dispatcherProcessReq (Dispatcher.cpp)</li> </ul>"},{"location":"stm/functions/#e","title":"e","text":"<ul> <li>EXTI4_IRQHandler (Bsp.cpp)</li> <li>EXTI9_5_IRQHandler (Bsp.cpp)</li> </ul>"},{"location":"stm/functions/#f","title":"f","text":"<ul> <li>flashWritePage (Flash.hpp)</li> </ul>"},{"location":"stm/functions/#g","title":"g","text":"<ul> <li>getButtons (Bsp.hpp)</li> <li>getExternalSensorDWord (Mpu6050.hpp, MpuController.hpp)</li> <li>getXFineGain (Mpu6050.hpp, MpuController.hpp)</li> <li>getXGyroOffsetTC (Mpu6050.hpp, MpuController.hpp)</li> <li>getYFineGain (Mpu6050.hpp, MpuController.hpp)</li> <li>getYGyroOffsetTC (Mpu6050.hpp, MpuController.hpp)</li> <li>getZFineGain (Mpu6050.hpp, MpuController.hpp)</li> <li>getZGyroOffsetTC (Mpu6050.hpp, MpuController.hpp)</li> </ul>"},{"location":"stm/functions/#h","title":"h","text":"<ul> <li>HAL_DMA_PollForTransfer_Really (HalDma.hpp)</li> <li>HAL_I2C_ErrorCallback (I2cController.cpp)</li> <li>HAL_I2C_MasterRxCpltCallback (I2cController.cpp)</li> <li>HAL_I2C_MasterTxCpltCallback (I2cController.cpp)</li> <li>HAL_I2C_MemRxCpltCallback (I2cController.cpp)</li> <li>HAL_I2C_MemTxCpltCallback (I2cController.cpp)</li> </ul>"},{"location":"stm/functions/#i","title":"i","text":"<ul> <li>isPressed (Bsp.hpp)</li> <li>I2Cdev_IsDeviceReady (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_Master_Receive (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_Master_Transmit (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_Mem_Read (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_Mem_Write (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_Slave_Receive (I2cController.hpp)</li> <li>I2Cdev_Slave_Transmit (I2cController.hpp)</li> <li>I2Cdev_init (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_readBit (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_readBitW (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_readBits (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_readBitsW (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_readByte (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_readBytes (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_readWord (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_readWords (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_scan (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_writeBit (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_writeBitW (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_writeBits (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_writeBitsW (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_writeByte (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_writeBytes (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_writeWord (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_writeWords (I2cController.hpp, I2cController.cpp)</li> <li>i2cDispatch (I2cController.hpp, I2cController.cpp)</li> <li>i2cReset (I2cController.hpp, I2cController.cpp)</li> <li>isInInterrupt (Debug.hpp)</li> <li>I2C1_ER_IRQHandler (I2cController.cpp)</li> <li>I2C1_EV_IRQHandler (I2cController.cpp)</li> <li>i2cNotify (I2cController.cpp)</li> <li>i2cWait (I2cController.cpp)</li> <li>i2cWrap (I2cController.cpp)</li> </ul>"},{"location":"stm/functions/#l","title":"l","text":"<ul> <li>LL_ADC_SetChannelSamplingTimeFix (Bsp.hpp)</li> <li>LL_GPIO_AF_Remap (Bsp.hpp)</li> <li>loadCalibration (Power.cpp)</li> </ul>"},{"location":"stm/functions/#m","title":"m","text":"<ul> <li>motorDispatch (MotorController.hpp, MotorController.cpp)</li> <li>motorInit (MotorController.hpp, MotorController.cpp)</li> <li>motorReset (MotorController.hpp, MotorController.cpp)</li> <li>MPU6050 (Mpu6050.hpp)</li> <li>MPU6050_getAccelFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getAccelXSelfTest (Mpu6050.hpp)</li> <li>MPU6050_getAccelYSelfTest (Mpu6050.hpp)</li> <li>MPU6050_getAccelZSelfTest (Mpu6050.hpp)</li> <li>MPU6050_getAcceleration (Mpu6050.hpp)</li> <li>MPU6050_getAccelerationX (Mpu6050.hpp)</li> <li>MPU6050_getAccelerationY (Mpu6050.hpp)</li> <li>MPU6050_getAccelerationZ (Mpu6050.hpp)</li> <li>MPU6050_getAccelerometerPowerOnDelay (Mpu6050.hpp)</li> <li>MPU6050_getAuxVDDIOLevel (Mpu6050.hpp)</li> <li>MPU6050_getClockOutputEnabled (Mpu6050.hpp)</li> <li>MPU6050_getClockSource (Mpu6050.hpp)</li> <li>MPU6050_getDHPFMode (Mpu6050.hpp)</li> <li>MPU6050_getDLPFMode (Mpu6050.hpp)</li> <li>MPU6050_getDMPConfig1 (Mpu6050.hpp)</li> <li>MPU6050_getDMPConfig2 (Mpu6050.hpp)</li> <li>MPU6050_getDMPEnabled (Mpu6050.hpp)</li> <li>MPU6050_getDMPInt0Status (Mpu6050.hpp)</li> <li>MPU6050_getDMPInt1Status (Mpu6050.hpp)</li> <li>MPU6050_getDMPInt2Status (Mpu6050.hpp)</li> <li>MPU6050_getDMPInt3Status (Mpu6050.hpp)</li> <li>MPU6050_getDMPInt4Status (Mpu6050.hpp)</li> <li>MPU6050_getDMPInt5Status (Mpu6050.hpp)</li> <li>MPU6050_getDeviceID (Mpu6050.hpp)</li> <li>MPU6050_getExternalFrameSync (Mpu6050.hpp)</li> <li>MPU6050_getExternalSensorByte (Mpu6050.hpp)</li> <li>MPU6050_getExternalSensorWord (Mpu6050.hpp)</li> <li>MPU6050_getExternalShadowDelayEnabled (Mpu6050.hpp)</li> <li>MPU6050_getFIFOByte (Mpu6050.hpp)</li> <li>MPU6050_getFIFOBytes (Mpu6050.hpp)</li> <li>MPU6050_getFIFOCount (Mpu6050.hpp)</li> <li>MPU6050_getFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getFSyncInterruptEnabled (Mpu6050.hpp)</li> <li>MPU6050_getFSyncInterruptLevel (Mpu6050.hpp)</li> <li>MPU6050_getFreefallDetectionCounterDecrement (Mpu6050.hpp)</li> <li>MPU6050_getFreefallDetectionDuration (Mpu6050.hpp)</li> <li>MPU6050_getFreefallDetectionThreshold (Mpu6050.hpp)</li> <li>MPU6050_getFullScaleAccelRange (Mpu6050.hpp)</li> <li>MPU6050_getFullScaleGyroRange (Mpu6050.hpp)</li> <li>MPU6050_getI2CBypassEnabled (Mpu6050.hpp)</li> <li>MPU6050_getI2CMasterModeEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntDMPEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntDMPStatus (Mpu6050.hpp)</li> <li>MPU6050_getIntDataReadyEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntDataReadyStatus (Mpu6050.hpp)</li> <li>MPU6050_getIntEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntFIFOBufferOverflowEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntFIFOBufferOverflowStatus (Mpu6050.hpp)</li> <li>MPU6050_getIntFreefallEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntFreefallStatus (Mpu6050.hpp)</li> <li>MPU6050_getIntI2CMasterEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntI2CMasterStatus (Mpu6050.hpp)</li> <li>MPU6050_getIntMotionEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntMotionStatus (Mpu6050.hpp)</li> <li>MPU6050_getIntPLLReadyEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntPLLReadyStatus (Mpu6050.hpp)</li> <li>MPU6050_getIntStatus (Mpu6050.hpp)</li> <li>MPU6050_getIntZeroMotionEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntZeroMotionStatus (Mpu6050.hpp)</li> <li>MPU6050_getInterruptDrive (Mpu6050.hpp)</li> <li>MPU6050_getInterruptLatch (Mpu6050.hpp)</li> <li>MPU6050_getInterruptLatchClear (Mpu6050.hpp)</li> <li>MPU6050_getInterruptMode (Mpu6050.hpp)</li> <li>MPU6050_getLostArbitration (Mpu6050.hpp)</li> <li>MPU6050_getMasterClockSpeed (Mpu6050.hpp)</li> <li>MPU6050_getMotion6 (Mpu6050.hpp)</li> <li>MPU6050_getMotion9 (Mpu6050.hpp)</li> <li>MPU6050_getMotionDetectionCounterDecrement (Mpu6050.hpp)</li> <li>MPU6050_getMotionDetectionDuration (Mpu6050.hpp)</li> <li>MPU6050_getMotionDetectionThreshold (Mpu6050.hpp)</li> <li>MPU6050_getMultiMasterEnabled (Mpu6050.hpp)</li> <li>MPU6050_getOTPBankValid (Mpu6050.hpp)</li> <li>MPU6050_getPassthroughStatus (Mpu6050.hpp)</li> <li>MPU6050_getRate (Mpu6050.hpp)</li> <li>MPU6050_getRotation (Mpu6050.hpp)</li> <li>MPU6050_getRotationX (Mpu6050.hpp)</li> <li>MPU6050_getRotationY (Mpu6050.hpp)</li> <li>MPU6050_getRotationZ (Mpu6050.hpp)</li> <li>MPU6050_getSlate4InputByte (Mpu6050.hpp)</li> <li>MPU6050_getSlave0FIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getSlave0Nack (Mpu6050.hpp)</li> <li>MPU6050_getSlave1FIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getSlave1Nack (Mpu6050.hpp)</li> <li>MPU6050_getSlave2FIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getSlave2Nack (Mpu6050.hpp)</li> <li>MPU6050_getSlave3FIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getSlave3Nack (Mpu6050.hpp)</li> <li>MPU6050_getSlave4Address (Mpu6050.hpp)</li> <li>MPU6050_getSlave4Enabled (Mpu6050.hpp)</li> <li>MPU6050_getSlave4InterruptEnabled (Mpu6050.hpp)</li> <li>MPU6050_getSlave4IsDone (Mpu6050.hpp)</li> <li>MPU6050_getSlave4MasterDelay (Mpu6050.hpp)</li> <li>MPU6050_getSlave4Nack (Mpu6050.hpp)</li> <li>MPU6050_getSlave4Register (Mpu6050.hpp)</li> <li>MPU6050_getSlave4WriteMode (Mpu6050.hpp)</li> <li>MPU6050_getSlaveAddress (Mpu6050.hpp)</li> <li>MPU6050_getSlaveDataLength (Mpu6050.hpp)</li> <li>MPU6050_getSlaveDelayEnabled (Mpu6050.hpp)</li> <li>MPU6050_getSlaveEnabled (Mpu6050.hpp)</li> <li>MPU6050_getSlaveReadWriteTransitionEnabled (Mpu6050.hpp)</li> <li>MPU6050_getSlaveRegister (Mpu6050.hpp)</li> <li>MPU6050_getSlaveWordByteSwap (Mpu6050.hpp)</li> <li>MPU6050_getSlaveWordGroupOffset (Mpu6050.hpp)</li> <li>MPU6050_getSlaveWriteMode (Mpu6050.hpp)</li> <li>MPU6050_getSleepEnabled (Mpu6050.hpp)</li> <li>MPU6050_getStandbyXAccelEnabled (Mpu6050.hpp)</li> <li>MPU6050_getStandbyXGyroEnabled (Mpu6050.hpp)</li> <li>MPU6050_getStandbyYAccelEnabled (Mpu6050.hpp)</li> <li>MPU6050_getStandbyYGyroEnabled (Mpu6050.hpp)</li> <li>MPU6050_getStandbyZAccelEnabled (Mpu6050.hpp)</li> <li>MPU6050_getStandbyZGyroEnabled (Mpu6050.hpp)</li> <li>MPU6050_getTempFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getTempSensorEnabled (Mpu6050.hpp)</li> <li>MPU6050_getTemperature (Mpu6050.hpp)</li> <li>MPU6050_getWaitForExternalSensorEnabled (Mpu6050.hpp)</li> <li>MPU6050_getWakeCycleEnabled (Mpu6050.hpp)</li> <li>MPU6050_getWakeFrequency (Mpu6050.hpp)</li> <li>MPU6050_getXAccelOffset (Mpu6050.hpp)</li> <li>MPU6050_getXGyroFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getXGyroOffset (Mpu6050.hpp)</li> <li>MPU6050_getXNegMotionDetected (Mpu6050.hpp)</li> <li>MPU6050_getXPosMotionDetected (Mpu6050.hpp)</li> <li>MPU6050_getYAccelOffset (Mpu6050.hpp)</li> <li>MPU6050_getYGyroFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getYGyroOffset (Mpu6050.hpp)</li> <li>MPU6050_getYNegMotionDetected (Mpu6050.hpp)</li> <li>MPU6050_getYPosMotionDetected (Mpu6050.hpp)</li> <li>MPU6050_getZAccelOffset (Mpu6050.hpp)</li> <li>MPU6050_getZGyroFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getZGyroOffset (Mpu6050.hpp)</li> <li>MPU6050_getZNegMotionDetected (Mpu6050.hpp)</li> <li>MPU6050_getZPosMotionDetected (Mpu6050.hpp)</li> <li>MPU6050_getZeroMotionDetected (Mpu6050.hpp)</li> <li>MPU6050_getZeroMotionDetectionDuration (Mpu6050.hpp)</li> <li>MPU6050_getZeroMotionDetectionThreshold (Mpu6050.hpp)</li> <li>MPU6050_init (Mpu6050.hpp)</li> <li>MPU6050_initialize (Mpu6050.hpp)</li> <li>MPU6050_readMemoryBlock (Mpu6050.hpp)</li> <li>MPU6050_readMemoryByte (Mpu6050.hpp)</li> <li>MPU6050_reset (Mpu6050.hpp)</li> <li>MPU6050_resetAccelerometerPath (Mpu6050.hpp)</li> <li>MPU6050_resetDMP (Mpu6050.hpp)</li> <li>MPU6050_resetFIFO (Mpu6050.hpp)</li> <li>MPU6050_resetGyroscopePath (Mpu6050.hpp)</li> <li>MPU6050_resetI2CMaster (Mpu6050.hpp)</li> <li>MPU6050_resetSensors (Mpu6050.hpp)</li> <li>MPU6050_resetTemperaturePath (Mpu6050.hpp)</li> <li>MPU6050_setAccelFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setAccelXSelfTest (Mpu6050.hpp)</li> <li>MPU6050_setAccelYSelfTest (Mpu6050.hpp)</li> <li>MPU6050_setAccelZSelfTest (Mpu6050.hpp)</li> <li>MPU6050_setAccelerometerPowerOnDelay (Mpu6050.hpp)</li> <li>MPU6050_setAuxVDDIOLevel (Mpu6050.hpp)</li> <li>MPU6050_setClockOutputEnabled (Mpu6050.hpp)</li> <li>MPU6050_setClockSource (Mpu6050.hpp)</li> <li>MPU6050_setDHPFMode (Mpu6050.hpp)</li> <li>MPU6050_setDLPFMode (Mpu6050.hpp)</li> <li>MPU6050_setDMPConfig1 (Mpu6050.hpp)</li> <li>MPU6050_setDMPConfig2 (Mpu6050.hpp)</li> <li>MPU6050_setDMPEnabled (Mpu6050.hpp)</li> <li>MPU6050_setDeviceID (Mpu6050.hpp)</li> <li>MPU6050_setExternalFrameSync (Mpu6050.hpp)</li> <li>MPU6050_setExternalShadowDelayEnabled (Mpu6050.hpp)</li> <li>MPU6050_setFIFOByte (Mpu6050.hpp)</li> <li>MPU6050_setFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setFSyncInterruptEnabled (Mpu6050.hpp)</li> <li>MPU6050_setFSyncInterruptLevel (Mpu6050.hpp)</li> <li>MPU6050_setFreefallDetectionCounterDecrement (Mpu6050.hpp)</li> <li>MPU6050_setFreefallDetectionDuration (Mpu6050.hpp)</li> <li>MPU6050_setFreefallDetectionThreshold (Mpu6050.hpp)</li> <li>MPU6050_setFullScaleAccelRange (Mpu6050.hpp)</li> <li>MPU6050_setFullScaleGyroRange (Mpu6050.hpp)</li> <li>MPU6050_setI2CBypassEnabled (Mpu6050.hpp)</li> <li>MPU6050_setI2CMasterModeEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntDMPEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntDataReadyEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntFIFOBufferOverflowEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntFreefallEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntI2CMasterEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntMotionEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntPLLReadyEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntZeroMotionEnabled (Mpu6050.hpp)</li> <li>MPU6050_setInterruptDrive (Mpu6050.hpp)</li> <li>MPU6050_setInterruptLatch (Mpu6050.hpp)</li> <li>MPU6050_setInterruptLatchClear (Mpu6050.hpp)</li> <li>MPU6050_setInterruptMode (Mpu6050.hpp)</li> <li>MPU6050_setMasterClockSpeed (Mpu6050.hpp)</li> <li>MPU6050_setMemoryBank (Mpu6050.hpp)</li> <li>MPU6050_setMemoryStartAddress (Mpu6050.hpp)</li> <li>MPU6050_setMotionDetectionCounterDecrement (Mpu6050.hpp)</li> <li>MPU6050_setMotionDetectionDuration (Mpu6050.hpp)</li> <li>MPU6050_setMotionDetectionThreshold (Mpu6050.hpp)</li> <li>MPU6050_setMultiMasterEnabled (Mpu6050.hpp)</li> <li>MPU6050_setOTPBankValid (Mpu6050.hpp)</li> <li>MPU6050_setRate (Mpu6050.hpp)</li> <li>MPU6050_setSlave0FIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setSlave1FIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setSlave2FIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setSlave3FIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setSlave4Address (Mpu6050.hpp)</li> <li>MPU6050_setSlave4Enabled (Mpu6050.hpp)</li> <li>MPU6050_setSlave4InterruptEnabled (Mpu6050.hpp)</li> <li>MPU6050_setSlave4MasterDelay (Mpu6050.hpp)</li> <li>MPU6050_setSlave4OutputByte (Mpu6050.hpp)</li> <li>MPU6050_setSlave4Register (Mpu6050.hpp)</li> <li>MPU6050_setSlave4WriteMode (Mpu6050.hpp)</li> <li>MPU6050_setSlaveAddress (Mpu6050.hpp)</li> <li>MPU6050_setSlaveDataLength (Mpu6050.hpp)</li> <li>MPU6050_setSlaveDelayEnabled (Mpu6050.hpp)</li> <li>MPU6050_setSlaveEnabled (Mpu6050.hpp)</li> <li>MPU6050_setSlaveOutputByte (Mpu6050.hpp)</li> <li>MPU6050_setSlaveReadWriteTransitionEnabled (Mpu6050.hpp)</li> <li>MPU6050_setSlaveRegister (Mpu6050.hpp)</li> <li>MPU6050_setSlaveWordByteSwap (Mpu6050.hpp)</li> <li>MPU6050_setSlaveWordGroupOffset (Mpu6050.hpp)</li> <li>MPU6050_setSlaveWriteMode (Mpu6050.hpp)</li> <li>MPU6050_setSleepEnabled (Mpu6050.hpp)</li> <li>MPU6050_setStandbyXAccelEnabled (Mpu6050.hpp)</li> <li>MPU6050_setStandbyXGyroEnabled (Mpu6050.hpp)</li> <li>MPU6050_setStandbyYAccelEnabled (Mpu6050.hpp)</li> <li>MPU6050_setStandbyYGyroEnabled (Mpu6050.hpp)</li> <li>MPU6050_setStandbyZAccelEnabled (Mpu6050.hpp)</li> <li>MPU6050_setStandbyZGyroEnabled (Mpu6050.hpp)</li> <li>MPU6050_setTempFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setTempSensorEnabled (Mpu6050.hpp)</li> <li>MPU6050_setWaitForExternalSensorEnabled (Mpu6050.hpp)</li> <li>MPU6050_setWakeCycleEnabled (Mpu6050.hpp)</li> <li>MPU6050_setWakeFrequency (Mpu6050.hpp)</li> <li>MPU6050_setXAccelOffset (Mpu6050.hpp)</li> <li>MPU6050_setXFineGain (Mpu6050.hpp)</li> <li>MPU6050_setXGyroFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setXGyroOffset (Mpu6050.hpp)</li> <li>MPU6050_setXGyroOffsetTC (Mpu6050.hpp)</li> <li>MPU6050_setYAccelOffset (Mpu6050.hpp)</li> <li>MPU6050_setYFineGain (Mpu6050.hpp)</li> <li>MPU6050_setYGyroFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setYGyroOffset (Mpu6050.hpp)</li> <li>MPU6050_setYGyroOffsetTC (Mpu6050.hpp)</li> <li>MPU6050_setZAccelOffset (Mpu6050.hpp)</li> <li>MPU6050_setZFineGain (Mpu6050.hpp)</li> <li>MPU6050_setZGyroFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setZGyroOffset (Mpu6050.hpp)</li> <li>MPU6050_setZGyroOffsetTC (Mpu6050.hpp)</li> <li>MPU6050_setZeroMotionDetectionDuration (Mpu6050.hpp)</li> <li>MPU6050_setZeroMotionDetectionThreshold (Mpu6050.hpp)</li> <li>MPU6050_switchSPIEnabled (Mpu6050.hpp)</li> <li>MPU6050_testConnection (Mpu6050.hpp)</li> <li>MPU6050_writeMemoryByte (Mpu6050.hpp)</li> <li>mpuCreate (MpuController.hpp, MpuController.cpp)</li> <li>mpuDispatch (MpuController.hpp, MpuController.cpp)</li> <li>mpuInitialize (MpuController.hpp, MpuController.cpp)</li> <li>mpuReset (MpuController.hpp, MpuController.cpp)</li> <li>mpuTick (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAccelFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAccelXSelfTest (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAccelYSelfTest (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAccelZSelfTest (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAcceleration (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAccelerationX (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAccelerationY (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAccelerationZ (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAccelerometerPowerOnDelay (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAuxVDDIOLevel (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getClockOutputEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getClockSource (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getDHPFMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getDLPFMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getDMPConfig1 (MpuController.hpp)</li> <li>mpu_getDMPConfig2 (MpuController.hpp)</li> <li>mpu_getDMPEnabled (MpuController.hpp)</li> <li>mpu_getDMPInt0Status (MpuController.hpp)</li> <li>mpu_getDMPInt1Status (MpuController.hpp)</li> <li>mpu_getDMPInt2Status (MpuController.hpp)</li> <li>mpu_getDMPInt3Status (MpuController.hpp)</li> <li>mpu_getDMPInt4Status (MpuController.hpp)</li> <li>mpu_getDMPInt5Status (MpuController.hpp)</li> <li>mpu_getDeviceID (MpuController.hpp)</li> <li>mpu_getExternalFrameSync (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getExternalSensorByte (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getExternalSensorWord (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getExternalShadowDelayEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getFIFOByte (MpuController.hpp)</li> <li>mpu_getFIFOBytes (MpuController.hpp)</li> <li>mpu_getFIFOCount (MpuController.hpp)</li> <li>mpu_getFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getFSyncInterruptEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getFSyncInterruptLevel (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getFreefallDetectionCounterDecrement (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getFreefallDetectionDuration (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getFreefallDetectionThreshold (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getFullScaleAccelRange (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getFullScaleGyroRange (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getI2CBypassEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getI2CMasterModeEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntDMPEnabled (MpuController.hpp)</li> <li>mpu_getIntDMPStatus (MpuController.hpp)</li> <li>mpu_getIntDataReadyEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntDataReadyStatus (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntFIFOBufferOverflowEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntFIFOBufferOverflowStatus (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntFreefallEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntFreefallStatus (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntI2CMasterEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntI2CMasterStatus (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntMotionEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntMotionStatus (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntPLLReadyEnabled (MpuController.hpp)</li> <li>mpu_getIntPLLReadyStatus (MpuController.hpp)</li> <li>mpu_getIntStatus (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntZeroMotionEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntZeroMotionStatus (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getInterruptDrive (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getInterruptLatch (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getInterruptLatchClear (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getInterruptMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getLostArbitration (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getMasterClockSpeed (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getMotion6 (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getMotion9 (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getMotionDetectionCounterDecrement (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getMotionDetectionDuration (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getMotionDetectionThreshold (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getMultiMasterEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getOTPBankValid (MpuController.hpp)</li> <li>mpu_getPassthroughStatus (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getRate (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getRotation (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getRotationX (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getRotationY (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getRotationZ (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlate4InputByte (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave0FIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave0Nack (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave1FIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave1Nack (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave2FIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave2Nack (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave3FIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave3Nack (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave4Address (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave4Enabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave4InterruptEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave4IsDone (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave4MasterDelay (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave4Nack (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave4Register (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave4WriteMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveAddress (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveDataLength (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveDelayEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveReadWriteTransitionEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveRegister (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveWordByteSwap (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveWordGroupOffset (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveWriteMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSleepEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getStandbyXAccelEnabled (MpuController.hpp)</li> <li>mpu_getStandbyXGyroEnabled (MpuController.hpp)</li> <li>mpu_getStandbyYAccelEnabled (MpuController.hpp)</li> <li>mpu_getStandbyYGyroEnabled (MpuController.hpp)</li> <li>mpu_getStandbyZAccelEnabled (MpuController.hpp)</li> <li>mpu_getStandbyZGyroEnabled (MpuController.hpp)</li> <li>mpu_getTempFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getTempSensorEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getTemperature (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getWaitForExternalSensorEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getWakeCycleEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getWakeFrequency (MpuController.hpp)</li> <li>mpu_getXAccelOffset (MpuController.hpp)</li> <li>mpu_getXGyroFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getXGyroOffset (MpuController.hpp)</li> <li>mpu_getXNegMotionDetected (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getXPosMotionDetected (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getYAccelOffset (MpuController.hpp)</li> <li>mpu_getYGyroFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getYGyroOffset (MpuController.hpp)</li> <li>mpu_getYNegMotionDetected (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getYPosMotionDetected (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getZAccelOffset (MpuController.hpp)</li> <li>mpu_getZGyroFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getZGyroOffset (MpuController.hpp)</li> <li>mpu_getZNegMotionDetected (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getZPosMotionDetected (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getZeroMotionDetected (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getZeroMotionDetectionDuration (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getZeroMotionDetectionThreshold (MpuController.hpp, MpuController.cpp)</li> <li>mpu_readMemoryBlock (MpuController.hpp)</li> <li>mpu_readMemoryByte (MpuController.hpp)</li> <li>mpu_reset (MpuController.hpp, MpuController.cpp)</li> <li>mpu_resetAccelerometerPath (MpuController.hpp, MpuController.cpp)</li> <li>mpu_resetDMP (MpuController.hpp)</li> <li>mpu_resetFIFO (MpuController.hpp, MpuController.cpp)</li> <li>mpu_resetGyroscopePath (MpuController.hpp, MpuController.cpp)</li> <li>mpu_resetI2CMaster (MpuController.hpp, MpuController.cpp)</li> <li>mpu_resetSensors (MpuController.hpp, MpuController.cpp)</li> <li>mpu_resetTemperaturePath (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setAccelFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setAccelXSelfTest (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setAccelYSelfTest (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setAccelZSelfTest (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setAccelerometerPowerOnDelay (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setAuxVDDIOLevel (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setClockOutputEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setClockSource (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setDHPFMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setDLPFMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setDMPConfig1 (MpuController.hpp)</li> <li>mpu_setDMPConfig2 (MpuController.hpp)</li> <li>mpu_setDMPEnabled (MpuController.hpp)</li> <li>mpu_setDeviceID (MpuController.hpp)</li> <li>mpu_setExternalFrameSync (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setExternalShadowDelayEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setFIFOByte (MpuController.hpp)</li> <li>mpu_setFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setFSyncInterruptEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setFSyncInterruptLevel (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setFreefallDetectionCounterDecrement (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setFreefallDetectionDuration (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setFreefallDetectionThreshold (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setFullScaleAccelRange (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setFullScaleGyroRange (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setI2CBypassEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setI2CMasterModeEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setIntDMPEnabled (MpuController.hpp)</li> <li>mpu_setIntDataReadyEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setIntEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setIntFIFOBufferOverflowEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setIntFreefallEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setIntI2CMasterEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setIntMotionEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setIntPLLReadyEnabled (MpuController.hpp)</li> <li>mpu_setIntZeroMotionEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setInterruptDrive (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setInterruptLatch (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setInterruptLatchClear (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setInterruptMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setMasterClockSpeed (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setMemoryBank (MpuController.hpp)</li> <li>mpu_setMemoryStartAddress (MpuController.hpp)</li> <li>mpu_setMotionDetectionCounterDecrement (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setMotionDetectionDuration (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setMotionDetectionThreshold (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setMultiMasterEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setOTPBankValid (MpuController.hpp)</li> <li>mpu_setRate (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave0FIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave1FIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave2FIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave3FIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave4Address (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave4Enabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave4InterruptEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave4MasterDelay (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave4OutputByte (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave4Register (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave4WriteMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveAddress (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveDataLength (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveDelayEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveOutputByte (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveReadWriteTransitionEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveRegister (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveWordByteSwap (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveWordGroupOffset (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveWriteMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSleepEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setStandbyXAccelEnabled (MpuController.hpp)</li> <li>mpu_setStandbyXGyroEnabled (MpuController.hpp)</li> <li>mpu_setStandbyYAccelEnabled (MpuController.hpp)</li> <li>mpu_setStandbyYGyroEnabled (MpuController.hpp)</li> <li>mpu_setStandbyZAccelEnabled (MpuController.hpp)</li> <li>mpu_setStandbyZGyroEnabled (MpuController.hpp)</li> <li>mpu_setTempFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setTempSensorEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setWaitForExternalSensorEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setWakeCycleEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setWakeFrequency (MpuController.hpp)</li> <li>mpu_setXAccelOffset (MpuController.hpp)</li> <li>mpu_setXFineGain (MpuController.hpp)</li> <li>mpu_setXGyroFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setXGyroOffset (MpuController.hpp)</li> <li>mpu_setXGyroOffsetTC (MpuController.hpp)</li> <li>mpu_setYAccelOffset (MpuController.hpp)</li> <li>mpu_setYFineGain (MpuController.hpp)</li> <li>mpu_setYGyroFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setYGyroOffset (MpuController.hpp)</li> <li>mpu_setYGyroOffsetTC (MpuController.hpp)</li> <li>mpu_setZAccelOffset (MpuController.hpp)</li> <li>mpu_setZFineGain (MpuController.hpp)</li> <li>mpu_setZGyroFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setZGyroOffset (MpuController.hpp)</li> <li>mpu_setZGyroOffsetTC (MpuController.hpp)</li> <li>mpu_setZeroMotionDetectionDuration (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setZeroMotionDetectionThreshold (MpuController.hpp, MpuController.cpp)</li> <li>mpu_switchSPIEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_testConnection (MpuController.hpp, MpuController.cpp)</li> <li>mpu_writeMemoryByte (MpuController.hpp)</li> <li>mpuRead (MpuController.cpp)</li> <li>mpuSend (MpuController.cpp)</li> <li>mpuTickCallback (MpuController.cpp)</li> <li>mpu_getExternalSensorDWord (MpuController.cpp)</li> <li>main (main.cpp)</li> </ul>"},{"location":"stm/functions/#o","title":"o","text":"<ul> <li>oledDispatch (OledController.hpp, OledController.cpp)</li> <li>oledDrawArc (OledController.hpp, OledController.cpp)</li> <li>oledDrawCircle (OledController.hpp, OledController.cpp)</li> <li>oledDrawLine (OledController.hpp, OledController.cpp)</li> <li>oledDrawPixel (OledController.hpp, OledController.cpp)</li> <li>oledDrawRectangle (OledController.hpp, OledController.cpp)</li> <li>oledFill (OledController.hpp, OledController.cpp)</li> <li>oledFillBuffer (OledController.hpp, OledController.cpp)</li> <li>oledGetDisplayOn (OledController.hpp, OledController.cpp)</li> <li>oledInit (OledController.hpp, OledController.cpp)</li> <li>oledInitOld (OledController.hpp)</li> <li>oledInitStm (OledController.hpp)</li> <li>oledPolyline (OledController.hpp, OledController.cpp)</li> <li>oledSetContrast (OledController.hpp, OledController.cpp)</li> <li>oledSetCursor (OledController.hpp, OledController.cpp)</li> <li>oledSetDisplayOn (OledController.hpp, OledController.cpp)</li> <li>oledTestConnection (OledController.hpp, OledController.cpp)</li> <li>oledUpdateScreen (OledController.hpp, OledController.cpp)</li> <li>oledWriteChar (OledController.hpp, OledController.cpp)</li> <li>oledWriteCommand (OledController.hpp, OledController.cpp)</li> <li>oledWriteData (OledController.hpp, OledController.cpp)</li> <li>oledWriteString (OledController.hpp, OledController.cpp)</li> <li>oledDegToRad (OledController.cpp)</li> <li>oledNormalizeTo0_360 (OledController.cpp)</li> </ul>"},{"location":"stm/functions/#p","title":"p","text":"<ul> <li>pinInit (Bsp.hpp)</li> <li>pinRead (Bsp.hpp)</li> <li>pinToggle (Bsp.hpp)</li> <li>pinWrite (Bsp.hpp)</li> <li>pinsInit (Bsp.hpp)</li> <li>powerBatteryMidMv (Power.hpp, Power.cpp)</li> <li>powerBatteryMv (Power.hpp, Power.cpp)</li> <li>powerCalibrate (Power.hpp, Power.cpp)</li> <li>powerInit (Power.hpp, Power.cpp)</li> <li>powerPoll (Power.hpp, Power.cpp)</li> <li>powerShutDown (Power.hpp, Power.cpp)</li> <li>powerTemperatureC (Power.hpp, Power.cpp)</li> <li>powerVrefMv (Power.hpp, Power.cpp)</li> <li>printTaskInfo (Debug.hpp)</li> <li>parser (ControlLink.cpp)</li> <li>processRxBuf (DebugLink.cpp)</li> </ul>"},{"location":"stm/functions/#r","title":"r","text":"<ul> <li>reinitEspStrappingPins (Bsp.hpp)</li> <li>rebootToDfu (Debug.hpp, Debug.cpp)</li> </ul>"},{"location":"stm/functions/#s","title":"s","text":"<ul> <li>setLeds (Bsp.hpp)</li> <li>softReset (Bsp.hpp, Bsp.cpp)</li> <li>softResetInit (Bsp.hpp, Bsp.cpp)</li> <li>stupidServoDispatch (StupidServoController.hpp, StupidServoController.cpp)</li> <li>stupidServoInit (StupidServoController.hpp, StupidServoController.cpp)</li> <li>stupidServoReset (StupidServoController.hpp, StupidServoController.cpp)</li> <li>setMotorPower (MotorController.cpp)</li> <li>setPwmValue (MotorController.cpp)</li> <li>stupidServoDisable (StupidServoController.cpp)</li> <li>stupidServoSetPosition (StupidServoController.cpp)</li> </ul>"},{"location":"stm/functions/#t","title":"t","text":"<ul> <li>tunnelOnSetLineCodingInIrq (CdcUartTunnel.hpp, CdcUartTunnel.cpp)</li> <li>tunnelPoll (CdcUartTunnel.hpp, CdcUartTunnel.cpp)</li> <li>tunnelUartInit (CdcUartTunnel.hpp, CdcUartTunnel.cpp)</li> <li>tunnelDownstreamHandler (CdcUartTunnel.cpp)</li> <li>tunnelUartRxPoll (CdcUartTunnel.cpp)</li> <li>tunnelUartTx (CdcUartTunnel.cpp)</li> <li>tunnelUartTxReady (CdcUartTunnel.cpp)</li> <li>tunnelUpstreamHandler (CdcUartTunnel.cpp)</li> <li>taskFunc (MotorController.cpp)</li> <li>tunnel_check_for_dfu_request (UsbCdcLink.cpp)</li> <li>testInt (main.cpp)</li> </ul>"},{"location":"stm/functions/#u","title":"u","text":"<ul> <li>ultrasoundDispatch (UltrasoundController.hpp, UltrasoundController.cpp)</li> <li>ultrasoundInit (UltrasoundController.hpp, UltrasoundController.cpp)</li> <li>ultrasoundOnEchoEdge (UltrasoundController.hpp, UltrasoundController.cpp)</li> <li>ultrasoundReset (UltrasoundController.hpp, UltrasoundController.cpp)</li> <li>USB_LP_IRQ_HANDLER (UsbCdcLink.cpp)</li> </ul>"},{"location":"stm/functions/#v","title":"v","text":"<ul> <li>vApplicationGetIdleTaskMemory (FreeRTOSCallbacks.cpp)</li> <li>vApplicationStackOverflowHook (FreeRTOSCallbacks.cpp)</li> <li>vApplicationTickHook (FreeRTOSCallbacks.cpp)</li> </ul>"},{"location":"stm/functions/#_","title":"_","text":"<ul> <li>_write (DebugLink.cpp)</li> <li>_exit (FreeRTOSCallbacks.cpp)</li> <li>__attribute__ (UsbCdcLink.cpp)</li> </ul>"},{"location":"stm/macros/","title":"Macros","text":""},{"location":"stm/macros/#a","title":"a","text":"<ul> <li>AFIO_MAPR_RESERVED (Bsp.hpp)</li> <li>AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER (Bsp.hpp)</li> </ul>"},{"location":"stm/macros/#c","title":"c","text":"<ul> <li>CONTROLUART_TX_DMA_HANDLER (Bsp.hpp)</li> <li>configASSERT (FreeRTOSConfig.h)</li> <li>configCHECK_FOR_STACK_OVERFLOW (FreeRTOSConfig.h)</li> <li>configCPU_CLOCK_HZ (FreeRTOSConfig.h)</li> <li>configGENERATE_RUN_TIME_STATS (FreeRTOSConfig.h)</li> <li>configIDLE_SHOULD_YIELD (FreeRTOSConfig.h)</li> <li>configKERNEL_INTERRUPT_PRIORITY (FreeRTOSConfig.h)</li> <li>configLIBRARY_LOWEST_INTERRUPT_PRIORITY (FreeRTOSConfig.h)</li> <li>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY (FreeRTOSConfig.h)</li> <li>configMAX_CO_ROUTINE_PRIORITIES (FreeRTOSConfig.h)</li> <li>configMAX_PRIORITIES (FreeRTOSConfig.h)</li> <li>configMAX_SYSCALL_INTERRUPT_PRIORITY (FreeRTOSConfig.h)</li> <li>configMAX_TASK_NAME_LEN (FreeRTOSConfig.h)</li> <li>configMINIMAL_STACK_SIZE (FreeRTOSConfig.h)</li> <li>configPRIO_BITS (FreeRTOSConfig.h)</li> <li>configQUEUE_REGISTRY_SIZE (FreeRTOSConfig.h)</li> <li>configRECORD_STACK_HIGH_ADDRESS (FreeRTOSConfig.h)</li> <li>configSUPPORT_DYNAMIC_ALLOCATION (FreeRTOSConfig.h)</li> <li>configSUPPORT_STATIC_ALLOCATION (FreeRTOSConfig.h)</li> <li>configTICK_RATE_HZ (FreeRTOSConfig.h)</li> <li>configTIMER_QUEUE_LENGTH (FreeRTOSConfig.h)</li> <li>configTIMER_TASK_PRIORITY (FreeRTOSConfig.h)</li> <li>configTIMER_TASK_STACK_DEPTH (FreeRTOSConfig.h)</li> <li>configTOTAL_HEAP_SIZE (FreeRTOSConfig.h)</li> <li>configUSE_16_BIT_TICKS (FreeRTOSConfig.h)</li> <li>configUSE_APPLICATION_TASK_TAG (FreeRTOSConfig.h)</li> <li>configUSE_COUNTING_SEMAPHORES (FreeRTOSConfig.h)</li> <li>configUSE_CO_ROUTINES (FreeRTOSConfig.h)</li> <li>configUSE_IDLE_HOOK (FreeRTOSConfig.h)</li> <li>configUSE_MALLOC_FAILED_HOOK (FreeRTOSConfig.h)</li> <li>configUSE_MUTEXES (FreeRTOSConfig.h)</li> <li>configUSE_PORT_OPTIMISED_TASK_SELECTION (FreeRTOSConfig.h)</li> <li>configUSE_PREEMPTION (FreeRTOSConfig.h)</li> <li>configUSE_RECURSIVE_MUTEXES (FreeRTOSConfig.h)</li> <li>configUSE_TICK_HOOK (FreeRTOSConfig.h)</li> <li>configUSE_TIMERS (FreeRTOSConfig.h)</li> <li>configUSE_TRACE_FACILITY (FreeRTOSConfig.h)</li> <li>CDC_DATA_SZ (UsbCdcLink.h)</li> <li>CDC_DEBUG_NTF_EP (UsbCdcLink.h)</li> <li>CDC_DEBUG_RXD_EP (UsbCdcLink.h)</li> <li>CDC_DEBUG_TXD_EP (UsbCdcLink.h)</li> <li>CDC_EP0_SIZE (UsbCdcLink.h)</li> <li>CDC_NTF_SZ (UsbCdcLink.h)</li> <li>CDC_TUNNEL_NTF_EP (UsbCdcLink.h)</li> <li>CDC_TUNNEL_RXD_EP (UsbCdcLink.h)</li> <li>CDC_TUNNEL_TXD_EP (UsbCdcLink.h)</li> <li>COMMAND (DebugLink.cpp)</li> <li>CIRCLE_APPROXIMATION_SEGMENTS (OledController.cpp)</li> </ul>"},{"location":"stm/macros/#d","title":"d","text":"<ul> <li>DEBUGUART_HANDLER (Bsp.hpp)</li> <li>DEBUGUART_TX_DMA_HANDLER (Bsp.hpp)</li> <li>DEBUG (Debug.hpp)</li> <li>DEBUGLN (Debug.hpp)</li> <li>DEBUG_DESCRIPTORS (UsbCdcLink.cpp)</li> </ul>"},{"location":"stm/macros/#i","title":"i","text":"<ul> <li>IN4AMASK (Bsp.hpp)</li> <li>IN4BMASK (Bsp.hpp)</li> <li>IN4PORT (Bsp.hpp)</li> <li>INCLUDE_eTaskGetState (FreeRTOSConfig.h)</li> <li>INCLUDE_uxTaskGetStackHighWaterMark (FreeRTOSConfig.h)</li> <li>INCLUDE_uxTaskPriorityGet (FreeRTOSConfig.h)</li> <li>INCLUDE_vTaskDelay (FreeRTOSConfig.h)</li> <li>INCLUDE_vTaskDelayUntil (FreeRTOSConfig.h)</li> <li>INCLUDE_vTaskDelete (FreeRTOSConfig.h)</li> <li>INCLUDE_vTaskPrioritySet (FreeRTOSConfig.h)</li> <li>INCLUDE_vTaskSuspend (FreeRTOSConfig.h)</li> <li>INCLUDE_xEventGroupSetBitFromISR (FreeRTOSConfig.h)</li> <li>INCLUDE_xResumeFromISR (FreeRTOSConfig.h)</li> <li>INCLUDE_xTaskAbortDelay (FreeRTOSConfig.h)</li> <li>INCLUDE_xTaskGetCurrentTaskHandle (FreeRTOSConfig.h)</li> <li>INCLUDE_xTaskGetHandle (FreeRTOSConfig.h)</li> <li>INCLUDE_xTaskGetIdleTaskHandle (FreeRTOSConfig.h)</li> <li>INCLUDE_xTaskGetSchedulerState (FreeRTOSConfig.h)</li> <li>INCLUDE_xTaskResumeFromISR (FreeRTOSConfig.h)</li> <li>INCLUDE_xTimerPendFunctionCall (FreeRTOSConfig.h)</li> <li>I2CDEV_DEFAULT_READ_TIMEOUT (I2cController.hpp)</li> </ul>"},{"location":"stm/macros/#m","title":"m","text":"<ul> <li>MPU6050_ACCEL_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_ACCEL_FS_16 (Mpu6050.hpp)</li> <li>MPU6050_ACCEL_FS_2 (Mpu6050.hpp)</li> <li>MPU6050_ACCEL_FS_4 (Mpu6050.hpp)</li> <li>MPU6050_ACCEL_FS_8 (Mpu6050.hpp)</li> <li>MPU6050_ACONFIG_ACCEL_HPF_BIT (Mpu6050.hpp)</li> <li>MPU6050_ACONFIG_ACCEL_HPF_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_ACONFIG_AFS_SEL_BIT (Mpu6050.hpp)</li> <li>MPU6050_ACONFIG_AFS_SEL_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_ACONFIG_XA_ST_BIT (Mpu6050.hpp)</li> <li>MPU6050_ACONFIG_YA_ST_BIT (Mpu6050.hpp)</li> <li>MPU6050_ACONFIG_ZA_ST_BIT (Mpu6050.hpp)</li> <li>MPU6050_ADDRESS_AD0_HIGH (Mpu6050.hpp)</li> <li>MPU6050_ADDRESS_AD0_LOW (Mpu6050.hpp)</li> <li>MPU6050_BANKSEL_CFG_USER_BANK_BIT (Mpu6050.hpp)</li> <li>MPU6050_BANKSEL_MEM_SEL_BIT (Mpu6050.hpp)</li> <li>MPU6050_BANKSEL_MEM_SEL_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_BANKSEL_PRFTCH_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_CFG_DLPF_CFG_BIT (Mpu6050.hpp)</li> <li>MPU6050_CFG_DLPF_CFG_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_CFG_EXT_SYNC_SET_BIT (Mpu6050.hpp)</li> <li>MPU6050_CFG_EXT_SYNC_SET_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_258 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_267 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_276 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_286 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_296 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_308 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_320 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_333 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_348 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_364 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_381 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_400 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_421 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_444 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_471 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_500 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_INTERNAL (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_KEEP_RESET (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_PLL_EXT19M (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_PLL_EXT32K (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_PLL_XGYRO (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_PLL_YGYRO (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_PLL_ZGYRO (Mpu6050.hpp)</li> <li>MPU6050_DEFAULT_ADDRESS (Mpu6050.hpp)</li> <li>MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT (Mpu6050.hpp)</li> <li>MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_DELAYCTRL_I2C_SLV1_DLY_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_DELAYCTRL_I2C_SLV2_DLY_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_DELAYCTRL_I2C_SLV3_DLY_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_DELAYCTRL_I2C_SLV4_DLY_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_DETECT_ACCEL_ON_DELAY_BIT (Mpu6050.hpp)</li> <li>MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_DETECT_DECREMENT_1 (Mpu6050.hpp)</li> <li>MPU6050_DETECT_DECREMENT_2 (Mpu6050.hpp)</li> <li>MPU6050_DETECT_DECREMENT_4 (Mpu6050.hpp)</li> <li>MPU6050_DETECT_DECREMENT_RESET (Mpu6050.hpp)</li> <li>MPU6050_DETECT_FF_COUNT_BIT (Mpu6050.hpp)</li> <li>MPU6050_DETECT_FF_COUNT_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_DETECT_MOT_COUNT_BIT (Mpu6050.hpp)</li> <li>MPU6050_DETECT_MOT_COUNT_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_DHPF_0P63 (Mpu6050.hpp)</li> <li>MPU6050_DHPF_1P25 (Mpu6050.hpp)</li> <li>MPU6050_DHPF_2P5 (Mpu6050.hpp)</li> <li>MPU6050_DHPF_5 (Mpu6050.hpp)</li> <li>MPU6050_DHPF_HOLD (Mpu6050.hpp)</li> <li>MPU6050_DHPF_RESET (Mpu6050.hpp)</li> <li>MPU6050_DLPF_BW_10 (Mpu6050.hpp)</li> <li>MPU6050_DLPF_BW_188 (Mpu6050.hpp)</li> <li>MPU6050_DLPF_BW_20 (Mpu6050.hpp)</li> <li>MPU6050_DLPF_BW_256 (Mpu6050.hpp)</li> <li>MPU6050_DLPF_BW_42 (Mpu6050.hpp)</li> <li>MPU6050_DLPF_BW_5 (Mpu6050.hpp)</li> <li>MPU6050_DLPF_BW_98 (Mpu6050.hpp)</li> <li>MPU6050_DMPINT_0_BIT (Mpu6050.hpp)</li> <li>MPU6050_DMPINT_1_BIT (Mpu6050.hpp)</li> <li>MPU6050_DMPINT_2_BIT (Mpu6050.hpp)</li> <li>MPU6050_DMPINT_3_BIT (Mpu6050.hpp)</li> <li>MPU6050_DMPINT_4_BIT (Mpu6050.hpp)</li> <li>MPU6050_DMPINT_5_BIT (Mpu6050.hpp)</li> <li>MPU6050_DMP_MEMORY_BANKS (Mpu6050.hpp)</li> <li>MPU6050_DMP_MEMORY_BANK_SIZE (Mpu6050.hpp)</li> <li>MPU6050_DMP_MEMORY_CHUNK_SIZE (Mpu6050.hpp)</li> <li>MPU6050_EXT_SYNC_ACCEL_XOUT_L (Mpu6050.hpp)</li> <li>MPU6050_EXT_SYNC_ACCEL_YOUT_L (Mpu6050.hpp)</li> <li>MPU6050_EXT_SYNC_ACCEL_ZOUT_L (Mpu6050.hpp)</li> <li>MPU6050_EXT_SYNC_DISABLED (Mpu6050.hpp)</li> <li>MPU6050_EXT_SYNC_GYRO_XOUT_L (Mpu6050.hpp)</li> <li>MPU6050_EXT_SYNC_GYRO_YOUT_L (Mpu6050.hpp)</li> <li>MPU6050_EXT_SYNC_GYRO_ZOUT_L (Mpu6050.hpp)</li> <li>MPU6050_EXT_SYNC_TEMP_OUT_L (Mpu6050.hpp)</li> <li>MPU6050_GCONFIG_FS_SEL_BIT (Mpu6050.hpp)</li> <li>MPU6050_GCONFIG_FS_SEL_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_GYRO_FS_1000 (Mpu6050.hpp)</li> <li>MPU6050_GYRO_FS_2000 (Mpu6050.hpp)</li> <li>MPU6050_GYRO_FS_250 (Mpu6050.hpp)</li> <li>MPU6050_GYRO_FS_500 (Mpu6050.hpp)</li> <li>MPU6050_I2C_MST_CLK_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_MST_CLK_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_I2C_MST_P_NSR_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV4_ADDR_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV4_ADDR_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV4_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV4_INT_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV4_MST_DLY_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV4_MST_DLY_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV4_REG_DIS_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV4_RW_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_ADDR_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_ADDR_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_BYTE_SW_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_GRP_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_LEN_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_LEN_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_REG_DIS_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_RW_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCFG_CLKOUT_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCFG_FSYNC_INT_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCFG_I2C_BYPASS_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCFG_INT_LEVEL_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCFG_INT_OPEN_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCFG_INT_RD_CLEAR_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCFG_LATCH_INT_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCLEAR_ANYREAD (Mpu6050.hpp)</li> <li>MPU6050_INTCLEAR_STATUSREAD (Mpu6050.hpp)</li> <li>MPU6050_INTDRV_OPENDRAIN (Mpu6050.hpp)</li> <li>MPU6050_INTDRV_PUSHPULL (Mpu6050.hpp)</li> <li>MPU6050_INTERRUPT_DATA_RDY_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTERRUPT_DMP_INT_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTERRUPT_FF_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTERRUPT_FIFO_OFLOW_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTERRUPT_I2C_MST_INT_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTERRUPT_MOT_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTERRUPT_PLL_RDY_INT_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTERRUPT_ZMOT_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTLATCH_50USPULSE (Mpu6050.hpp)</li> <li>MPU6050_INTLATCH_WAITCLEAR (Mpu6050.hpp)</li> <li>MPU6050_INTMODE_ACTIVEHIGH (Mpu6050.hpp)</li> <li>MPU6050_INTMODE_ACTIVELOW (Mpu6050.hpp)</li> <li>MPU6050_MOTION_MOT_XNEG_BIT (Mpu6050.hpp)</li> <li>MPU6050_MOTION_MOT_XPOS_BIT (Mpu6050.hpp)</li> <li>MPU6050_MOTION_MOT_YNEG_BIT (Mpu6050.hpp)</li> <li>MPU6050_MOTION_MOT_YPOS_BIT (Mpu6050.hpp)</li> <li>MPU6050_MOTION_MOT_ZNEG_BIT (Mpu6050.hpp)</li> <li>MPU6050_MOTION_MOT_ZPOS_BIT (Mpu6050.hpp)</li> <li>MPU6050_MOTION_MOT_ZRMOT_BIT (Mpu6050.hpp)</li> <li>MPU6050_MST_I2C_LOST_ARB_BIT (Mpu6050.hpp)</li> <li>MPU6050_MST_I2C_SLV0_NACK_BIT (Mpu6050.hpp)</li> <li>MPU6050_MST_I2C_SLV1_NACK_BIT (Mpu6050.hpp)</li> <li>MPU6050_MST_I2C_SLV2_NACK_BIT (Mpu6050.hpp)</li> <li>MPU6050_MST_I2C_SLV3_NACK_BIT (Mpu6050.hpp)</li> <li>MPU6050_MST_I2C_SLV4_DONE_BIT (Mpu6050.hpp)</li> <li>MPU6050_MST_I2C_SLV4_NACK_BIT (Mpu6050.hpp)</li> <li>MPU6050_MST_PASS_THROUGH_BIT (Mpu6050.hpp)</li> <li>MPU6050_MULT_MST_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_PATHRESET_ACCEL_RESET_BIT (Mpu6050.hpp)</li> <li>MPU6050_PATHRESET_GYRO_RESET_BIT (Mpu6050.hpp)</li> <li>MPU6050_PATHRESET_TEMP_RESET_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR1_CLKSEL_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR1_CLKSEL_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_PWR1_CYCLE_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR1_DEVICE_RESET_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR1_SLEEP_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR1_TEMP_DIS_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR2_LP_WAKE_CTRL_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR2_LP_WAKE_CTRL_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_PWR2_STBY_XA_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR2_STBY_XG_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR2_STBY_YA_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR2_STBY_YG_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR2_STBY_ZA_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR2_STBY_ZG_BIT (Mpu6050.hpp)</li> <li>MPU6050_RA_ACCEL_CONFIG (Mpu6050.hpp)</li> <li>MPU6050_RA_ACCEL_XOUT_H (Mpu6050.hpp)</li> <li>MPU6050_RA_ACCEL_XOUT_L (Mpu6050.hpp)</li> <li>MPU6050_RA_ACCEL_YOUT_H (Mpu6050.hpp)</li> <li>MPU6050_RA_ACCEL_YOUT_L (Mpu6050.hpp)</li> <li>MPU6050_RA_ACCEL_ZOUT_H (Mpu6050.hpp)</li> <li>MPU6050_RA_ACCEL_ZOUT_L (Mpu6050.hpp)</li> <li>MPU6050_RA_BANK_SEL (Mpu6050.hpp)</li> <li>MPU6050_RA_CONFIG (Mpu6050.hpp)</li> <li>MPU6050_RA_DMP_CFG_1 (Mpu6050.hpp)</li> <li>MPU6050_RA_DMP_CFG_2 (Mpu6050.hpp)</li> <li>MPU6050_RA_DMP_INT_STATUS (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_00 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_01 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_02 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_03 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_04 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_05 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_06 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_07 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_08 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_09 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_10 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_11 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_12 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_13 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_14 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_15 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_16 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_17 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_18 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_19 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_20 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_21 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_22 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_23 (Mpu6050.hpp)</li> <li>MPU6050_RA_FF_DUR (Mpu6050.hpp)</li> <li>MPU6050_RA_FF_THR (Mpu6050.hpp)</li> <li>MPU6050_RA_FIFO_COUNTH (Mpu6050.hpp)</li> <li>MPU6050_RA_FIFO_COUNTL (Mpu6050.hpp)</li> <li>MPU6050_RA_FIFO_EN (Mpu6050.hpp)</li> <li>MPU6050_RA_FIFO_R_W (Mpu6050.hpp)</li> <li>MPU6050_RA_GYRO_CONFIG (Mpu6050.hpp)</li> <li>MPU6050_RA_GYRO_XOUT_H (Mpu6050.hpp)</li> <li>MPU6050_RA_GYRO_XOUT_L (Mpu6050.hpp)</li> <li>MPU6050_RA_GYRO_YOUT_H (Mpu6050.hpp)</li> <li>MPU6050_RA_GYRO_YOUT_L (Mpu6050.hpp)</li> <li>MPU6050_RA_GYRO_ZOUT_H (Mpu6050.hpp)</li> <li>MPU6050_RA_GYRO_ZOUT_L (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_MST_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_MST_DELAY_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_MST_STATUS (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV0_ADDR (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV0_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV0_DO (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV0_REG (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV1_ADDR (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV1_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV1_DO (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV1_REG (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV2_ADDR (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV2_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV2_DO (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV2_REG (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV3_ADDR (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV3_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV3_DO (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV3_REG (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV4_ADDR (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV4_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV4_DI (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV4_DO (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV4_REG (Mpu6050.hpp)</li> <li>MPU6050_RA_INT_ENABLE (Mpu6050.hpp)</li> <li>MPU6050_RA_INT_PIN_CFG (Mpu6050.hpp)</li> <li>MPU6050_RA_INT_STATUS (Mpu6050.hpp)</li> <li>MPU6050_RA_MEM_R_W (Mpu6050.hpp)</li> <li>MPU6050_RA_MEM_START_ADDR (Mpu6050.hpp)</li> <li>MPU6050_RA_MOT_DETECT_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_MOT_DETECT_STATUS (Mpu6050.hpp)</li> <li>MPU6050_RA_MOT_DUR (Mpu6050.hpp)</li> <li>MPU6050_RA_MOT_THR (Mpu6050.hpp)</li> <li>MPU6050_RA_PWR_MGMT_1 (Mpu6050.hpp)</li> <li>MPU6050_RA_PWR_MGMT_2 (Mpu6050.hpp)</li> <li>MPU6050_RA_SIGNAL_PATH_RESET (Mpu6050.hpp)</li> <li>MPU6050_RA_SMPLRT_DIV (Mpu6050.hpp)</li> <li>MPU6050_RA_TEMP_OUT_H (Mpu6050.hpp)</li> <li>MPU6050_RA_TEMP_OUT_L (Mpu6050.hpp)</li> <li>MPU6050_RA_USER_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_WHO_AM_I (Mpu6050.hpp)</li> <li>MPU6050_RA_XA_OFFS_H (Mpu6050.hpp)</li> <li>MPU6050_RA_XA_OFFS_L_TC (Mpu6050.hpp)</li> <li>MPU6050_RA_XG_OFFS_TC (Mpu6050.hpp)</li> <li>MPU6050_RA_XG_OFFS_USRH (Mpu6050.hpp)</li> <li>MPU6050_RA_XG_OFFS_USRL (Mpu6050.hpp)</li> <li>MPU6050_RA_X_FINE_GAIN (Mpu6050.hpp)</li> <li>MPU6050_RA_YA_OFFS_H (Mpu6050.hpp)</li> <li>MPU6050_RA_YA_OFFS_L_TC (Mpu6050.hpp)</li> <li>MPU6050_RA_YG_OFFS_TC (Mpu6050.hpp)</li> <li>MPU6050_RA_YG_OFFS_USRH (Mpu6050.hpp)</li> <li>MPU6050_RA_YG_OFFS_USRL (Mpu6050.hpp)</li> <li>MPU6050_RA_Y_FINE_GAIN (Mpu6050.hpp)</li> <li>MPU6050_RA_ZA_OFFS_H (Mpu6050.hpp)</li> <li>MPU6050_RA_ZA_OFFS_L_TC (Mpu6050.hpp)</li> <li>MPU6050_RA_ZG_OFFS_TC (Mpu6050.hpp)</li> <li>MPU6050_RA_ZG_OFFS_USRH (Mpu6050.hpp)</li> <li>MPU6050_RA_ZG_OFFS_USRL (Mpu6050.hpp)</li> <li>MPU6050_RA_ZRMOT_DUR (Mpu6050.hpp)</li> <li>MPU6050_RA_ZRMOT_THR (Mpu6050.hpp)</li> <li>MPU6050_RA_Z_FINE_GAIN (Mpu6050.hpp)</li> <li>MPU6050_SLV0_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_SLV1_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_SLV2_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_SLV_3_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_TC_OFFSET_BIT (Mpu6050.hpp)</li> <li>MPU6050_TC_OFFSET_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_TC_OTP_BNK_VLD_BIT (Mpu6050.hpp)</li> <li>MPU6050_TC_PWR_MODE_BIT (Mpu6050.hpp)</li> <li>MPU6050_TEMP_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_USERCTRL_DMP_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_USERCTRL_DMP_RESET_BIT (Mpu6050.hpp)</li> <li>MPU6050_USERCTRL_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_USERCTRL_FIFO_RESET_BIT (Mpu6050.hpp)</li> <li>MPU6050_USERCTRL_I2C_IF_DIS_BIT (Mpu6050.hpp)</li> <li>MPU6050_USERCTRL_I2C_MST_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_USERCTRL_I2C_MST_RESET_BIT (Mpu6050.hpp)</li> <li>MPU6050_USERCTRL_SIG_COND_RESET_BIT (Mpu6050.hpp)</li> <li>MPU6050_VDDIO_LEVEL_VDD (Mpu6050.hpp)</li> <li>MPU6050_VDDIO_LEVEL_VLOGIC (Mpu6050.hpp)</li> <li>MPU6050_WAIT_FOR_ES_BIT (Mpu6050.hpp)</li> <li>MPU6050_WAKE_FREQ_10 (Mpu6050.hpp)</li> <li>MPU6050_WAKE_FREQ_1P25 (Mpu6050.hpp)</li> <li>MPU6050_WAKE_FREQ_2P5 (Mpu6050.hpp)</li> <li>MPU6050_WAKE_FREQ_5 (Mpu6050.hpp)</li> <li>MPU6050_WHO_AM_I_BIT (Mpu6050.hpp)</li> <li>MPU6050_WHO_AM_I_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_XG_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_YG_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_ZG_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>mpu_ACCEL_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_ACCEL_FS_16 (MpuController.hpp)</li> <li>mpu_ACCEL_FS_2 (MpuController.hpp)</li> <li>mpu_ACCEL_FS_4 (MpuController.hpp)</li> <li>mpu_ACCEL_FS_8 (MpuController.hpp)</li> <li>mpu_ACONFIG_ACCEL_HPF_BIT (MpuController.hpp)</li> <li>mpu_ACONFIG_ACCEL_HPF_LENGTH (MpuController.hpp)</li> <li>mpu_ACONFIG_AFS_SEL_BIT (MpuController.hpp)</li> <li>mpu_ACONFIG_AFS_SEL_LENGTH (MpuController.hpp)</li> <li>mpu_ACONFIG_XA_ST_BIT (MpuController.hpp)</li> <li>mpu_ACONFIG_YA_ST_BIT (MpuController.hpp)</li> <li>mpu_ACONFIG_ZA_ST_BIT (MpuController.hpp)</li> <li>mpu_ADDRESS_AD0_HIGH (MpuController.hpp)</li> <li>mpu_ADDRESS_AD0_LOW (MpuController.hpp)</li> <li>mpu_BANKSEL_CFG_USER_BANK_BIT (MpuController.hpp)</li> <li>mpu_BANKSEL_MEM_SEL_BIT (MpuController.hpp)</li> <li>mpu_BANKSEL_MEM_SEL_LENGTH (MpuController.hpp)</li> <li>mpu_BANKSEL_PRFTCH_EN_BIT (MpuController.hpp)</li> <li>mpu_CFG_DLPF_CFG_BIT (MpuController.hpp)</li> <li>mpu_CFG_DLPF_CFG_LENGTH (MpuController.hpp)</li> <li>mpu_CFG_EXT_SYNC_SET_BIT (MpuController.hpp)</li> <li>mpu_CFG_EXT_SYNC_SET_LENGTH (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_258 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_267 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_276 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_286 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_296 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_308 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_320 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_333 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_348 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_364 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_381 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_400 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_421 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_444 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_471 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_500 (MpuController.hpp)</li> <li>mpu_CLOCK_INTERNAL (MpuController.hpp)</li> <li>mpu_CLOCK_KEEP_RESET (MpuController.hpp)</li> <li>mpu_CLOCK_PLL_EXT19M (MpuController.hpp)</li> <li>mpu_CLOCK_PLL_EXT32K (MpuController.hpp)</li> <li>mpu_CLOCK_PLL_XGYRO (MpuController.hpp)</li> <li>mpu_CLOCK_PLL_YGYRO (MpuController.hpp)</li> <li>mpu_CLOCK_PLL_ZGYRO (MpuController.hpp)</li> <li>mpu_DEFAULT_ADDRESS (MpuController.hpp)</li> <li>mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT (MpuController.hpp)</li> <li>mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT (MpuController.hpp)</li> <li>mpu_DELAYCTRL_I2C_SLV1_DLY_EN_BIT (MpuController.hpp)</li> <li>mpu_DELAYCTRL_I2C_SLV2_DLY_EN_BIT (MpuController.hpp)</li> <li>mpu_DELAYCTRL_I2C_SLV3_DLY_EN_BIT (MpuController.hpp)</li> <li>mpu_DELAYCTRL_I2C_SLV4_DLY_EN_BIT (MpuController.hpp)</li> <li>mpu_DETECT_ACCEL_ON_DELAY_BIT (MpuController.hpp)</li> <li>mpu_DETECT_ACCEL_ON_DELAY_LENGTH (MpuController.hpp)</li> <li>mpu_DETECT_DECREMENT_1 (MpuController.hpp)</li> <li>mpu_DETECT_DECREMENT_2 (MpuController.hpp)</li> <li>mpu_DETECT_DECREMENT_4 (MpuController.hpp)</li> <li>mpu_DETECT_DECREMENT_RESET (MpuController.hpp)</li> <li>mpu_DETECT_FF_COUNT_BIT (MpuController.hpp)</li> <li>mpu_DETECT_FF_COUNT_LENGTH (MpuController.hpp)</li> <li>mpu_DETECT_MOT_COUNT_BIT (MpuController.hpp)</li> <li>mpu_DETECT_MOT_COUNT_LENGTH (MpuController.hpp)</li> <li>mpu_DHPF_0P63 (MpuController.hpp)</li> <li>mpu_DHPF_1P25 (MpuController.hpp)</li> <li>mpu_DHPF_2P5 (MpuController.hpp)</li> <li>mpu_DHPF_5 (MpuController.hpp)</li> <li>mpu_DHPF_HOLD (MpuController.hpp)</li> <li>mpu_DHPF_RESET (MpuController.hpp)</li> <li>mpu_DLPF_BW_10 (MpuController.hpp)</li> <li>mpu_DLPF_BW_188 (MpuController.hpp)</li> <li>mpu_DLPF_BW_20 (MpuController.hpp)</li> <li>mpu_DLPF_BW_256 (MpuController.hpp)</li> <li>mpu_DLPF_BW_42 (MpuController.hpp)</li> <li>mpu_DLPF_BW_5 (MpuController.hpp)</li> <li>mpu_DLPF_BW_98 (MpuController.hpp)</li> <li>mpu_DMPINT_0_BIT (MpuController.hpp)</li> <li>mpu_DMPINT_1_BIT (MpuController.hpp)</li> <li>mpu_DMPINT_2_BIT (MpuController.hpp)</li> <li>mpu_DMPINT_3_BIT (MpuController.hpp)</li> <li>mpu_DMPINT_4_BIT (MpuController.hpp)</li> <li>mpu_DMPINT_5_BIT (MpuController.hpp)</li> <li>mpu_DMP_MEMORY_BANKS (MpuController.hpp)</li> <li>mpu_DMP_MEMORY_BANK_SIZE (MpuController.hpp)</li> <li>mpu_DMP_MEMORY_CHUNK_SIZE (MpuController.hpp)</li> <li>mpu_EXT_SYNC_ACCEL_XOUT_L (MpuController.hpp)</li> <li>mpu_EXT_SYNC_ACCEL_YOUT_L (MpuController.hpp)</li> <li>mpu_EXT_SYNC_ACCEL_ZOUT_L (MpuController.hpp)</li> <li>mpu_EXT_SYNC_DISABLED (MpuController.hpp)</li> <li>mpu_EXT_SYNC_GYRO_XOUT_L (MpuController.hpp)</li> <li>mpu_EXT_SYNC_GYRO_YOUT_L (MpuController.hpp)</li> <li>mpu_EXT_SYNC_GYRO_ZOUT_L (MpuController.hpp)</li> <li>mpu_EXT_SYNC_TEMP_OUT_L (MpuController.hpp)</li> <li>mpu_GCONFIG_FS_SEL_BIT (MpuController.hpp)</li> <li>mpu_GCONFIG_FS_SEL_LENGTH (MpuController.hpp)</li> <li>mpu_GYRO_FS_1000 (MpuController.hpp)</li> <li>mpu_GYRO_FS_2000 (MpuController.hpp)</li> <li>mpu_GYRO_FS_250 (MpuController.hpp)</li> <li>mpu_GYRO_FS_500 (MpuController.hpp)</li> <li>mpu_I2C_MST_CLK_BIT (MpuController.hpp)</li> <li>mpu_I2C_MST_CLK_LENGTH (MpuController.hpp)</li> <li>mpu_I2C_MST_P_NSR_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV4_ADDR_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV4_ADDR_LENGTH (MpuController.hpp)</li> <li>mpu_I2C_SLV4_EN_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV4_INT_EN_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV4_MST_DLY_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV4_MST_DLY_LENGTH (MpuController.hpp)</li> <li>mpu_I2C_SLV4_REG_DIS_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV4_RW_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV_ADDR_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV_ADDR_LENGTH (MpuController.hpp)</li> <li>mpu_I2C_SLV_BYTE_SW_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV_EN_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV_GRP_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV_LEN_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV_LEN_LENGTH (MpuController.hpp)</li> <li>mpu_I2C_SLV_REG_DIS_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV_RW_BIT (MpuController.hpp)</li> <li>mpu_INTCFG_CLKOUT_EN_BIT (MpuController.hpp)</li> <li>mpu_INTCFG_FSYNC_INT_EN_BIT (MpuController.hpp)</li> <li>mpu_INTCFG_FSYNC_INT_LEVEL_BIT (MpuController.hpp)</li> <li>mpu_INTCFG_I2C_BYPASS_EN_BIT (MpuController.hpp)</li> <li>mpu_INTCFG_INT_LEVEL_BIT (MpuController.hpp)</li> <li>mpu_INTCFG_INT_OPEN_BIT (MpuController.hpp)</li> <li>mpu_INTCFG_INT_RD_CLEAR_BIT (MpuController.hpp)</li> <li>mpu_INTCFG_LATCH_INT_EN_BIT (MpuController.hpp)</li> <li>mpu_INTCLEAR_ANYREAD (MpuController.hpp)</li> <li>mpu_INTCLEAR_STATUSREAD (MpuController.hpp)</li> <li>mpu_INTDRV_OPENDRAIN (MpuController.hpp)</li> <li>mpu_INTDRV_PUSHPULL (MpuController.hpp)</li> <li>mpu_INTERRUPT_DATA_RDY_BIT (MpuController.hpp)</li> <li>mpu_INTERRUPT_DMP_INT_BIT (MpuController.hpp)</li> <li>mpu_INTERRUPT_FF_BIT (MpuController.hpp)</li> <li>mpu_INTERRUPT_FIFO_OFLOW_BIT (MpuController.hpp)</li> <li>mpu_INTERRUPT_I2C_MST_INT_BIT (MpuController.hpp)</li> <li>mpu_INTERRUPT_MOT_BIT (MpuController.hpp)</li> <li>mpu_INTERRUPT_PLL_RDY_INT_BIT (MpuController.hpp)</li> <li>mpu_INTERRUPT_ZMOT_BIT (MpuController.hpp)</li> <li>mpu_INTLATCH_50USPULSE (MpuController.hpp)</li> <li>mpu_INTLATCH_WAITCLEAR (MpuController.hpp)</li> <li>mpu_INTMODE_ACTIVEHIGH (MpuController.hpp)</li> <li>mpu_INTMODE_ACTIVELOW (MpuController.hpp)</li> <li>mpu_MOTION_MOT_XNEG_BIT (MpuController.hpp)</li> <li>mpu_MOTION_MOT_XPOS_BIT (MpuController.hpp)</li> <li>mpu_MOTION_MOT_YNEG_BIT (MpuController.hpp)</li> <li>mpu_MOTION_MOT_YPOS_BIT (MpuController.hpp)</li> <li>mpu_MOTION_MOT_ZNEG_BIT (MpuController.hpp)</li> <li>mpu_MOTION_MOT_ZPOS_BIT (MpuController.hpp)</li> <li>mpu_MOTION_MOT_ZRMOT_BIT (MpuController.hpp)</li> <li>mpu_MST_I2C_LOST_ARB_BIT (MpuController.hpp)</li> <li>mpu_MST_I2C_SLV0_NACK_BIT (MpuController.hpp)</li> <li>mpu_MST_I2C_SLV1_NACK_BIT (MpuController.hpp)</li> <li>mpu_MST_I2C_SLV2_NACK_BIT (MpuController.hpp)</li> <li>mpu_MST_I2C_SLV3_NACK_BIT (MpuController.hpp)</li> <li>mpu_MST_I2C_SLV4_DONE_BIT (MpuController.hpp)</li> <li>mpu_MST_I2C_SLV4_NACK_BIT (MpuController.hpp)</li> <li>mpu_MST_PASS_THROUGH_BIT (MpuController.hpp)</li> <li>mpu_MULT_MST_EN_BIT (MpuController.hpp)</li> <li>mpu_PATHRESET_ACCEL_RESET_BIT (MpuController.hpp)</li> <li>mpu_PATHRESET_GYRO_RESET_BIT (MpuController.hpp)</li> <li>mpu_PATHRESET_TEMP_RESET_BIT (MpuController.hpp)</li> <li>mpu_PWR1_CLKSEL_BIT (MpuController.hpp)</li> <li>mpu_PWR1_CLKSEL_LENGTH (MpuController.hpp)</li> <li>mpu_PWR1_CYCLE_BIT (MpuController.hpp)</li> <li>mpu_PWR1_DEVICE_RESET_BIT (MpuController.hpp)</li> <li>mpu_PWR1_SLEEP_BIT (MpuController.hpp)</li> <li>mpu_PWR1_TEMP_DIS_BIT (MpuController.hpp)</li> <li>mpu_PWR2_LP_WAKE_CTRL_BIT (MpuController.hpp)</li> <li>mpu_PWR2_LP_WAKE_CTRL_LENGTH (MpuController.hpp)</li> <li>mpu_PWR2_STBY_XA_BIT (MpuController.hpp)</li> <li>mpu_PWR2_STBY_XG_BIT (MpuController.hpp)</li> <li>mpu_PWR2_STBY_YA_BIT (MpuController.hpp)</li> <li>mpu_PWR2_STBY_YG_BIT (MpuController.hpp)</li> <li>mpu_PWR2_STBY_ZA_BIT (MpuController.hpp)</li> <li>mpu_PWR2_STBY_ZG_BIT (MpuController.hpp)</li> <li>mpu_RA_ACCEL_CONFIG (MpuController.hpp)</li> <li>mpu_RA_ACCEL_XOUT_H (MpuController.hpp)</li> <li>mpu_RA_ACCEL_XOUT_L (MpuController.hpp)</li> <li>mpu_RA_ACCEL_YOUT_H (MpuController.hpp)</li> <li>mpu_RA_ACCEL_YOUT_L (MpuController.hpp)</li> <li>mpu_RA_ACCEL_ZOUT_H (MpuController.hpp)</li> <li>mpu_RA_ACCEL_ZOUT_L (MpuController.hpp)</li> <li>mpu_RA_BANK_SEL (MpuController.hpp)</li> <li>mpu_RA_CONFIG (MpuController.hpp)</li> <li>mpu_RA_DMP_CFG_1 (MpuController.hpp)</li> <li>mpu_RA_DMP_CFG_2 (MpuController.hpp)</li> <li>mpu_RA_DMP_INT_STATUS (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_00 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_01 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_02 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_03 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_04 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_05 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_06 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_07 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_08 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_09 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_10 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_11 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_12 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_13 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_14 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_15 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_16 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_17 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_18 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_19 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_20 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_21 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_22 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_23 (MpuController.hpp)</li> <li>mpu_RA_FF_DUR (MpuController.hpp)</li> <li>mpu_RA_FF_THR (MpuController.hpp)</li> <li>mpu_RA_FIFO_COUNTH (MpuController.hpp)</li> <li>mpu_RA_FIFO_COUNTL (MpuController.hpp)</li> <li>mpu_RA_FIFO_EN (MpuController.hpp)</li> <li>mpu_RA_FIFO_R_W (MpuController.hpp)</li> <li>mpu_RA_GYRO_CONFIG (MpuController.hpp)</li> <li>mpu_RA_GYRO_XOUT_H (MpuController.hpp)</li> <li>mpu_RA_GYRO_XOUT_L (MpuController.hpp)</li> <li>mpu_RA_GYRO_YOUT_H (MpuController.hpp)</li> <li>mpu_RA_GYRO_YOUT_L (MpuController.hpp)</li> <li>mpu_RA_GYRO_ZOUT_H (MpuController.hpp)</li> <li>mpu_RA_GYRO_ZOUT_L (MpuController.hpp)</li> <li>mpu_RA_I2C_MST_CTRL (MpuController.hpp)</li> <li>mpu_RA_I2C_MST_DELAY_CTRL (MpuController.hpp)</li> <li>mpu_RA_I2C_MST_STATUS (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV0_ADDR (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV0_CTRL (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV0_DO (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV0_REG (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV1_ADDR (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV1_CTRL (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV1_DO (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV1_REG (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV2_ADDR (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV2_CTRL (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV2_DO (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV2_REG (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV3_ADDR (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV3_CTRL (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV3_DO (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV3_REG (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV4_ADDR (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV4_CTRL (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV4_DI (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV4_DO (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV4_REG (MpuController.hpp)</li> <li>mpu_RA_INT_ENABLE (MpuController.hpp)</li> <li>mpu_RA_INT_PIN_CFG (MpuController.hpp)</li> <li>mpu_RA_INT_STATUS (MpuController.hpp)</li> <li>mpu_RA_MEM_R_W (MpuController.hpp)</li> <li>mpu_RA_MEM_START_ADDR (MpuController.hpp)</li> <li>mpu_RA_MOT_DETECT_CTRL (MpuController.hpp)</li> <li>mpu_RA_MOT_DETECT_STATUS (MpuController.hpp)</li> <li>mpu_RA_MOT_DUR (MpuController.hpp)</li> <li>mpu_RA_MOT_THR (MpuController.hpp)</li> <li>mpu_RA_PWR_MGMT_1 (MpuController.hpp)</li> <li>mpu_RA_PWR_MGMT_2 (MpuController.hpp)</li> <li>mpu_RA_SIGNAL_PATH_RESET (MpuController.hpp)</li> <li>mpu_RA_SMPLRT_DIV (MpuController.hpp)</li> <li>mpu_RA_TEMP_OUT_H (MpuController.hpp)</li> <li>mpu_RA_TEMP_OUT_L (MpuController.hpp)</li> <li>mpu_RA_USER_CTRL (MpuController.hpp)</li> <li>mpu_RA_WHO_AM_I (MpuController.hpp)</li> <li>mpu_RA_XA_OFFS_H (MpuController.hpp)</li> <li>mpu_RA_XA_OFFS_L_TC (MpuController.hpp)</li> <li>mpu_RA_XG_OFFS_TC (MpuController.hpp)</li> <li>mpu_RA_XG_OFFS_USRH (MpuController.hpp)</li> <li>mpu_RA_XG_OFFS_USRL (MpuController.hpp)</li> <li>mpu_RA_X_FINE_GAIN (MpuController.hpp)</li> <li>mpu_RA_YA_OFFS_H (MpuController.hpp)</li> <li>mpu_RA_YA_OFFS_L_TC (MpuController.hpp)</li> <li>mpu_RA_YG_OFFS_TC (MpuController.hpp)</li> <li>mpu_RA_YG_OFFS_USRH (MpuController.hpp)</li> <li>mpu_RA_YG_OFFS_USRL (MpuController.hpp)</li> <li>mpu_RA_Y_FINE_GAIN (MpuController.hpp)</li> <li>mpu_RA_ZA_OFFS_H (MpuController.hpp)</li> <li>mpu_RA_ZA_OFFS_L_TC (MpuController.hpp)</li> <li>mpu_RA_ZG_OFFS_TC (MpuController.hpp)</li> <li>mpu_RA_ZG_OFFS_USRH (MpuController.hpp)</li> <li>mpu_RA_ZG_OFFS_USRL (MpuController.hpp)</li> <li>mpu_RA_ZRMOT_DUR (MpuController.hpp)</li> <li>mpu_RA_ZRMOT_THR (MpuController.hpp)</li> <li>mpu_RA_Z_FINE_GAIN (MpuController.hpp)</li> <li>mpu_SLV0_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_SLV1_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_SLV2_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_SLV_3_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_TC_OFFSET_BIT (MpuController.hpp)</li> <li>mpu_TC_OFFSET_LENGTH (MpuController.hpp)</li> <li>mpu_TC_OTP_BNK_VLD_BIT (MpuController.hpp)</li> <li>mpu_TC_PWR_MODE_BIT (MpuController.hpp)</li> <li>mpu_TEMP_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_USERCTRL_DMP_EN_BIT (MpuController.hpp)</li> <li>mpu_USERCTRL_DMP_RESET_BIT (MpuController.hpp)</li> <li>mpu_USERCTRL_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_USERCTRL_FIFO_RESET_BIT (MpuController.hpp)</li> <li>mpu_USERCTRL_I2C_IF_DIS_BIT (MpuController.hpp)</li> <li>mpu_USERCTRL_I2C_MST_EN_BIT (MpuController.hpp)</li> <li>mpu_USERCTRL_I2C_MST_RESET_BIT (MpuController.hpp)</li> <li>mpu_USERCTRL_SIG_COND_RESET_BIT (MpuController.hpp)</li> <li>mpu_VDDIO_LEVEL_VDD (MpuController.hpp)</li> <li>mpu_VDDIO_LEVEL_VLOGIC (MpuController.hpp)</li> <li>mpu_WAIT_FOR_ES_BIT (MpuController.hpp)</li> <li>mpu_WAKE_FREQ_10 (MpuController.hpp)</li> <li>mpu_WAKE_FREQ_1P25 (MpuController.hpp)</li> <li>mpu_WAKE_FREQ_2P5 (MpuController.hpp)</li> <li>mpu_WAKE_FREQ_5 (MpuController.hpp)</li> <li>mpu_WHO_AM_I_BIT (MpuController.hpp)</li> <li>mpu_WHO_AM_I_LENGTH (MpuController.hpp)</li> <li>mpu_XG_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_YG_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_ZG_FIFO_EN_BIT (MpuController.hpp)</li> </ul>"},{"location":"stm/macros/#o","title":"o","text":"<ul> <li>OLED_BUFFER_SIZE (OledController.hpp)</li> <li>OLED_I2C_ADDR (OledController.hpp)</li> </ul>"},{"location":"stm/macros/#s","title":"s","text":"<ul> <li>STRINGIFY (Debug.hpp)</li> </ul>"},{"location":"stm/macros/#t","title":"t","text":"<ul> <li>TOSTRING (Debug.hpp)</li> </ul>"},{"location":"stm/macros/#u","title":"u","text":"<ul> <li>USB_LP_IRQ_HANDLER (Bsp.hpp)</li> <li>USE_FreeRTOS_HEAP_4 (FreeRTOSConfig.h)</li> </ul>"},{"location":"stm/macros/#v","title":"v","text":"<ul> <li>vPortSVCHandler (FreeRTOSConfig.h)</li> </ul>"},{"location":"stm/macros/#x","title":"x","text":"<ul> <li>xPortPendSVHandler (FreeRTOSConfig.h)</li> <li>xPortSysTickHandler (FreeRTOSConfig.h)</li> </ul>"},{"location":"stm/variables/","title":"Variables","text":""},{"location":"stm/variables/#a","title":"a","text":"<ul> <li>ADC_channel_t (Bsp.hpp)</li> <li>ADC_rank_t (Bsp.hpp)</li> <li>auxiliaryAdc (Bsp.hpp)</li> <li>auxiliaryAndMotorAdcIRQn (Bsp.hpp)</li> <li>auxiliaryAndMotorAdcIrqPrio (Bsp.hpp)</li> </ul>"},{"location":"stm/variables/#b","title":"b","text":"<ul> <li>batteryMiddleVoltageAdcChannel (Bsp.hpp)</li> <li>batteryMiddleVoltageAdcRank (Bsp.hpp)</li> <li>batteryMiddleVoltagePin (Bsp.hpp)</li> <li>batteryVoltageAdcChannel (Bsp.hpp)</li> <li>batteryVoltageAdcRank (Bsp.hpp)</li> <li>batteryVoltagePin (Bsp.hpp)</li> <li>button1Pin (Bsp.hpp)</li> <li>button2Pin (Bsp.hpp)</li> <li>button3Pin (Bsp.hpp)</li> <li>button4Pin (Bsp.hpp)</li> <li>buttonOffPin (Bsp.hpp)</li> <li>buttonOnPin (Bsp.hpp)</li> <li>buttonPin (Bsp.hpp)</li> <li>buzzerPin (Bsp.hpp)</li> <li>buttonState (ButtonController.cpp)</li> </ul>"},{"location":"stm/variables/#c","title":"c","text":"<ul> <li>controlUart (Bsp.hpp)</li> <li>controlUartRxDmaChannel (Bsp.hpp)</li> <li>controlUartRxPin (Bsp.hpp)</li> <li>controlUartTxDmaChannel (Bsp.hpp)</li> <li>controlUartTxDmaIRQn (Bsp.hpp)</li> <li>controlUartTxDmaIRQnPrio (Bsp.hpp)</li> <li>controlUartTxPin (Bsp.hpp)</li> <li>codec (ControlLink.cpp)</li> <li>compressCoef (MpuController.cpp)</li> <li>calib (Power.cpp)</li> <li>calibrationDataMagic (Power.cpp)</li> <li>calibrationDefaults (Power.cpp)</li> <li>cdc_iface_desc_en (UsbCdcDescriptors.c, UsbCdcLink.cpp)</li> <li>cdc_line_debug (UsbCdcLink.cpp)</li> <li>cdc_line_tunnel (UsbCdcLink.cpp)</li> <li>config (UsbCdcLink.cpp)</li> <li>config_desc (UsbCdcLink.cpp)</li> </ul>"},{"location":"stm/variables/#d","title":"d","text":"<ul> <li>DMA_channel_t (Bsp.hpp)</li> <li>debugUart (Bsp.hpp)</li> <li>debugUartIRQn (Bsp.hpp)</li> <li>debugUartIrqPrio (Bsp.hpp)</li> <li>debugUartRxDmaChannel (Bsp.hpp)</li> <li>debugUartRxPin (Bsp.hpp)</li> <li>debugUartTxDmaChannel (Bsp.hpp)</li> <li>debugUartTxDmaIRQn (Bsp.hpp)</li> <li>debugUartTxDmaIrqPrio (Bsp.hpp)</li> <li>debugUartTxPin (Bsp.hpp)</li> <li>debugStateChanges (ButtonController.cpp)</li> <li>dmaRxHandle (CdcUartTunnel.cpp, ControlLink.cpp, DebugLink.cpp)</li> <li>dmaTxHandle (CdcUartTunnel.cpp, ControlLink.cpp, DebugLink.cpp)</li> <li>dispatchStatPeriodMs (Power.cpp)</li> <li>dispatchStatTimer (Power.cpp)</li> <li>debug_iface_desc_en (UsbCdcDescriptors.c, UsbCdcLink.cpp)</li> <li>DebugDescriptorsSize (UsbCdcLink.cpp)</li> <li>device_desc (UsbCdcLink.cpp)</li> <li>dtable (UsbCdcLink.cpp)</li> </ul>"},{"location":"stm/variables/#e","title":"e","text":"<ul> <li>encoder1aPin (Bsp.hpp)</li> <li>encoder1bPin (Bsp.hpp)</li> <li>encoder2aPin (Bsp.hpp)</li> <li>encoder2bPin (Bsp.hpp)</li> <li>encoder3aPin (Bsp.hpp)</li> <li>encoder3bPin (Bsp.hpp)</li> <li>encoder4aPin (Bsp.hpp)</li> <li>encoder4bPin (Bsp.hpp)</li> <li>encoderTimer (Bsp.hpp)</li> <li>esp0Pin (Bsp.hpp)</li> <li>esp12Pin (Bsp.hpp)</li> <li>esp15Pin (Bsp.hpp)</li> <li>esp2Pin (Bsp.hpp)</li> <li>espEnPin (Bsp.hpp)</li> <li>Esp32WatchdogTimeoutMs (Esp32Manager.cpp)</li> <li>encoderFilter (MotorController.cpp)</li> <li>echoRestoreTimeoutMs (UltrasoundController.cpp)</li> <li>enableDebugEp (UsbCdcLink.cpp)</li> </ul>"},{"location":"stm/variables/#f","title":"f","text":"<ul> <li>Font_11x18 (OledController_fonts.hpp, OledController_fonts.cpp)</li> <li>Font_16x26 (OledController_fonts.hpp, OledController_fonts.cpp)</li> <li>Font_6x8 (OledController_fonts.hpp, OledController_fonts.cpp)</li> <li>Font_7x10 (OledController_fonts.hpp, OledController_fonts.cpp)</li> <li>FLASH_PAGE_POWER_CALIBRATION (Flash.hpp)</li> <li>Font11x18 (OledController_fonts.cpp)</li> <li>Font16x26 (OledController_fonts.cpp)</li> <li>Font6x8 (OledController_fonts.cpp)</li> <li>Font7x10 (OledController_fonts.cpp)</li> </ul>"},{"location":"stm/variables/#i","title":"i","text":"<ul> <li>i2cErIRQn (Bsp.hpp)</li> <li>i2cEvIRQn (Bsp.hpp)</li> <li>i2cIRQnPrio (Bsp.hpp)</li> <li>i2cPrio (Bsp.hpp)</li> <li>i2cScl (Bsp.hpp)</li> <li>i2cSda (Bsp.hpp)</li> <li>in4aPin (Bsp.hpp)</li> <li>in4bPin (Bsp.hpp)</li> <li>internalReferenceVoltageAdcRank (Bsp.hpp)</li> <li>I2cEvents (I2cController.hpp)</li> <li>i2cEventGroup (I2cController.hpp, I2cController.cpp)</li> <li>i2cTaskHandle (I2cController.hpp, I2cController.cpp)</li> <li>idleTaskStack (FreeRTOSCallbacks.cpp)</li> <li>idleTaskStruct (FreeRTOSCallbacks.cpp)</li> <li>I2Cdev_hi2c (I2cController.cpp)</li> <li>I2Cdev_readTimeout (I2cController.cpp)</li> <li>i2cCallingTask (I2cController.cpp)</li> <li>i2cEventBuffer (I2cController.cpp)</li> <li>i2cMutex (I2cController.cpp)</li> <li>i2cQueue (I2cController.cpp)</li> <li>i2cTask (I2cController.cpp)</li> </ul>"},{"location":"stm/variables/#l","title":"l","text":"<ul> <li>led1Pin (Bsp.hpp)</li> <li>led2Pin (Bsp.hpp)</li> <li>led3Pin (Bsp.hpp)</li> <li>led4Pin (Bsp.hpp)</li> <li>ledPin (Bsp.hpp)</li> <li>ledPins (Bsp.hpp)</li> <li>lang_desc (UsbCdcDescriptors.c, UsbCdcLink.cpp)</li> </ul>"},{"location":"stm/variables/#m","title":"m","text":"<ul> <li>mainTaskPrio (Bsp.hpp)</li> <li>motorTaskPrio (Bsp.hpp)</li> <li>motorLoopFreq (Motor.hpp)</li> <li>MPU6050_t (Mpu6050.hpp)</li> <li>mpu_t (MpuController.hpp)</li> <li>MaxLineLength (DebugLink.cpp)</li> <li>maxPwm (MotorController.cpp)</li> <li>motor (MotorController.cpp)</li> <li>motorMut (MotorController.cpp)</li> <li>motorTask (MotorController.cpp)</li> <li>MpuMotion32 (MpuController.cpp)</li> <li>MpuMotion6 (MpuController.cpp)</li> <li>MpuVector (MpuController.cpp)</li> <li>MpuVector32 (MpuController.cpp)</li> <li>mpu6050 (MpuController.cpp)</li> <li>mpuAggrCounter (MpuController.cpp)</li> <li>mpuAggrData (MpuController.cpp)</li> <li>mpuTickPeriodMs (MpuController.cpp)</li> <li>mpuTimerBuffer (MpuController.cpp)</li> <li>mpuTimerHandle (MpuController.cpp)</li> <li>manuf_desc_en (UsbCdcDescriptors.c, UsbCdcLink.cpp)</li> <li>mainTask (main.cpp)</li> </ul>"},{"location":"stm/variables/#o","title":"o","text":"<ul> <li>OLED_COLOR (OledController.hpp)</li> <li>OLED_Error_t (OledController.hpp)</li> <li>OLED (OledController.cpp)</li> <li>OLED_Buffer (OledController.cpp)</li> <li>oled_height (OledController.cpp)</li> <li>oled_width (OledController.cpp)</li> </ul>"},{"location":"stm/variables/#p","title":"p","text":"<ul> <li>PinDef (Bsp.hpp)</li> <li>powerPin (Bsp.hpp)</li> <li>pwm1aPin (Bsp.hpp)</li> <li>pwm1bPin (Bsp.hpp)</li> <li>pwm2aPin (Bsp.hpp)</li> <li>pwm2bPin (Bsp.hpp)</li> <li>pwm3aPin (Bsp.hpp)</li> <li>pwm3bPin (Bsp.hpp)</li> <li>pwm4Pin (Bsp.hpp)</li> <li>pwmTimer (Bsp.hpp)</li> <li>POWER_CALIBRATE_DEFAULT (Power.hpp)</li> <li>POWER_CALIBRATE_NO_CHANGE (Power.hpp)</li> <li>powerOffAt (ButtonController.cpp)</li> <li>pwmCenterValue (StupidServoController.cpp)</li> <li>pwmCoef (StupidServoController.cpp)</li> <li>pingTimeoutMs (UltrasoundController.cpp)</li> <li>prod_desc_en (UsbCdcDescriptors.c, UsbCdcLink.cpp)</li> </ul>"},{"location":"stm/variables/#r","title":"r","text":"<ul> <li>rxFifo (CdcUartTunnel.cpp, ControlLink.cpp)</li> <li>rxLineBuffer (DebugLink.cpp)</li> <li>requestQueue (Dispatcher.cpp)</li> <li>rawBattery (Power.cpp)</li> <li>rawInternalRef (Power.cpp)</li> <li>rawMidBattery (Power.cpp)</li> <li>rawTemperature (Power.cpp)</li> <li>risingMicros (UltrasoundController.cpp)</li> </ul>"},{"location":"stm/variables/#s","title":"s","text":"<ul> <li>servo1Pin (Bsp.hpp)</li> <li>servo2Pin (Bsp.hpp)</li> <li>servo3Pin (Bsp.hpp)</li> <li>servo4Pin (Bsp.hpp)</li> <li>servoPins (Bsp.hpp)</li> <li>servoTimer (Bsp.hpp)</li> <li>servoUart (Bsp.hpp)</li> <li>servoUartTxRxPin (Bsp.hpp)</li> <li>softResetTaskPrio (Bsp.hpp)</li> <li>sEsp32Manager (Esp32Manager.hpp, Esp32Manager.cpp)</li> <li>softResetTask (Bsp.cpp)</li> <li>statusQueue (Dispatcher.cpp)</li> <li>status (UltrasoundController.cpp)</li> <li>serial_number_desc_en (UsbCdcDescriptors.c, UsbCdcLink.cpp)</li> </ul>"},{"location":"stm/variables/#t","title":"t","text":"<ul> <li>temperatureAdcRank (Bsp.hpp)</li> <li>tunnelUart (Bsp.hpp)</li> <li>tunnelUartRxDmaChannel (Bsp.hpp)</li> <li>tunnelUartRxPin (Bsp.hpp)</li> <li>tunnelUartTxDmaChannel (Bsp.hpp)</li> <li>tunnelUartTxPin (Bsp.hpp)</li> <li>txBuf (CdcUartTunnel.cpp)</li> <li>txDmaBuf (ControlLink.cpp, DebugLink.cpp)</li> <li>txEncodeBuf (ControlLink.cpp)</li> <li>txMessageBuf (ControlLink.cpp)</li> <li>txUartStreamBuf (DebugLink.cpp)</li> <li>ThresholdNoBatteryMv (Power.cpp)</li> <li>ThresholdPowerOffMv (Power.cpp)</li> <li>tempAvgSlope (Power.cpp)</li> <li>trigQueue (UltrasoundController.cpp)</li> <li>tunnel_cdc_acm (UsbCdcLink.cpp)</li> <li>tunnel_cdc_hdr (UsbCdcLink.cpp)</li> <li>tunnel_cdc_mgmt (UsbCdcLink.cpp)</li> <li>tunnel_cdc_union (UsbCdcLink.cpp)</li> <li>tunnel_comm (UsbCdcLink.cpp)</li> <li>tunnel_comm_ep (UsbCdcLink.cpp)</li> <li>tunnel_comm_iad (UsbCdcLink.cpp)</li> <li>tunnel_data (UsbCdcLink.cpp)</li> <li>tunnel_data_eprx (UsbCdcLink.cpp)</li> <li>tunnel_data_eptx (UsbCdcLink.cpp)</li> </ul>"},{"location":"stm/variables/#u","title":"u","text":"<ul> <li>ultrasoundTaskPrio (Bsp.hpp)</li> <li>usbBusDetectionPin (Bsp.hpp)</li> <li>usbDnPin (Bsp.hpp)</li> <li>usbDpPin (Bsp.hpp)</li> <li>usbDpPullUpPin (Bsp.hpp)</li> <li>usbLpIRQn (Bsp.hpp)</li> <li>usbLpIRQnPrio (Bsp.hpp)</li> <li>userUart (Bsp.hpp)</li> <li>userUartRxPin (Bsp.hpp)</li> <li>userUartTxPin (Bsp.hpp)</li> <li>uts1EchoPin (Bsp.hpp)</li> <li>uts1TrigPin (Bsp.hpp)</li> <li>uts2EchoPin (Bsp.hpp)</li> <li>uts2TrigPin (Bsp.hpp)</li> <li>uts3EchoPin (Bsp.hpp)</li> <li>uts3TrigPin (Bsp.hpp)</li> <li>uts4EchoPin (Bsp.hpp)</li> <li>uts4TrigPin (Bsp.hpp)</li> <li>utsEchoPin (Bsp.hpp)</li> <li>utsIRQPrio (Bsp.hpp)</li> <li>utsTimer (Bsp.hpp)</li> <li>utsTrigPin (Bsp.hpp)</li> <li>udev (UsbCdcLink.h, UsbCdcLink.cpp)</li> <li>usbIrqPrioRaise (CdcUartTunnel.cpp, DebugLink.cpp)</li> <li>uartRxFifo (DebugLink.cpp)</li> <li>usbFrameBuf (DebugLink.cpp)</li> <li>usbRxFifo (DebugLink.cpp)</li> <li>usbTxFifo (DebugLink.cpp)</li> <li>undervoltageCounter (Power.cpp)</li> <li>undervoltageShutdownThreshold (Power.cpp)</li> <li>undervoltageWarningOn (Power.cpp)</li> <li>utsActiveIndex (UltrasoundController.cpp)</li> <li>utsTask (UltrasoundController.cpp)</li> <li>ubuf (UsbCdcLink.cpp)</li> </ul>"},{"location":"stm/variables/#v","title":"v","text":"<ul> <li>vrefMv (Power.cpp)</li> </ul>"},{"location":"stm/variables/#_","title":"_","text":"<ul> <li>_myint (main.cpp)</li> </ul>"},{"location":"stm/variables/#_1","title":"@","text":"<ul> <li>@0 (UsbCdcLink.cpp)</li> <li>@1 (UsbCdcLink.cpp)</li> </ul>"},{"location":"stm/links/","title":"Links","text":"<ul> <li>Related Pages<ul> <li>Source</li> </ul> </li> <li>Modules</li> <li>Class List<ul> <li>class BasePriorityRaiser</li> <li>class ByteFifo</li> <li>struct CalibrationData</li> <li>class Esp32Manager</li> <li>struct FontDef</li> <li>struct MPU6050_t</li> <li>class MessageBufferWrapper</li> <li>class Motor</li> <li>struct MpuMotion32</li> <li>struct MpuMotion6</li> <li>struct MpuVector</li> <li>struct MpuVector32</li> <li>class MutexWrapper</li> <li>struct OLED_VERTEX</li> <li>struct OLED_t</li> <li>class QueueWrapper</li> <li>struct Regulator</li> <li>class StreamBufferWrapper</li> <li>class TaskWrapper</li> <li>class TickTimer</li> <li>class XorShift</li> <li>struct __debug_descriptors</li> <li>struct cdc_config</li> <li>struct mpu_t</li> </ul> </li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files<ul> <li>Readme.md</li> <li>Readme.md source</li> <li>demo-projets</li> <li>demo-projets/stm32<ul> <li>demo-projets/stm32/include</li> <li>Bsp.hpp</li> <li>Bsp.hpp source</li> <li>ButtonController.hpp</li> <li>ButtonController.hpp source</li> <li>BuzzerController.hpp</li> <li>BuzzerController.hpp source</li> <li>CdcUartTunnel.hpp</li> <li>CdcUartTunnel.hpp source</li> <li>ControlLink.hpp</li> <li>ControlLink.hpp source</li> <li>DebugLink.hpp</li> <li>DebugLink.hpp source</li> <li>Dispatcher.hpp</li> <li>Dispatcher.hpp source</li> <li>Esp32Manager.hpp</li> <li>Esp32Manager.hpp source</li> <li>FreeRTOSConfig.h</li> <li>FreeRTOSConfig.h source</li> <li>I2cController.hpp</li> <li>I2cController.hpp source</li> <li>Motor.hpp</li> <li>Motor.hpp source</li> <li>MotorController.hpp</li> <li>MotorController.hpp source</li> <li>Mpu6050.hpp</li> <li>Mpu6050.hpp source</li> <li>MpuController.hpp</li> <li>MpuController.hpp source</li> <li>OledController.hpp</li> <li>OledController.hpp source</li> <li>OledController_fonts.hpp</li> <li>OledController_fonts.hpp source</li> <li>Power.hpp</li> <li>Power.hpp source</li> <li>StupidServoController.hpp</li> <li>StupidServoController.hpp source</li> <li>UltrasoundController.hpp</li> <li>UltrasoundController.hpp source</li> <li>UsbCdcLink.h</li> <li>UsbCdcLink.h source</li> <li>demo-projets/stm32/include/utils<ul> <li>BasePriorityRaiser.hpp</li> <li>BasePriorityRaiser.hpp source</li> <li>ByteFifo.hpp</li> <li>ByteFifo.hpp source</li> <li>Debug.hpp</li> <li>Debug.hpp source</li> <li>Flash.hpp</li> <li>Flash.hpp source</li> <li>HalDma.hpp</li> <li>HalDma.hpp source</li> <li>MessageBufferWrapper.hpp</li> <li>MessageBufferWrapper.hpp source</li> <li>MutexWrapper.hpp</li> <li>MutexWrapper.hpp source</li> <li>QueueWrapper.hpp</li> <li>QueueWrapper.hpp source</li> <li>Regulator.hpp</li> <li>Regulator.hpp source</li> <li>StreamBufferWrapper.hpp</li> <li>StreamBufferWrapper.hpp source</li> <li>TaskWrapper.hpp</li> <li>TaskWrapper.hpp source</li> <li>TickTimer.hpp</li> <li>TickTimer.hpp source</li> <li>XorShift.hpp</li> <li>XorShift.hpp source</li> </ul> </li> <li>demo-projets/stm32/src</li> <li>Bsp.cpp</li> <li>Bsp.cpp source</li> <li>ButtonController.cpp</li> <li>ButtonController.cpp source</li> <li>CdcUartTunnel.cpp</li> <li>CdcUartTunnel.cpp source</li> <li>ControlLink.cpp</li> <li>ControlLink.cpp source</li> <li>DebugLink.cpp</li> <li>DebugLink.cpp source</li> <li>Dispatcher.cpp</li> <li>Dispatcher.cpp source</li> <li>Esp32Manager.cpp</li> <li>Esp32Manager.cpp source</li> <li>FreeRTOSCallbacks.cpp</li> <li>FreeRTOSCallbacks.cpp source</li> <li>I2cController.cpp</li> <li>I2cController.cpp source</li> <li>MotorController.cpp</li> <li>MotorController.cpp source</li> <li>MpuController.cpp</li> <li>MpuController.cpp source</li> <li>OledController.cpp</li> <li>OledController.cpp source</li> <li>OledController_fonts.cpp</li> <li>OledController_fonts.cpp source</li> <li>Power.cpp</li> <li>Power.cpp source</li> <li>StupidServoController.cpp</li> <li>StupidServoController.cpp source</li> <li>UltrasoundController.cpp</li> <li>UltrasoundController.cpp source</li> <li>UsbCdcDescriptors.c</li> <li>UsbCdcDescriptors.c source</li> <li>UsbCdcLink.cpp</li> <li>UsbCdcLink.cpp source</li> <li>demo-projets/stm32/src/utils<ul> <li>Debug.cpp</li> <li>Debug.cpp source</li> </ul> </li> <li>main.cpp</li> <li>main.cpp source</li> </ul> </li> </ul> </li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"jaculus/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class Controller </li> <li>class GpioFeature </li> <li>class Gpio </li> <li>class LinkIoFeature </li> <li>class LinkIo </li> <li>struct Logger </li> <li>class NeopixelFeature </li> <li>struct NeopixelProtoBuilder </li> <li>class SerialStream </li> <li>class Uploader </li> <li>class WdtResetFeature </li> <li>namespace jac </li> <li>struct ConvTraits&lt; Rgb &gt; </li> <li>namespace ProtoBuilder </li> </ul>"},{"location":"jaculus/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir demo-projets </li> <li>dir jaculus <ul> <li>dir main </li> <li>dir features <ul> <li>file gpioFeature.h </li> <li>file linkIoFeature.h </li> <li>file neopixelFeature.h </li> <li>file wdtResetFeature.h </li> </ul> </li> <li>dir util <ul> <li>file controller.h </li> <li>file logger.cpp </li> <li>file logger.h </li> <li>file uploader.cpp </li> <li>file uploader.h </li> </ul> </li> <li>file main.cpp </li> <li>file serialStream.h </li> </ul> </li> </ul>"},{"location":"jaculus/classController/","title":"Class Controller","text":"<p>template &lt;class Machine class Machine&gt;</p> <p>ClassList &gt; Controller</p>"},{"location":"jaculus/classController/#public-types","title":"Public Types","text":"Type Name enum uint8_t Command"},{"location":"jaculus/classController/#public-functions","title":"Public Functions","text":"Type Name Controller (std::function&lt; std::string()&gt; getMemoryStats, std::function&lt; std::string()&gt; getStorageStats)  void onConfigureMachine (std::function&lt; void(Machine &amp;)&gt; f)  void processStart (int sender, std::span&lt; const uint8_t &gt; data)  void processStatus (int sender)  void processStop (int sender)  Router &amp; router ()  bool startMachine (std::string path)  bool stopMachine ()  Uploader &amp; uploader ()"},{"location":"jaculus/classController/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"jaculus/classController/#enum-command","title":"enum Command","text":"<pre><code>enum Controller::Command {\nSTART = 0x01,\nSTOP = 0x02,\nSTATUS = 0x03,\nOK = 0x20,\nERROR = 0x21\n};\n</code></pre>"},{"location":"jaculus/classController/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"jaculus/classController/#function-controller","title":"function Controller","text":"<pre><code>inline Controller::Controller (\nstd::function&lt; std::string()&gt; getMemoryStats,\nstd::function&lt; std::string()&gt; getStorageStats\n) </code></pre>"},{"location":"jaculus/classController/#function-onconfiguremachine","title":"function onConfigureMachine","text":"<pre><code>inline void Controller::onConfigureMachine (\nstd::function&lt; void(Machine &amp;)&gt; f\n) </code></pre>"},{"location":"jaculus/classController/#function-processstart","title":"function processStart","text":"<pre><code>void Controller::processStart (\nint sender,\nstd::span&lt; const uint8_t &gt; data\n) </code></pre>"},{"location":"jaculus/classController/#function-processstatus","title":"function processStatus","text":"<pre><code>void Controller::processStatus (\nint sender\n) </code></pre>"},{"location":"jaculus/classController/#function-processstop","title":"function processStop","text":"<pre><code>void Controller::processStop (\nint sender\n) </code></pre>"},{"location":"jaculus/classController/#function-router","title":"function router","text":"<pre><code>inline Router &amp; Controller::router () </code></pre>"},{"location":"jaculus/classController/#function-startmachine","title":"function startMachine","text":"<pre><code>bool Controller::startMachine (\nstd::string path\n) </code></pre>"},{"location":"jaculus/classController/#function-stopmachine","title":"function stopMachine","text":"<pre><code>bool Controller::stopMachine () </code></pre>"},{"location":"jaculus/classController/#function-uploader","title":"function uploader","text":"<pre><code>inline Uploader &amp; Controller::uploader () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/util/controller.h</code></p>"},{"location":"jaculus/classGpioFeature/","title":"Class GpioFeature","text":"<p>template &lt;class Next class Next&gt;</p> <p>ClassList &gt; GpioFeature</p> <p>Inherits the following classes: Next</p>"},{"location":"jaculus/classGpioFeature/#classes","title":"Classes","text":"Type Name class Gpio"},{"location":"jaculus/classGpioFeature/#public-attributes","title":"Public Attributes","text":"Type Name Gpio gpio"},{"location":"jaculus/classGpioFeature/#public-functions","title":"Public Functions","text":"Type Name void initialize ()"},{"location":"jaculus/classGpioFeature/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"jaculus/classGpioFeature/#variable-gpio","title":"variable gpio","text":"<pre><code>Gpio GpioFeature&lt; Next &gt;::gpio;\n</code></pre>"},{"location":"jaculus/classGpioFeature/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"jaculus/classGpioFeature/#function-initialize","title":"function initialize","text":"<pre><code>inline void GpioFeature::initialize () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/features/gpioFeature.h</code></p>"},{"location":"jaculus/classGpioFeature_1_1Gpio/","title":"Class GpioFeature::Gpio","text":"<p>ClassList &gt; GpioFeature &gt; Gpio</p>"},{"location":"jaculus/classGpioFeature_1_1Gpio/#public-types","title":"Public Types","text":"Type Name enum int DIRECTION enum int PULL_MODE"},{"location":"jaculus/classGpioFeature_1_1Gpio/#public-functions","title":"Public Functions","text":"Type Name void pinMode (int pin, int mode)  void pullMode (int pin, int mode)  int read (int pin)  void write (int pin, int value)"},{"location":"jaculus/classGpioFeature_1_1Gpio/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"jaculus/classGpioFeature_1_1Gpio/#enum-direction","title":"enum DIRECTION","text":"<pre><code>enum GpioFeature::Gpio::DIRECTION {\nDISABLE = static_cast&lt;int&gt;(GPIO_MODE_DISABLE),\nINPUT = static_cast&lt;int&gt;(GPIO_MODE_INPUT),\nOUTPUT = static_cast&lt;int&gt;(GPIO_MODE_OUTPUT),\nOUTPUT_OD = static_cast&lt;int&gt;(GPIO_MODE_OUTPUT_OD),\nINPUT_OUTPUT_OD = static_cast&lt;int&gt;(GPIO_MODE_INPUT_OUTPUT_OD),\nINPUT_OUTPUT = static_cast&lt;int&gt;(GPIO_MODE_INPUT_OUTPUT)\n};\n</code></pre>"},{"location":"jaculus/classGpioFeature_1_1Gpio/#enum-pull_mode","title":"enum PULL_MODE","text":"<pre><code>enum GpioFeature::Gpio::PULL_MODE {\nFLOATING = static_cast&lt;int&gt;(GPIO_FLOATING),\nPULL_UP = static_cast&lt;int&gt;(GPIO_PULLUP_ONLY),\nPULL_DOWN = static_cast&lt;int&gt;(GPIO_PULLDOWN_ONLY),\nPULL_UP_DOWN = static_cast&lt;int&gt;(GPIO_PULLUP_PULLDOWN)\n};\n</code></pre>"},{"location":"jaculus/classGpioFeature_1_1Gpio/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"jaculus/classGpioFeature_1_1Gpio/#function-pinmode","title":"function pinMode","text":"<pre><code>inline void GpioFeature::Gpio::pinMode (\nint pin,\nint mode\n) </code></pre>"},{"location":"jaculus/classGpioFeature_1_1Gpio/#function-pullmode","title":"function pullMode","text":"<pre><code>inline void GpioFeature::Gpio::pullMode (\nint pin,\nint mode\n) </code></pre>"},{"location":"jaculus/classGpioFeature_1_1Gpio/#function-read","title":"function read","text":"<pre><code>inline int GpioFeature::Gpio::read (\nint pin\n) </code></pre>"},{"location":"jaculus/classGpioFeature_1_1Gpio/#function-write","title":"function write","text":"<pre><code>inline void GpioFeature::Gpio::write (\nint pin,\nint value\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/features/gpioFeature.h</code></p>"},{"location":"jaculus/classLinkIoFeature/","title":"Class LinkIoFeature","text":"<p>template &lt;class Next class Next&gt;</p> <p>ClassList &gt; LinkIoFeature</p> <p>Inherits the following classes: Next</p>"},{"location":"jaculus/classLinkIoFeature/#classes","title":"Classes","text":"Type Name class LinkIo"},{"location":"jaculus/classLinkIoFeature/#public-attributes","title":"Public Attributes","text":"Type Name LinkIo linkIo"},{"location":"jaculus/classLinkIoFeature/#public-functions","title":"Public Functions","text":"Type Name void initialize ()"},{"location":"jaculus/classLinkIoFeature/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"jaculus/classLinkIoFeature/#variable-linkio","title":"variable linkIo","text":"<pre><code>LinkIo LinkIoFeature&lt; Next &gt;::linkIo;\n</code></pre>"},{"location":"jaculus/classLinkIoFeature/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"jaculus/classLinkIoFeature/#function-initialize","title":"function initialize","text":"<pre><code>inline void LinkIoFeature::initialize () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/features/linkIoFeature.h</code></p>"},{"location":"jaculus/classLinkIoFeature_1_1LinkIo/","title":"Class LinkIoFeature::LinkIo","text":"<p>ClassList &gt; LinkIoFeature &gt; LinkIo</p>"},{"location":"jaculus/classLinkIoFeature_1_1LinkIo/#public-attributes","title":"Public Attributes","text":"Type Name std::unique_ptr&lt; OutputStreamCommunicator &gt; _output"},{"location":"jaculus/classLinkIoFeature_1_1LinkIo/#public-functions","title":"Public Functions","text":"Type Name void print (std::string str)"},{"location":"jaculus/classLinkIoFeature_1_1LinkIo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"jaculus/classLinkIoFeature_1_1LinkIo/#variable-_output","title":"variable _output","text":"<pre><code>std::unique_ptr&lt;OutputStreamCommunicator&gt; LinkIoFeature&lt; Next &gt;::LinkIo::_output;\n</code></pre>"},{"location":"jaculus/classLinkIoFeature_1_1LinkIo/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"jaculus/classLinkIoFeature_1_1LinkIo/#function-print","title":"function print","text":"<pre><code>inline void LinkIoFeature::LinkIo::print (\nstd::string str\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/features/linkIoFeature.h</code></p>"},{"location":"jaculus/structLogger/","title":"Struct Logger","text":"<p>ClassList &gt; Logger</p>"},{"location":"jaculus/structLogger/#public-static-attributes","title":"Public Static Attributes","text":"Type Name std::unique_ptr&lt; OutputStreamCommunicator &gt; _debugStream std::unique_ptr&lt; OutputStreamCommunicator &gt; _logStream"},{"location":"jaculus/structLogger/#public-static-functions","title":"Public Static Functions","text":"Type Name void debug (std::string message)  void log (std::string message)"},{"location":"jaculus/structLogger/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"jaculus/structLogger/#variable-_debugstream","title":"variable _debugStream","text":"<pre><code>std::unique_ptr&lt; OutputStreamCommunicator &gt; Logger::_debugStream;\n</code></pre>"},{"location":"jaculus/structLogger/#variable-_logstream","title":"variable _logStream","text":"<pre><code>std::unique_ptr&lt; OutputStreamCommunicator &gt; Logger::_logStream;\n</code></pre>"},{"location":"jaculus/structLogger/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"jaculus/structLogger/#function-debug","title":"function debug","text":"<pre><code>static inline void Logger::debug (\nstd::string message\n) </code></pre>"},{"location":"jaculus/structLogger/#function-log","title":"function log","text":"<pre><code>static inline void Logger::log (\nstd::string message\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/util/logger.h</code></p>"},{"location":"jaculus/classNeopixelFeature/","title":"Class NeopixelFeature","text":"<p>template &lt;class Next class Next&gt;</p> <p>ClassList &gt; NeopixelFeature</p> <p>Inherits the following classes: Next</p>"},{"location":"jaculus/classNeopixelFeature/#public-types","title":"Public Types","text":"Type Name typedef jac::Class&lt; NeopixelProtoBuilder &gt; NeopixelClass"},{"location":"jaculus/classNeopixelFeature/#public-functions","title":"Public Functions","text":"Type Name NeopixelFeature ()  void initialize ()"},{"location":"jaculus/classNeopixelFeature/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"jaculus/classNeopixelFeature/#typedef-neopixelclass","title":"typedef NeopixelClass","text":"<pre><code>using NeopixelFeature&lt; Next &gt;::NeopixelClass =  jac::Class&lt;NeopixelProtoBuilder&gt;;\n</code></pre>"},{"location":"jaculus/classNeopixelFeature/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"jaculus/classNeopixelFeature/#function-neopixelfeature","title":"function NeopixelFeature","text":"<pre><code>inline NeopixelFeature::NeopixelFeature () </code></pre>"},{"location":"jaculus/classNeopixelFeature/#function-initialize","title":"function initialize","text":"<pre><code>inline void NeopixelFeature::initialize () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/features/neopixelFeature.h</code></p>"},{"location":"jaculus/structNeopixelFeature_1_1NeopixelProtoBuilder/","title":"Struct NeopixelFeature::NeopixelProtoBuilder","text":"<p>ClassList &gt; NeopixelProtoBuilder</p> <p>Inherits the following classes: jac::ProtoBuilder::Opaque&lt; SmartLed &gt;,  jac::ProtoBuilder::Properties</p>"},{"location":"jaculus/structNeopixelFeature_1_1NeopixelProtoBuilder/#public-static-functions","title":"Public Static Functions","text":"Type Name void addProperties (JSContext * ctx, jac::Object proto)  SmartLed * constructOpaque (JSContext * ctx, std::vector&lt; jac::ValueConst &gt; args)"},{"location":"jaculus/structNeopixelFeature_1_1NeopixelProtoBuilder/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"jaculus/structNeopixelFeature_1_1NeopixelProtoBuilder/#function-addproperties","title":"function addProperties","text":"<pre><code>static inline void NeopixelProtoBuilder::addProperties (\nJSContext * ctx,\njac::Object proto\n) </code></pre>"},{"location":"jaculus/structNeopixelFeature_1_1NeopixelProtoBuilder/#function-constructopaque","title":"function constructOpaque","text":"<pre><code>static inline SmartLed * NeopixelProtoBuilder::constructOpaque (\nJSContext * ctx,\nstd::vector&lt; jac::ValueConst &gt; args\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/features/neopixelFeature.h</code></p>"},{"location":"jaculus/classSerialStream/","title":"Class SerialStream","text":"<p>ClassList &gt; SerialStream</p> <p>Inherits the following classes: Duplex</p>"},{"location":"jaculus/classSerialStream/#public-functions","title":"Public Functions","text":"Type Name SerialStream (uart_port_t uartNum, int baudRate, int rxBufferSize, int txBufferSize, int txPin=UART_PIN_NO_CHANGE, int rxPin=UART_PIN_NO_CHANGE, int rtsPin=UART_PIN_NO_CHANGE, int ctsPin=UART_PIN_NO_CHANGE)  SerialStream (SerialStream &amp;&amp;) = delete SerialStream (const SerialStream &amp;) = delete bool flush () override int get () override void onData (Func callback)  SerialStream &amp; operator= (SerialStream &amp;&amp;) = delete SerialStream &amp; operator= (const SerialStream &amp;) = delete bool put (uint8_t c) override size_t read (std::span&lt; uint8_t &gt; data) override size_t write (std::span&lt; const uint8_t &gt; data) override ~SerialStream () override"},{"location":"jaculus/classSerialStream/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"jaculus/classSerialStream/#function-serialstream-13","title":"function SerialStream [1/3]","text":"<pre><code>inline SerialStream::SerialStream (\nuart_port_t uartNum,\nint baudRate,\nint rxBufferSize,\nint txBufferSize,\nint txPin=UART_PIN_NO_CHANGE,\nint rxPin=UART_PIN_NO_CHANGE,\nint rtsPin=UART_PIN_NO_CHANGE,\nint ctsPin=UART_PIN_NO_CHANGE\n) </code></pre>"},{"location":"jaculus/classSerialStream/#function-serialstream-23","title":"function SerialStream [2/3]","text":"<pre><code>SerialStream::SerialStream (\nSerialStream &amp;&amp;\n) = delete\n</code></pre>"},{"location":"jaculus/classSerialStream/#function-serialstream-33","title":"function SerialStream [3/3]","text":"<pre><code>SerialStream::SerialStream (\nconst SerialStream &amp;\n) = delete\n</code></pre>"},{"location":"jaculus/classSerialStream/#function-flush","title":"function flush","text":"<pre><code>inline bool SerialStream::flush () override\n</code></pre>"},{"location":"jaculus/classSerialStream/#function-get","title":"function get","text":"<pre><code>inline int SerialStream::get () override\n</code></pre>"},{"location":"jaculus/classSerialStream/#function-ondata","title":"function onData","text":"<pre><code>template&lt;typename Func typename Func&gt;\ninline void SerialStream::onData (\nFunc callback\n) </code></pre>"},{"location":"jaculus/classSerialStream/#function-operator","title":"function operator=","text":"<pre><code>SerialStream &amp; SerialStream::operator= (\nSerialStream &amp;&amp;\n) = delete\n</code></pre>"},{"location":"jaculus/classSerialStream/#function-operator_1","title":"function operator=","text":"<pre><code>SerialStream &amp; SerialStream::operator= (\nconst SerialStream &amp;\n) = delete\n</code></pre>"},{"location":"jaculus/classSerialStream/#function-put","title":"function put","text":"<pre><code>inline bool SerialStream::put (\nuint8_t c\n) override\n</code></pre>"},{"location":"jaculus/classSerialStream/#function-read","title":"function read","text":"<pre><code>inline size_t SerialStream::read (\nstd::span&lt; uint8_t &gt; data\n) override\n</code></pre>"},{"location":"jaculus/classSerialStream/#function-write","title":"function write","text":"<pre><code>inline size_t SerialStream::write (\nstd::span&lt; const uint8_t &gt; data\n) override\n</code></pre>"},{"location":"jaculus/classSerialStream/#function-serialstream","title":"function ~SerialStream","text":"<pre><code>inline SerialStream::~SerialStream () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/serialStream.h</code></p>"},{"location":"jaculus/classUploader/","title":"Class Uploader","text":"<p>ClassList &gt; Uploader</p>"},{"location":"jaculus/classUploader/#public-types","title":"Public Types","text":"Type Name enum uint8_t Command enum uint8_t Error"},{"location":"jaculus/classUploader/#public-functions","title":"Public Functions","text":"Type Name Uploader (std::unique_ptr&lt; BufferedInputPacketCommunicator &gt; input, std::unique_ptr&lt; OutputPacketCommunicator &gt; output)  Uploader (const Uploader &amp;) = delete Uploader (Uploader &amp;&amp;) = delete Uploader &amp; operator= (const Uploader &amp;) = delete Uploader &amp; operator= (Uploader &amp;&amp;) = delete"},{"location":"jaculus/classUploader/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"jaculus/classUploader/#enum-command","title":"enum Command","text":"<pre><code>enum Uploader::Command {\nREAD_FILE = 0x01,\nWRITE_FILE = 0x02,\nDELETE_FILE = 0x03,\nLIST_DIR = 0x04,\nCREATE_DIR = 0x05,\nDELETE_DIR = 0x06,\nHAS_MORE_DATA = 0x10,\nLAST_DATA = 0x11,\nOK = 0x20,\nERROR = 0x21,\nNOT_FOUND = 0x22,\nCONTINUE = 0x23\n};\n</code></pre>"},{"location":"jaculus/classUploader/#enum-error","title":"enum Error","text":"<pre><code>enum Uploader::Error {\nUNKNOWN_COMMAND = 0x01,\nFILE_OPEN_FAILED = 0x02,\nFILE_DELETE_FAILED = 0x03,\nDIR_OPEN_FAILED = 0x04,\nDIR_CREATE_FAILED = 0x05,\nDIR_DELETE_FAILED = 0x06,\nINVALID_FILENAME = 0x07\n};\n</code></pre>"},{"location":"jaculus/classUploader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"jaculus/classUploader/#function-uploader-13","title":"function Uploader [1/3]","text":"<pre><code>inline Uploader::Uploader (\nstd::unique_ptr&lt; BufferedInputPacketCommunicator &gt; input,\nstd::unique_ptr&lt; OutputPacketCommunicator &gt; output\n) </code></pre>"},{"location":"jaculus/classUploader/#function-uploader-23","title":"function Uploader [2/3]","text":"<pre><code>Uploader::Uploader (\nconst Uploader &amp;\n) = delete\n</code></pre>"},{"location":"jaculus/classUploader/#function-uploader-33","title":"function Uploader [3/3]","text":"<pre><code>Uploader::Uploader (\nUploader &amp;&amp;\n) = delete\n</code></pre>"},{"location":"jaculus/classUploader/#function-operator","title":"function operator=","text":"<pre><code>Uploader &amp; Uploader::operator= (\nconst Uploader &amp;\n) = delete\n</code></pre>"},{"location":"jaculus/classUploader/#function-operator_1","title":"function operator=","text":"<pre><code>Uploader &amp; Uploader::operator= (\nUploader &amp;&amp;\n) = delete\n</code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/util/uploader.h</code></p>"},{"location":"jaculus/classWdtResetFeature/","title":"Class WdtResetFeature","text":"<p>template &lt;class Next class Next&gt;</p> <p>ClassList &gt; WdtResetFeature</p> <p>Inherits the following classes: Next</p>"},{"location":"jaculus/classWdtResetFeature/#public-functions","title":"Public Functions","text":"Type Name void onEventLoop ()"},{"location":"jaculus/classWdtResetFeature/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"jaculus/classWdtResetFeature/#function-oneventloop","title":"function onEventLoop","text":"<pre><code>inline void WdtResetFeature::onEventLoop () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/features/wdtResetFeature.h</code></p>"},{"location":"jaculus/namespacejac/","title":"Namespace jac","text":"<p>Namespace List &gt; jac</p>"},{"location":"jaculus/namespacejac/#namespaces","title":"Namespaces","text":"Type Name namespace ProtoBuilder"},{"location":"jaculus/namespacejac/#classes","title":"Classes","text":"Type Name struct ConvTraits&lt; Rgb &gt; &lt;&gt; <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"jaculus/structjac_1_1ConvTraits_3_01Rgb_01_4/","title":"Struct jac::ConvTraits&lt; Rgb &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; jac &gt; ConvTraits&lt; Rgb &gt;</p>"},{"location":"jaculus/structjac_1_1ConvTraits_3_01Rgb_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name Rgb from (ContextRef ctx, ValueConst val)  Value to (ContextRef ctx, Rgb val)"},{"location":"jaculus/structjac_1_1ConvTraits_3_01Rgb_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"jaculus/structjac_1_1ConvTraits_3_01Rgb_01_4/#function-from","title":"function from","text":"<pre><code>static inline Rgb jac::ConvTraits&lt; Rgb &gt;::from (\nContextRef ctx,\nValueConst val\n) </code></pre>"},{"location":"jaculus/structjac_1_1ConvTraits_3_01Rgb_01_4/#function-to","title":"function to","text":"<pre><code>static inline Value jac::ConvTraits&lt; Rgb &gt;::to (\nContextRef ctx,\nRgb val\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/features/neopixelFeature.h</code></p>"},{"location":"jaculus/namespacejac_1_1ProtoBuilder/","title":"Namespace jac::ProtoBuilder","text":"<p>Namespace List &gt; jac &gt; ProtoBuilder</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"jaculus/dir_9ba036507fddba3d714985d68e6a47f2/","title":"Dir demo-projets","text":"<p>FileList &gt; demo-projets</p>"},{"location":"jaculus/dir_9ba036507fddba3d714985d68e6a47f2/#directories","title":"Directories","text":"Type Name dir jaculus <p>The documentation for this class was generated from the following file <code>demo-projets/</code></p>"},{"location":"jaculus/dir_267444f6ee241552a50bfa821599de34/","title":"Dir demo-projets/jaculus","text":"<p>FileList &gt; demo-projets &gt; jaculus</p>"},{"location":"jaculus/dir_267444f6ee241552a50bfa821599de34/#directories","title":"Directories","text":"Type Name dir main <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/</code></p>"},{"location":"jaculus/dir_c4c307c9b7f3f24c8fca77f310768851/","title":"Dir demo-projets/jaculus/main","text":"<p>FileList &gt; demo-projets &gt; jaculus &gt; main</p>"},{"location":"jaculus/dir_c4c307c9b7f3f24c8fca77f310768851/#files","title":"Files","text":"Type Name file main.cpp file serialStream.h"},{"location":"jaculus/dir_c4c307c9b7f3f24c8fca77f310768851/#directories","title":"Directories","text":"Type Name dir features dir util <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/</code></p>"},{"location":"jaculus/dir_1e8b4acc7ef9ac62d3337e7318c63a8e/","title":"Dir demo-projets/jaculus/main/features","text":"<p>FileList &gt; demo-projets &gt; jaculus &gt; main &gt; features</p>"},{"location":"jaculus/dir_1e8b4acc7ef9ac62d3337e7318c63a8e/#files","title":"Files","text":"Type Name file gpioFeature.h file linkIoFeature.h file neopixelFeature.h file wdtResetFeature.h <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/features/</code></p>"},{"location":"jaculus/gpioFeature_8h/","title":"File gpioFeature.h","text":"<p>FileList &gt; demo-projets &gt; jaculus &gt; main &gt; features &gt; gpioFeature.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;jac/machine/machine.h&gt;</code></li> <li><code>#include &lt;jac/machine/values.h&gt;</code></li> <li><code>#include &lt;jac/machine/functionFactory.h&gt;</code></li> <li><code>#include &lt;noal_func.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include \"driver/gpio.h\"</code></li> </ul>"},{"location":"jaculus/gpioFeature_8h/#classes","title":"Classes","text":"Type Name class GpioFeature &lt;class Next&gt; class Gpio <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/features/gpioFeature.h</code></p>"},{"location":"jaculus/gpioFeature_8h_source/","title":"File gpioFeature.h","text":"<p>File List &gt; demo-projets &gt; jaculus &gt; main &gt; features &gt; gpioFeature.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;jac/machine/machine.h&gt;\n#include &lt;jac/machine/values.h&gt;\n#include &lt;jac/machine/functionFactory.h&gt;\n#include &lt;noal_func.h&gt;\n#include &lt;memory&gt;\n#include &lt;map&gt;\n#include \"driver/gpio.h\"\n\ntemplate&lt;class Next&gt;\nclass GpioFeature : public Next {\npublic:\nclass Gpio {\npublic:\nenum class DIRECTION : int {\nDISABLE = static_cast&lt;int&gt;(GPIO_MODE_DISABLE),\nINPUT = static_cast&lt;int&gt;(GPIO_MODE_INPUT),\nOUTPUT = static_cast&lt;int&gt;(GPIO_MODE_OUTPUT),\nOUTPUT_OD = static_cast&lt;int&gt;(GPIO_MODE_OUTPUT_OD),\nINPUT_OUTPUT_OD = static_cast&lt;int&gt;(GPIO_MODE_INPUT_OUTPUT_OD),\nINPUT_OUTPUT = static_cast&lt;int&gt;(GPIO_MODE_INPUT_OUTPUT),\n};\n\nenum class PULL_MODE : int {\nFLOATING = static_cast&lt;int&gt;(GPIO_FLOATING),\nPULL_UP = static_cast&lt;int&gt;(GPIO_PULLUP_ONLY),\nPULL_DOWN = static_cast&lt;int&gt;(GPIO_PULLDOWN_ONLY),\nPULL_UP_DOWN = static_cast&lt;int&gt;(GPIO_PULLUP_PULLDOWN),\n};\n\nvoid pinMode(int pin, int mode) {\n// gpio_pad_select_gpio(pin);\ngpio_set_direction((gpio_num_t)pin, (gpio_mode_t)mode);\n}\n\nvoid pullMode(int pin, int mode) {\ngpio_set_pull_mode((gpio_num_t)pin, (gpio_pull_mode_t)mode);\n}\n\nvoid write(int pin, int value) {\ngpio_set_level((gpio_num_t)pin, value);\n}\n\nint read(int pin) {\nreturn gpio_get_level((gpio_num_t)pin);\n}\n};\nGpio gpio;\n\nvoid initialize() {\nNext::initialize();\n\njac::FunctionFactory ff(this-&gt;_context);\n\nauto&amp; module = this-&gt;newModule(\"gpio\");\nmodule.addExport(\"pinMode\", ff.newFunction(noal::function(&amp;Gpio::pinMode, &amp;gpio)));\nmodule.addExport(\"pullMode\", ff.newFunction(noal::function(&amp;Gpio::pullMode, &amp;gpio)));\nmodule.addExport(\"write\", ff.newFunction(noal::function(&amp;Gpio::write, &amp;gpio)));\nmodule.addExport(\"read\", ff.newFunction(noal::function(&amp;Gpio::read, &amp;gpio)));\n\nmodule.addExport(\"DISABLE\", jac::Value::from(this-&gt;_context, static_cast&lt;int&gt;(Gpio::DIRECTION::DISABLE)));\nmodule.addExport(\"INPUT\", jac::Value::from(this-&gt;_context, static_cast&lt;int&gt;(Gpio::DIRECTION::INPUT)));\nmodule.addExport(\"OUTPUT\", jac::Value::from(this-&gt;_context, static_cast&lt;int&gt;(Gpio::DIRECTION::OUTPUT)));\nmodule.addExport(\"OUTPUT_OD\", jac::Value::from(this-&gt;_context, static_cast&lt;int&gt;(Gpio::DIRECTION::OUTPUT_OD)));\nmodule.addExport(\"INPUT_OUTPUT_OD\", jac::Value::from(this-&gt;_context, static_cast&lt;int&gt;(Gpio::DIRECTION::INPUT_OUTPUT_OD)));\nmodule.addExport(\"INPUT_OUTPUT\", jac::Value::from(this-&gt;_context, static_cast&lt;int&gt;(Gpio::DIRECTION::INPUT_OUTPUT)));\n\nmodule.addExport(\"FLOATING\", jac::Value::from(this-&gt;_context, static_cast&lt;int&gt;(Gpio::PULL_MODE::FLOATING)));\nmodule.addExport(\"PULL_UP\", jac::Value::from(this-&gt;_context, static_cast&lt;int&gt;(Gpio::PULL_MODE::PULL_UP)));\nmodule.addExport(\"PULL_DOWN\", jac::Value::from(this-&gt;_context, static_cast&lt;int&gt;(Gpio::PULL_MODE::PULL_DOWN)));\nmodule.addExport(\"PULL_UP_DOWN\", jac::Value::from(this-&gt;_context, static_cast&lt;int&gt;(Gpio::PULL_MODE::PULL_UP_DOWN)));\n}\n};\n</code></pre>"},{"location":"jaculus/linkIoFeature_8h/","title":"File linkIoFeature.h","text":"<p>FileList &gt; demo-projets &gt; jaculus &gt; main &gt; features &gt; linkIoFeature.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;jac/machine/machine.h&gt;</code></li> <li><code>#include &lt;noal_func.h&gt;</code></li> <li><code>#include &lt;jac/link/communicator.h&gt;</code></li> <li><code>#include &lt;jac/machine/functionFactory.h&gt;</code></li> </ul>"},{"location":"jaculus/linkIoFeature_8h/#classes","title":"Classes","text":"Type Name class LinkIoFeature &lt;class Next&gt; class LinkIo <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/features/linkIoFeature.h</code></p>"},{"location":"jaculus/linkIoFeature_8h_source/","title":"File linkIoFeature.h","text":"<p>File List &gt; demo-projets &gt; jaculus &gt; main &gt; features &gt; linkIoFeature.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;memory&gt;\n\n#include &lt;jac/machine/machine.h&gt;\n#include &lt;noal_func.h&gt;\n#include &lt;jac/link/communicator.h&gt;\n#include &lt;jac/machine/functionFactory.h&gt;\n\ntemplate&lt;class Next&gt;\nclass LinkIoFeature : public Next {\npublic:\nclass LinkIo {\npublic:\nstd::unique_ptr&lt;OutputStreamCommunicator&gt; _output;\nvoid print(std::string str) {\n_output-&gt;write(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(str.data()), str.size()));\n}\n};\nLinkIo linkIo;\n\nvoid initialize() {\nNext::initialize();\n\njac::FunctionFactory ff(this-&gt;_context);\n\nauto&amp; module = this-&gt;newModule(\"stdio\");\nmodule.addExport(\"print\", ff.newFunction(noal::function(&amp;LinkIo::print, &amp;linkIo)));\n}\n};\n</code></pre>"},{"location":"jaculus/neopixelFeature_8h/","title":"File neopixelFeature.h","text":"<p>FileList &gt; demo-projets &gt; jaculus &gt; main &gt; features &gt; neopixelFeature.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;jac/machine/machine.h&gt;</code></li> <li><code>#include &lt;noal_func.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;SmartLeds.h&gt;</code></li> <li><code>#include &lt;jac/machine/functionFactory.h&gt;</code></li> <li><code>#include &lt;jac/machine/class.h&gt;</code></li> </ul>"},{"location":"jaculus/neopixelFeature_8h/#classes","title":"Classes","text":"Type Name class NeopixelFeature &lt;class Next&gt; struct ConvTraits&lt; Rgb &gt; &lt;&gt; <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/features/neopixelFeature.h</code></p>"},{"location":"jaculus/neopixelFeature_8h_source/","title":"File neopixelFeature.h","text":"<p>File List &gt; demo-projets &gt; jaculus &gt; main &gt; features &gt; neopixelFeature.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;jac/machine/machine.h&gt;\n#include &lt;noal_func.h&gt;\n#include &lt;memory&gt;\n#include &lt;map&gt;\n#include &lt;SmartLeds.h&gt;\n#include &lt;jac/machine/functionFactory.h&gt;\n#include &lt;jac/machine/class.h&gt;\n\n\ntemplate&lt;&gt;\nstruct jac::ConvTraits&lt;Rgb&gt; {\nstatic Value to(ContextRef ctx, Rgb val) {\nauto obj = Object::create(ctx);\nobj.set&lt;int&gt;(\"r\", val.r);\nobj.set&lt;int&gt;(\"g\", val.g);\nobj.set&lt;int&gt;(\"b\", val.b);\nreturn obj;\n}\n\nstatic Rgb from(ContextRef ctx, ValueConst val) {\nauto obj = val.to&lt;Object&gt;();\nreturn Rgb(obj.get(\"r\").to&lt;int&gt;(), obj.get(\"g\").to&lt;int&gt;(), obj.get(\"b\").to&lt;int&gt;());\n}\n};\n\n\ntemplate&lt;class Next&gt;\nclass NeopixelFeature : public Next {\nstruct NeopixelProtoBuilder : public jac::ProtoBuilder::Opaque&lt;SmartLed&gt;, public jac::ProtoBuilder::Properties {\nstatic SmartLed* constructOpaque(JSContext* ctx, std::vector&lt;jac::ValueConst&gt; args) {\nif (args.size() != 2) {\nthrow std::runtime_error(\"Invalid number of arguments\");\n}\nint pin = args[0].to&lt;int&gt;();\nint count = args[1].to&lt;int&gt;();\n\nreturn new SmartLed(LED_WS2812, count, pin, 0, SingleBuffer);\n}\n\nstatic void addProperties(JSContext* ctx, jac::Object proto) {\njac::FunctionFactory ff(ctx);\n\naddProp(ctx, proto, \"show\", ff.newFunctionThis([](jac::ContextRef ctx, jac::ValueConst thisValue) {\nSmartLed&amp; led = *getOpaque(ctx, thisValue);\nled.wait();\nled.show();\n}));\n\naddProp(ctx, proto, \"set\", ff.newFunctionThis([](jac::ContextRef ctx, jac::ValueConst thisValue, int idx, Rgb color) {\nSmartLed&amp; strip = *getOpaque(ctx, thisValue);\nstrip[idx] = color;\n}));\n\naddProp(ctx, proto, \"get\", ff.newFunctionThis([](jac::ContextRef ctx, jac::ValueConst thisValue, int idx) {\nSmartLed&amp; strip = *getOpaque(ctx, thisValue);\nreturn strip[idx];\n}));\n}\n};\npublic:\nusing NeopixelClass = jac::Class&lt;NeopixelProtoBuilder&gt;;\n\nNeopixelFeature() {\nNeopixelClass::init(\"Neopixel\");\n}\n\nvoid initialize() {\nNext::initialize();\n\nauto&amp; mod = this-&gt;newModule(\"neopixel\");\njac::Function ctor = NeopixelClass::getConstructor(this-&gt;_context);\nmod.addExport(\"Neopixel\", ctor);\n}\n};\n</code></pre>"},{"location":"jaculus/wdtResetFeature_8h/","title":"File wdtResetFeature.h","text":"<p>FileList &gt; demo-projets &gt; jaculus &gt; main &gt; features &gt; wdtResetFeature.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;jac/machine/machine.h&gt;</code></li> <li><code>#include &lt;deque&gt;</code></li> <li><code>#include \"freertos/FreeRTOS.h\"</code></li> <li><code>#include \"freertos/task.h\"</code></li> </ul>"},{"location":"jaculus/wdtResetFeature_8h/#classes","title":"Classes","text":"Type Name class WdtResetFeature &lt;class Next&gt; <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/features/wdtResetFeature.h</code></p>"},{"location":"jaculus/wdtResetFeature_8h_source/","title":"File wdtResetFeature.h","text":"<p>File List &gt; demo-projets &gt; jaculus &gt; main &gt; features &gt; wdtResetFeature.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;jac/machine/machine.h&gt;\n#include &lt;deque&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n\n\ntemplate&lt;class Next&gt;\nclass WdtResetFeature : public Next {\npublic:\nvoid onEventLoop() {\nNext::onEventLoop();\nvTaskDelay(1);\n};\n};\n</code></pre>"},{"location":"jaculus/dir_e0311e01bb8f9af585b26a1cc7722295/","title":"Dir demo-projets/jaculus/main/util","text":"<p>FileList &gt; demo-projets &gt; jaculus &gt; main &gt; util</p>"},{"location":"jaculus/dir_e0311e01bb8f9af585b26a1cc7722295/#files","title":"Files","text":"Type Name file controller.h file logger.cpp file logger.h file uploader.cpp file uploader.h <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/util/</code></p>"},{"location":"jaculus/controller_8h/","title":"File controller.h","text":"<p>FileList &gt; demo-projets &gt; jaculus &gt; main &gt; util &gt; controller.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;jac/link/mux.h&gt;</code></li> <li><code>#include &lt;jac/link/router.h&gt;</code></li> <li><code>#include \"uploader.h\"</code></li> <li><code>#include \"logger.h\"</code></li> <li><code>#include &lt;jac/link/routerCommunicator.h&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include \"esp_pthread.h\"</code></li> </ul>"},{"location":"jaculus/controller_8h/#classes","title":"Classes","text":"Type Name class Controller &lt;class Machine&gt; <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/util/controller.h</code></p>"},{"location":"jaculus/controller_8h_source/","title":"File controller.h","text":"<p>File List &gt; demo-projets &gt; jaculus &gt; main &gt; util &gt; controller.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;jac/link/mux.h&gt;\n#include &lt;jac/link/router.h&gt;\n#include \"uploader.h\"\n#include \"logger.h\"\n#include &lt;jac/link/routerCommunicator.h&gt;\n\n#include &lt;sstream&gt;\n#include &lt;filesystem&gt;\n#include &lt;optional&gt;\n#include &lt;thread&gt;\n\n#include \"esp_pthread.h\"\n\n\ntemplate&lt;class Machine&gt;\nclass Controller {\nRouter _router;\nstd::optional&lt;Uploader&gt; _uploader;\n\nstd::unique_ptr&lt;BufferedInputPacketCommunicator&gt; _input;\nstd::unique_ptr&lt;OutputPacketCommunicator&gt; _output;\n\nstd::unique_ptr&lt;Machine&gt; _machine;\nbool _running = false;\nstd::thread _thread;\n\nstd::function&lt;std::string()&gt; _getMemoryStats;\nstd::function&lt;std::string()&gt; _getStorageStats;\n\nstd::vector&lt;std::function&lt;void(Machine&amp;)&gt;&gt; _onConfigureMachine;\n\nstd::thread _controllerThread;\n\nvoid configureMachine() {\n_machine = std::make_unique&lt;Machine&gt;();\nfor (auto&amp; f : _onConfigureMachine) {\nf(*_machine);\n}\n}\npublic:\nvoid processStart(int sender, std::span&lt;const uint8_t&gt; data);\nvoid processStop(int sender);\nvoid processStatus(int sender);\n\nenum class Command : uint8_t {\nSTART = 0x01,\nSTOP = 0x02,\nSTATUS = 0x03,\nOK = 0x20,\nERROR = 0x21,\n};\n\nController(std::function&lt;std::string()&gt; getMemoryStats, std::function&lt;std::string()&gt; getStorageStats):\n_getMemoryStats(getMemoryStats),\n_getStorageStats(getStorageStats)\n{\nLogger::_logStream = std::make_unique&lt;TransparentOutputStreamCommunicator&gt;(_router, 255, std::vector&lt;int&gt;{});\nLogger::_debugStream = std::make_unique&lt;TransparentOutputStreamCommunicator&gt;(_router, 254, std::vector&lt;int&gt;{});\n\nauto uploaderInput = std::make_unique&lt;AsyncBufferedInputPacketCommunicator&gt;();\nauto uploaderOutput = std::make_unique&lt;TransparentOutputPacketCommunicator&gt;(_router, 1);\n_router.subscribeChannel(1, *uploaderInput);\n\n_uploader.emplace(std::move(uploaderInput), std::move(uploaderOutput));\n\nauto controllerInput = std::make_unique&lt;AsyncBufferedInputPacketCommunicator&gt;();\n_router.subscribeChannel(0, *controllerInput);\n_input = std::move(controllerInput);\n_output = std::make_unique&lt;TransparentOutputPacketCommunicator&gt;(_router, 0);\n\n_controllerThread = std::thread([this]() {\nwhile (true) {\nauto [sender, data] = _input-&gt;get();\nif (data.size() == 0) {\ncontinue;\n}\nauto begin = data.begin();\nCommand cmd = static_cast&lt;Command&gt;(data[0]);\nbegin++;\n\nLogger::debug(std::string(\"Controller: \") + std::to_string(static_cast&lt;int&gt;(cmd)));\n\nswitch (cmd) {\ncase Command::START: {\nprocessStart(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\nbreak;\n}\ncase Command::STOP: {\nprocessStop(sender);\nbreak;\n}\ncase Command::STATUS: {\nprocessStatus(sender);\nbreak;\n}\ndefault: {\nbreak;\n}\n}\n}\n});\n}\n\nRouter&amp; router() {\nreturn _router;\n}\n\nUploader&amp; uploader() {\nreturn *_uploader;\n}\n\nbool startMachine(std::string path);\nbool stopMachine();\n\nvoid onConfigureMachine(std::function&lt;void(Machine&amp;)&gt; f) {\n_onConfigureMachine.push_back(f);\n}\n};\n\n\ntemplate&lt;class Machine&gt;\nvoid Controller&lt;Machine&gt;::processStart(int sender, std::span&lt;const uint8_t&gt; data) {\nstd::string filename(data.begin(), data.end());\n\nauto result = Command::OK;\n\nif (!startMachine(filename)) {\nresult = Command::ERROR;\n}\n\nauto response = this-&gt;_output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(result));\nresponse-&gt;send();\n}\n\ntemplate&lt;class Machine&gt;\nvoid Controller&lt;Machine&gt;::processStop(int sender) {\nauto result = Command::OK;\n\nif (!stopMachine()) {\nresult = Command::ERROR;\n}\n\nauto response = this-&gt;_output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(result));\nresponse-&gt;send();\n}\n\ntemplate&lt;class Machine&gt;\nvoid Controller&lt;Machine&gt;::processStatus(int sender) {\nauto response = this-&gt;_output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Command::STATUS));\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(_running));\nresponse-&gt;put(_machine-&gt;eventLoop_getExitCode());\n\nstd::stringstream oss;\noss &lt;&lt; \"Memory usage: \" &lt;&lt; _getMemoryStats() &lt;&lt; std::endl;\noss &lt;&lt; \"Storage usage: \" &lt;&lt; _getStorageStats() &lt;&lt; std::endl;\nstd::string data = oss.str();\nresponse-&gt;put(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(data.data()), data.size()));\nresponse-&gt;send();\n}\n\ntemplate&lt;class Machine&gt;\nbool Controller&lt;Machine&gt;::startMachine(std::string path) {\nif (_running) {\nreturn false;\n}\n\nif (!std::filesystem::exists(path)) {\nLogger::log(\"File not found: \" + path);\nreturn false;\n}\n\nesp_pthread_cfg_t cfg = esp_pthread_get_default_config();\ncfg.stack_size = 8 * 1024;\nesp_pthread_set_cfg(&amp;cfg);\n\n_thread = std::thread([this, path]() {\nController&lt;Machine&gt;&amp; self = *this;\nself._running = true;\n\nLogger::log(\"Starting machine\");\n\nself.configureMachine();\nself._machine-&gt;initialize();\ntry {\nself._machine-&gt;evalFile(path);\nself._machine-&gt;eventLoop_run();\n}\ncatch (const std::runtime_error&amp; e) {\nLogger::log(\"Runtime error - \" + std::string(e.what()));\n}\ncatch (const std::exception&amp; e) {\nLogger::log(\"Exception - \" + std::string(e.what()));\n}\ncatch (...) {\nLogger::log(\"Unknown exception\");\n}\n\nself._running = false;\n});\n\nreturn true;\n}\n\ntemplate&lt;class Machine&gt;\nbool Controller&lt;Machine&gt;::stopMachine() {\nif (!_running) {\nreturn false;\n}\n\n_machine-&gt;eventLoop_exit();\n\nif (_thread.joinable()) {\n_thread.join();\n}\n_thread = std::thread();\n\nreturn true;\n}\n</code></pre>"},{"location":"jaculus/logger_8cpp/","title":"File logger.cpp","text":"<p>FileList &gt; demo-projets &gt; jaculus &gt; main &gt; util &gt; logger.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"logger.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/util/logger.cpp</code></p>"},{"location":"jaculus/logger_8cpp_source/","title":"File logger.cpp","text":"<p>File List &gt; demo-projets &gt; jaculus &gt; main &gt; util &gt; logger.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"logger.h\"\n\nstd::unique_ptr&lt;OutputStreamCommunicator&gt; Logger::_logStream;\nstd::unique_ptr&lt;OutputStreamCommunicator&gt; Logger::_debugStream;\n</code></pre>"},{"location":"jaculus/logger_8h/","title":"File logger.h","text":"<p>FileList &gt; demo-projets &gt; jaculus &gt; main &gt; util &gt; logger.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;jac/link/communicator.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"jaculus/logger_8h/#classes","title":"Classes","text":"Type Name struct Logger <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/util/logger.h</code></p>"},{"location":"jaculus/logger_8h_source/","title":"File logger.h","text":"<p>File List &gt; demo-projets &gt; jaculus &gt; main &gt; util &gt; logger.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;jac/link/communicator.h&gt;\n#include &lt;string&gt;\n\nstruct Logger {\nstatic std::unique_ptr&lt;OutputStreamCommunicator&gt; _logStream;\nstatic void log(std::string message) {\nif (!_logStream) {\nreturn;\n}\n_logStream-&gt;write(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(message.c_str()), message.size()));\n}\n\nstatic std::unique_ptr&lt;OutputStreamCommunicator&gt; _debugStream;\nstatic void debug(std::string message) {\nif (!_debugStream) {\nreturn;\n}\n_debugStream-&gt;write(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(message.c_str()), message.size()));\n}\n};\n</code></pre>"},{"location":"jaculus/uploader_8cpp/","title":"File uploader.cpp","text":"<p>FileList &gt; demo-projets &gt; jaculus &gt; main &gt; util &gt; uploader.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"uploader.h\"</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;dirent.h&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> </ul>"},{"location":"jaculus/uploader_8cpp/#public-functions","title":"Public Functions","text":"Type Name bool deleteDir (std::string path)  std::optional&lt; std::pair&lt; std::vector&lt; std::string &gt;, size_t &gt; &gt; listDir (std::string path)"},{"location":"jaculus/uploader_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"jaculus/uploader_8cpp/#function-deletedir","title":"function deleteDir","text":"<pre><code>bool deleteDir (\nstd::string path\n) </code></pre>"},{"location":"jaculus/uploader_8cpp/#function-listdir","title":"function listDir","text":"<pre><code>std::optional&lt; std::pair&lt; std::vector&lt; std::string &gt;, size_t &gt; &gt; listDir (\nstd::string path\n) </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/util/uploader.cpp</code></p>"},{"location":"jaculus/uploader_8cpp_source/","title":"File uploader.cpp","text":"<p>File List &gt; demo-projets &gt; jaculus &gt; main &gt; util &gt; uploader.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"uploader.h\"\n\n#include &lt;fstream&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;filesystem&gt;\n#include &lt;dirent.h&gt;\n#include &lt;optional&gt;\n\n\nstd::optional&lt;std::pair&lt;std::vector&lt;std::string&gt;, size_t&gt;&gt; listDir(std::string path) {\nsize_t dataSize = 0;\nstd::vector&lt;std::string&gt; files;\nDIR *dir;\nstruct dirent *ent;\ndir = opendir(path.c_str());\nif (dir == NULL) {\nreturn std::nullopt;\n}\nwhile ((ent = readdir(dir)) != NULL) {\nfiles.push_back(ent-&gt;d_name);\ndataSize += files.back().size() + 1;\n}\nclosedir(dir);\nreturn std::make_pair(files, dataSize);\n}\n\nbool deleteDir(std::string path) {\nauto list = listDir(path);\nif (!list) {\nreturn false;\n}\n\nfor (auto&amp; file : list-&gt;first) {\nstd::string fullPath = path + \"/\" + file;\nif (std::filesystem::is_directory(fullPath)) {\nif (!deleteDir(fullPath)) {\nreturn false;\n}\n}\nelse if (!std::filesystem::remove(fullPath)) {\nreturn false;\n}\n}\nif (path == \"/\" || path == \"/data\" || path == \"/data/\") {\nreturn true;\n}\nreturn std::filesystem::remove(path);\n}\n\nbool Uploader::processPacket(int sender, std::span&lt;const uint8_t&gt; data) {\nif (data.size() &lt; 1) {\nreturn false;\n}\nauto begin = data.begin();\nCommand cmd = static_cast&lt;Command&gt;(*begin);\n++begin;\n\nif (state == State::WAITING_FOR_DATA) {\nbool success = false;\nswitch (cmd) {\ncase Command::HAS_MORE_DATA:\nsuccess = onData(std::span&lt;const uint8_t&gt;(begin, data.end()));\nbreak;\ncase Command::LAST_DATA:\nsuccess = onData(std::span&lt;const uint8_t&gt;(begin, data.end()));\nif (success) {\nsuccess = (!onDataComplete) || onDataComplete();\nstate = State::NONE;\nfile.close();\nonData = nullptr;\nonDataComplete = nullptr;\n}\nbreak;\ndefault:\n// TODO: ignore/reset state\nreturn false;\n}\n\nif (!success) {\nstate = State::NONE;\nfile.close();\nonData = nullptr;\nonDataComplete = nullptr;\n}\nreturn success;\n}\n\nswitch (cmd) {\ncase Command::READ_FILE:\nreturn processReadFile(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\ncase Command::WRITE_FILE:\nreturn processWriteFile(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\ncase Command::DELETE_FILE:\nreturn processDeleteFile(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\ncase Command::LIST_DIR:\nreturn processListDir(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\ncase Command::CREATE_DIR:\nreturn processCreateDir(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\ncase Command::DELETE_DIR:\nreturn processDeleteDir(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\ndefault:\nauto response = output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Error::UNKNOWN_COMMAND));\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(cmd));\nresponse-&gt;send();\nreturn false;\n}\n}\n\nbool Uploader::processReadFile(int sender, std::span&lt;const uint8_t&gt; data) {\n// TODO: check if file is open for writing\nauto begin = data.begin();\nstd::string filename(begin, data.end());\n\nfile = std::fstream(filename, std::ios::in | std::ios::binary);\nif (!file.is_open()) {\nauto response = output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Command::NOT_FOUND));\nresponse-&gt;send();\nreturn false;\n}\n\nstd::vector&lt;uint8_t&gt; buff(output-&gt;maxPacketSize({sender}) - 1);\n\nCommand prefix = Command::HAS_MORE_DATA;\nsize_t read = 1;\nwhile (read &gt; 0) {\nfile.read(reinterpret_cast&lt;char*&gt;(buff.data()), buff.size());\nread = file.gcount();\n\nif (read &lt; buff.size()) {\nprefix = Command::LAST_DATA;\n}\nauto response = output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(prefix));\nsize_t sent = response-&gt;put(std::span(buff.data(), read));\n(void)sent;\nresponse-&gt;send();\n}\nreturn true;\n}\n\nbool Uploader::processWriteFile(int sender, std::span&lt;const uint8_t&gt; data) {\n// TODO: check if file is available for writing\nauto filenameEnd = std::find(data.begin(), data.end(), '\\0');\nif (filenameEnd == data.end()) {\nauto response = output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Error::INVALID_FILENAME));\n\nresponse-&gt;send();\nreturn false;\n}\nstd::string filename(data.begin(), filenameEnd);\nauto begin = ++filenameEnd;\nstate = State::WAITING_FOR_DATA;\n// TODO: delete file\nfile = std::fstream(filename, std::ios::out | std::ios::binary);\nif (!file.is_open()) {\nauto response = output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Error::FILE_OPEN_FAILED));\nresponse-&gt;send();\nreturn false;\n}\nonData = [this, sender](std::span&lt;const uint8_t&gt; data) {\nfile.write(reinterpret_cast&lt;const char*&gt;(data.data()), data.size());\nfile.sync();\nauto response = output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Command::CONTINUE));\nresponse-&gt;send();\nreturn true;\n};\nonDataComplete = [this, sender]() {\nfile.close();\nauto response = output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Command::OK));\nresponse-&gt;send();\nreturn true;\n};\n\nif (begin != data.end()) {\nprocessPacket(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\n}\n\nreturn true;\n}\n\nbool Uploader::processDeleteFile(int sender, std::span&lt;const uint8_t&gt; data) {\n// TODO: check if file is available for writing\nauto begin = data.begin();\nstd::string filename(begin, data.end());\n\nif (!std::filesystem::is_directory(filename) &amp;&amp; std::filesystem::remove(filename)) {\nauto response = output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Command::OK));\nresponse-&gt;send();\nreturn true;\n}\nelse {\nauto response = output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Error::FILE_DELETE_FAILED));\nresponse-&gt;send();\nreturn false;\n}\n}\n\nbool Uploader::processListDir(int sender, std::span&lt;const uint8_t&gt; data) {\n// TODO: check if dir is available for reading\nauto begin = data.begin();\nstd::string filename(begin, data.end());\n\nstd::filesystem::path path(filename);\nif (!std::filesystem::is_directory(path)) {\nauto response = output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Command::NOT_FOUND));\nresponse-&gt;send();\nreturn false;\n}\n\nstd::vector&lt;std::string&gt; files;\nsize_t dataSize = 0;\n// for (const auto&amp; entry : std::filesystem::directory_iterator(path)) {\n//     files.push_back(entry.path().filename().string());\n//     dataSize += files.back().size() + 1;\n// }\n// TODO: check std::filesystem::directory_iterator\nauto result = listDir(path);\n\nif (!result) {\nauto response = output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Error::DIR_OPEN_FAILED));\nresponse-&gt;send();\nreturn false;\n}\n\nstd::tie(files, dataSize) = *result;\n\nauto it = files.begin();\nCommand prefix = Command::HAS_MORE_DATA;\ndo {\nif (dataSize &lt;= output-&gt;maxPacketSize({sender}) - 1) {\nprefix = Command::LAST_DATA;\n}\nauto response = output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(prefix));\nwhile (it != files.end() &amp;&amp; it-&gt;size() + 1 &lt;= response-&gt;space()) {\nresponse-&gt;put(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(it-&gt;data()), it-&gt;size()));\nresponse-&gt;put(static_cast&lt;uint8_t&gt;('\\0'));\ndataSize -= it-&gt;size() + 1;\n++it;\n}\nresponse-&gt;send();\n} while (it != files.end());\nreturn true;\n}\n\nbool Uploader::processCreateDir(int sender, std::span&lt;const uint8_t&gt; data) {\n// TODO: check if dir exists\nauto begin = data.begin();\nstd::string filename(begin, data.end());\n\nif (std::filesystem::create_directory(filename)) {\nauto response = output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Command::OK));\nresponse-&gt;send();\nreturn true;\n}\nelse {\nauto response = output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Error::DIR_CREATE_FAILED));\nresponse-&gt;send();\nreturn false;\n}\n}\n\nbool Uploader::processDeleteDir(int sender, std::span&lt;const uint8_t&gt; data) {\n// TODO: check if is available for writing\nauto begin = data.begin();\nstd::string filename(begin, data.end());\n\nif (deleteDir(filename)) {\nauto response = output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Command::OK));\nresponse-&gt;send();\nreturn true;\n}\nelse {\nauto response = output-&gt;buildPacket({sender});\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\nresponse-&gt;put(static_cast&lt;uint8_t&gt;(Error::DIR_DELETE_FAILED));\nresponse-&gt;send();\nreturn false;\n}\n}\n</code></pre>"},{"location":"jaculus/uploader_8h/","title":"File uploader.h","text":"<p>FileList &gt; demo-projets &gt; jaculus &gt; main &gt; util &gt; uploader.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;jac/link/router.h&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;deque&gt;</code></li> <li><code>#include &lt;memory.h&gt;</code></li> <li><code>#include &lt;jac/link/routerCommunicator.h&gt;</code></li> </ul>"},{"location":"jaculus/uploader_8h/#classes","title":"Classes","text":"Type Name class Uploader <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/util/uploader.h</code></p>"},{"location":"jaculus/uploader_8h_source/","title":"File uploader.h","text":"<p>File List &gt; demo-projets &gt; jaculus &gt; main &gt; util &gt; uploader.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;jac/link/router.h&gt;\n#include &lt;fstream&gt;\n#include &lt;deque&gt;\n#include &lt;memory.h&gt;\n\n#include &lt;jac/link/routerCommunicator.h&gt;\n\n\nclass Uploader {\npublic:\nenum class Command : uint8_t {\nREAD_FILE = 0x01,\nWRITE_FILE = 0x02,\nDELETE_FILE = 0x03,\nLIST_DIR = 0x04,\nCREATE_DIR = 0x05,\nDELETE_DIR = 0x06,\nHAS_MORE_DATA = 0x10,\nLAST_DATA = 0x11,\nOK = 0x20,\nERROR = 0x21,\nNOT_FOUND = 0x22,\nCONTINUE = 0x23\n};\n\nenum class Error : uint8_t {\nUNKNOWN_COMMAND = 0x01,\nFILE_OPEN_FAILED = 0x02,\nFILE_DELETE_FAILED = 0x03,\nDIR_OPEN_FAILED = 0x04,\nDIR_CREATE_FAILED = 0x05,\nDIR_DELETE_FAILED = 0x06,\nINVALID_FILENAME = 0x07\n};\nprivate:\nenum class State {\nNONE,\nWAITING_FOR_DATA\n};\n\nState state = State::NONE;\nstd::function&lt;bool(std::span&lt;const uint8_t&gt;)&gt; onData;\nstd::fstream file;\nstd::function&lt;bool()&gt; onDataComplete;\n\nstd::unique_ptr&lt;BufferedInputPacketCommunicator&gt; input;\nstd::unique_ptr&lt;OutputPacketCommunicator&gt; output;\n\nbool processPacket(int sender, std::span&lt;const uint8_t&gt; data);\nbool processReadFile(int sender, std::span&lt;const uint8_t&gt; data);\nbool processWriteFile(int sender, std::span&lt;const uint8_t&gt; data);\nbool processDeleteFile(int sender, std::span&lt;const uint8_t&gt; data);\nbool processListDir(int sender, std::span&lt;const uint8_t&gt; data);\nbool processCreateDir(int sender, std::span&lt;const uint8_t&gt; data);\nbool processDeleteDir(int sender, std::span&lt;const uint8_t&gt; data);\n\nstd::thread _thread;\npublic:\nUploader(std::unique_ptr&lt;BufferedInputPacketCommunicator&gt; input, std::unique_ptr&lt;OutputPacketCommunicator&gt; output):\ninput(std::move(input)),\noutput(std::move(output))\n{\n_thread = std::thread([this]() {\nwhile (true) {\nauto [sender, data] = this-&gt;input-&gt;get();\nprocessPacket(sender, std::span&lt;const uint8_t&gt;(data.begin(), data.end()));\n}\n});\n}\n\nUploader(const Uploader&amp;) = delete;\nUploader(Uploader&amp;&amp;) = delete;\nUploader&amp; operator=(const Uploader&amp;) = delete;\nUploader&amp; operator=(Uploader&amp;&amp;) = delete;\n};\n</code></pre>"},{"location":"jaculus/main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; demo-projets &gt; jaculus &gt; main &gt; main.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;jac/machine/machine.h&gt;</code></li> <li><code>#include &lt;jac/features/asyncEventLoopFeature.h&gt;</code></li> <li><code>#include &lt;jac/features/asyncTimersFeature.h&gt;</code></li> <li><code>#include &lt;jac/features/yieldFeature.h&gt;</code></li> <li><code>#include &lt;jac/features/moduleLoaderFeature.h&gt;</code></li> <li><code>#include &lt;jac/features/filesystemFeature.h&gt;</code></li> <li><code>#include &lt;jac/machine/values.h&gt;</code></li> <li><code>#include \"features/wdtResetFeature.h\"</code></li> <li><code>#include \"features/neopixelFeature.h\"</code></li> <li><code>#include \"features/gpioFeature.h\"</code></li> <li><code>#include \"features/linkIoFeature.h\"</code></li> <li><code>#include &lt;jac/link/mux.h&gt;</code></li> <li><code>#include &lt;jac/link/encoders/cobs.h&gt;</code></li> <li><code>#include \"serialStream.h\"</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include \"esp_vfs_fat.h\"</code></li> <li><code>#include \"freertos/task.h\"</code></li> <li><code>#include \"util/controller.h\"</code></li> <li><code>#include \"util/uploader.h\"</code></li> <li><code>#include \"util/logger.h\"</code></li> </ul>"},{"location":"jaculus/main_8cpp/#public-types","title":"Public Types","text":"Type Name typedef EventLoopTerminal&lt; AsyncTimersFeature&lt; YieldFeature&lt; WdtResetFeature&lt; AsyncEventLoopFeature&lt; NeopixelFeature&lt; GpioFeature&lt; LinkIoFeature&lt; ModuleLoaderFeature&lt; FilesystemFeature&lt; jac::MachineBase &gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; Machine typedef Mux&lt; CobsPacketizer, CobsSerializer, SerialStream &gt; Mux_t"},{"location":"jaculus/main_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name Controller&lt; Machine &gt; controller std::unique_ptr&lt; Mux_t &gt; mux"},{"location":"jaculus/main_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name wl_handle_t s_wl_handle   = = WL_INVALID_HANDLE"},{"location":"jaculus/main_8cpp/#public-functions","title":"Public Functions","text":"Type Name void app_main ()  int main ()"},{"location":"jaculus/main_8cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"jaculus/main_8cpp/#typedef-machine","title":"typedef Machine","text":"<pre><code>using Machine =  EventLoopTerminal&lt; AsyncTimersFeature&lt; YieldFeature&lt; WdtResetFeature&lt; AsyncEventLoopFeature&lt; NeopixelFeature&lt; GpioFeature&lt; LinkIoFeature&lt; ModuleLoaderFeature&lt; FilesystemFeature&lt; jac::MachineBase &gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt;;\n</code></pre>"},{"location":"jaculus/main_8cpp/#typedef-mux_t","title":"typedef Mux_t","text":"<pre><code>using Mux_t =  Mux&lt;CobsPacketizer, CobsSerializer, SerialStream&gt;;\n</code></pre>"},{"location":"jaculus/main_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"jaculus/main_8cpp/#variable-controller","title":"variable controller","text":"<pre><code>Controller&lt;Machine&gt; controller([]() { std::stringstream oss;oss&lt;&lt; esp_get_free_heap_size()&lt;&lt; \"/\"&lt;&lt; esp_get_minimum_free_heap_size();return oss.str();},[]() { return \"not implemented\";});\n</code></pre>"},{"location":"jaculus/main_8cpp/#variable-mux","title":"variable mux","text":"<pre><code>std::unique_ptr&lt;Mux_t&gt; mux;\n</code></pre>"},{"location":"jaculus/main_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"jaculus/main_8cpp/#variable-s_wl_handle","title":"variable s_wl_handle","text":"<pre><code>wl_handle_t s_wl_handle;\n</code></pre>"},{"location":"jaculus/main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"jaculus/main_8cpp/#function-app_main","title":"function app_main","text":"<pre><code>void app_main () </code></pre>"},{"location":"jaculus/main_8cpp/#function-main","title":"function main","text":"<pre><code>int main () </code></pre> <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/main.cpp</code></p>"},{"location":"jaculus/main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; demo-projets &gt; jaculus &gt; main &gt; main.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;jac/machine/machine.h&gt;\n#include &lt;jac/features/asyncEventLoopFeature.h&gt;\n#include &lt;jac/features/asyncTimersFeature.h&gt;\n#include &lt;jac/features/yieldFeature.h&gt;\n#include &lt;jac/features/moduleLoaderFeature.h&gt;\n#include &lt;jac/features/filesystemFeature.h&gt;\n#include &lt;jac/machine/values.h&gt;\n\n#include \"features/wdtResetFeature.h\"\n#include \"features/neopixelFeature.h\"\n#include \"features/gpioFeature.h\"\n#include \"features/linkIoFeature.h\"\n\n#include &lt;jac/link/mux.h&gt;\n#include &lt;jac/link/mux.h&gt;\n#include &lt;jac/link/encoders/cobs.h&gt;\n#include \"serialStream.h\"\n\n#include &lt;string&gt;\n#include &lt;filesystem&gt;\n#include &lt;sstream&gt;\n\n#include \"esp_vfs_fat.h\"\n#include \"freertos/task.h\"\n\n\n#include \"util/controller.h\"\n#include \"util/uploader.h\"\n#include \"util/logger.h\"\n\n\nstatic wl_handle_t s_wl_handle = WL_INVALID_HANDLE;\n\nusing Machine =\nEventLoopTerminal&lt;\nAsyncTimersFeature&lt;\nYieldFeature&lt;\nWdtResetFeature&lt;\nAsyncEventLoopFeature&lt;\nNeopixelFeature&lt;\nGpioFeature&lt;\nLinkIoFeature&lt;\nModuleLoaderFeature&lt;\nFilesystemFeature&lt;\njac::MachineBase\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;\n\nController&lt;Machine&gt; controller([]() {\nstd::stringstream oss;\noss &lt;&lt; esp_get_free_heap_size() &lt;&lt; \"/\" &lt;&lt; esp_get_minimum_free_heap_size();\nreturn oss.str();\n}, []() {\n// std::stringstream oss;\n// auto stats = std::filesystem::space(\"/data\");\n// oss &lt;&lt; \"Storage usage: \\n  \" &lt;&lt; stats.available &lt;&lt; \"/\" &lt;&lt; stats.capacity &lt;&lt; \"\\n\";\n// return oss.str();\nreturn \"not implemented\";\n});\n\nusing Mux_t = Mux&lt;CobsPacketizer, CobsSerializer, SerialStream&gt;;\nstd::unique_ptr&lt;Mux_t&gt; mux;\n\nint main() {\n// Initialize NVS\nesp_vfs_fat_mount_config_t conf = {\n.format_if_mount_failed = true,\n.max_files = 5,\n.allocation_unit_size = CONFIG_WL_SECTOR_SIZE,\n.disk_status_check_enable = false\n};\nESP_ERROR_CHECK(esp_vfs_fat_spiflash_mount_rw_wl(\"/data\", \"storage\", &amp;conf, &amp;s_wl_handle));\n\n\nauto serialStream = std::make_unique&lt;SerialStream&gt;(UART_NUM_0, 921600, 4096, 0);\nserialStream-&gt;onData([]() noexcept {\ntry {\nmux-&gt;receive();\n}\ncatch (std::exception &amp;e) {\nLogger::log(std::string(\"Exception: \") + e.what());\n}\ncatch (...) {\nLogger::log(\"Unknown exception\");\n}\n});\n\nmux = std::make_unique&lt;Mux_t&gt;(std::move(serialStream));\nmux-&gt;setErrorHandler([](Mux&lt;CobsPacketizer, CobsSerializer, SerialStream&gt;::Error error, std::vector&lt;int&gt; ctx) {\nstd::string message = \"Mux error: \" + std::to_string(static_cast&lt;int&gt;(error)) + \", ctx: [\";\nfor (auto c : ctx) {\nmessage += std::to_string(c) + \", \";\n}\nmessage += \"]\";\nLogger::log(message);\n});\nauto handle = controller.router().subscribeTx(1, *mux);\nmux-&gt;bindRx(std::make_unique&lt;decltype(handle)&gt;(std::move(handle)));\n\n\ncontroller.onConfigureMachine([&amp;](Machine &amp;machine) {\nauto machineOutput = std::make_unique&lt;TransparentOutputStreamCommunicator&gt;(controller.router(), 2, std::vector&lt;int&gt;{});\nmachine.linkIo._output = std::move(machineOutput);\n});\n\nif (std::filesystem::exists(\"/data/main.js\")) {\ncontroller.startMachine(\"/data/main.js\");\n}\n}\n\n\nextern \"C\" void app_main() {\nmain();\n\nvTaskDelete(NULL);\n}\n</code></pre>"},{"location":"jaculus/serialStream_8h/","title":"File serialStream.h","text":"<p>FileList &gt; demo-projets &gt; jaculus &gt; main &gt; serialStream.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;jac/link/stream.h&gt;</code></li> <li><code>#include \"driver/uart.h\"</code></li> <li><code>#include \"util/logger.h\"</code></li> </ul>"},{"location":"jaculus/serialStream_8h/#classes","title":"Classes","text":"Type Name class SerialStream <p>The documentation for this class was generated from the following file <code>demo-projets/jaculus/main/serialStream.h</code></p>"},{"location":"jaculus/serialStream_8h_source/","title":"File serialStream.h","text":"<p>File List &gt; demo-projets &gt; jaculus &gt; main &gt; serialStream.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;jac/link/stream.h&gt;\n#include \"driver/uart.h\"\n\n#include \"util/logger.h\"\n\nclass SerialStream : public Duplex {\nuart_port_t _port;\nstd::function&lt;void()&gt; _onData;\nQueueHandle_t _eventQueue;\nstd::thread _eventThread;\nbool _stopThread = false;\npublic:\nSerialStream(uart_port_t uartNum, int baudRate, int rxBufferSize, int txBufferSize,\nint txPin = UART_PIN_NO_CHANGE, int rxPin = UART_PIN_NO_CHANGE,\nint rtsPin = UART_PIN_NO_CHANGE, int ctsPin = UART_PIN_NO_CHANGE) : _port(uartNum) {\nuart_config_t uart_config = {\n.baud_rate = baudRate,\n.data_bits = UART_DATA_8_BITS,\n.parity = UART_PARITY_DISABLE,\n.stop_bits = UART_STOP_BITS_1,\n.flow_ctrl = UART_HW_FLOWCTRL_DISABLE,\n.rx_flow_ctrl_thresh = 122,\n.source_clk = UART_SCLK_DEFAULT\n};\n\nESP_ERROR_CHECK(uart_driver_install(uartNum, rxBufferSize, txBufferSize, 10, &amp;_eventQueue, 0));\nESP_ERROR_CHECK(uart_param_config(uartNum, &amp;uart_config));\nESP_ERROR_CHECK(uart_set_pin(uartNum, txPin, rxPin, rtsPin, ctsPin));\n\n_eventThread = std::thread([this]() noexcept {\nuart_event_t event;\nwhile (!_stopThread) {\nif (xQueueReceive(_eventQueue, &amp;event, portMAX_DELAY) == pdTRUE) {\nswitch (event.type) {\ncase UART_DATA:\nif (_onData) {\n_onData();\n}\nbreak;\ndefault:\nbreak;\n}\n}\n}\n});\n}\nSerialStream(SerialStream&amp;&amp;) = delete;\nSerialStream(const SerialStream&amp;) = delete;\nSerialStream&amp; operator=(SerialStream&amp;&amp;) = delete;\nSerialStream&amp; operator=(const SerialStream&amp;) = delete;\n\nbool put(uint8_t c) override {\nreturn uart_write_bytes(_port, (const char*)&amp;c, 1) == 1;\n}\n\nsize_t write(std::span&lt;const uint8_t&gt; data) override {\nreturn uart_write_bytes(_port, (const char*)data.data(), data.size());\n}\n\nint get() override {\nuint8_t c;\nif (uart_read_bytes(_port, &amp;c, 1, 0) == 1) {\nreturn c;\n}\nreturn -1;\n}\n\nsize_t read(std::span&lt;uint8_t&gt; data) override {\nreturn uart_read_bytes(_port, data.data(), data.size(), 0);\n}\n\nbool flush() override {\nreturn uart_wait_tx_done(_port, portMAX_DELAY) == ESP_OK;\n}\n\ntemplate&lt;typename Func&gt;\nvoid onData(Func callback) {\nstatic_assert(noexcept(callback()));\n_onData = callback;\n}\n\n~SerialStream() override {\n_stopThread = true;\n_eventThread.join();\nuart_driver_delete(_port);\n}\n};\n</code></pre>"},{"location":"jaculus/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace jac </li> <li>namespace ProtoBuilder </li> </ul>"},{"location":"jaculus/classes/","title":"Class Index","text":""},{"location":"jaculus/classes/#c","title":"c","text":"<ul> <li>Controller</li> <li>ConvTraits&lt; Rgb &gt; (jac)</li> </ul>"},{"location":"jaculus/classes/#g","title":"g","text":"<ul> <li>GpioFeature</li> <li>Gpio (GpioFeature)</li> </ul>"},{"location":"jaculus/classes/#l","title":"l","text":"<ul> <li>LinkIoFeature</li> <li>LinkIo (LinkIoFeature)</li> <li>Logger</li> </ul>"},{"location":"jaculus/classes/#n","title":"n","text":"<ul> <li>NeopixelFeature</li> <li>NeopixelProtoBuilder</li> </ul>"},{"location":"jaculus/classes/#s","title":"s","text":"<ul> <li>SerialStream</li> </ul>"},{"location":"jaculus/classes/#u","title":"u","text":"<ul> <li>Uploader</li> </ul>"},{"location":"jaculus/classes/#w","title":"w","text":"<ul> <li>WdtResetFeature</li> </ul>"},{"location":"jaculus/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class Controller </li> <li>class GpioFeature::Gpio </li> <li>class LinkIoFeature::LinkIo </li> <li>class Uploader </li> <li>struct Logger </li> <li>struct jac::ConvTraits&lt; Rgb &gt; </li> <li>class Next </li> <li>class GpioFeature </li> <li>class LinkIoFeature </li> <li>class NeopixelFeature </li> <li>class WdtResetFeature </li> <li>class Duplex </li> <li>class SerialStream </li> <li>class jac::ProtoBuilder::Opaque&lt; SmartLed &gt; </li> <li>struct NeopixelFeature::NeopixelProtoBuilder </li> <li>class jac::ProtoBuilder::Properties </li> <li>struct NeopixelFeature::NeopixelProtoBuilder </li> </ul>"},{"location":"jaculus/modules/","title":"Modules","text":"<p>Here is a list of all modules:</p>"},{"location":"jaculus/pages/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p>"},{"location":"jaculus/class_members/","title":"Class Members","text":""},{"location":"jaculus/class_members/#a","title":"a","text":"<ul> <li>addProperties (NeopixelFeature::NeopixelProtoBuilder)</li> </ul>"},{"location":"jaculus/class_members/#c","title":"c","text":"<ul> <li>Command (Controller, Uploader)</li> <li>Controller (Controller)</li> <li>configureMachine (Controller)</li> <li>constructOpaque (NeopixelFeature::NeopixelProtoBuilder)</li> </ul>"},{"location":"jaculus/class_members/#d","title":"d","text":"<ul> <li>DIRECTION (GpioFeature::Gpio)</li> <li>debug (Logger)</li> </ul>"},{"location":"jaculus/class_members/#e","title":"e","text":"<ul> <li>Error (Uploader)</li> </ul>"},{"location":"jaculus/class_members/#f","title":"f","text":"<ul> <li>flush (SerialStream)</li> <li>file (Uploader)</li> <li>from (jac::ConvTraits&lt; Rgb &gt;)</li> </ul>"},{"location":"jaculus/class_members/#g","title":"g","text":"<ul> <li>gpio (GpioFeature)</li> <li>get (SerialStream)</li> </ul>"},{"location":"jaculus/class_members/#i","title":"i","text":"<ul> <li>initialize (GpioFeature, LinkIoFeature, NeopixelFeature)</li> <li>input (Uploader)</li> </ul>"},{"location":"jaculus/class_members/#l","title":"l","text":"<ul> <li>linkIo (LinkIoFeature)</li> <li>log (Logger)</li> </ul>"},{"location":"jaculus/class_members/#n","title":"n","text":"<ul> <li>NeopixelClass (NeopixelFeature)</li> <li>NeopixelFeature (NeopixelFeature)</li> </ul>"},{"location":"jaculus/class_members/#o","title":"o","text":"<ul> <li>onConfigureMachine (Controller)</li> <li>onData (SerialStream, Uploader)</li> <li>operator= (SerialStream, Uploader)</li> <li>onDataComplete (Uploader)</li> <li>output (Uploader)</li> <li>onEventLoop (WdtResetFeature)</li> </ul>"},{"location":"jaculus/class_members/#p","title":"p","text":"<ul> <li>processStart (Controller)</li> <li>processStatus (Controller)</li> <li>processStop (Controller)</li> <li>PULL_MODE (GpioFeature::Gpio)</li> <li>pinMode (GpioFeature::Gpio)</li> <li>pullMode (GpioFeature::Gpio)</li> <li>print (LinkIoFeature::LinkIo)</li> <li>put (SerialStream)</li> <li>processCreateDir (Uploader)</li> <li>processDeleteDir (Uploader)</li> <li>processDeleteFile (Uploader)</li> <li>processListDir (Uploader)</li> <li>processPacket (Uploader)</li> <li>processReadFile (Uploader)</li> <li>processWriteFile (Uploader)</li> </ul>"},{"location":"jaculus/class_members/#r","title":"r","text":"<ul> <li>router (Controller)</li> <li>read (GpioFeature::Gpio, SerialStream)</li> </ul>"},{"location":"jaculus/class_members/#s","title":"s","text":"<ul> <li>startMachine (Controller)</li> <li>stopMachine (Controller)</li> <li>SerialStream (SerialStream)</li> <li>State (Uploader)</li> <li>state (Uploader)</li> </ul>"},{"location":"jaculus/class_members/#t","title":"t","text":"<ul> <li>to (jac::ConvTraits&lt; Rgb &gt;)</li> </ul>"},{"location":"jaculus/class_members/#u","title":"u","text":"<ul> <li>uploader (Controller)</li> <li>Uploader (Uploader)</li> </ul>"},{"location":"jaculus/class_members/#w","title":"w","text":"<ul> <li>write (GpioFeature::Gpio, SerialStream)</li> </ul>"},{"location":"jaculus/class_members/#_1","title":"~","text":"<ul> <li>~SerialStream (SerialStream)</li> </ul>"},{"location":"jaculus/class_members/#_","title":"_","text":"<ul> <li>_controllerThread (Controller)</li> <li>_getMemoryStats (Controller)</li> <li>_getStorageStats (Controller)</li> <li>_input (Controller)</li> <li>_machine (Controller)</li> <li>_onConfigureMachine (Controller)</li> <li>_output (Controller, LinkIoFeature::LinkIo)</li> <li>_router (Controller)</li> <li>_running (Controller)</li> <li>_thread (Controller, Uploader)</li> <li>_uploader (Controller)</li> <li>_debugStream (Logger)</li> <li>_logStream (Logger)</li> <li>_eventQueue (SerialStream)</li> <li>_eventThread (SerialStream)</li> <li>_onData (SerialStream)</li> <li>_port (SerialStream)</li> <li>_stopThread (SerialStream)</li> </ul>"},{"location":"jaculus/class_member_functions/","title":"Class Member Functions","text":""},{"location":"jaculus/class_member_functions/#a","title":"a","text":"<ul> <li>addProperties (NeopixelFeature::NeopixelProtoBuilder)</li> </ul>"},{"location":"jaculus/class_member_functions/#c","title":"c","text":"<ul> <li>Controller (Controller)</li> <li>configureMachine (Controller)</li> <li>constructOpaque (NeopixelFeature::NeopixelProtoBuilder)</li> </ul>"},{"location":"jaculus/class_member_functions/#d","title":"d","text":"<ul> <li>debug (Logger)</li> </ul>"},{"location":"jaculus/class_member_functions/#f","title":"f","text":"<ul> <li>flush (SerialStream)</li> <li>from (jac::ConvTraits&lt; Rgb &gt;)</li> </ul>"},{"location":"jaculus/class_member_functions/#g","title":"g","text":"<ul> <li>get (SerialStream)</li> </ul>"},{"location":"jaculus/class_member_functions/#i","title":"i","text":"<ul> <li>initialize (GpioFeature, LinkIoFeature, NeopixelFeature)</li> </ul>"},{"location":"jaculus/class_member_functions/#l","title":"l","text":"<ul> <li>log (Logger)</li> </ul>"},{"location":"jaculus/class_member_functions/#n","title":"n","text":"<ul> <li>NeopixelFeature (NeopixelFeature)</li> </ul>"},{"location":"jaculus/class_member_functions/#o","title":"o","text":"<ul> <li>onConfigureMachine (Controller)</li> <li>onData (SerialStream)</li> <li>operator= (SerialStream, Uploader)</li> <li>onEventLoop (WdtResetFeature)</li> </ul>"},{"location":"jaculus/class_member_functions/#p","title":"p","text":"<ul> <li>processStart (Controller)</li> <li>processStatus (Controller)</li> <li>processStop (Controller)</li> <li>pinMode (GpioFeature::Gpio)</li> <li>pullMode (GpioFeature::Gpio)</li> <li>print (LinkIoFeature::LinkIo)</li> <li>put (SerialStream)</li> <li>processCreateDir (Uploader)</li> <li>processDeleteDir (Uploader)</li> <li>processDeleteFile (Uploader)</li> <li>processListDir (Uploader)</li> <li>processPacket (Uploader)</li> <li>processReadFile (Uploader)</li> <li>processWriteFile (Uploader)</li> </ul>"},{"location":"jaculus/class_member_functions/#r","title":"r","text":"<ul> <li>router (Controller)</li> <li>read (GpioFeature::Gpio, SerialStream)</li> </ul>"},{"location":"jaculus/class_member_functions/#s","title":"s","text":"<ul> <li>startMachine (Controller)</li> <li>stopMachine (Controller)</li> <li>SerialStream (SerialStream)</li> </ul>"},{"location":"jaculus/class_member_functions/#t","title":"t","text":"<ul> <li>to (jac::ConvTraits&lt; Rgb &gt;)</li> </ul>"},{"location":"jaculus/class_member_functions/#u","title":"u","text":"<ul> <li>uploader (Controller)</li> <li>Uploader (Uploader)</li> </ul>"},{"location":"jaculus/class_member_functions/#w","title":"w","text":"<ul> <li>write (GpioFeature::Gpio, SerialStream)</li> </ul>"},{"location":"jaculus/class_member_functions/#_1","title":"~","text":"<ul> <li>~SerialStream (SerialStream)</li> </ul>"},{"location":"jaculus/class_member_variables/","title":"Class Member Variables","text":""},{"location":"jaculus/class_member_variables/#f","title":"f","text":"<ul> <li>file (Uploader)</li> </ul>"},{"location":"jaculus/class_member_variables/#g","title":"g","text":"<ul> <li>gpio (GpioFeature)</li> </ul>"},{"location":"jaculus/class_member_variables/#i","title":"i","text":"<ul> <li>input (Uploader)</li> </ul>"},{"location":"jaculus/class_member_variables/#l","title":"l","text":"<ul> <li>linkIo (LinkIoFeature)</li> </ul>"},{"location":"jaculus/class_member_variables/#o","title":"o","text":"<ul> <li>onData (Uploader)</li> <li>onDataComplete (Uploader)</li> <li>output (Uploader)</li> </ul>"},{"location":"jaculus/class_member_variables/#s","title":"s","text":"<ul> <li>state (Uploader)</li> </ul>"},{"location":"jaculus/class_member_variables/#_","title":"_","text":"<ul> <li>_controllerThread (Controller)</li> <li>_getMemoryStats (Controller)</li> <li>_getStorageStats (Controller)</li> <li>_input (Controller)</li> <li>_machine (Controller)</li> <li>_onConfigureMachine (Controller)</li> <li>_output (Controller, LinkIoFeature::LinkIo)</li> <li>_router (Controller)</li> <li>_running (Controller)</li> <li>_thread (Controller, Uploader)</li> <li>_uploader (Controller)</li> <li>_debugStream (Logger)</li> <li>_logStream (Logger)</li> <li>_eventQueue (SerialStream)</li> <li>_eventThread (SerialStream)</li> <li>_onData (SerialStream)</li> <li>_port (SerialStream)</li> <li>_stopThread (SerialStream)</li> </ul>"},{"location":"jaculus/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"jaculus/class_member_typedefs/#n","title":"n","text":"<ul> <li>NeopixelClass (NeopixelFeature)</li> </ul>"},{"location":"jaculus/class_member_enums/","title":"Class Member Enums","text":""},{"location":"jaculus/class_member_enums/#c","title":"c","text":"<ul> <li>Command (Controller, Uploader)</li> </ul>"},{"location":"jaculus/class_member_enums/#d","title":"d","text":"<ul> <li>DIRECTION (GpioFeature::Gpio)</li> </ul>"},{"location":"jaculus/class_member_enums/#e","title":"e","text":"<ul> <li>Error (Uploader)</li> </ul>"},{"location":"jaculus/class_member_enums/#p","title":"p","text":"<ul> <li>PULL_MODE (GpioFeature::Gpio)</li> </ul>"},{"location":"jaculus/class_member_enums/#s","title":"s","text":"<ul> <li>State (Uploader)</li> </ul>"},{"location":"jaculus/namespace_members/","title":"Namespace Members","text":""},{"location":"jaculus/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"jaculus/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"jaculus/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"jaculus/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"jaculus/functions/","title":"Functions","text":""},{"location":"jaculus/functions/#a","title":"a","text":"<ul> <li>app_main (main.cpp)</li> </ul>"},{"location":"jaculus/functions/#d","title":"d","text":"<ul> <li>deleteDir (uploader.cpp)</li> </ul>"},{"location":"jaculus/functions/#l","title":"l","text":"<ul> <li>listDir (uploader.cpp)</li> </ul>"},{"location":"jaculus/functions/#m","title":"m","text":"<ul> <li>main (main.cpp)</li> </ul>"},{"location":"jaculus/macros/","title":"Macros","text":""},{"location":"jaculus/variables/","title":"Variables","text":""},{"location":"jaculus/variables/#c","title":"c","text":"<ul> <li>controller (main.cpp)</li> </ul>"},{"location":"jaculus/variables/#m","title":"m","text":"<ul> <li>Machine (main.cpp)</li> <li>Mux_t (main.cpp)</li> <li>mux (main.cpp)</li> </ul>"},{"location":"jaculus/variables/#s","title":"s","text":"<ul> <li>s_wl_handle (main.cpp)</li> </ul>"},{"location":"jaculus/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List<ul> <li>class Controller</li> <li>class GpioFeature</li> <li>class GpioFeature::Gpio</li> <li>class LinkIoFeature</li> <li>class LinkIoFeature::LinkIo</li> <li>struct Logger</li> <li>class NeopixelFeature</li> <li>struct NeopixelFeature::NeopixelProtoBuilder</li> <li>class SerialStream</li> <li>class Uploader</li> <li>class WdtResetFeature</li> <li>namespace jac</li> <li>struct jac::ConvTraits&lt; Rgb &gt;</li> <li>namespace jac::ProtoBuilder</li> </ul> </li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files<ul> <li>demo-projets</li> <li>demo-projets/jaculus<ul> <li>demo-projets/jaculus/main</li> <li>demo-projets/jaculus/main/features<ul> <li>gpioFeature.h</li> <li>gpioFeature.h source</li> <li>linkIoFeature.h</li> <li>linkIoFeature.h source</li> <li>neopixelFeature.h</li> <li>neopixelFeature.h source</li> <li>wdtResetFeature.h</li> <li>wdtResetFeature.h source</li> </ul> </li> <li>demo-projets/jaculus/main/util<ul> <li>controller.h</li> <li>controller.h source</li> <li>logger.cpp</li> <li>logger.cpp source</li> <li>logger.h</li> <li>logger.h source</li> <li>uploader.cpp</li> <li>uploader.cpp source</li> <li>uploader.h</li> <li>uploader.h source</li> </ul> </li> <li>main.cpp</li> <li>main.cpp source</li> <li>serialStream.h</li> <li>serialStream.h source</li> </ul> </li> </ul> </li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}